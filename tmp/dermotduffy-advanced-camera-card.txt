Directory structure:
└── dermotduffy-advanced-camera-card/
    ├── README.md
    ├── docker-compose.yml
    ├── eslint.config.mjs
    ├── hacs.json
    ├── LICENSE
    ├── markdown-link-check.json
    ├── package.json
    ├── prettier.config.js
    ├── project.inlang.json
    ├── rollup.config.js
    ├── tsconfig.json
    ├── vite.config.ts
    ├── .eslintrc.cjs
    ├── .prettierignore
    ├── .yarnrc.yml
    ├── docs/
    │   ├── README.md
    │   ├── _coverpage.md
    │   ├── _sidebar.md
    │   ├── advanced-installation.md
    │   ├── CNAME
    │   ├── developing.md
    │   ├── examples.md
    │   ├── index.html
    │   ├── rolling-back.md
    │   ├── screenshots.md
    │   ├── support.md
    │   ├── troubleshooting.md
    │   ├── .nojekyll
    │   ├── configuration/
    │   │   ├── README.md
    │   │   ├── _sidebar.md
    │   │   ├── automations.md
    │   │   ├── conditions.md
    │   │   ├── dimensions.md
    │   │   ├── folders.md
    │   │   ├── grid-layout-algorithm.md
    │   │   ├── image.md
    │   │   ├── live.md
    │   │   ├── media-gallery.md
    │   │   ├── media-viewer.md
    │   │   ├── menu.md
    │   │   ├── overrides.md
    │   │   ├── performance.md
    │   │   ├── profiles.md
    │   │   ├── remote-control.md
    │   │   ├── status-bar.md
    │   │   ├── templates.md
    │   │   ├── timeline-pan-mode.md
    │   │   ├── timeline.md
    │   │   ├── view.md
    │   │   ├── actions/
    │   │   │   ├── README.md
    │   │   │   ├── _sidebar.md
    │   │   │   ├── custom/
    │   │   │   │   ├── README.md
    │   │   │   │   └── _sidebar.md
    │   │   │   └── stock/
    │   │   │       ├── README.md
    │   │   │       └── _sidebar.md
    │   │   ├── cameras/
    │   │   │   ├── README.md
    │   │   │   ├── _sidebar.md
    │   │   │   ├── engine.md
    │   │   │   └── live-provider.md
    │   │   ├── common/
    │   │   │   ├── expanded-warning.md
    │   │   │   ├── experimental-warning.md
    │   │   │   └── timeline-seek-info.md
    │   │   └── elements/
    │   │       ├── README.md
    │   │       ├── _sidebar.md
    │   │       ├── custom/
    │   │       │   ├── README.md
    │   │       │   └── _sidebar.md
    │   │       └── stock/
    │   │           ├── README.md
    │   │           └── _sidebar.md
    │   ├── css/
    │   │   ├── theme-simple-dark.css
    │   │   └── theme-simple.css
    │   ├── images/
    │   │   └── README.md
    │   ├── js/
    │   │   └── search.js
    │   └── usage/
    │       ├── README.md
    │       ├── 2-way-audio.md
    │       ├── _sidebar.md
    │       ├── casting.md
    │       ├── custom-icons.md
    │       ├── keyboard-shortcuts.md
    │       └── url-actions.md
    ├── project.inlang/
    │   ├── project_id
    │   └── settings.json
    ├── scripts/
    │   ├── docs-update-dependencies.sh
    │   ├── docs-update-icons.sh
    │   └── docs-update-images.sh
    ├── src/
    │   ├── action-handler-directive.ts
    │   ├── card.ts
    │   ├── const.ts
    │   ├── declarations.d.ts
    │   ├── editor.ts
    │   ├── types.ts
    │   ├── cache/
    │   │   ├── base.ts
    │   │   ├── cache.ts
    │   │   ├── equality-cache.ts
    │   │   ├── equality-map.ts
    │   │   ├── expiring-cache.ts
    │   │   ├── lru.ts
    │   │   └── types.ts
    │   ├── camera-manager/
    │   │   ├── cache.ts
    │   │   ├── camera.ts
    │   │   ├── capabilities.ts
    │   │   ├── engine-factory.ts
    │   │   ├── engine.ts
    │   │   ├── error.ts
    │   │   ├── manager.ts
    │   │   ├── range.ts
    │   │   ├── store.ts
    │   │   ├── types.ts
    │   │   ├── browse-media/
    │   │   │   ├── camera.ts
    │   │   │   └── engine-browse-media.ts
    │   │   ├── frigate/
    │   │   │   ├── camera.ts
    │   │   │   ├── engine-frigate.ts
    │   │   │   ├── event-watcher.ts
    │   │   │   ├── media-classifier.ts
    │   │   │   ├── media.ts
    │   │   │   ├── requests.ts
    │   │   │   ├── types.ts
    │   │   │   └── util.ts
    │   │   ├── generic/
    │   │   │   └── engine-generic.ts
    │   │   ├── motioneye/
    │   │   │   ├── camera.ts
    │   │   │   ├── engine-motioneye.ts
    │   │   │   └── types.ts
    │   │   ├── reolink/
    │   │   │   ├── camera.ts
    │   │   │   ├── engine-reolink.ts
    │   │   │   └── types.ts
    │   │   └── utils/
    │   │       ├── camera-entity-from-config.ts
    │   │       ├── cap-end-date.ts
    │   │       ├── go2rtc-endpoint.ts
    │   │       ├── ptz.ts
    │   │       └── range-to-cache-friendly.ts
    │   ├── card-controller/
    │   │   ├── automations-manager.ts
    │   │   ├── camera-url-manager.ts
    │   │   ├── card-element-manager.ts
    │   │   ├── controller.ts
    │   │   ├── default-manager.ts
    │   │   ├── expand-manager.ts
    │   │   ├── initialization-manager.ts
    │   │   ├── interaction-manager.ts
    │   │   ├── keyboard-state-manager.ts
    │   │   ├── media-info-manager.ts
    │   │   ├── media-player-manager.ts
    │   │   ├── message-manager.ts
    │   │   ├── microphone-manager.ts
    │   │   ├── query-string-manager.ts
    │   │   ├── status-bar-item-manager.ts
    │   │   ├── style-manager.ts
    │   │   ├── triggers-manager.ts
    │   │   ├── types.ts
    │   │   ├── actions/
    │   │   │   ├── actions-manager.ts
    │   │   │   ├── factory.ts
    │   │   │   ├── types.ts
    │   │   │   ├── actions/
    │   │   │   │   ├── base.ts
    │   │   │   │   ├── call-service.ts
    │   │   │   │   ├── camera-select.ts
    │   │   │   │   ├── camera-ui.ts
    │   │   │   │   ├── custom.ts
    │   │   │   │   ├── default.ts
    │   │   │   │   ├── display-mode-select.ts
    │   │   │   │   ├── download.ts
    │   │   │   │   ├── expand.ts
    │   │   │   │   ├── folders-view.ts
    │   │   │   │   ├── fullscreen.ts
    │   │   │   │   ├── internal-callback.ts
    │   │   │   │   ├── log.ts
    │   │   │   │   ├── media-player.ts
    │   │   │   │   ├── menu-toggle.ts
    │   │   │   │   ├── microphone-connect.ts
    │   │   │   │   ├── microphone-disconnect.ts
    │   │   │   │   ├── microphone-mute.ts
    │   │   │   │   ├── microphone-unmute.ts
    │   │   │   │   ├── more-info.ts
    │   │   │   │   ├── mute.ts
    │   │   │   │   ├── navigate.ts
    │   │   │   │   ├── none.ts
    │   │   │   │   ├── pause.ts
    │   │   │   │   ├── perform-action.ts
    │   │   │   │   ├── play.ts
    │   │   │   │   ├── ptz-controls.ts
    │   │   │   │   ├── ptz-digital.ts
    │   │   │   │   ├── ptz-multi.ts
    │   │   │   │   ├── ptz.ts
    │   │   │   │   ├── screenshot.ts
    │   │   │   │   ├── set.ts
    │   │   │   │   ├── sleep.ts
    │   │   │   │   ├── status-bar.ts
    │   │   │   │   ├── substream-off.ts
    │   │   │   │   ├── substream-on.ts
    │   │   │   │   ├── substream-select.ts
    │   │   │   │   ├── toggle.ts
    │   │   │   │   ├── unmute.ts
    │   │   │   │   ├── url.ts
    │   │   │   │   └── view.ts
    │   │   │   └── utils/
    │   │   │       ├── action-state.ts
    │   │   │       ├── execution-request.ts
    │   │   │       └── time-delta.ts
    │   │   ├── config/
    │   │   │   ├── config-manager.ts
    │   │   │   ├── load-automations.ts
    │   │   │   ├── load-control-entities.ts
    │   │   │   ├── load-folders.ts
    │   │   │   ├── load-keyboard-shortcuts.ts
    │   │   │   └── overrides-manager.ts
    │   │   ├── folders/
    │   │   │   ├── executor.ts
    │   │   │   ├── manager.ts
    │   │   │   ├── types.ts
    │   │   │   └── ha/
    │   │   │       ├── engine.ts
    │   │   │       ├── media-matcher.ts
    │   │   │       ├── metadata-generator.ts
    │   │   │       └── types.ts
    │   │   ├── fullscreen/
    │   │   │   ├── factory.ts
    │   │   │   ├── fullscreen-manager.ts
    │   │   │   ├── provider.ts
    │   │   │   ├── types.ts
    │   │   │   ├── screenfull/
    │   │   │   │   └── index.ts
    │   │   │   └── webkit/
    │   │   │       └── index.ts
    │   │   ├── hass/
    │   │   │   ├── hass-manager.ts
    │   │   │   └── state-watcher.ts
    │   │   ├── templates/
    │   │   │   └── index.ts
    │   │   └── view/
    │   │       ├── factory.ts
    │   │       ├── item-manager.ts
    │   │       ├── query-executor.ts
    │   │       ├── sort.ts
    │   │       ├── types.ts
    │   │       ├── view-manager.ts
    │   │       ├── view-query-executor.ts
    │   │       └── modifiers/
    │   │           ├── index.ts
    │   │           ├── merge-context.ts
    │   │           ├── remove-context-property.ts
    │   │           ├── remove-context.ts
    │   │           ├── set-query.ts
    │   │           ├── substream-off.ts
    │   │           ├── substream-on.ts
    │   │           └── substream-select.ts
    │   ├── components/
    │   │   ├── carousel.ts
    │   │   ├── date-picker.ts
    │   │   ├── diagnostics.ts
    │   │   ├── drawer.ts
    │   │   ├── elements.ts
    │   │   ├── icon.ts
    │   │   ├── image-player.ts
    │   │   ├── image-updating-player.ts
    │   │   ├── image.ts
    │   │   ├── key-assigner.ts
    │   │   ├── loading.ts
    │   │   ├── media-filter.ts
    │   │   ├── media-grid.ts
    │   │   ├── menu.ts
    │   │   ├── message.ts
    │   │   ├── next-prev-control.ts
    │   │   ├── overlay.ts
    │   │   ├── progress-indicator.ts
    │   │   ├── ptz.ts
    │   │   ├── select.ts
    │   │   ├── status-bar.ts
    │   │   ├── surround-basic.ts
    │   │   ├── surround.ts
    │   │   ├── thumbnail-carousel.ts
    │   │   ├── timeline-core.ts
    │   │   ├── timeline.ts
    │   │   ├── video-player.ts
    │   │   ├── views.ts
    │   │   ├── zoomer.ts
    │   │   ├── gallery/
    │   │   │   ├── folder-gallery.ts
    │   │   │   ├── gallery-core.ts
    │   │   │   ├── media-gallery.ts
    │   │   │   └── types.ts
    │   │   ├── live/
    │   │   │   ├── carousel.ts
    │   │   │   ├── grid.ts
    │   │   │   ├── index.ts
    │   │   │   ├── provider.ts
    │   │   │   └── providers/
    │   │   │       ├── ha.ts
    │   │   │       ├── image.ts
    │   │   │       ├── jsmpeg.ts
    │   │   │       ├── webrtc-card.ts
    │   │   │       └── go2rtc/
    │   │   │           ├── README.md
    │   │   │           ├── index.ts
    │   │   │           ├── video-rtc.d.ts
    │   │   │           └── video-rtc.js
    │   │   ├── submenu/
    │   │   │   ├── index.ts
    │   │   │   ├── select-button.ts
    │   │   │   ├── submenu-button.ts
    │   │   │   └── types.ts
    │   │   ├── thumbnail/
    │   │   │   ├── details.ts
    │   │   │   ├── thumbnail.ts
    │   │   │   └── feature/
    │   │   │       ├── feature.ts
    │   │   │       └── thumbnail.ts
    │   │   └── viewer/
    │   │       ├── carousel.ts
    │   │       ├── grid.ts
    │   │       ├── index.ts
    │   │       └── provider.ts
    │   ├── components-lib/
    │   │   ├── cached-value-controller.ts
    │   │   ├── icon-controller.ts
    │   │   ├── key-assigner-controller.ts
    │   │   ├── lazy-load-controller.ts
    │   │   ├── media-actions-controller.ts
    │   │   ├── media-filter-controller.ts
    │   │   ├── media-grid-controller.ts
    │   │   ├── media-height-controller.ts
    │   │   ├── menu-button-controller.ts
    │   │   ├── menu-controller.ts
    │   │   ├── status-bar-controller.ts
    │   │   ├── timeline-source.ts
    │   │   ├── folder/
    │   │   │   └── up-folder.ts
    │   │   ├── gallery/
    │   │   │   ├── folder-gallery-controller.ts
    │   │   │   ├── gallery-core-controller.ts
    │   │   │   └── media-gallery-controller.ts
    │   │   ├── live/
    │   │   │   ├── live-controller.ts
    │   │   │   └── utils/
    │   │   │       ├── dispatch-live-error.ts
    │   │   │       └── get-technology-for-video-rtc.ts
    │   │   ├── media-player/
    │   │   │   ├── image.ts
    │   │   │   ├── jsmpeg.ts
    │   │   │   ├── updating-image.ts
    │   │   │   └── video.ts
    │   │   ├── message/
    │   │   │   ├── controller.ts
    │   │   │   └── dispatch.ts
    │   │   ├── ptz/
    │   │   │   ├── ptz-controller.ts
    │   │   │   └── types.ts
    │   │   ├── thumbnail/
    │   │   │   ├── details-controller.ts
    │   │   │   └── feature/
    │   │   │       └── controller.ts
    │   │   └── zoom/
    │   │       ├── types.ts
    │   │       ├── zoom-controller.ts
    │   │       └── zoom-view-context.ts
    │   ├── conditions/
    │   │   ├── conditions-manager.ts
    │   │   ├── state-manager-via-event.ts
    │   │   ├── state-manager.ts
    │   │   └── types.ts
    │   ├── config/
    │   │   ├── management.ts
    │   │   ├── types.ts
    │   │   ├── profiles/
    │   │   │   ├── casting.ts
    │   │   │   ├── low-performance.ts
    │   │   │   ├── scrubbing.ts
    │   │   │   └── set-profiles.ts
    │   │   └── schema/
    │   │       ├── automations.ts
    │   │       ├── cameras.ts
    │   │       ├── debug.ts
    │   │       ├── dimensions.ts
    │   │       ├── folders.ts
    │   │       ├── image.ts
    │   │       ├── live.ts
    │   │       ├── media-gallery.ts
    │   │       ├── menu.ts
    │   │       ├── overrides.ts
    │   │       ├── performance.ts
    │   │       ├── profiles.ts
    │   │       ├── remote-control.ts
    │   │       ├── status-bar.ts
    │   │       ├── timeline.ts
    │   │       ├── types.ts
    │   │       ├── view.ts
    │   │       ├── viewer.ts
    │   │       ├── actions/
    │   │       │   ├── base.ts
    │   │       │   ├── types.ts
    │   │       │   ├── custom/
    │   │       │   │   ├── base.ts
    │   │       │   │   ├── camera-select.ts
    │   │       │   │   ├── display-mode.ts
    │   │       │   │   ├── folders-view.ts
    │   │       │   │   ├── general.ts
    │   │       │   │   ├── internal.ts
    │   │       │   │   ├── log.ts
    │   │       │   │   ├── media-player.ts
    │   │       │   │   ├── ptz-controls.ts
    │   │       │   │   ├── ptz-digital.ts
    │   │       │   │   ├── ptz-multi.ts
    │   │       │   │   ├── ptz.ts
    │   │       │   │   ├── sleep.ts
    │   │       │   │   ├── substream-select.ts
    │   │       │   │   └── view.ts
    │   │       │   └── stock/
    │   │       │       ├── call-service.ts
    │   │       │       ├── custom.ts
    │   │       │       ├── more-info.ts
    │   │       │       ├── navigate.ts
    │   │       │       ├── none.ts
    │   │       │       ├── perform-action.ts
    │   │       │       ├── target.ts
    │   │       │       ├── toggle.ts
    │   │       │       ├── types.ts
    │   │       │       └── url.ts
    │   │       ├── camera/
    │   │       │   ├── media-layout.ts
    │   │       │   └── ptz.ts
    │   │       ├── common/
    │   │       │   ├── aspect-ratio.ts
    │   │       │   ├── const.ts
    │   │       │   ├── display.ts
    │   │       │   ├── events-media.ts
    │   │       │   ├── image.ts
    │   │       │   ├── media-actions.ts
    │   │       │   ├── pan.ts
    │   │       │   ├── regex.ts
    │   │       │   ├── status-bar.ts
    │   │       │   ├── transition-effect.ts
    │   │       │   ├── zoom.ts
    │   │       │   └── controls/
    │   │       │       ├── next-previous.ts
    │   │       │       ├── ptz.ts
    │   │       │       ├── thumbnails.ts
    │   │       │       └── timeline.ts
    │   │       ├── conditions/
    │   │       │   ├── types.ts
    │   │       │   ├── custom/
    │   │       │   │   ├── camera.ts
    │   │       │   │   ├── config.ts
    │   │       │   │   ├── display-mode.ts
    │   │       │   │   ├── expand.ts
    │   │       │   │   ├── fullscreen.ts
    │   │       │   │   ├── initialized.ts
    │   │       │   │   ├── interaction.ts
    │   │       │   │   ├── key.ts
    │   │       │   │   ├── media-loaded.ts
    │   │       │   │   ├── microphone.ts
    │   │       │   │   ├── triggered.ts
    │   │       │   │   ├── user-agent.ts
    │   │       │   │   └── view.ts
    │   │       │   └── stock/
    │   │       │       ├── numeric.ts
    │   │       │       ├── screen.ts
    │   │       │       ├── state.ts
    │   │       │       ├── template.ts
    │   │       │       ├── types.ts
    │   │       │       └── users.ts
    │   │       └── elements/
    │   │           ├── base.ts
    │   │           ├── types.ts
    │   │           ├── custom/
    │   │           │   └── menu/
    │   │           │       ├── base.ts
    │   │           │       ├── icon.ts
    │   │           │       ├── state-icon.ts
    │   │           │       ├── submenu-select.ts
    │   │           │       ├── submenu.ts
    │   │           │       └── types.ts
    │   │           └── stock/
    │   │               ├── custom.ts
    │   │               ├── icon.ts
    │   │               ├── image.ts
    │   │               ├── service-call.ts
    │   │               ├── state-badge.ts
    │   │               ├── state-icon.ts
    │   │               └── state-label.ts
    │   ├── ha/
    │   │   ├── README.md
    │   │   ├── brands-url.ts
    │   │   ├── canonical-url.ts
    │   │   ├── CC-LICENSE
    │   │   ├── compute-domain.ts
    │   │   ├── const.ts
    │   │   ├── download.ts
    │   │   ├── entity-state-translation.ts
    │   │   ├── fire-hass-event.ts
    │   │   ├── get-entities.ts
    │   │   ├── get-entity-title.ts
    │   │   ├── get-hass-differences.ts
    │   │   ├── haptic.ts
    │   │   ├── has-hass-connection-changed.ts
    │   │   ├── is-ha-relative-url.ts
    │   │   ├── is-hass-different.ts
    │   │   ├── is-triggered-state.ts
    │   │   ├── panel.ts
    │   │   ├── resolved-media.ts
    │   │   ├── side-load-ha-elements.ts
    │   │   ├── sign-path.ts
    │   │   ├── supports-feature.ts
    │   │   ├── types.ts
    │   │   ├── web-proxy.ts
    │   │   ├── ws-request.ts
    │   │   ├── browse-media/
    │   │   │   ├── browse-media-to-view-media.ts
    │   │   │   ├── item-factory.ts
    │   │   │   ├── item.ts
    │   │   │   ├── sort.ts
    │   │   │   ├── types.ts
    │   │   │   ├── walker.ts
    │   │   │   └── within-dates.ts
    │   │   ├── integration/
    │   │   │   ├── index.ts
    │   │   │   └── types.ts
    │   │   └── registry/
    │   │       ├── device/
    │   │       │   ├── index.ts
    │   │       │   └── types.ts
    │   │       └── entity/
    │   │           ├── index.ts
    │   │           └── types.ts
    │   ├── images/
    │   │   └── README.md
    │   ├── localize/
    │   │   ├── localize.ts
    │   │   └── languages/
    │   │       ├── ca.json
    │   │       ├── en.json
    │   │       ├── fr.json
    │   │       ├── it.json
    │   │       ├── pt-BR.json
    │   │       └── pt-PT.json
    │   ├── patches/
    │   │   ├── ha-camera-stream.ts
    │   │   ├── ha-hls-player.ts
    │   │   ├── ha-web-rtc-player.ts
    │   │   └── types.ts
    │   ├── scoped-elements/
    │   │   └── gr-select.js
    │   ├── scss/
    │   │   ├── basic-block.scss
    │   │   ├── button.scss
    │   │   ├── card.scss
    │   │   ├── carousel.scss
    │   │   ├── const.scss
    │   │   ├── date-picker.scss
    │   │   ├── dotdotdot.scss
    │   │   ├── drawer-inject.scss
    │   │   ├── drawer.scss
    │   │   ├── editor.scss
    │   │   ├── elements.scss
    │   │   ├── folder-gallery.scss
    │   │   ├── folder.scss
    │   │   ├── gallery-core.scss
    │   │   ├── icon.scss
    │   │   ├── image-player.scss
    │   │   ├── image-updating-player.scss
    │   │   ├── image.scss
    │   │   ├── key-assigner.scss
    │   │   ├── live-carousel.scss
    │   │   ├── live-go2rtc.scss
    │   │   ├── live-grid.scss
    │   │   ├── live-ha-components.scss
    │   │   ├── live-ha.scss
    │   │   ├── live-jsmpeg.scss
    │   │   ├── live-provider.scss
    │   │   ├── live-webrtc-card.scss
    │   │   ├── loading.scss
    │   │   ├── media-background.scss
    │   │   ├── media-filter.scss
    │   │   ├── media-gallery.scss
    │   │   ├── media-grid.scss
    │   │   ├── media-layout.scss
    │   │   ├── menu-button.scss
    │   │   ├── menu.scss
    │   │   ├── message.scss
    │   │   ├── next-previous-control.scss
    │   │   ├── overlay.scss
    │   │   ├── ptz.scss
    │   │   ├── select.scss
    │   │   ├── status.scss
    │   │   ├── submenu.scss
    │   │   ├── surround-basic.scss
    │   │   ├── thumbnail-carousel.scss
    │   │   ├── thumbnail-details.scss
    │   │   ├── thumbnail-feature-thumbnail.scss
    │   │   ├── thumbnail-feature.scss
    │   │   ├── thumbnail.scss
    │   │   ├── timeline-core.scss
    │   │   ├── video-player.scss
    │   │   ├── viewer-carousel.scss
    │   │   ├── viewer-provider.scss
    │   │   ├── viewer.scss
    │   │   ├── views.scss
    │   │   ├── z-index.scss
    │   │   └── themes/
    │   │       ├── base.scss
    │   │       ├── dark.scss
    │   │       ├── light.scss
    │   │       └── traditional.scss
    │   ├── utils/
    │   │   ├── action.ts
    │   │   ├── audio.ts
    │   │   ├── basic.ts
    │   │   ├── camera.ts
    │   │   ├── casting.ts
    │   │   ├── companion.ts
    │   │   ├── controls.ts
    │   │   ├── debug.ts
    │   │   ├── diagnostics.ts
    │   │   ├── download.ts
    │   │   ├── endpoint.ts
    │   │   ├── find-best-media-time-index.ts
    │   │   ├── fire-advanced-camera-card-event.ts
    │   │   ├── interaction-mode.ts
    │   │   ├── media-info.ts
    │   │   ├── media-layout.ts
    │   │   ├── ptz.ts
    │   │   ├── regexp-extract.ts
    │   │   ├── screenshot.ts
    │   │   ├── scroll.ts
    │   │   ├── sleep.ts
    │   │   ├── substream.ts
    │   │   ├── task.ts
    │   │   ├── text-direction.ts
    │   │   ├── thumbnail.ts
    │   │   ├── timer.ts
    │   │   ├── zod.ts
    │   │   ├── embla/
    │   │   │   ├── carousel-controller.ts
    │   │   │   └── plugins/
    │   │   │       └── auto-media-loaded-info/
    │   │   │           └── auto-media-loaded-info.ts
    │   │   └── initializer/
    │   │       └── initializer.ts
    │   └── view/
    │       ├── item-classifier.ts
    │       ├── item.ts
    │       ├── query-classifier.ts
    │       ├── query-results.ts
    │       ├── query.ts
    │       ├── types.ts
    │       ├── view-to-cameras.ts
    │       └── view.ts
    ├── tests/
    │   ├── cached-value-controller.test.ts
    │   ├── test-utils.ts
    │   ├── cache/
    │   │   ├── cache.test.ts
    │   │   ├── equality-cache.test.ts
    │   │   ├── equality-map.test.ts
    │   │   ├── expiring-cache.test.ts
    │   │   └── lru.test.ts
    │   ├── camera-manager/
    │   │   ├── cache.test.ts
    │   │   ├── camera.test.ts
    │   │   ├── capabilities.test.ts
    │   │   ├── engine-factory.test.ts
    │   │   ├── manager.test.ts
    │   │   ├── range.test.ts
    │   │   ├── store.test.ts
    │   │   ├── browse-media/
    │   │   │   └── camera.test.ts
    │   │   ├── frigate/
    │   │   │   ├── camera.test.ts
    │   │   │   ├── engine-frigate.test.ts
    │   │   │   ├── event-watcher.test.ts
    │   │   │   ├── requests.test.ts
    │   │   │   └── util.test.ts
    │   │   ├── generic/
    │   │   │   └── engine-generic.test.ts
    │   │   ├── reolink/
    │   │   │   ├── camera.test.ts
    │   │   │   └── engine-reolink.test.ts
    │   │   └── utils/
    │   │       ├── camera-entity-from-config.test.ts
    │   │       ├── cap-end-date.test.ts
    │   │       ├── go2rtc-endpoint.test.ts
    │   │       ├── ptz.test.ts
    │   │       └── range-to-cache-friendly.test.ts
    │   ├── card-controller/
    │   │   ├── automations-manager.test.ts
    │   │   ├── camera-url-manager.test.ts
    │   │   ├── card-element-manager.test.ts
    │   │   ├── controller.test.ts
    │   │   ├── default-manager.test.ts
    │   │   ├── expand-manager.test.ts
    │   │   ├── initialization-manager.test.ts
    │   │   ├── interaction-manager.test.ts
    │   │   ├── keyboard-state-manager.test.ts
    │   │   ├── media-info-manager.test.ts
    │   │   ├── media-player-manager.test.ts
    │   │   ├── message-manager.test.ts
    │   │   ├── microphone-manager.test.ts
    │   │   ├── query-string-manager.test.ts
    │   │   ├── status-bar-item-manager.test.ts
    │   │   ├── style-manager.test.ts
    │   │   ├── triggers-manager.test.ts
    │   │   ├── actions/
    │   │   │   ├── actions-manager.test.ts
    │   │   │   ├── factory.test.ts
    │   │   │   ├── actions/
    │   │   │   │   ├── base.test.ts
    │   │   │   │   ├── call-service.test.ts
    │   │   │   │   ├── camera-select.test.ts
    │   │   │   │   ├── camera-ui.test.ts
    │   │   │   │   ├── custom.test.ts
    │   │   │   │   ├── default.test.ts
    │   │   │   │   ├── display-mode-select.test.ts
    │   │   │   │   ├── download.test.ts
    │   │   │   │   ├── expand.test.ts
    │   │   │   │   ├── folder.test.ts
    │   │   │   │   ├── fullscreen.test.ts
    │   │   │   │   ├── internal-callback.test.ts
    │   │   │   │   ├── log.test.ts
    │   │   │   │   ├── media-player.test.ts
    │   │   │   │   ├── menu-toggle.test.ts
    │   │   │   │   ├── microphone-connect.test.ts
    │   │   │   │   ├── microphone-disconnect.test.ts
    │   │   │   │   ├── microphone-mute.test.ts
    │   │   │   │   ├── microphone-unmute.test.ts
    │   │   │   │   ├── more-info.test.ts
    │   │   │   │   ├── mute.test.ts
    │   │   │   │   ├── navigate.test.ts
    │   │   │   │   ├── none.test.ts
    │   │   │   │   ├── pause.test.ts
    │   │   │   │   ├── perform-action.test.ts
    │   │   │   │   ├── play.test.ts
    │   │   │   │   ├── ptz-controls.test.ts
    │   │   │   │   ├── ptz-digital.test.ts
    │   │   │   │   ├── ptz-multi.test.ts
    │   │   │   │   ├── ptz.test.ts
    │   │   │   │   ├── screenshot.test.ts
    │   │   │   │   ├── set.test.ts
    │   │   │   │   ├── sleep.test.ts
    │   │   │   │   ├── status-bar.test.ts
    │   │   │   │   ├── substream-off.test.ts
    │   │   │   │   ├── substream-on.test.ts
    │   │   │   │   ├── substream-select.test.ts
    │   │   │   │   ├── toggle.test.ts
    │   │   │   │   ├── unmute.test.ts
    │   │   │   │   ├── url.test.ts
    │   │   │   │   └── view.test.ts
    │   │   │   └── utils/
    │   │   │       └── time-delta.test.ts
    │   │   ├── config/
    │   │   │   ├── config-manager.test.ts
    │   │   │   ├── load-automations.test.ts
    │   │   │   ├── load-control-entities.test.ts
    │   │   │   ├── load-folders.test.ts
    │   │   │   ├── load-keyboard-shortcuts.test.ts
    │   │   │   └── overrides-manager.test.ts
    │   │   ├── folders/
    │   │   │   ├── executor.test.ts
    │   │   │   ├── manager.test.ts
    │   │   │   └── ha/
    │   │   │       ├── engine.test.ts
    │   │   │       ├── media-matcher.test.ts
    │   │   │       └── metadata-generator.test.ts
    │   │   ├── fullscreen/
    │   │   │   ├── factory.test.ts
    │   │   │   ├── fullscreen-manager.test.ts
    │   │   │   ├── screenfull/
    │   │   │   │   └── index.test.ts
    │   │   │   └── webkit/
    │   │   │       └── index.test.ts
    │   │   ├── hass/
    │   │   │   ├── hass-manager.test.ts
    │   │   │   └── state-watcher.test.ts
    │   │   └── view/
    │   │       ├── factory.test.ts
    │   │       ├── item-manager.test.ts
    │   │       ├── query-executor.test.ts
    │   │       ├── sort.test.ts
    │   │       ├── test-utils.ts
    │   │       ├── view-manager.test.ts
    │   │       ├── view-query-executor.test.ts
    │   │       └── modifiers/
    │   │           ├── index.test.ts
    │   │           ├── merge-context.test.ts
    │   │           ├── remove-context-property.test.ts
    │   │           ├── remove-context.test.ts
    │   │           ├── set-query.test.ts
    │   │           ├── substream-off.test.ts
    │   │           ├── substream-on.test.ts
    │   │           └── substream-select.test.ts
    │   ├── components-lib/
    │   │   ├── icon-controller.test.ts
    │   │   ├── key-assigner-controller.test.ts
    │   │   ├── lazy-load-controller.test.ts
    │   │   ├── media-actions-controller.test.ts
    │   │   ├── media-filter-controller.test.ts
    │   │   ├── media-grid-controller.test.ts
    │   │   ├── media-height-controller.test.ts
    │   │   ├── menu-button-controller.test.ts
    │   │   ├── menu-controller.test.ts
    │   │   ├── status-bar-controller.test.ts
    │   │   ├── folder/
    │   │   │   └── up-folder.test.ts
    │   │   ├── gallery/
    │   │   │   ├── folder-gallery-controller.test.ts
    │   │   │   ├── gallery-core-controller.test.ts
    │   │   │   └── media-gallery-controller.test.ts
    │   │   ├── live/
    │   │   │   ├── live-controller.test.ts
    │   │   │   └── utils/
    │   │   │       ├── dispatch-live-error.test.ts
    │   │   │       └── get-technology-for-video-rts.test.ts
    │   │   ├── media-player/
    │   │   │   ├── image.test.ts
    │   │   │   ├── jsmpeg.test.ts
    │   │   │   ├── updating-image.test.ts
    │   │   │   └── video.test.ts
    │   │   ├── message/
    │   │   │   ├── controller.test.ts
    │   │   │   └── dispatch.test.ts
    │   │   ├── ptz/
    │   │   │   └── ptz-controller.test.ts
    │   │   ├── thumbnail/
    │   │   │   ├── details-controller.test.ts
    │   │   │   └── feature/
    │   │   │       └── controller.test.ts
    │   │   └── zoom/
    │   │       ├── zoom-controller.test.ts
    │   │       └── zoom-view-context.test.ts
    │   ├── conditions/
    │   │   ├── conditions-manager.test.ts
    │   │   ├── state-manager-via-event.test.ts
    │   │   └── state-manager.test.ts
    │   ├── config/
    │   │   ├── management.test.ts
    │   │   ├── types.test.ts
    │   │   ├── profiles/
    │   │   │   ├── casting.test.ts
    │   │   │   ├── index.test.ts
    │   │   │   ├── low-performance.test.ts
    │   │   │   └── scrubbing.test.ts
    │   │   └── schema/
    │   │       └── folders.test.ts
    │   ├── ha/
    │   │   ├── brands-url.test.ts
    │   │   ├── canonical-url.test.ts
    │   │   ├── compute-domain.test.ts
    │   │   ├── download.test.ts
    │   │   ├── entity-state-translation.test.ts
    │   │   ├── fire-hass-event.test.ts
    │   │   ├── get-entities.test.ts
    │   │   ├── get-entity-title.test.ts
    │   │   ├── get-hass-differences.test.ts
    │   │   ├── haptic.test.ts
    │   │   ├── has-hass-connection-changed.test.ts
    │   │   ├── is-ha-relative-url.test.ts
    │   │   ├── is-hass-different.test.ts
    │   │   ├── is-triggered-state.test.ts
    │   │   ├── panel.test.ts
    │   │   ├── resolved-media.test.ts
    │   │   ├── side-load-ha-elements.test.ts
    │   │   ├── sign-path.test.ts
    │   │   ├── supports-feature.test.ts
    │   │   ├── web-proxy.test.ts
    │   │   ├── ws-request.test.ts
    │   │   ├── browse-media/
    │   │   │   ├── browse-media-to-view-media.test.ts
    │   │   │   ├── item-factory.test.ts
    │   │   │   ├── item.test.ts
    │   │   │   ├── sort.test.ts
    │   │   │   ├── types.test.ts
    │   │   │   ├── walker.test.ts
    │   │   │   └── within-dates.test.ts
    │   │   ├── integration/
    │   │   │   └── index.test.ts
    │   │   └── registry/
    │   │       ├── device/
    │   │       │   └── index.test.ts
    │   │       └── entity/
    │   │           ├── index.test.ts
    │   │           └── mock.ts
    │   ├── templates/
    │   │   └── index.test.ts
    │   ├── utils/
    │   │   ├── action.test.ts
    │   │   ├── audio.test.ts
    │   │   ├── basic.test.ts
    │   │   ├── camera.test.ts
    │   │   ├── casting.test.ts
    │   │   ├── companion.test.ts
    │   │   ├── controls.test.ts
    │   │   ├── debug.test.ts
    │   │   ├── diagnostics.test.ts
    │   │   ├── download.test.ts
    │   │   ├── endpoint.test.ts
    │   │   ├── fire-advanced-camera-card-event.test.ts
    │   │   ├── initializer.test.ts
    │   │   ├── interaction-mode.test.ts
    │   │   ├── media-info.test.ts
    │   │   ├── media-layout.test.ts
    │   │   ├── ptz.test.ts
    │   │   ├── regexp-extract.test.ts
    │   │   ├── screenshot.test.ts
    │   │   ├── scroll.test.ts
    │   │   ├── sleep.test.ts
    │   │   ├── substream.test.ts
    │   │   ├── text-direction.test.ts
    │   │   ├── timer.test.ts
    │   │   ├── zod.test.ts
    │   │   └── embla/
    │   │       ├── carousel-controller.test.ts
    │   │       ├── test-utils.ts
    │   │       └── plugins/
    │   │           └── auto-media-loaded-info/
    │   │               └── auto-media-loaded-info.test.ts
    │   └── view/
    │       ├── item-classifier.test.ts
    │       ├── item.test.ts
    │       ├── query-classifier.test.ts
    │       ├── query-results.test.ts
    │       ├── query.test.ts
    │       ├── view-to-cameras.test.ts
    │       └── view.test.ts
    ├── .devcontainer/
    │   ├── devcontainer.json
    │   ├── Dockerfile
    │   ├── homeassistant_preconfig/
    │   │   └── .storage/
    │   │       ├── lovelace
    │   │       └── lovelace_resources
    │   └── scripts/
    │       └── devcontainer_initialize.sh
    └── .github/
        ├── dependabot.yml
        ├── FUNDING.yml
        ├── labels.yml
        ├── release-drafter.yml
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            ├── build.yml
            ├── labeler.yml
            ├── lock.yml
            ├── manual-release-drafter.yml
            ├── manual-release.yml
            ├── semantic-prs.yml
            └── semantic-release.yml

================================================
FILE: README.md
================================================
<!-- markdownlint-disable first-line-heading -->
<!-- markdownlint-disable fenced-code-language -->
<!-- markdownlint-disable no-inline-html -->

[![GitHub Release](https://img.shields.io/github/release/dermotduffy/advanced-camera-card.svg?style=flat-square)](https://github.com/dermotduffy/advanced-camera-card/releases)
[![Build Status](https://img.shields.io/github/actions/workflow/status/dermotduffy/advanced-camera-card/build.yml?style=flat-square)](https://github.com/dermotduffy/advanced-camera-card/actions/workflows/build.yml)
[![License](https://img.shields.io/github/license/dermotduffy/advanced-camera-card.svg?style=flat-square)](LICENSE)
[![HACS](https://img.shields.io/badge/HACS-default-orange.svg?style=flat-square)](https://hacs.xyz)
[![Sponsor](https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=%23fe8e86&style=flat-square)](https://github.com/sponsors/dermotduffy)

<img src="https://raw.githubusercontent.com/dermotduffy/advanced-camera-card/main/docs/images/advanced-camera-card.png" alt="Advanced Camera Card" width="500px">

# Advanced Camera Card

Formerly known as: `Frigate Card`

A comprehensive camera card for Home Assistant.

- Live viewing of multiple cameras.
- Clips and snapshot browsing via mini-gallery.
- Automatic updating to continually show latest clip / snapshot.
- Support for filtering events by zone and label.
- Arbitrary entity access via menu (e.g. motion sensor access).
- Fullscreen mode.
- Grid or carousel/swipeable media, thumbnails and cameras.
- Direct media downloads.
- Lovelace visual editing.
- Full [Picture Elements](https://www.home-assistant.io/lovelace/picture-elements/) support.
- Theme friendly.

See [full documentation](https://dermotduffy.github.io/advanced-camera-card).



================================================
FILE: docker-compose.yml
================================================
---
services:
  devcontainer:
    build: .devcontainer
    init: true
    env_file:
      - .env
    volumes:
      - /var/run/docker.sock:/var/run/docker-host.sock
      - .:${LOCAL_WORKSPACE_FOLDER}:cached
  homeassistant:
    extends:
      file: .devcontainer/frigate-hass-integration/docker-compose.yml
      service: homeassistant
    volumes:
      - .devcontainer/homeassistant_preconfig:/preconfig.d/02-card:ro
  frigate:
    extends:
      file: .devcontainer/frigate-hass-integration/docker-compose.yml
      service: frigate
  mqtt:
    extends:
      file: .devcontainer/frigate-hass-integration/docker-compose.yml
      service: mqtt



================================================
FILE: eslint.config.mjs
================================================
import { defineConfig } from 'eslint/config';
import tsParser from '@typescript-eslint/parser';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import js from '@eslint/js';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
});

export default defineConfig([
  {
    extends: compat.extends('plugin:@typescript-eslint/recommended', 'prettier'),

    languageOptions: {
      parser: tsParser,
      ecmaVersion: 2020,
      sourceType: 'module',
    },

    rules: {},
  },
]);



================================================
FILE: hacs.json
================================================
{
  "name": "Advanced Camera Card",
  "render_readme": true,
  "filename": "advanced-camera-card.js",
  "homeassistant": "2022.3.0"
}



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2021 Dermot Duffy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: markdown-link-check.json
================================================
{
  "ignorePatterns": [
    {
      "pattern": "vscode://"
    }
  ]
}



================================================
FILE: package.json
================================================
{
  "name": "advanced-camera-card",
  "version": "0.0.0-dev",
  "description": "Advanced Camera Card for Home Assistant",
  "keywords": [
    "advanced",
    "camera",
    "card",
    "frigate",
    "home-assistant",
    "homeassistant",
    "hass",
    "lovelace"
  ],
  "type": "module",
  "module": "advanced-camera-card.js",
  "repository": "github:dermotduffy/advanced-camera-card",
  "author": "Dermot Duffy <dermot.duffy@gmail.com>",
  "license": "MIT",
  "dependencies": {
    "@cycjimmy/jsmpeg-player": "^6.0.5",
    "@dermotduffy/panzoom": "^4.5.1",
    "@egjs/hammerjs": "^2.0.17",
    "@graphiteds/core": "^1.9.21",
    "@lit-labs/scoped-registry-mixin": "^1.0.3",
    "@lit-labs/task": "^1.1.3",
    "@types/bluebird": "^3.5.42",
    "any-date-parser": "^2.2.0",
    "component-emitter": "^1.3.1",
    "compute-scroll-into-view": "^3.1.1",
    "crypto": "^1.0.1",
    "date-fns": "^3.6.0",
    "date-fns-tz": "^3.1.3",
    "embla-carousel": "^8.6.0",
    "embla-carousel-wheel-gestures": "^8.0.1",
    "ha-nunjucks": "^1.3.0",
    "home-assistant-js-websocket": "^9.4.0",
    "js-yaml": "^4.1.0",
    "keycharm": "^0.4.0",
    "lit": "^3.1.4",
    "lodash-es": "^4.17.21",
    "masonry-layout": "^4.2.2",
    "moment": "^2.30.1",
    "p-queue": "^8.0.1",
    "propagating-hammerjs": "^2.0.1",
    "quick-lru": "^6.1.2",
    "screenfull": "^6.0.2",
    "side-drawer": "^3.1.0",
    "uuid": "^8.3.2",
    "vis-data": "^7.1.9",
    "vis-timeline": "^7.7.3",
    "vis-util": "^5.0.7",
    "web-dialog": "^0.0.11",
    "xss": "^1.0.15",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@babel/core": "^7.24.7",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@babel/plugin-transform-class-properties": "^7.24.7",
    "@rollup/plugin-babel": "^6.0.4",
    "@rollup/plugin-commonjs": "^26.0.1",
    "@rollup/plugin-image": "^3.0.3",
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-replace": "^5.0.7",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^11.1.6",
    "@semantic-release/github": "^10.3.3",
    "@types/js-yaml": "^4",
    "@types/lodash-es": "^4.17.12",
    "@types/masonry-layout": "^4.2.8",
    "@typescript-eslint/eslint-plugin": "^8.30.1",
    "@typescript-eslint/parser": "^8.30.1",
    "@vitest/coverage-istanbul": "^1.6.0",
    "conventional-changelog-conventionalcommits": "^8.0.0",
    "docsify-cli": "^4.4.4",
    "eslint": "^9.24.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-import": "^2.29.1",
    "jsdom": "^21.1.2",
    "markdown-link-check": "^3.12.2",
    "prettier": "^3.3.2",
    "rollup": "^3.29.4",
    "rollup-plugin-git-info": "^1.0.0",
    "rollup-plugin-serve": "^1.1.1",
    "rollup-plugin-styler": "^1.8.0",
    "rollup-plugin-svgo": "^2.0.0",
    "rollup-plugin-visualizer": "^5.12.0",
    "sass": "patch:sass@npm%3A1.77.4#~/.yarn/patches/sass-npm-1.77.4-13b6910aea.patch",
    "semantic-release": "^24.1.1",
    "semantic-release-export-data": "^1.1.0",
    "ts-prune": "^0.10.3",
    "type-fest": "^4.41.0",
    "typescript": "^5.8.3",
    "vitest": "^1.6.0",
    "vitest-mock-extended": "^1.3.1"
  },
  "release": {
    "plugins": [
      [
        "@semantic-release/commit-analyzer",
        {
          "preset": "conventionalcommits"
        }
      ],
      [
        "@semantic-release/release-notes-generator",
        {
          "preset": "conventionalcommits",
          "presetConfig": {
            "types": [
              {
                "type": "feat",
                "section": ":rocket: Features"
              },
              {
                "type": "fix",
                "section": ":bug: Bug Fixes"
              },
              {
                "type": "docs",
                "section": ":books: Documentation"
              },
              {
                "type": "test",
                "section": ":rotating_light: Tests"
              },
              {
                "type": "ci",
                "section": ":construction_worker: Continuous Integration"
              },
              {
                "type": "refactor",
                "section": ":hammer: Code Refactoring"
              },
              {
                "type": "perf",
                "section": ":racehorse: Performance Improvements"
              },
              {
                "type": "chore",
                "section": ":wrench: Chores"
              }
            ]
          }
        }
      ],
      "semantic-release-export-data",
      [
        "@semantic-release/github",
        {
          "assets": [
            {
              "path": "advanced-camera-card.zip",
              "label": "Zip distribution"
            },
            {
              "path": "dist/*.js"
            }
          ],
          "draftRelease": false,
          "labels": [
            "ci"
          ],
          "assignees": [
            "dermotduffy"
          ],
          "successComment": ":tada: This issue has been resolved in version ${nextRelease.version} :tada:\n\nSee: [GitHub release](https://github.com/dermotduffy/advanced-camera-card/releases/tag/${nextRelease.gitTag})",
          "releaseNameTemplate": "v${nextRelease.version}"
        }
      ]
    ]
  },
  "scripts": {
    "start": "rollup -c --watch",
    "build": "yarn run lint && yarn run rollup",
    "docs": "docsify serve ./docs",
    "docs-check-links": "find ./docs -name '*.md' -print0 | xargs -0 -n1 markdown-link-check -c ./markdown-link-check.json",
    "docs-update-images": "./scripts/docs-update-images.sh",
    "docs-update-dependencies": "./scripts/docs-update-dependencies.sh",
    "lint": "eslint 'src/**/*.ts'",
    "format": "prettier --write .",
    "format-check": "prettier --check .",
    "rollup": "rollup -c",
    "prune": "ts-prune",
    "test": "vitest run",
    "coverage": "vitest run --coverage"
  },
  "volta": {
    "node": "22.14.0",
    "yarn": "4.9.1"
  }
}



================================================
FILE: prettier.config.js
================================================
// @ts-check

/**
 * @see https://prettier.io/docs/en/configuration.html
 * @type {import('prettier').Options}
 * */
const config = {
  semi: true,
  trailingComma: 'all',
  singleQuote: true,
  printWidth: 89,
  tabWidth: 2,
  embeddedLanguageFormatting: 'auto',
};

export default config;



================================================
FILE: project.inlang.json
================================================
{
  "$schema": "https://inlang.com/schema/project-settings",
  "sourceLanguageTag": "en",
  "languageTags": ["ca", "en", "fr", "it", "pt-BR", "pt-PT"],
  "modules": [
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-json@4/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-identical-pattern@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@1/dist/index.js"
  ],
  "plugin.inlang.json": {
    "pathPattern": "./src/localize/languages/{languageTag}.json",
    "variableReferencePattern": ["{", "}"]
  }
}



================================================
FILE: rollup.config.js
================================================
import commonjs from '@rollup/plugin-commonjs';
import image from '@rollup/plugin-image';
import json from '@rollup/plugin-json';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import replace from '@rollup/plugin-replace';
import terser from '@rollup/plugin-terser';
import typescript from '@rollup/plugin-typescript';
import gitInfo from 'rollup-plugin-git-info';
import serve from 'rollup-plugin-serve';
import styles from 'rollup-plugin-styler';
import svgo from 'rollup-plugin-svgo';
import { visualizer } from 'rollup-plugin-visualizer';

const watch = process.env.ROLLUP_WATCH === 'true' || process.env.ROLLUP_WATCH === '1';
const dev = watch || process.env.DEV === 'true' || process.env.DEV === '1';

/**
 * @type {import('rollup-plugin-serve').ServeOptions}
 */
const serveopts = {
  contentBase: ['./dist'],
  host: '0.0.0.0',
  port: 10001,
  allowCrossOrigin: true,
  headers: {
    'Access-Control-Allow-Origin': '*',
  },
};

/**
 * @type {import('rollup').RollupOptions['plugins']}
 */
const plugins = [
  gitInfo.default({ enableBuildDate: true, updateVersion: false }),
  styles({
    modules: false,
    // Behavior of inject mode, without actually injecting style
    // into <head>.
    mode: ['inject', () => undefined],
    sass: {
      includePaths: ['./node_modules/'],
    },
  }),
  svgo(),
  image({ exclude: '**/*.svg' }),
  nodeResolve({
    browser: true,
  }),
  commonjs({
    include: 'node_modules/**',
    sourceMap: false,
  }),
  typescript({
    sourceMap: dev,
    inlineSources: dev,
    exclude: ['dist/**', 'tests/**/*.test.ts'],
  }),
  json({ exclude: 'package.json' }),
  replace({
    preventAssignment: true,
    values: {
      'process.env.NODE_ENV': JSON.stringify(dev ? 'development' : 'production'),
      __ADVANCED_CAMERA_CARD_RELEASE_VERSION__:
        process.env.RELEASE_VERSION ?? (dev ? 'dev' : 'pkg'),
    },
  }),
  watch && serve(serveopts),
  !dev && terser(),
  visualizer({
    filename: 'visualizations/treemap.html',
    template: 'treemap',
  }),
];

const outputEntryTemplate = {
  entryFileNames: 'advanced-camera-card.js',
  dir: 'dist',
  chunkFileNames: (chunk) => {
    // Add "lang-" to the front of the language chunk names for readability.
    if (
      chunk.facadeModuleId &&
      chunk.facadeModuleId.match(/localize\/languages\/.*\.json/)
    ) {
      return 'lang-[name]-[hash].js';
    }
    return '[name]-[hash].js';
  },
  format: 'es',
  sourcemap: dev,
};

const CIRCULAR_DEPENDENCY_IGNORE_REGEXP = /(ha-nunjucks|ts-py-datetime)/;

/**
 * @type {import('rollup').RollupOptions}
 */
const config = {
  input: 'src/card.ts',
  // Specifically want a facade created as HACS will attach a hacstag
  // queryparameter to the resource. Without a facade when chunks re-import the
  // card chunk, they'll refer to a 'different' copy of the card chunk without
  // the hacstag, causing a re-download of the same content and functionality
  // problems.
  preserveEntrySignatures: 'strict',
  output: [
    outputEntryTemplate,

    // Continue to include the old file name for backwards compatibility.
    {
      ...outputEntryTemplate,
      entryFileNames: 'frigate-hass-card.js',
    },
  ],
  plugins: plugins,
  // These files use this at the toplevel, which causes rollup warning
  // spam on build: `this` has been rewritten to `undefined`.
  moduleContext: {
    './node_modules/@formatjs/intl-utils/lib/src/diff.js': 'window',
    './node_modules/@formatjs/intl-utils/lib/src/resolve-locale.js': 'window',
  },
  // Ignore circular dependencies from underlying libraries.
  onwarn: (warning, defaultHandler) => {
    if (
      warning.code === 'CIRCULAR_DEPENDENCY' &&
      warning.ids.some((id) => id.match(CIRCULAR_DEPENDENCY_IGNORE_REGEXP))
    ) {
      return;
    }
    defaultHandler(warning);
  },
};

export default config;



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2021",
    "module": "es2020",
    "moduleResolution": "node",
    "lib": ["es2021", "dom", "dom.iterable"],
    "noEmit": true,
    "noErrorTruncation": false,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "strict": true,
    "noImplicitAny": false,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "plugins": [
      {
        "name": "ts-lit-plugin",
        "strict": false,
        // These tags are provided by the HA frontend and [almost all] cannot be
        // imported by a custom card directly.
        "globalTags": [
          "ha-button-menu",
          "ha-button",
          "ha-camera-stream",
          "ha-card",
          "ha-combo-box",
          "ha-hls-player",
          "ha-icon-button",
          "ha-icon",
          "ha-menu-button",
          "ha-selector",
          "ha-spinner",
          "ha-state-icon",
          "ha-web-rtc-player",
          "mwc-button",
          "mwc-list-item",
          "state-badge"
        ],
        "rules": {
          "no-unknown-tag-name": "error",
          "no-missing-import": "error",
          "no-unclosed-tag": "error",
          "no-incompatible-type-binding": "warning",
          "no-invalid-css": "warning",
          "no-missing-element-type-definition": "warning",
          "no-property-visibility-mismatch": "error"
        }
      }
    ]
  }
}



================================================
FILE: vite.config.ts
================================================
import { defineConfig } from 'vitest/config';

// These globs are expected to have 100% coverage.
const FULL_COVERAGE_FILES_RELATIVE = [
  'camera-manager/*.ts',
  'camera-manager/browse-media/camera.ts',
  'camera-manager/browse-media/utils/*.ts',
  'camera-manager/frigate/camera.ts',
  'camera-manager/frigate/requests.ts',
  'camera-manager/frigate/util.ts',
  'camera-manager/generic/*.ts',
  'camera-manager/reolink/*.ts',
  'camera-manager/utils/*.ts',
  'card-controller/**/*.ts',
  'components-lib/**/!(timeline-source.ts)',
  'conditions/**/*.ts',
  'config/**/*.ts',
  'const.ts',
  'ha/**/*.ts',
  'types.ts',
  'utils/action.ts',
  'utils/audio.ts',
  'utils/basic.ts',
  'utils/camera.ts',
  'utils/casting.ts',
  'utils/companion.ts',
  'utils/custom-icons.ts',
  'utils/debug.ts',
  'utils/diagnostics.ts',
  'utils/download.ts',
  'utils/embla/**/*.ts',
  'utils/endpoint.ts',
  'utils/initializer.ts',
  'utils/interaction-mode.ts',
  'utils/media-info.ts',
  'utils/media-layout.ts',
  'utils/media.ts',
  'utils/ptz.ts',
  'utils/regexp-extract.ts',
  'utils/screenshot.ts',
  'utils/scroll.ts',
  'utils/substream.ts',
  'utils/text-direction.ts',
  'utils/timer.ts',
  'utils/zod.ts',
  'view/*.ts',
];

interface Threshold {
  statements: number;
  branches: number;
  functions: number;
  lines: number;
  perFile: boolean;
}

const fullCoverage: Threshold = {
  statements: 100,
  branches: 100,
  functions: 100,
  lines: 100,
  perFile: true,
};

const calculateFullCoverageThresholds = (): Record<string, Threshold> => {
  return FULL_COVERAGE_FILES_RELATIVE.reduce(
    (a, v) => ({ ...a, ['**/src/' + v]: fullCoverage }),
    {},
  );
};

// ts-prune-ignore-next
export default defineConfig({
  test: {
    server: {
      deps: {
        // These dependencies import without extensions.
        // Related: https://github.com/vitest-dev/vitest/issues/2313
        inline: ['ha-nunjucks', 'ts-py-datetime'],
      },
    },
    include: ['tests/**/*.test.ts'],
    coverage: {
      exclude: ['docs/**', 'tests/**', '.eslintrc.cjs'],

      // Favor istanbul for coverage over v8 due to better accuracy.
      provider: 'istanbul',
      thresholds: {
        ...calculateFullCoverageThresholds(),
      },
    },
  },
});



================================================
FILE: .eslintrc.cjs
================================================
module.exports = {
  parser: '@typescript-eslint/parser', // Specifies the ESLint parser
  parserOptions: {
    ecmaVersion: 2020, // Allows for the parsing of modern ECMAScript features
    sourceType: 'module', // Allows for the use of imports
  },
  extends: [
    'plugin:@typescript-eslint/recommended', // Uses the recommended rules from the @typescript-eslint/eslint-plugin
    'prettier', // Uses eslint-config-prettier to disable ESLint rules from @typescript-eslint/eslint-plugin that would conflict with prettier
  ],
  rules: {
    // Place to specify ESLint rules. Can be used to overwrite rules specified from the extended configs
    // e.g. "@typescript-eslint/explicit-function-return-type": "off",
  },
};



================================================
FILE: .prettierignore
================================================
docs/js/
.devcontainer/



================================================
FILE: .yarnrc.yml
================================================
nodeLinker: node-modules



================================================
FILE: docs/README.md
================================================
# Getting Started

## Installation

- [HACS](https://hacs.xyz/) is **highly** recommended to install the card -- it works for all Home Assistant variants. If you don't have [HACS](https://hacs.xyz/) installed, start there -- then come back to these instructions.

- Find the card in HACS:

```
Home Assistant > HACS > Frontend > "Explore & Add Integrations" > Advanced Camera Card
```

- Click `Download this repository with HACS`.

See [Advanced Installation](advanced-installation.md) for other installation resources, or [Rolling Back](./rolling-back.md) to rollback to prior versions.

## Adding your card

- On a Home Assistant dashboard, choose:

```
[Three dots menu] > Edit dashboard
```

- Click `+ Add Card` shown on the bottom of the screen
- Choose `Custom: Advanced Camera Card` from the list

## Initial configuration

### Minimal configuration

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
```

### Video scrubbing configuration

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
profiles:
  - scrubbing
```

### Multi-camera grid configuration

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
  - camera_entity: camera.kitchen
live:
  display:
    mode: grid
```

See [Configuration](configuration/README.md) for full details on supported configuration options.



================================================
FILE: docs/_coverpage.md
================================================
![logo](images/icons/iris.svg ':size=48px')

# Advanced Camera Card

> A comprehensive camera card for Home Assistant

<small>FKA: Frigate Card</small>

[GitHub](https://github.com/dermotduffy/advanced-camera-card/)
[Documentation](README.md)



================================================
FILE: docs/_sidebar.md
================================================
- [Getting Started](README.md)
- [Configuration](configuration/README.md)
- [Examples](examples.md)
- [Screenshots](screenshots.md)
- [Troubleshooting](troubleshooting.md)
- [Usage](usage/README.md)

---

- [Developing](developing.md)



================================================
FILE: docs/advanced-installation.md
================================================
# Advanced Installation

For most users, the installation instructions in the [Getting Started](README.md) section will install the card successfully. In some rarer situations, additional steps may need to be taken.

### Manual resource management

For most users, HACS should automatically add the necessary resources. Should this auto-registration not work you will need to complete one additional step.

#### Lovelace in "Storage Mode" (default)

- Navigate:

```
Three dots menu -> "Edit Dashboard" -> Three dots menu -> "Manage resources" -> "Add Resource"
```

- URL: `/hacsfiles/advanced-camera-card/advanced-camera-card.js`
- Resource type: `JavaScript Module`

#### Lovelace in "YAML mode" (rare)

You would see`mode: yaml` under `lovelace:` in your `configuration.yaml` if this applies to you.

- Add the following to `configuration.yaml`:

```yaml
lovelace:
  resources:
    - url: /hacsfiles/advanced-camera-card/advanced-camera-card.js
      type: module
```

- Restart Home Assistant.

### Manual installation

- Download the `advanced-camera-card.zip` attachment of the desired [release](https://github.com/dermotduffy/advanced-camera-card/releases) to a location accessible by Home Assistant. Note that the release will have a series of `.js` files (for HACS users) **and** a `advanced-camera-card.zip` for the convenience of manual installers.
- Unzip the file and move the contents of the `dist/` folder to any subfolder name you'd like, e.g. `advanced-camera-card` is used in the below example.
- Add the location as a Lovelace resource via the UI, or via [YAML configuration](https://www.home-assistant.io/lovelace/dashboards/#resources) such as:

```yaml
lovelace:
  mode: yaml
  resources:
    - url: /local/advanced-camera-card/advanced-camera-card.js
      type: module
```

### Unreleased versions

You can install any unreleased version of the card by leveraging the GitHub Actions artifacts that are generated on every revision. See a [video walkthrough](https://user-images.githubusercontent.com/29582865/228320074-6a2607f5-c637-48d5-b833-a553f8df8f4f.mp4) installing the latest revision of the `release-4.1.0` branch.



================================================
FILE: docs/CNAME
================================================
card.camera


================================================
FILE: docs/developing.md
================================================
# Developing

?> Want to contribute? Development help [**welcome**](https://github.com/dermotduffy/advanced-camera-card/issues/1248)!

## Building

This project uses [Volta](https://github.com/volta-cli/volta) to ensure a
consistent version of Node and Yarn are used during development. If you install
Volta in your environment, you should not need to worry about which version of
both to choose. **Note:** the dev container already comes with Volta installed.

However, if you are not using Volta, you can check the `volta` key in the
`package.json` to see which version of Node and Yarn should be used.

```sh
$ git clone https://github.com/dermotduffy/advanced-camera-card
$ cd advanced-camera-card
$ yarn install
$ yarn run build
```

Resultant build entry file will be in `dist/advanced-camera-card.js`. This could be
installed via the [manual installation
instructions](advanced-installation.md?id=manual-installation).

## Releasing

### Release Philosophy

Post `v6.0.0`, all releases are automated with ([semantic-release](https://github.com/semantic-release/semantic-release)) after every merged commit. This significantly reduces the time between merge and ability for users to try the change, but also entirely removes the "emotional notion" that a new major release version (i.e. `v6` -> `v7`) contains major new features. Rather it may simply contain a single backwards incompatible change.

Releases follow [Semantic Versioning](https://semver.org/) with the following definitions:

- **MAJOR** version changes for any backwards incompatible changes (excluding functionality marked as experimental). This means any change that would _require_ users to update their card config, regardless of whether that update is automated or manual.
- **MINOR** version changes for any functionality added in a backwards compatible manner. This may mean new features or behavioral changes that do not require a card update.
- **PATCH** version changes for backward compatible bug fixes

### Manual Releases

1. Merge a PR that contains only a `package.json` version number bump.
1. Go to the [releases page](https://github.com/dermotduffy/advanced-camera-card/releases).
1. A release draft will automatically have been created, click 'Edit'.
1. Use the same version number for the release title and tag.
1. Choose 'This is a pre-release' for a beta version.
1. Hit 'Publish release'.

## Translations

To add translations, you can manually edit the JSON translation files in
`src/localize/languages` or use the [inlang](https://inlang.com/) online editor.

## Using a dev container

[![Open in Dev Containers](https://img.shields.io/static/v1?label=Dev%20Containers&message=Open&color=blue&logo=visualstudiocode)](https://vscode.dev/redirect?url=vscode://ms-vscode-remote.remote-containers/cloneInVolume?url=https://github.com/dermotduffy/advanced-camera-card)

You can use the [VS Code Dev Containers](https://code.visualstudio.com/docs/remote/containers) extension to
speed up the development environment creation. Simply:

1. Clone the repository to your machine
2. Open VS Code on it
3. Reopen the folder in the Dev Container
4. Once done, press `F5` to start debugging

Everything should just work without any additional configuration. Under the
hood, the dev container setup takes care of bringing up:

- Home Assistant (port `8123` or the next available one)
- Frigate (ports `5000` or the next available one)
- MQTT (port `1883` or the next available one)

As docker-compose containers.

- The Frigate Home Assistant Integration is registered as a `git submodule` at `.devcontainer/frigate-hass-integration`, and VS Code will initialize/clone it for you before opening the dev container.

Some environment variables are supported in a `.env` file:

- `FRIGATE_VERSION`: The version of Frigate to use. Defaults to the latest stable version.
- `HA_VERSION`: The version of Home Assistant to use. Defaults to the latest stable version.

?> When not specifying any version, it's recommended that you `docker-compose pull` the stack from time to time to ensure you have the latest versions of the images.

The Home Assistant container will get preconfigured during first initialization,
therefore, if you changed the Home Assistant configuration, you will need to
remove the HA container and start another.



================================================
FILE: docs/examples.md
================================================
# Examples

## Actions on `tap`

You can add actions to the card to be trigger on `tap`, `double_tap`, `hold`, `start_tap` or `end_tap`.

In this example double clicking the card in any view will cause the card to go
into fullscreen mode, **except** when the view is `live` in which case the
office lights are toggled.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
view:
  actions:
    double_tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: fullscreen
live:
  actions:
    entity: light.office_main_lights
    double_tap_action:
      action: toggle
```

## Aspect ratios

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
dimensions:
  aspect_ratio_mode: static
  aspect_ratio: '4:3'
```

## Automation

### Responding to fullscreen

This example will automatically turn on the first configured substream when the
card is put in fullscreen mode, and turn off the substream when exiting
fullscreen mode.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: image
    dependencies:
      cameras:
        - office_hd
  - camera_entity: camera.office
    title: Office HD
    live_provider: go2rtc
    id: office_hd
    capabilities:
      disable_except:
        - substream
        # Also allow PTZ controls on the substream.
        - ptz
automations:
  - conditions:
      - condition: fullscreen
        fullscreen: true
    actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live_substream_on
    actions_not:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live_substream_off
```

### Responding to key input

In addition to a handful of reconfigurable [built-in keyboard shortcuts](./usage/keyboard-shortcuts.md), `automations` can be used to take any action based on any keyboard input. These examples use [`key` conditions](./configuration/conditions.md?id=key) to assess keyboard state before taking action.

#### Change to `live` temporarily

In this example, the view will change to `live`, when `Alt+Z` is pressed, and change to the `clips` view `5` seconds later.

```yaml
automations:
  - conditions:
      - condition: key
        key: z
        alt: true
    actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: sleep
        duration:
          s: 5
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: clips
```

#### Change to `live` while key _held_ down

In this example, the view will change to `live`, when `Alt+Z` is _held_ down, and immediately change to `clips` when _released_.

```yaml
automations:
  - conditions:
      - condition: key
        key: z
        alt: true
    actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live
    actions_not:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: clips
```

## Cameras

### `frigate` camera without a `camera_entity`

In this example, there is no Home Assistant entity linked to the camera, just a `frigate` camera name:

```yaml
type: custom:advanced-camera-card
cameras:
  - frigate:
      camera_name: office
    live_provider: go2rtc
```

### `go2rtc` stream without a `camera_entity`

In this example, there is no Home Assistant entity linked to the camera, just a `go2rtc` stream.

```yaml
type: custom:advanced-camera-card
cameras:
  - live_provider: go2rtc
    go2rtc:
      stream: office
      url: https://my.go2rtc.url:1984/
```

!> Browsers will reject [mixed content](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content): if you access Home Assistant over `https`, you must also put `go2rtc` behind `https` and use that in the `url` parameter.

## `card-mod`

This card allows the use of
[card-mod](https://github.com/thomasloven/lovelace-card-mod) to style arbitrary
card contents.

!> `card-mod` relies on the underlying internal DOM structure to style elements
-- as such, while its use is possible, it's not officially supported and zero
attempt is made to preserve backwards compatability of the internal DOM between
any versions. It may look good, but you're on your own!

This example changes the color and removes the padding around a [Picture
Elements state
label](https://www.home-assistant.io/lovelace/picture-elements/#state-label).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
card_mod:
  style:
    advanced-camera-card-elements $:
      hui-state-label-element $: |
        div {
          padding: 0px !important;
          color: blue;
        }
```

## Cast a `dashboard`

This example will configure an Advanced Camera Card that can cast a dashboard view to a media player, which has a second Advanced Camera Card in panel mode with a low-latency live provider.

### Source card

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: image
    cast:
      method: dashboard
      dashboard:
        dashboard_path: cast
        view_path: office
```

### Dashboard configuration

?> This dashboard is configured at the path `/cast/` (path referred to in `dashboard_path` above).

```yaml
title: Advanced Camera Card Casting
views:
  - title: Casting
    # This path is referred to in `view_path` above.
    path: office
    # Ensure the video is "maximized" / dashboard in "panel" mode.
    type: panel
    cards:
      - type: custom:advanced-camera-card
        cameras:
          - camera_entity: camera.office
            live_provider: go2rtc
```

## Conditional elements

You can restrict elements to only show for certain
[views](configuration/view.md?id=supported-views) using a
`custom:advanced-camera-card-conditional` element. This example shows a car icon that
calls a service but only in the `live` view.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-conditional
    conditions:
      - condition: view
        views:
          - live
    elements:
      - type: icon
        icon: mdi:car
        style:
          background: rgba(255, 255, 255, 0.25)
          border-radius: 5px
          right: 25px
          bottom: 50px
        tap_action:
          action: perform-action
          service: amcrest.ptz_control
          data:
            entity_id: camera.kitchen
            movement: up
```

## Conditional menu icons

You can have icons conditionally added to the menu based on entity state.

### Show a menu icon based on state

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: conditional
    conditions:
      - condition: state
        entity: light.office_main_lights
        state: on
    elements:
      - type: custom:advanced-camera-card-menu-state-icon
        entity: light.office
        tap_action:
          action: toggle
```

### Show a menu icon based on camera triggering

This example adds a menu button to optionally activate a siren when the camera is triggered.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-conditional
    elements:
      - type: custom:advanced-camera-card-menu-icon
        icon: mdi:alarm-bell
        title: Activate alarm
        style:
          color: red
        tap_action:
          action: perform-action
          perform_action: homeassistant.toggle
          target:
            entity_id: siren.siren
    conditions:
      - condition: triggered
        triggered:
          - camera.office
```

## Doorbell

[felipecrs/dahua-vto-on-home-assistant](https://github.com/felipecrs/dahua-vto-on-home-assistant#readme) provides an example on how this card can be used to answer a doorbell in Home Assistant.

![Doorbell example](images/doorbell-example.gif 'Doorbell example :size=400')

## Events from other cameras

`dependencies.cameras` allows events/recordings for other cameras to be shown
along with the currently selected camera. For example, this can be used to show
events with the `birdseye` camera (since it will not have events of its own).

### Using dependent cameras with birdseye

This example shows events for two other cameras when `birdseye` is selected.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
  - camera_entity: camera.kitchen
  - frigate:
      camera_name: birdseye
    dependencies:
      cameras:
        - camera.office
        - camera.kitchen
```

### Using dependent cameras with birdseye for all cameras

This example shows events for _all_ other cameras when `birdseye` is selected.
This is just a shortcut for naming all other cameras.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.kitchen
  - camera_entity: camera.sitting_room
  - frigate:
      camera_name: birdseye
    dependencies:
      all_cameras: true
```

## Folders

These examples create folders that can be viewed in the
[`media_gallery`](./configuration/media-gallery.md).

?> Having difficulty configuring your folders? Consult the [Worked
Examples](./configuration/folders.md?id=worked-examples) in the [`folders`
documentation](./configuration/folders.md?id=worked-examples).

### Home Assistant default root

This example creates a folder at the Home Assistant media root.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
folders:
  - type: ha
```

### Folder within the Home Assistant default root

This example applies a title match against the Home Assistant media root folder
looking for a folder entitled `Frigate`, and shows all items within it (since no
matcher is specified at the lowest level).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
folders:
  - type: ha
    ha:
      path:
        - matchers:
            - type: title
              title: 'Frigate'
        - {}
```

### Folder date parsing and matching

This example parses dates from a folder, and matches only those dates in the
last two days. It then parses times from the media items themselves.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
folders:
  - type: ha
    ha:
      url: >-
        https://my-ha-instance.local/media-browser/browser/app%2Cmedia-source%3A%2F%2Freolink/playlist%2Cmedia-source%3A%2F%2Freolink%2FCAM%7C01J8XHYTNH77WE3C654K03KX1F%7C0
      path:
        # Matches against the "Low resolution" folder.
        - matchers:
            - type: title
              regexp: (?<value>.*) resolution
              title: Low
        # Parses the date out of the next level (auto-detected format).
        - parsers:
            - type: date
          matchers:
            - type: date
              since:
                days: 2
        # Parses the time out of the items themselves (user-specified format).
        - parsers:
            - type: date
              format: 'HH:mm:ss'
```

#### Folder date matching by `template`

This example dynamically includes media from two subfolders, one for today and
one for yesterday both in `%Y/%-m/%d`
[format](https://www.man7.org/linux/man-pages/man3/strftime.3.html).
[Templating](https://www.home-assistant.io/docs/configuration/templating/#time)
is used to dynamically refer to "today" and "yesterday".

?> Using a `date` matcher (as above) should be preferred for matching dates,
this example is included for illustration.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
folders:
  - type: ha
    ha:
      url: https://my-ha-instance.local/media-browser/browser/app%2Cmedia-source%3A%2F%2Freolink/playlist%2Cmedia-source%3A%2F%2Freolink%2FCAM%7C01J8XAATNH77WE5D654K07KY1F%7C0
      path:
        - matchers:
            - type: title
              title: 'Low resolution'
        - matchers:
            - type: or
              matchers:
                - type: template
                  value_template: "{{ acc.media.title == now().strftime('%Y/%-m/%d') }}"
                - type: template
                  value_template: "{{ acc.media.title == (now() - dt.timedelta(days=1)) | timestamp_custom('%Y/%-m/%d') }}"
        - {}
```

### Folder Paths

This example starts with the `media-source://frigate` folder, and looks for a
precisely titled `Clips [my-instance]` folder within that. The resulting media
will be the contents of that folder (if found).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
folders:
  - type: ha
    ha:
      path:
        - id: 'media-source://frigate'
        - title: 'Clips [my-instance]'
```

### Folder URLs

This example uses the `url` parameter to establish the root of the query. Within
that folder, it looks for a sub-folder that matches the regular expression
`Clips.*`, and within that looks for a folder that matches the regular
expression `Person.*`. The resulting media will be the contents of that folder
(if found).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
folders:
  - type: ha
    ha:
      url: https://my-ha-instance.local/media-browser/browser/app%2Cmedia-source%3A%2F%2Ffrigate
      path:
        - matchers:
            - type: title
              regexp: 'Clips.*'
        - matchers:
            - type: title
              regexp: 'Person.*'
```

## Human interaction

This example will automatically use a HD live substream when
the mouse cursor interacts with the card.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: image
    dependencies:
      cameras:
        - camera.office_hd
  - camera_entity: camera.office_hd
    live_provider: go2rtc
    capabilities:
      disable_except:
        - substream
        # Also allow PTZ controls on the substream.
        - ptz
automations:
  - actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live_substream_on
    actions_not:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live_substream_off
    conditions:
      - condition: interaction
        interaction: true
```

## Media layout

These examples change how the media fits and is positioned within the card dimensions.

### Stretch a camera into a 4:4 square

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.landing
    dimensions:
      aspect_ratio: '4:4'
      layout:
        fit: fill
```

### Convert a landscape camera to a portrait live view

Take the left-hand side (position with x == `0`) and use that as the basis of a `9:16` (i.e. portrait) live view.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    dimensions:
      aspect_ratio: '9:16'
      layout:
        fit: cover
        position:
          x: 0
```

## Menu alignment

This example moves the fullscreen button into its own group aligned to the
`left`, enables the `image` button and orders it furthest to the `right`.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
menu:
  alignment: right
  buttons:
    image:
      enabled: true
      priority: 100
    fullscreen:
      alignment: opposing
```

## Menu icons

You can add custom icons to the menu with arbitrary actions. This example adds
an icon that navigates the browser to the releases page for this card:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:book
    tap_action:
      action: url
      url_path: https://github.com/dermotduffy/advanced-camera-card/releases
```

## Menu state icons

You can add custom state icons to the menu to show the state of an entity and
complete arbitrary actions. This example adds an icon that represents the state
of the `light.office_main_lights` entity, that toggles the light on double
click.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-menu-state-icon
    entity: light.office_main_lights
    tap_action:
      action: toggle
```

## Multiple actions

This example shows how to configure multiple actions for a single Advanced Camera Card user interaction, in this case both selecting a different camera and changing the view on `tap`. Note that multiple actions are not supported on stock Picture Elements, see [actions](configuration/actions/README.md) for more information.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:chair-rolling
    tap_action:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: camera_select
        camera: camera.office
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live
```

## Multiple providers

Cameras can be repeated with different providers (note the required use of `id`
to provide a separate unambiguous way of referring to that camera, since the
`camera_entity` is shared between the two cameras).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: jsmpeg
    title: Office (JSMPEG)
  - camera_entity: camera.office
    live_provider: webrtc-card
    title: Office (WebRTC)
    id: office-webrtc
```

## Overriding configuration

You can override card configuration when certain [conditions](configuration/conditions.md) are met.

### Change menu position based on HA state

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
overrides:
  - conditions:
      - condition: state
        entity: light.office_main_lights
        state: 'on'
    merge:
      menu:
        position: bottom
```

### Change default view based on HA state

This example changes the default card view from `live` to `image` depending on
the value of the `binary_sensor.alarm_armed` sensor. The override alone will
only change the _default_ when the card next is requested to change to the
default view. By also including the `view.default_reset.entities` parameter, we
ask the card to trigger a card update based on that entity -- which causes it to
use the new overriden default immediately.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
view:
  default: live
  default_reset:
    entities:
      - binary_sensor.alarm_armed
overrides:
  - conditions:
      - condition: state
        entity: binary_sensor.alarm_armed
        state: 'off'
    merge:
      view:
        default: image
```

### Change grid behavior in full screen

This example will always render 5 columns in fullscreen mode in both the live
and media viewer views, and will not enlarge the selected item. The [normal auto-layout behavior](configuration/grid-layout-algorithm.md) will be used outside of fullscreen mode.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
overrides:
  - conditions:
      - condition: fullscreen
        fullscreen: true
      - condition: display_mode
        display_mode: grid
    merge:
      live:
        display:
          grid_columns: 5
          grid_selected_width_factor: 1
      media_viewer:
        display:
          grid_columns: 5
          grid_selected_width_factor: 1
```

### Change menu style when expanded

This example changes the menu style to `overlay` in expanded mode in order to
take advantage of the extra horizontal space of the dialog/popup.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
menu:
  style: hidden
overrides:
  - conditions:
      - condition: expand
        expand: true
    merge:
      menu:
        style: overlay
```

### Hide menu in fullscreen

This example disables the menu unless the card is in fullscreen mode, and uses a
card-wide action to enable fullscreen mode on `double_tap`.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
view:
  actions:
    double_tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: fullscreen
overrides:
  - conditions:
      - condition: fullscreen
        fullscreen: true
    merge:
      menu:
        style: none
```

### Remove a camera when an entity state changes

This example removes a camera from the card when an entity is disabled (e.g. a switch controlling power to the camera).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
  - camera_entity: camera.kitchen
overrides:
  - conditions:
      - condition: state
        entity: switch.kitchen_camera_power
        state: off
    delete:
      - 'cameras[1]'
```

### Disable PTZ controls in the Home Assistant Companion App

This example disables the PTZ controls when the card is viewed on the Companion app:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
overrides:
  - conditions:
      - condition: user_agent
        companion: true
    set:
      live.controls.ptz.mode: 'off'
```

## PTZ control

The card supports using PTZ controls to conveniently control pan, tilt and zoom
for cameras. If you're using a Frigate camera, and Frigate itself shows PTZ
controls, this should work straight out of the box without any extra
configuration:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
```

If you're using a non-Frigate camera, or Frigate itself does not support the PTZ
controls on your camera but Home Assistant does, you can still manually
configure actions for the card to perform for each PTZ control:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    ptz:
      actions_left:
        action: perform-action
        perform_action: homeassistant.toggle
        target:
          entity_id: switch.camera_move_left
```

See the full [Camera PTZ Configuration](./configuration/live.md?id=ptz) for more information.

## `screen` conditions

These examples show altering the card configuration based on device or viewport properties.

### Change menu position when orientation changes

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
  - camera_entity: camera.kitchen
menu:
  style: overlay
overrides:
  - conditions:
      - condition: screen
        media_query: '(orientation: landscape)'
    merge:
      menu:
        position: left
```

### Hide menu & controls when viewport width &lt;= 300 (e.g. PIP mode)

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
  - camera_entity: camera.kitchen
overrides:
  - conditions:
      - condition: screen
        media_query: '(max-width: 300px)'
    merge:
      menu:
        style: none
      live:
        controls:
          next_previous:
            style: none
          thumbnails:
            mode: none
```

## State Badges

You can add a state badge to the card showing arbitrary entity states. This
example adds a state badge showing the temperature and hides the label text:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: state-badge
    entity: sensor.office_temperature
    style:
      right: '-20px'
      top: 100px
      color: rgba(0,0,0,0)
      opacity: 0.5
```

![Picture elements temperature example](images/picture-elements-temperature.png 'Picture elements temperature example :size=400')

## Static images

This example fetches a static image every 10 seconds (in this case the latest image saved on the Frigate server for a given camera).

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
view:
  default: image
image:
  src: https://my-friage-server/api/living_room/latest.jpg
  refresh_seconds: 10
```

## Status bar

### Disable status bar

This example disables the status bar.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
status_bar:
  style: none
```

### Dynamic status bar contents

This example shows an icon and a message on the status bar when a camera is triggered, replacing the existing contents of the status bar through the use of `exclusive`.

![Dynamic Status Messages](images/dynamic-status.gif 'Dynamic Status Messages :size=400')

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
automations:
  - conditions:
      - condition: triggered
        triggered:
          - camera.office
    actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: status_bar
        status_bar_action: add
        items:
          - type: custom:advanced-camera-card-status-bar-icon
            icon: mdi:alarm-light
            exclusive: true
          - type: custom:advanced-camera-card-status-bar-string
            string: Intruder detected!
            expand: true
            exclusive: true
            sufficient: true
    actions_not:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: status_bar
        status_bar_action: reset
```

## Submenus

You can add submenus to the menu -- buttons that when pressed reveal a dropdown submenu of configurable options.

### Basic submenu

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-menu-submenu
    icon: mdi:menu
    items:
      - title: Lights
        icon: mdi:lightbulb
        entity: light.office_main_lights
        tap_action:
          action: toggle
      - title: Google
        icon: mdi:google
        tap_action:
          action: url
          url_path: https://www.google.com
      - title: Fullscreen
        icon: mdi:fullscreen
        tap_action:
          action: custom:advanced-camera-card-action
          advanced_camera_card_action: fullscreen
```

### Conditional submenu

This example shows submenus conditional on the camera selected.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-conditional
    conditions:
      - condition: camera
        cameras:
          - camera.office
    elements:
      - type: custom:advanced-camera-card-menu-submenu
        icon: mdi:door
        items:
          - title: Office Lights
            icon: mdi:lightbulb
            entity: light.office_main_lights
            tap_action:
              action: toggle
  - type: custom:advanced-camera-card-conditional
    conditions:
      - condition: camera
        cameras:
          - camera.kitchen
    elements:
      - type: custom:advanced-camera-card-menu-submenu
        icon: mdi:sofa
        items:
          - title: Kitchen Lights
            icon: mdi:lightbulb
            entity: light.kitchen_lights
            tap_action:
              action: toggle
          - title: Kitchen Lamp
            icon: mdi:lightbulb
            entity: light.kitchen_lamp
            tap_action:
              action: toggle
```

### `select` submenu

You can easily add a submenu to the menu based on a `select` or `input_select` entity. This example imagines the user has an `input_select` entity configured in their Home Assistant configuration like so:

```yaml
input_select:
  office_scene:
    name: Office Scene Select
    options:
      - scene.office_quiet_scene
      - scene.office_party_scene
    icon: mdi:lightbulb
```

The following will convert this entity into a submenu:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-menu-submenu-select
    entity: input_select.office_scene
```

To override 1 or more individual options (e.g. to set custom icons and titles)

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: custom:advanced-camera-card-menu-submenu-select
    icon: mdi:lamps
    entity: input_select.office_scene
    options:
      scene.office_quiet_scene:
        icon: mdi:volume-off
        title: Ssssssh
      scene.office_party_scene:
        icon: mdi:party-popper
        title: Party!
```

## Substreams

The card supports configuring 'substreams' (alternative live views) a given
camera through the use of [camera dependencies](configuration/cameras/README.md?id=dependencies).

This example shows two substreams for a single live camera, and uses the 'HD' icon.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: image
    dependencies:
      cameras:
        - office_hd
  - camera_entity: camera.office
    title: Office HD
    live_provider: go2rtc
    id: office_hd
    capabilities:
      disable_except:
        # This camera serves only as a substream.
        - substream
        # Also allow PTZ controls on the substream.
        - ptz
menu:
  buttons:
    substreams:
      icon: mdi:high-definition
```

## Templates in actions

### Accessing Home Assistant state

Perhaps the most common usage of templates is to access Home Assistant state
values. In the below example a fictitious service `homeassistant.service` is
called with data that refers to the current state of the `light.sunroom_ceiling`
entity.

```yaml
tap_action:
  action: perform-action
  perform_action: homeassistant.service
  data:
    key: '{{ hass.states["light.sunroom_ceiling"].state }}'
```

See [Stock Templates](./configuration/templates.md?id=stock-templates).

### Accessing Advanced Camera Card state

In this example, the currently selected camera and
[view](./configuration/view.md) are passed as data to a fictitious service
`homeassistant.service`.

```yaml
tap_action:
  action: perform-action
  perform_action: homeassistant.service
  data:
    camera: '{{ advanced_camera_card.camera }}'
    view: '{{ advanced_camera_card.view }}'
```

See [Custom Templates](./configuration/templates.md?id=custom-templates).

### Accessing Trigger state

In this example, an [automation](./configuration/automations.md) is triggered,
and values associated with the triggering are included in the action.

```yaml
automations:
  - conditions:
      - condition: camera
    actions:
      - action: perform-action
        perform_action: homeassistant.service
        data:
          from_camera: '{{ acc.trigger.camera.from }}'
          to_camera: '{{ acc.trigger.camera.to }}'
```

See [Trigger Templates](./configuration/templates.md?id=triggers).

## Trigger actions

You can control the card itself with the `custom:advanced-camera-card-action` action.
This example shows an icon that toggles the card fullscreen mode.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
elements:
  - type: icon
    icon: mdi:fullscreen
    style:
      left: 40px
      top: 40px
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: fullscreen
```

## Trigger fullscreen

The card cannot automatically natively trigger fullscreen mode without the user
clicking, since Javascript (understandbly) prevents random websites from
triggering fullscreen mode without the user having activated it.

This example uses
[hass-browser_mod](https://github.com/thomasloven/hass-browser_mod) with an
automation to trigger a popup. Thanks to
[conorlap@](https://github.com/conorlap) for the following example:

```yaml
alias: >-
  Doorbell Pressed OR Human Detected - Firefox browser full screen video feed
  for 15 seconds
description: ''
trigger:
  - platform: state
    from: 'off'
    to: 'on'
    entity_id:
      - binary_sensor.frontdoor_person_occupancy
  - platform: state
    entity_id:
      - binary_sensor.front_door_dahua_button_pressed
    to: 'on'
condition: []
action:
  - service: browser_mod.popup
    data:
      size: wide
      timeout: 15000
      content:
        type: custom:advanced-camera-card
        aspect_ratio: 55%
        cameras:
          - camera_entity: camera.frontdoor
            live_provider: ha
        menu:
          style: none
        live:
          controls:
            title:
              mode: none
    target:
      device_id:
        - d0e93101edfg44y3yt35y5y45y54y
mode: single
```

## Trigger `live`

This example will change to `live` when a camera is triggered, using different
trigger conditions per camera. It will change back to the `default` view when
untriggered.

```yaml
type: custom:advanced-camera-card
cameras:
  # This is a Frigate camera which will automatically
  # be triggered when events occur.
  - camera_entity: camera.office
  # This is a Frigate camera which will only be triggered
  # by motion entity changes or a door being opened.
  - camera_entity: camera.kitchen
    triggers:
      occupancy: false
      motion: true
      entities:
        - binary_sensor.kitchen_door_opened
      events: []
view:
  triggers:
    show_trigger_status: true
    filter_selected_camera: false
    actions:
      trigger: live
      untrigger: default
```

## Video control from menu

Disable the stock video controls and add menu button equivalents.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
live:
  controls:
    builtin: false
media_viewer:
  controls:
    builtin: false
menu:
  buttons:
    play:
      enabled: true
    mute:
      enabled: true
```

## URL actions

The card can respond to actions in the query string. See [URL Actions](usage/url-actions.md).

?> These examples assume the dashboard URL is `https://ha.mydomain.org/lovelace-test/0` .

### Choosing `clips` view on a named card

This example assumes that one card (of potentially multiple Advanced Camera Cards on the dashboard) is configured with a `card_id` parameter:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
card_id: main
```

```text
https://ha.mydomain.org/lovelace-test/0?advanced-camera-card-action.main.clips
```

### Choosing the camera from a separate picture elements card

In this example, the card will select a given camera when the user navigates from a _separate_ Picture Elements card:

Advanced Camera Card configuration:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
  - camera_entity: camera.kitchen
```

Picture Elements configuration:

```yaml
type: picture-elements
image: https://demo.home-assistant.io/stub_config/floorplan.png
elements:
  - type: icon
    icon: mdi:cctv
    style:
      top: 22%
      left: 30%
    tap_action:
      action: navigate
      navigation_path: /lovelace-test/0?advanced-camera-card-action.camera_select=camera.office
  - type: icon
    icon: mdi:cctv
    style:
      top: 71%
      left: 42%
    tap_action:
      action: navigate
      navigation_path: /lovelace-test/0?advanced-camera-card-action.camera_select=camera.kitchen
```

![Taking card actions via the URL](images/navigate-picture-elements.gif 'Taking card actions via the URL :size=400')

### Selecting a camera in expanded mode via query string

```text
https://ha.mydomain.org/lovelace-test/0?advanced-camera-card-action.camera_select=kitchen&advanced_camera_card_action-action.expand
```

## WebRTC Card configuration

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: webrtc-card
    webrtc_card:
      ui: true
```

## Zoom

### Pre-defining camera zoom and pan

This example changes the default [zoom/pan settings for a camera](./configuration/cameras/README.md?id=layout-configuration) to always zoom in on a given area:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    dimensions:
      layout:
        zoom: 3
        pan:
          x: 20
          y: 80
```

### Disable zooming in media views

This example prevents zooming on the media viewer but keeps it on in other views (e.g. `live` view):

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    dimensions:
      layout:
        zoom: 3
        pan:
          x: 20
          y: 80
media_viewer:
  zoomable: false
```

### Different zoom settings in media viewer vs `live`

This example uses different settings for the media viewer and `live` view, by overriding the camera configuration:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    dimensions:
      layout:
        zoom: 2
overrides:
  - conditions:
      - condition: view
        views:
          - media
    set:
      'cameras[0].dimensions.layout':
        zoom: 3
        pan:
          x: 100
          y: 100
```

### Automatically zoom based on state

This example automatically zooms in and out based on the state of an entity:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.living_room
    live_provider: go2rtc
debug:
  logging: true
automations:
  - conditions:
      - condition: state
        entity: binary_sensor.door_contact
        state: 'on'
    actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: ptz_digital
        target_id: camera.living_room
        absolute:
          zoom: 4
          pan:
            x: 38
            y: 20
    actions_not:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: ptz_digital
        target_id: camera.living_room
```

![Zoom automation example](images/zoom-automation.gif 'Zoom automation example :size=400')



================================================
FILE: docs/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Advanced Camera Card</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="Advanced Camera Card Documentation" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no, viewport-fit=cover"
    />

    <!-- Favicon -->
    <link rel="icon" href="images/favicon.ico" />

    <!-- Themes (light + dark) -->
    <link
      rel="stylesheet"
      media="(prefers-color-scheme: dark)"
      href="./css/theme-simple-dark.css"
    />
    <link
      rel="stylesheet"
      media="(prefers-color-scheme: light)"
      href="./css/theme-simple.css"
    />
    <style>
      :root {
        --content-max-width: 95vw;
        --cover-heading-font-size-max: 48;
      }
      .svg-icon {
        background-color: rgb(255, 255, 255);
        vertical-align: middle;
        background: repeating-conic-gradient(#80808091 0% 25%, transparent 0% 50%) 50% /
          4px 4px;
      }
      #__sidebar img {
        max-width: 48px;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script>
      window.$docsify = {
        // Full reference: https://docsify.js.org/#/configuration

        // The repo to link to.
        repo: 'dermotduffy/advanced-camera-card',

        // The overall documentation name.
        name: 'Advanced Camera Card',

        // The logo to show on the top of the sidebar.
        logo: 'images/icons/iris.svg',

        // Automatically go to the top of a page on route change.
        auto2top: true,

        // Use a sidebar.
        loadSidebar: true,

        // Automatically use headings up to H2 for sider.
        subMaxLevel: 2,

        // Show the Advanced Camera Card cover page.
        coverpage: true,

        // Use relative links (this way both vscode and docsify work on clicking
        // a link).
        relativePath: true,

        // Skip the link to the main content.
        skipLink: false,

        // Google tag (Google Analytics 4).
        gtag: 'G-ZFD19QWCJP',
      };
    </script>

    <!-- Docsify preview (necessary for Google Analytics 4) -->
    <!-- Update when there's a docsify release after
    https://github.com/docsifyjs/docsify/pull/1702  -->
    <script src="./js/docsify.min.js"></script>
    <script src="./js/gtag.min.js"></script>

    <!-- Themeable -->
    <script src="./js/docsify-themeable.min.js"></script>

    <!-- Prism Syntax Highlighting for YAML -->
    <script src="./js/prism-yaml.min.js"></script>

    <!-- Search plugin -->
    <script src="./js/search.js"></script>

    <!-- Zoom in on images on click -->
    <script src="./js/zoom-image.min.js"></script>

    <!-- Copy samples can copy to clipboard -->
    <script src="./js/docsify-copy-code.min.js"></script>

    <!-- Allow sidebar selections to collapse -->
    <script src="./js/docsify-sidebar-collapse.min.js"></script>
  </body>
</html>



================================================
FILE: docs/rolling-back.md
================================================
# Rolling Back

There may be many versions of this card (see [release philosophy](./developing.md?id=release-philosophy)). If you experience trouble with one version, you can always rollback to a prior version.

### Rolling Back in HACS

- Open your Home Assistant instance and navigate to `HACS` in the sidebar
- Choose "Frontend"
- Click on "Advanced Camera Card"
- Click on the "Three dots menu"
- Choose "Redownload"
- Select the version you wish to change to
- Click "Download"
- Reload your browser

### Rolling Back Manually

If you didn't use `HACS` to install the card, you're on your own to roll it
back! Generally though this amounts to simply "replacing" an installation with
an older one, by following the [manual
installation](./advanced-installation.md?id=manual-installation) instructions
and simply choosing an older version to install.



================================================
FILE: docs/screenshots.md
================================================
# Screenshots

## 2-way audio

![](images/microphone.gif '2-way audio support :size=400')

## Cast media from card

![](images/cast-your-events.gif 'Cast media from the card :size=400')

## Cast whole card

A dashboard with the card can be cast onto a suitable device (such as the Nest Hub shown below).

![](images/card-on-nest-hub.jpg 'Card casting :size=400')

## Control via Entities

Bidirectional control of camera selection via an entity.

![](images/control-entities.gif 'Control via Entities :size=400')

## Dark mode

![](images/dark-mode.gif 'Dark mode :size=400')

## Editing

![](images/editor.gif 'Card editing :size=400')

## Events

![](images/gallery.png 'Full Viewing Of Events :size=400')

## Expanded mode

![](images/expanded.gif 'Expanded mode :size=400')

## Favoriting events

![](images/star.gif 'Card casting :size=400')

## Filtering

![](images/media-filtering.gif 'Media filtering :size=400')

## Folders

![](images/folders/ha-root.png 'Media Folders :size=400')

## Grid

![](images/grid-small.gif 'Interacting with a camera grid :size=400')

## Media layout

Pan around a large camera view to only show part of the video feed in the card at a different aspect ratio:

### Before

![](images/media-layout-a.png 'Before :size=400')

### After

![](images/media-layout-b.png 'After :size=400')

## Menu hovering

![](images/viewer-with-thumbnail-next-prev.gif 'Hover menu / Next & Previous controls :size=400')

## Menu media control

![](images/native-media-control.png 'In-menu media / mute control :size=400')

## Mixed engines

![](images/motioneye.gif 'Different camera sources/engines :size=400')

## Multiple cameras

Scroll through your live cameras, or choose from a menu. Seamlessly supports
cameras of different dimensions, and custom submenus per camera.

![](images/camera-carousel.gif 'Live viewing of multiple cameras :size=400')

## PTZ

![](images/native-ptz.gif 'PTZ control :size=400')

## Recordings

### Recordings single

![](images/recording-seek.gif 'Single camera recordings :size=400')

### Recordings multiple

![](images/recording-seek-all-cameras.gif 'Multiple camera recordings :size=400')

## Scrubbing

![](images/video-scrubbing.gif 'Video scrubbing :size=400')

## Status Bar

### Dynamic Status Messages

![](images/dynamic-status.gif 'Dynamic Status Messages :size=400')

## Submenus

![](images/submenu.gif 'Configurable submenus :size=400')

## Submenus with `select` entities

![](images/submenu-select.gif 'select entity submenus :size=400')

## Substreams

![](images/substream.gif 'Substreams :size=400')

## Thumbnail drawers

![](images/thumbnails-in-drawer.gif 'Thumbnail drawers :size=400')

## Thumbnails in live

![](images/live-thumbnails.gif 'Live viewing with thumbnail carousel :size=400')

## Thumbnails in media viewer

![](images/viewer-thumbnails.gif 'Clip viewing with thumbnail carousel :size=400')

## Timeline

![](images/timeline.gif 'Event timeline :size=400')

## Timeline date picking

![](images/date-picker.gif 'Timeline date picking :size=400')

## Timeline `ribbon`

![](images/ribbon-timeline.png 'Ribbon timeline :size=400')

## Triggering

Automatically choose the camera with the action!

![](images/triggered.gif 'Triggered! :size=400')

## URL actions

![](images/navigate-picture-elements.gif 'Taking card actions via the URL :size=400')

## Zoom

![](images/zoom.gif 'Zoom support :size=400')



================================================
FILE: docs/support.md
================================================
# Common Support Answers

## Diagnostics Missing In Issue

You have filed an issue against the card, but failed to include the required
diagnostics and/or missed this warning in the new issue template:

```
<!-- =================================================================
***               PLEASE DO NOT IGNORE THIS TEMPLATE
***
*** This is the smallest amount of information needed to help you!
====================================================================== -->
```

Without the diagnostic data, it is substantially more time consuming to try to
"guess" the basic parameters necessary to help you. I _really_ want this card to
incrementally improve, and I think time is better spent working on reproducible
issues or new features, than guessing what versions/options you are using. The
new issue template asks for the minimum possible information to support you:

- **Diagnostics**: On the card, hold down the Iris (default) menu button for a
  few seconds then paste the diagnostics into the issue between the backticks.
- **Description of the problem**: I need to understand the issue in sufficient
  detail.

This seems like a reasonably low bar for help, so if your issue gets closed for
not providing this information, please do not be offended. I want to help, just
need to prioritize my limited development time well. Feel free to re-open your
issue, providing the requested information.

## Misconceptions About Open Source

- The fixes aren't fast enough!
- The features aren't good enough!
- The quality control / testing is not sufficient!
- There are too [many](./troubleshooting.md?id=too-many-releases) / too few releases!
- It breaks too frequently!
- This just isn't good enough!
- My tone is disrespectful!

This is the joy of open source. A sense of entitlement regarding when/how soon
fixes should be provided, or new features developed, is misunderstanding the
fundamental dynamics of open source. I am sorry you feel this way, but open
source software (including this card) is typically provided "as-is". Take it or
leave it. If you want things to go faster / differently, [please
contribute](https://github.com/dermotduffy/advanced-camera-card/issues/1248). If
you don't want to contribute to the shared codebase, fork it and make your own.
Or pay for a (different) Enterprise grade solution to your problem. This is
certainly not that -- a card, developed in hobbiest-level time, with
hobbiest-level skills and ... at best ... hobbiest level support.

If you find yourself complaining, your expectations are incorrect! This is
undoubtedly frustrating (and I have often shared in this frustration), but it is
nonetheless just the way open source is. Take it or leave it.

Thank you for understanding!



================================================
FILE: docs/troubleshooting.md
================================================
# Troubleshooting

## Highlighted Issues

### Duplicate versions / Duplicate element registrations / `Custom element not found: advanced-camera-card`

If your card appears to not load anymore (but was working previously), you're
seeing the version of the card changing between reloads, or seeing log entries
like:

`Failed to execute 'define' on 'CustomElementRegistry': the name "focus-trap" has already been used with this registry window`

Verify that your dashboard resources contain only a single instance of the card
(for HACS users, you should see only `/hacsfiles/advanced-camera-card/`. If you
_also_ see `/hacsfiles/frigate-card/`, remove it, clear your caches and reload).

Steps:

1. Edit your dashboard -> (Three dots menu) -> `Manage Resources`. Remove any line item that refers to `frigate-hass-card`. You should only have a single row entry for `advanced-camera-card`.
1. [Optionally] You can delete the frigate-hass-card directory on your filesystem if present, e.g. `$HA_PATH/www/community/frigate-hass-card`, as long as it has an `advanced-camera-card` directory there too.
1. Clear all your caches.

### Stream does not load

Stream not loading? Permanent "loading circle"?

A stream not loading is a relatively common error, but can be caused by any
number of issues (e.g. installation problems, networking problems, video/codec
problems, a Home Assistant bug or card bug).

During the stream load, the card will show a "loading circle" icon and, for
cameras with a `camera_entity` configured, will show images refreshing once per
second until the stream has fully loaded (unless `live.show_image_during_load`
is set to false).

Debugging broken streams:

1. If you're using the default `auto` live provider, or explicitly setting the
   `ha` live provider, try opening the `camera_entity` in Home Assistant and
   verifying whether the stream loads there. You can press the `e` key on any
   Home Assistant dashboard, choose the relevant entity, and see if the stream
   loads. If it does not, you have a upstream installation issue with your
   camera / the integration for the camera, and need to resolve that first.
   Your issue is not related to the card itself.
1. Check whether any URLs specified in your card configuration are accessible
   _from the network of the browser_.
1. Check whether or not there are helpful clues shown on your Javascript
   console (`F12` in many browsers) that might indicate the source of the
   issue.
1. Check you are using the latest version of all relevant camera integrations
   (e.g.
   [Frigate](https://github.com/blakeblackshear/frigate-hass-integration)).
1. If you're using a Frigate camera and are requesting a `webrtc` stream,
   ensure [you have configured Frigate
   accordingly](https://docs.frigate.video/configuration/live/#webrtc-extra-configuration).
1. Search for your symptoms on the [card issues
   page](https://github.com/dermotduffy/advanced-camera-card/issues) and see if
   you find any prior relevant discussions.

If you're happy with just using an image stream but want the small circle to go
away, use the [`image live provider`](./configuration/cameras/live-provider.md?id=image) .

### Unknown Command

`Camera initialization failed: Unknown command`

Your Frigate integration may not be up to date. Check [the latest Frigate
Integration
releases](https://github.com/blakeblackshear/frigate-hass-integration/releases/tag/v5.7.0).

## Other Issues

### 2-way audio doesn't work

There are many requirements for 2-way audio to work. See [Using 2-way
audio](usage/2-way-audio.md) for more information about these. If your
microphone still does not work and you believe you meet all the requirements try
eliminating the card from the picture by going directly to the `go2rtc` UI,
navigating to `links` for your given stream, then to `webrtc.html` with a
microphone. If this does not work correctly with 2-way audio then your issue is
with `go2rtc` not with the card. In this case, you could file an issue in [that
repo](https://github.com/AlexxIT/go2rtc/issues) with debugging information as
appropriate.

### Android will not render &gt;4 JSMPEG live views

Android Webview (as used by Android Chrome / Android Home Assistant Companion)
appears to severely limit the number of simultaneous OpenGL contexts that can be
opened. The JSMPEG player (that this card uses), consumes 1 OpenGL context per
rendering.

This limitation may be worked around (at a performance penalty) by disabling
OpenGL for JSMPEG live views:

```yaml
live:
  jsmpeg:
    options:
      disableGl: true
```

[This bug](https://github.com/dermotduffy/advanced-camera-card/issues/191) has some
more discussion on this topic. New ideas to address this underlying limitation
most welcome!

### Autoplay in Chrome when a tab becomes visible again

Even if `live.auto_play` or `media_viewer.auto_play` is set to `[]`, Chrome
itself will still auto play a video that was previously playing prior to the tab
being hidden, once that tab is visible again. This behavior cannot be influenced
by the card. Other browsers (e.g. Firefox, Safari) do not exhibit this behavior.

### Blank white image on `live` view

For some slowly loading cameras, for which [Home Assistant stream
preloading](https://www.home-assistant.io/integrations/camera/) is not enabled,
Home Assistant may return a blank white image when asked for a still. These
stills are used during initial Advanced Camera Card load of the `live` view if the
`live.show_image_during_load` option is enabled. Disabling this option should
show the default media loading controls (e.g. a spinner or empty video player)
instead of the blank white image.

### Casting to Chromecast broken

This could be for any number of reasons. Chromecast devices can be quite picky
on network, DNS and certificate issues, as well as audio and video codecs. Check
your Home Assistant log as there may be more information in there.

!> In particular, for Frigate to support casting of clips, the default ffmpeg
settings for Frigate must be modified, i.e. Frigate does not encode clips in a
Chromecast compatible format out of the box (specifically: audio must be enabled
in the AAC codec, whether your camera supports audio or not). See the [Frigate
Home Assistant
documentation](https://docs.frigate.video/integrations/home-assistant) or [this
issue](https://github.com/blakeblackshear/frigate/issues/3175) for more.

### Custom element does not exist

This is usually a sign that the card is not correctly installed (i.e. the
browser cannot find the Javascript). In cases where it works in some browsers /
devices but not in others it may simply be an old browser / webview that does
not support modern Javascript (this is occasionally seen on old Android
hardware). In this latter case, you are out of luck.

### `double_tap` does not work in Android

The Android video player swallows `double_tap` interactions in order to
rewind or fast-forward. Workarounds:

- Use `hold` instead of `double_tap` for your card-wide action.
- Use an [Advanced Camera Card Element](configuration/elements/README.md) or menu icon to
  trigger the action instead.

### Dragging in carousels broken in Firefox

The Firefox video player swallows mouse interactions, so dragging is not
possible in carousels that use the Firefox video player (e.g. `clips` carousel,
or live views that use the `frigate` or `webrtc-card` provider). The next and
previous buttons may be used to navigate in these instances.

Dragging works as expected for snapshots, or for the `jsmpeg` provider.

### Dragging video control doesn't work in Safari

Dragging the Safari video controls "progress bar" conflicts with carousel
"dragging", meaning the video controls progress bar cannot be moved left or
right. Turning off carousel dragging (and using next/previous controls) will
return full video controls in Safari:

```yaml
live:
  draggable: false
media_viewer:
  draggable: false
```

### Downloads don't work

Downloads are assembled by the Frigate backend out of ~10s segment files. You
must have enough cache space in your Frigate instance to allow this assembly to
happen -- if large downloads don't work, especially for recordings, check your
Frigate backend logs to see if it's running out of space. You can increase your
cache size with the `tmpfs` `size` argument, see [Frigate
documentation](https://docs.frigate.video/frigate/installation#docker).

Large downloads may take a few seconds to assemble, so there may be a delay
between clicking the download button and the download starting.

### `Forbidden media source identifier`

- If you are using a custom `client_id` setting in your `frigate.yml` file (the
  configuration file for the Frigate backend itself), you must tell the card
  about it. See [Frigate engine
  configuration](configuration/cameras/engine.md?id=frigate).
- You must have the `Enable the media browser` option enabled for the Frigate
  integration, in order for media fetches to work for the card. Media fetches
  are used to fetch events / clips / snapshots, etc. If you just wish to use
  live streams without media fetches, you can use the following configuration:

```yaml
live:
  controls:
    thumbnails:
      mode: none
```

### Fullscreen doesn't work on iPhone

Unfortunately, [iOS does not support the Javascript fullscreen
API](https://caniuse.com/fullscreen) on the iPhone, which severely limits the
fullscreen functionality available. On iPhone, fullscreen is only possible of
the selected video element. As a result, there will be no menu, status bar, grid
support, gallery / timeline support, nor support for non-video based [live
providers](./configuration/cameras/live-provider.md) such as `image` or `jsmpeg`
-- exclusively viewing a selected live video or media video in fullscreen.

The card will only show the fullscreen menu button when fullscreen can usefully
be activated, which means for certain views on the iPhone it will be absent.

### iOS App not updating after card version change

Try resetting the app frontend cache:

- `Configuration -> Companion App -> Debugging -> Reset frontend cache`

### Javascript console errors

#### `[Violation] Added non-passive event listener to a scroll-blocking [...] event`

This card uses [visjs](https://github.com/visjs/vis-timeline) -- a timeline
library -- to show camera timelines. This library currently uses non-passive
event-listeners. These warnings can be safely ignored in this instance and
cannot easily be fixed in the underlying library.

### Microphone menu button not shown

The microphone menu button will only appear if both enabled (see [Menu Button
configuration](configuration/menu.md?id=available-buttons)) and if the media
that is currently loaded supports 2-way audio. See [Using 2-way
audio](usage/2-way-audio.md) for more information about the requirements that
must be followed.

### New version not working in Chrome

When upgrading the card it's recommended to reset the frontend cache. Sometimes
clearing site data in Chrome settings isn't enough.

- Press F12 to display `Dev Console` in Chrome then right click on the refresh
  icon and select `Empty Cache and Hard Reload`

### Static image URL with credentials doesn't load

Your browser will not allow a page/script (like this card) to pass credentials
to a cross-origin (different host) image URL for security reasons. There is no
way around this unless you could also control the webserver that is serving the
image to specifically allow `crossorigin` requests (which is typically not the
case for an image served from a camera, for example). The stock Home Assistant
Picture Glance card has the same limitation, for the same reasons.

### Status "popup" continually popping up

Status popup can be disabled with this configuration:

```yaml
status_bar:
  style: none
```

### Too many releases!

A new version of this card is [automatically
released](./developing.md?id=release-philosophy) on each change ("Pull
Request"). This means features and fixes are available immediately! However, it
also means there may be visual notifications in Home Assistant frequently
recommending update and some users find this annoying.

The topic of intentionally doing fewer releases has been discussed fairly
extensively
([#1781](https://github.com/dermotduffy/advanced-camera-card/issues/1781),
[#2072](https://github.com/dermotduffy/advanced-camera-card/issues/2072)) but it
always comes down to some users (and this developer!) like it instant / often,
others like it slower / rarer.

As a workaround for those that this bothers, the visual notification (the 'dot')
to remind users to upgrade can be disabled by disabling the matching `update`
entity provided by HACS. The entity is usually called
`update.advanced_camera_card_update`. To disable it:

- Navigate to: `Settings -> Devices & Services -> HACS -> # Entities -> Advanced Camera Card update`
- Click the settings "cog"
- Set "Enabled" to off

### Unknown Frigate instance `frigate`

e.g. `API error whilst subscribing to events for unknown Frigate instance frigate`

If you are using a custom `client_id` setting in your `frigate.yml` file (the
configuration file for the Frigate backend itself), you must tell the card about
it via the `client_id` parameter:

```yaml
cameras:
  - camera_entity: camera.my_frigate_camera
    frigate:
      client_id: my-frigate
```

See [Frigate engine configuration](configuration/cameras/engine.md?id=frigate)
for more details.

If you're not using a custom `client_id`, your Frigate integration is likely not
installed correct.

### `webrtc_card` unloads in the background

[AlexxIT's WebRTC Card](https://github.com/AlexxIT/WebRTC) which is embedded by
the `webrtc_card` live provider internally disconnects the stream when the
browser tab is changed (regardless of any Advanced Camera Card configuration settings,
e.g. `lazy_unload`). To allow the stream to continue running in the background,
pass the `background` argument to the `webrtc_card` live provider as shown
below. This effectively allows the Advanced Camera Card to decide whether or not to
unload the stream.

```yaml
live:
  webrtc_card:
    background: true
```



================================================
FILE: docs/.nojekyll
================================================
[Empty file]


================================================
FILE: docs/configuration/README.md
================================================
# Configuration

The card supports a myriad of configuration options for simple or complex setups.

### Minimal configuration

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
```

### Configuration blocks

#### Top-level configuration blocks

Only the `cameras` option is required, all other parameters are optional.

| Option                                | Description                                                                                                                                                                                             |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`automations`](automations.md)       | Take action when conditions are met.                                                                                                                                                                    |
| [`cameras`](cameras/README.md)        | Configures the cameras to be used in the card. At least one camera must be specified.                                                                                                                   |
| [`cameras_global`](cameras/README.md) | Global defaults that apply to all cameras from the `cameras` section.                                                                                                                                   |
| `card_id`                             | An optional ID to uniquely identify this card. For use when actions are being sent to card(s) via [URL actions](../usage/url-actions.md). Must exclusively consist of these characters: `[a-zA-Z0-9_]`. |
| [`dimensions`](dimensions.md)         | Configures the overall card dimensions.                                                                                                                                                                 |
| [`elements`](elements/README.md)      | Add custom elements to the card.                                                                                                                                                                        |
| [`image`](image.md)                   | Configures the `image` view.                                                                                                                                                                            |
| [`live`](live.md)                     | Configures the `live` view.                                                                                                                                                                             |
| [`media_gallery`](media-gallery.md)   | Configures the media gallery.                                                                                                                                                                           |
| [`media_viewer`](media-viewer.md)     | Configures the media viewer.                                                                                                                                                                            |
| [`menu`](menu.md)                     | Configures the card menu.                                                                                                                                                                               |
| [`overrides`](overrides.md)           | Override card configuration when conditions are met.                                                                                                                                                    |
| [`performance`](performance.md)       | Configures the card performance.                                                                                                                                                                        |
| [`profiles`](profiles.md)             | Apply pre-configured sets of defaults to ease card configuration.                                                                                                                                       |
| [`timeline`](timeline.md)             | Configures the `timeline` view.                                                                                                                                                                         |
| [`view`](view.md)                     | Configures the default view and behavior of the card.                                                                                                                                                   |

#### Common configuration blocks

| Option                         | Description           |
| ------------------------------ | --------------------- |
| [`actions`](actions/README.md) | Configure actions.    |
| [`conditions`](conditions.md)  | Configure conditions. |



================================================
FILE: docs/configuration/_sidebar.md
================================================
- [Getting Started](../README.md)
- [Configuration](README.md)
  - [`actions`](actions/README.md)
  - [`automations`](automations.md)
  - [`cameras`](cameras/README.md)
  - [`conditions`](conditions.md)
  - [`dimensions`](dimensions.md)
  - [`elements`](elements/README.md)
  - [`folders`](folders.md)
  - [`image`](image.md)
  - [`live`](live.md)
  - [`media_gallery`](media-gallery.md)
  - [`media_viewer`](media-viewer.md)
  - [`menu`](menu.md)
  - [`overrides`](overrides.md)
  - [`performance`](performance.md)
  - [`profiles`](profiles.md)
  - [`remote_control`](remote-control.md)
  - [`status_bar`](status-bar.md)
  - [`timeline`](timeline.md)
  - [`view`](view.md)
  - [Templates](templates.md)
- [Examples](../examples.md)
- [Screenshots](../screenshots.md)
- [Troubleshooting](../troubleshooting.md)
- [Usage](../usage/README.md)

---

- [Developing](../developing.md)



================================================
FILE: docs/configuration/automations.md
================================================
# `automations`

Automatically take [actions](actions/README.md) based on [conditions](conditions.md) being met.

?> To change configuration conditionally use [overrides](overrides.md).

```yaml
automations:
  - conditions:
      - [condition]
    actions:
      - [action]
    actions_not:
      - [action]
```

| Option        | Default | Description                                                                                                              |
| ------------- | ------- | ------------------------------------------------------------------------------------------------------------------------ |
| `conditions`  |         | A list of [conditions](conditions.md) that must evaluate to `true` in order to trigger the automation.                   |
| `actions`     |         | An optional list of [actions](actions/README.md) that will be run when the [conditions](conditions.md) evaluate `true`.  |
| `actions_not` |         | An optional list of [actions](actions/README.md) that will be run when the [conditions](conditions.md) evaluate `false`. |

# Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
automations:
  - conditions:
      - condition: fullscreen
        fullscreen: true
    actions:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live_substream_on
    actions_not:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: live_substream_off
```



================================================
FILE: docs/configuration/conditions.md
================================================
# `conditions`

`conditions` is not a top-level configuration block, but can be used as part of
multiple other blocks.

Conditions are used to conditionally take action (in `automations`), to apply
certain configurations (in `overrides`) or to display "picture elements" (in
`elements`) depending on runtime evaluation.

```yaml
[used as part of other configuration]
  conditions:
    - [condition_1]
    - [condition_2]
```

## `and`

Evaluates to `true` if _all_ embedded conditions evaluate to `true`.

```yaml
conditions:
  - condition: and
    # [...]
```

| Parameter    | Description                                                                                                    |
| ------------ | -------------------------------------------------------------------------------------------------------------- |
| `condition`  | Must be `and`.                                                                                                 |
| `conditions` | A list of other conditions _all_ of which must evaluate `true` in order for this condition to evaluate `true`. |

## `camera`

Matches based on the selected camera. Does not match other cameras (whether
visible or not).

```yaml
conditions:
  - condition: camera
    # [...]
```

| Parameter   | Description                                                                                                                                                                           |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition` | Must be `camera`.                                                                                                                                                                     |
| `cameras`   | An optional list of camera IDs in which this condition is satisfied. If not specified, any camera change will satisy the condition. See the camera [id](cameras/README.md) parameter. |

## `config`

Matches when card configuration changes (e.g. on startup, or when [Configuration Overrides](./overrides.md) are applied).

```yaml
conditions:
  - condition: config
    # [...]
```

| Parameter   | Description                                                                                                                                           |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition` | Must be `config`.                                                                                                                                     |
| `paths`     | An optional array of configuration paths (e.g. `menu.style`). If provided condition matches if _ANY_ of the provided configuration paths has changed. |

## `display_mode`

Matches when card display mode changes (e.g. `single` or `grid` mode). See the display settings for [`live`](live.md?id=display) or [`media_viewer`](media-viewer.md?id=display).

```yaml
conditions:
  - condition: display_mode
    # [...]
```

| Parameter      | Description                 |
| -------------- | --------------------------- |
| `condition`    | Must be `display_mode`.     |
| `display_mode` | Must be `single` or `grid`. |

## `expand`

Matches based on whether the card is in "expanded" mode.

```yaml
conditions:
  - condition: expand
    # [...]
```

| Parameter   | Description                                                                                                                                                                                  |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition` | Must be `expand`.                                                                                                                                                                            |
| `expand`    | If `true` the condition is satisfied if the card is in expanded mode (in a dialog/popup). If `false` the condition is satisfied if the card is **NOT** in expanded mode (in a dialog/popup). |

## `fullscreen`

Matches based on whether the card is in fullscreen.

```yaml
conditions:
  - condition: fullscreen
    # [...]
```

| Parameter    | Description                                                                                                                                              |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition`  | Must be `fullscreen`.                                                                                                                                    |
| `fullscreen` | If `true` the condition is satisfied if the card is in fullscreen mode. If `false` the condition is satisfied if the card is **NOT** in fullscreen mode. |

## `initialized`

Matches when the card is first initialized.

```yaml
conditions:
  - condition: initialized
```

| Parameter   | Description            |
| ----------- | ---------------------- |
| `condition` | Must be `initialized`. |

?> This is exclusively useful for running [automations](./automations.md) on card start.

## `interaction`

Matches based on whether the card has been interacted with.

```yaml
conditions:
  - condition: interaction
    # [...]
```

| Parameter     | Description                                                                                                                                                                                                                     |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition`   | Must be `interaction`.                                                                                                                                                                                                          |
| `interaction` | If `true` the condition is satisfied if the card has had human interaction within `view.interaction_seconds` elapsed seconds. If `false` the condition is satisfied if the card has **NOT** had human interaction in that time. |

## `key`

Matches based on key state.

```yaml
conditions:
  - condition: key
    # [...]
```

| Parameter   | Default | Description                                                                                                                       |
| ----------- | ------- | --------------------------------------------------------------------------------------------------------------------------------- |
| `condition` | -       | Must be `key`.                                                                                                                    |
| `alt`       | `false` | An optional value to match whether the `alt` key is being held.                                                                   |
| `ctrl`      | `false` | An optional value to match whether the `ctrl` key is being held.                                                                  |
| `key`       |         | Any [keyboard key value](https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values), e.g. `ArrowLeft`. |
| `meta`      | `false` | An optional value to match whether the `meta` key is being held.                                                                  |
| `shift`     | `false` | An optional value to match whether the `shift` key is being held.                                                                 |
| `state`     | `down`  | An optional value to match the state of the. Must be one of `down` or `up`.                                                       |

## `media_loaded`

Matches based on whether the selected live or media stream has loaded.

```yaml
conditions:
  - condition: media_loaded
    # [...]
```

| Parameter      | Description                                                                                                                                                                                                                                    |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition`    | Must be `media_loaded`.                                                                                                                                                                                                                        |
| `media_loaded` | If `true` the condition is satisfied if there is media load**ED** (not load**ING**) in the card (e.g. a clip, snapshot or live view). This may be used to hide controls during media loading or when a message (not media) is being displayed. |

## `microphone`

Matches based on microphone state.

```yaml
conditions:
  - condition: microphone
    # [...]
```

| Parameter   | Description                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------- |
| `condition` | Must be `microphone`.                                                                                                  |
| `connected` | Optional: If `true` or `false` the condition is satisfied if the microphone is connected or disconnected respectively. |
| `muted`     | Optional: If `true` or `false` the condition is satisfied if the microphone is muted or unmuted respectively.          |

When multiple parameters are specified they must all match for the condition to
match.

## `not`

Evaluates to `true` if _all_ embedded conditions evaluate to `false`.

```yaml
conditions:
  - condition: not
    # [...]
```

| Parameter    | Description                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------------- |
| `condition`  | Must be `not`.                                                                                                  |
| `conditions` | A list of other conditions _all_ of which must evaluate `false` in order for this condition to evaluate `true`. |

## `numeric_state`

Matches based on numeric Home Assistant state.

```yaml
conditions:
  - condition: numeric_state
    # [...]
```

See [Home Assistant conditions documentation](https://www.home-assistant.io/dashboards/conditional/#numeric-state).

## `or`

Evaluates to `true` if _any_ embedded condition evaluates to `true`.

```yaml
conditions:
  - condition: or
    # [...]
```

| Parameter    | Description                                                                                              |
| ------------ | -------------------------------------------------------------------------------------------------------- |
| `condition`  | Must be `or`.                                                                                            |
| `conditions` | A list of conditions _any_ of which must evaluate `true` in order for this condition to evaluate `true`. |

## `screen`

Matches based on [media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries).

```yaml
conditions:
  - condition: screen
    # [...]
```

| Parameter     | Description                                                                                                                                                                                                                                                                                                                                                                    |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `condition`   | Must be `screen`.                                                                                                                                                                                                                                                                                                                                                              |
| `media_query` | Any valid [media query](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries) string. Media queries must start and end with parentheses. This may be used to alter card configuration based on device/media properties (e.g. viewport width, orientation). Please note that `width` and `height` refer to the entire viewport not just the card. |

See the [screen conditions examples](../examples.md?id=screen-conditions).

## `state`

Matches based on Home Assistant state.

```yaml
conditions:
  - condition: state
    # [...]
```

| Parameter   | Description                                                                                            |
| ----------- | ------------------------------------------------------------------------------------------------------ |
| `condition` | Must be `state`.                                                                                       |
| `entity`    | The entity to check the state of.                                                                      |
| `state`     | A single entity state, or list of entity states, against which the entity state is compared.           |
| `state_not` | A single entity state, or list of entity states, against which the entity state is inversely compared. |

!> If multiple state conditions are used together with neither `state` nor
`state_not` specified, this effectively means the state for multiple entities
needs to _change_ simultaneously. This is unlikely to happen in reality, and
almost certainly not useful / reliable as a condition.

See [Home Assistant conditions documentation](https://www.home-assistant.io/dashboards/conditional/#state).

## `template`

Matches based on a template.

```yaml
conditions:
  - condition: template
    # [...]
```

| Parameter        | Description                                                                        |
| ---------------- | ---------------------------------------------------------------------------------- |
| `condition`      | Must be `template`.                                                                |
| `value_template` | The Home Assistant template to check, e.g. `{{ states('switch.office') == 'on' }}` |

See [Home Assistant conditions documentation](https://www.home-assistant.io/docs/scripts/conditions/#template-condition).

?> The Advanced Camera Card uses
[ha-nunjucks](https://github.com/Nerwyn/ha-nunjucks) to process templates.
Consult its documentation for the wide variety of different template values
supported.

## `triggered`

Matches based on whether the selected camera has been triggered.

```yaml
conditions:
  - condition: triggered
    # [...]
```

| Parameter   | Description                                                                                       |
| ----------- | ------------------------------------------------------------------------------------------------- |
| `condition` | Must be `triggered`.                                                                              |
| `triggered` | A list of camera IDs which, if [triggered](cameras/README.md?id=triggers), satisfy the condition. |

## `user`

Matches based on the Home Assistant user that is logged in. See [Home Assistant conditions documentation](https://www.home-assistant.io/dashboards/conditional/#user).

```yaml
conditions:
  - condition: user
    # [...]
```

## `user_agent`

Matches based on the [User-Agent](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent).

```yaml
conditions:
  - condition: user_agent
    # [...]
```

| Parameter       | Description                                                                                                                                              |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `condition`     | Must be `user_agent`.                                                                                                                                    |
| `user_agent`    | Exactly matches a user-agent, e.g. `Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36`               |
| `user_agent_re` | Matches a user-agent based on a regular expression, e.g. `Chrome/`.                                                                                      |
| `companion`     | If `true` matches if the user-agent is the Home Assistant companion app, if `false` matches if the user-agent is _NOT_ the Home Assistant companion app. |

When multiple parameters are specified they must all match for the condition to
match.

See the [user-agent overrides example](../examples.md?id=disable-ptz-controls-in-the-home-assistant-companion-app).

## `view`

Matches based on the selected view.

```yaml
conditions:
  - condition: view
    # [...]
```

| Parameter   | Description                                                                                                                                                              |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `condition` | Must be `view`.                                                                                                                                                          |
| `views`     | An optional list of [views](view.md?id=supported-views) in which this condition is satified (e.g. `clips`). If not specified, any view change will satisy the condition. |

?> Internally, views associated with the media viewer (e.g. `clip`, `snapshot`,
`recording`) are translated to a special view called `media` after the relevant
media is fetched. When including views as part of a [condition](conditions.md),
you may need to refer to this special `media` view.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
conditions:
 - condition: camera
   cameras:
     - camera.office
  - condition: config
    paths:
      - "menu.style"
  - condition: display_mode
    display_mode: single
  - condition: expand
    expand: true
  - condition: fullscreen
    fullscreen: true
  - condition: initialized
  - condition: interaction
    interaction: true
  - condition: key
    alt: false
    ctrl: false
    key: F
    meta: false
    shift: false
    state: down
  - condition: media_loaded
    media_loaded: true
  - condition: microphone
    connected: true
    muted: true
  - condition: numeric_state
    entity: sensor.office_temperature
    above: 10
    below: 20
  - condition: screen
    media_query: '(orientation: landscape)'
  - condition: state
    entity: climate.office
    state: heat
    state_not: off
  - condition: triggered
    triggered:
      - camera.office
  - condition: user
    users:
      - 581fca7fdc014b8b894519cc531f9a04
  - condition: user_agent
    user_agent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
    user_agent_re: "Chrome/"
    companion: true
  - condition: view
    views:
      - live
```



================================================
FILE: docs/configuration/dimensions.md
================================================
# `dimensions`

These options control the dimensions and aspect-ratio of the card (See [Camera
Dimensions](./cameras/README.md?id=dimensions) to set the dimensions of a camera
and not the whole card). These options configuration applies once to the entire
card (including the menu, thumbnails, etc), not just to displayed media. This
only applies to the card in normal render mode -- when in fullscreen, or when in
expanded (popup/dialog mode) the aspect ratio is chosen dynamically to maximize
the amount of content shown.

```yaml
dimensions:
  # [...]
```

| Option              | Default   | Description                                                                                                                                                                             |
| ------------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `aspect_ratio_mode` | `dynamic` | The aspect ratio mode to use. Acceptable values: `dynamic`, `static`, `unconstrained`. See below.                                                                                       |
| `aspect_ratio`      | `16:9`    | The aspect ratio to use. Acceptable values: `[W]:[H]` or `[W]/[H]`. See below.                                                                                                          |
| `height`            | `auto`    | The height for the card. Specified in [CSS units](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units). Generally users should not need to change this. |

### `aspect_ratio_mode`

| Option          | Description                                                                                                                                                                                                         |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dynamic`       | The aspect-ratio of the entire card will match the aspect-ratio of the last selected media item.                                                                                                                    |
| `static`        | A fixed aspect-ratio (as defined by `aspect_ratio`) will be applied to the card.                                                                                                                                    |
| `unconstrained` | No aspect ratio is enforced in any view, the card will expand with the content. This may be especially useful for a panel-mode dashboard, or in views that have no intrinsic aspect-ratio (e.g. the media gallery). |

### `aspect_ratio`

- `16 / 9` or `16:9`: Default widescreen ratio.
- `4 / 3` or `4:3`: Default fullscreen ratio.
- `[W]/[H]` or `[W]:[H]`: Any arbitrary aspect-ratio.

?> When in a [Panel View](https://www.home-assistant.io/dashboards/panel/) the aspect-ratio of the card are pegged to the exact size of the panel. As such, static aspect-ratio parameters will have no effect.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
dimensions:
  aspect_ratio_mode: dynamic
  aspect_ratio: 16:9
  height: auto
```



================================================
FILE: docs/configuration/folders.md
================================================
# `folders`

[](./common/experimental-warning.md ':include')

The `folders` stanza is used for configuring folders from which media/subfolders may be viewed.

?> To configure the behavior of the gallery in which folders are displayed, see the [`media_gallery` configuration](./media-gallery.md).

```yaml
folders:
  # [...]
```

| Option  | Default | Description                                                                                                                                    |
| ------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`    |         | An optional folder `id` which can be used by the [`folder` action](./actions/custom/README.md?id=folder) to show a particular folder contents. |
| `ha`    |         | Options for `ha` folder types. See below.                                                                                                      |
| `icon`  |         | An optional folder icon.                                                                                                                       |
| `title` |         | An optional folder title.                                                                                                                      |
| `type`  | `ha`    | The type of folder, `ha` for Home Assistant media folders (currently the only supported type of folder).                                       |

## `ha`

Used to specify a path to Home Assistant media.

```yaml
folders:
  - type: ha
    ha:
      # [...]
```

| Option | Default                     | Description                                                                                                                                                                                     |
| ------ | --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `url`  |                             | An optional Home Assistant `Media` browser URL to use as the query base. If `path` is also specified, those matchers/parsers are applied against folders "below" the folder specified in `url`. |
| `path` | [`{ id: media-source:// }`] | An optional array of parsers and matchers to dynamically compare and extract metadata from the Home Assistant media folder hierarchy. See below.                                                |

?> `url` is never fetched, nor sent over the network. It is only processed
locally in your browser. The host part of the URL can optionally be removed.

### `path`

An array of values that represents the path to a Home Assistant media item, e.g.
a media item at a path of `one/two/three` would be represented by a path array
of length three.

| Option     | Default | Description                                                                                                                                                    |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`       |         | An optional exact media item to select, usually the parent of where `matchers` and `parsers` should apply.                                                     |
| `matchers` |         | An optional array of matchers to evaluate whether to return a given media item. If no matcher is specified, everything in the given folder matches. See below. |
| `parsers`  |         | An optional array of parsers that extract data out of a media item. See below.                                                                                 |

If `url` is also specified, parsers/matchers are applied starting at that
folder, otherwise they are applied from the media source root (i.e.
`media-source://`).

```yaml
folders:
  - type: ha
    ha:
      path:
        # [...]
```

?> To match everything at a given level whilst parsing nothing would simply be
represented by an empty object `{}`

#### Matchers

Matches are used to match a given media item. Multiple matchers may be specified
to perform multiple tests. A given match may match multiple items. If an item
does not match, it will not be returned to the user nor (in case of subfolders)
feature in future traversals.

?> The higher in the path you can match, the more performant the query.

##### Matcher: `date` / `startdate`

Match if the media was started more recently than the provided date information.

?> Matching based on date requires the media has been parsed with the [`date` parser](#parser-date-startdate) somewhere above or equal to the position of the matcher in the `path` hierarchy.

```yaml
type: date
# [...]
```

| Parameter       | Default | Description                                |
| --------------- | ------- | ------------------------------------------ |
| `since.minutes` | 0       | Media no older than this many minutes ago. |
| `since.hours`   | 0       | Media no older than this many hours ago.   |
| `since.days`    | 0       | Media no older than this many days ago.    |
| `since.months`  | 0       | Media no older than this many months ago.  |
| `since.years`   | 0       | Media no older than this many years ago.   |

##### Matcher: `or`

Match if any single matcher matches.

```yaml
type: or
# [...]
```

| Parameter | Description                                                  |
| --------- | ------------------------------------------------------------ |
| `type`    | Must be `or`.                                                |
| `matches` | An array of other matchers only one of which needs to match. |

##### Matcher: `template`

Match against a template.

```yaml
type: template
# [...]
```

| Parameter        | Description                                                            |
| ---------------- | ---------------------------------------------------------------------- |
| `type`           | Must be `template`.                                                    |
| `value_template` | A [template](./templates.md?id=media-matching) to match media against. |

##### Matcher: `title`

Match against the media item title.

```yaml
type: title
# [...]
```

| Parameter | Description                                                          |
| --------- | -------------------------------------------------------------------- |
| `type`    | Must be `title`.                                                     |
| `regexp`  | An optional regular expression to match against the title.           |
| `title`   | An optional exact value (case-sensitive) to match against the title. |

#### Parsers

Parsers are used to extract data from a media item (e.g. an event start time).
Parsed data is propagated down the hierarcy, e.g. a given media item inherits
the metadata of its parents.

##### Parser `date` / `startdate`

Parses a start date from a media title. `date` is an convenient alias for
`startdate`.

```yaml
type: date
# [...]
```

| Parameter | Description                                                                                                                                                                                                                                                                                                 |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`    | Must be `date` or `startdate`.                                                                                                                                                                                                                                                                              |
| `format`  | A [`date-fns` format string](https://date-fns.org/docs/parse). If unspecified, [`any-date-parser`](https://www.npmjs.com/package/any-date-parser) is used to parse a date and/or time which covers many common cases. In the event of missing or inaccurate metadata, specifying a precise format may help. |
| `regexp`  | An optional regular expression to first match the title against before parsing. May be used to match against a subset of the string, see [tip below](#regular-expression-matching).                                                                                                                         |

## Advanced

### Regular Expression Matching

For `matchers` and `parsers` that support the `regexp` option, it may be used to
compare against only a portion of the media title. By default, that portion is
whatever part of the title matches the given regexp. For extra-precision, use a
named regexp group called `value`.

For example, pulling time values out of a media title, before parsing them with
a `HH:mm:ss` format.

```yaml
parsers:
  - type: date
    regexp: "\d{2}:\d{2}:\d{2}"
    format: HH:mm:ss
```

Similarly, this example uses a named group to refer to the text at the end of
the title.

```yaml
parsers:
  - type: date
    regexp: '^Time: (?<value>.*)+'
    format: HH:mm:ss
```

In this contrived example, the regular expression is used to extract either
`Low` or `High` from the title, and then match only the `High` entry.

```yaml
matchers:
  - type: title
    regexp: '(?<value>Low|High) Resolution'
    title: High
```

### Understanding Media Source IDs and "parent folders"

Home Assistant Media Source IDs are typically long integration-specific non-user
friendly strings that refer to a media item, or folder of media items. Media
source "folders" do not have an intrinsic parent as with filesystem folders,
rather a trail is built as the user navigates "downwards" -- but anything could
theoretically be the parent of anything.

## Worked Examples

### Worked Example 1

Imagine a media folder hierarchy that starts with a choice of resolution (Low or
High). Lets start by specifying a basic folder referring to the URL of the Home
Assistant Media Browser for that folder (via copy and paste of the URL from
another browser window with the folder open):

```yaml
folders:
  - type: ha
    ha:
      url: >-
        /media-browser/browser/app%2Cmedia-source%3A%2F%2Freolink/playlist%2Cmedia-source%3A%2F%2Freolink%2FCAM%7C01J8XAATNH77WE5D654K07KY1F%7C0
```

The result:

![](../images/folders/a1.png 'Folder Hierarchy 1 :size=400')

Now lets include selecting the High resolution folder:

```yaml
folders:
  - type: ha
    ha:
      url: >-
        /media-browser/browser/app%2Cmedia-source%3A%2F%2Freolink/playlist%2Cmedia-source%3A%2F%2Freolink%2FCAM%7C01J8XAATNH77WE5D654K07KY1F%7C0
      # Added below:
      path:
        - matchers:
            - type: title
              title: High resolution
```

The result:

![](../images/folders/a2.png 'Folder Hierarchy 2 :size=400')

The next step is to navigate down to the date folder, parsing the date as we go
(auto-detecting the format):

```yaml
folders:
  - type: ha
    ha:
      url: >-
        /media-browser/browser/app%2Cmedia-source%3A%2F%2Freolink/playlist%2Cmedia-source%3A%2F%2Freolink%2FCAM%7C01J8XAATNH77WE5D654K07KY1F%7C0
      path:
        - matchers:
            - type: title
              title: High resolution
        # Added below:
        - parsers:
            - type: startdate
```

The result:

![](../images/folders/a3.png 'Folder Hierarchy 3 :size=400')

The final step is to navigate down to the media item themselves, automatically parsing the time out of them:

```yaml
folders:
  - type: ha
    ha:
      url: >-
        /media-browser/browser/app%2Cmedia-source%3A%2F%2Freolink/playlist%2Cmedia-source%3A%2F%2Freolink%2FCAM%7C01J8XAATNH77WE5D654K07KY1F%7C0
      path:
        - matchers:
            - type: title
              title: High resolution
        - parsers:
            - type: startdate
        # Added below:
        - parsers:
            - type: startdate
```

The final result:

![](../images/folders/a4.png 'Folder Hierarchy 2 :size=400')

### Worked Example 2

Imagine a media folder hierarchy that contains directories named after rooms
(e.g. `Office`) and where the filenames in those directories contain both the
date and the time in a complex format (e.g. `Foscam
C1-20250507-171758-1746631078004-3.mp4`, where the date is the first numeric 8
digits after a `-` and the time is following 6 numeric digits after an
additional `-`).

The first step is to match all sub-directories. No parsing needs to be done at
this level, since all the details that need to be parsed are contained within
the filename in the next level.

```yaml
folders:
  - type: ha
    id: my-folder
    ha:
      url: >-
        https://ha.ondu.org/media-browser/browser/app%2Cmedia-source%3A%2F%2Fmedia_source
      path:
        # Match everything, parse nothing.
        - {}
```

The result:

![](../images/folders/b1.png 'Folder Hierarchy 1 :size=400')

The last step is to match all filenames, parsing the date and time out of them.

```yaml
folders:
  - type: ha
    id: my-folder
    ha:
      url: >-
        https://ha.ondu.org/media-browser/browser/app%2Cmedia-source%3A%2F%2Fmedia_source
      path:
        - {}
        # At the final level, match everything, parse the date and time.
        - parsers:
            # Use a regexp to extract date and time and parse them using a particular format.
            - type: date
              regexp: \d{8}-\d{6}
              format: yyyyMMdd-HHmmss
```

Alternative, the date and time could be parsed separately, which will produce the same result:

```yaml
folders:
  - type: ha
    id: my-folder
    ha:
      url: >-
        https://ha.ondu.org/media-browser/browser/app%2Cmedia-source%3A%2F%2Fmedia_source
      path:
        - {}
        # At the final level, match everything, parse the date and time.
        - parsers:
            # Parse the date from the first 8 numeric characters. The format need
            # not be specified as the 8 digits will be correctly parsed automatically.
            - type: date
              regexp: \d{8}
            - type: date
              # Parse the time from the first hypen-surrounded 6 numeric characters.
              # The format *does* need to be specified as 6 numeric digits is ambiguous.
              regexp: -(?<value>\d{6})-
              format: HHmmss
```

The final result:

![](../images/folders/b2.png 'Folder Hierarchy 2 :size=400')

### Other Examples

See [Folder Examples](../examples.md?id=folders).

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
folders:
  - type: ha
    ha:
      url: https://my-ha-instance.local/media-browser/browser/app%2Cmedia-source%3A%2F%2Ffrigate
      path:
        - id: 'media-source://'
        - matchers:
            - type: title
              regexp: (?<value>.*) resolution
              title: Low
        - parsers:
            - type: date
              format: yyyy/MM/dd
        - parsers:
            - type: startdate
              format: HH:mm:ss
              regexp: 'File (?<value>.*)'
  - type: ha
    ha:
      path:
        - id: 'media-source://'
        - matchers:
            - type: template
              value_template: "{{ acc.media.title == now().strftime('%Y/%-m/%d') }}"
        - parsers:
            - type: date
        - matchers:
            - type: date
              since:
                minutes: 1
                hours: 2
                days: 3
                months: 4
                years: 5
```



================================================
FILE: docs/configuration/grid-layout-algorithm.md
================================================
# Grid Layout Algorithm

When display mode (in [`live`](live.md?id=display) or
[`media_viewer`](media-viewer.md?id=display) views) is set to `grid`, this
algorithm is used to control the layout.

## Layout Order

Cameras are laid out horizontally in the order they are specified in the config,
first to last. The card may tweak item positioning in order to optimize grid
'density'.

In addition, if the `grid_selected_position` parameter is `first` or `last`, the
selected camera is always laid out first (at the top) or last (at the bottom) of
the layout.

## Number of columns in the grid

The following algorithm is used to calculate the number of columns. This
attempts to offers a balance between configurability, reasonable display in a
typical Lovelace card width and reasonable display in a typical fullscreen
display.

- Use `grid_columns` if specified.
- Otherwise, use the largest number of columns in the range `[2 -
grid_max_columns]` that will fit at least a `600px` column width.
- Otherwise, use the largest number of columns in the range `[2 -
grid_max_columns]` that will fit at least a `190px` column width.
- Otherwise, there will be `1` column only.



================================================
FILE: docs/configuration/image.md
================================================
# `image`

Configure the `image` view.

```yaml
image:
  # [...]
```

| Option              | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `actions`           |         | [Actions](actions/README.md) to use for the `image` view.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `entity`            |         | The entity to use when `mode` is set to `entity`. This entity is expected to have an `entity_picture` attribute that specifies the image URL.                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `entity_parameters` |         | Optional URL parameters to add to the URL generated for entity-based modes (i.e. when `mode` is `camera` or `entity`).                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `mode`              | `auto`  | Value must be one of `url` (to fetch an arbitrary image URL), `camera` (to show a still of the currently selected camera entity using either `camera_entity` or `webrtc_card.entity` in that order of precedence), `entity` to show an image associated with a named entity (see the `entity` parameter below), or `screensaver` (to show an [embedded image](https://github.com/dermotduffy/advanced-camera-card/blob/main/src/images/iris-screensaver.jpg)). If `auto`, the mode is chosen automatically based on whether `url` or `entity` parameters have been specified. |
| `refresh_seconds`   | 1       | The image will be refreshed at least every `refresh_seconds` (it may refresh more frequently, e.g. whenever Home Assistant updates its camera security token). `0` implies no refreshing.                                                                                                                                                                                                                                                                                                                                                                                     |
| `url`               |         | A static image URL to be used when the `mode` is set to `url` or when a temporary image is required (e.g. may appear momentarily prior to load of a camera snapshot in the `camera` mode). Note that a `_t=[timestsamp]` query parameter will be automatically added to all URLs such that the image will not be cached by the browser.                                                                                                                                                                                                                                       |

?> When `mode` is set to `camera` this is effectively providing the same image as the `image` [live provider](cameras/live-provider.md) would show in the live camera carousel.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
image:
  mode: auto
  refresh_seconds: 1
  url: 'https://path/to/image.png'
  entity: image.office_person
  entity_parameters: 'width=400&height=200'
  actions:
    entity: light.office_main_lights
    tap_action:
      action: none
    hold_action:
      action: none
    double_tap_action:
      action: none
    start_tap_action:
      action: none
    end_tap_action:
      action: none
```



================================================
FILE: docs/configuration/live.md
================================================
# `live`

Configures the behavior of the `live` view.

```yaml
live:
  # [...]
```

| Option                   | Default                            | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------------ | ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `actions`                |                                    | [Actions](actions/README.md) to use for the `live` view.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `auto_mute`              | `[unselected, hidden, microphone]` | A list of conditions in which live camera feeds are muted. `unselected` will automatically mute when a camera is unselected in the carousel or grid. `hidden` will automatically mute when the camera becomes hidden (e.g. browser tab change) or `microphone` will automatically mute after the microphone is muted as long as the camera stays selected (see the `live.microphone.mute_after_microphone_mute_seconds` to control how long after). Use an empty list (`[]`) to never automatically mute. Note that if `auto_play` is enabled, the stream may mute itself automatically in order to honor the `auto_play` setting, as some browsers will not auto play media that is unmuted -- that is to say, where necessary, the `auto_play` parameter will take priority over the `auto_mute` parameter. |
| `auto_pause`             | `[]`                               | A list of conditions in which live camera feeds are automatically paused. `unselected` will automatically pause when a camera is unselected in the carousel or grid. `hidden` will automatically pause when the browser/tab becomes hidden. Use an empty list (`[]`) to never automatically pause. **Caution**: Some live providers (e.g. `jsmpeg`) may not offer human-accessible means to resume play if it is paused, unless the `auto_play` option is used.                                                                                                                                                                                                                                                                                                                                               |
| `auto_play`              | `[selected, visible]`              | A list of conditions in which live camera feeds are automatically played. `selected` will automatically play when a camera is selected in a carousel or grid. `visible` will automatically play when a camera becomes visible (e.g. browser tab change, or visible in a grid but not selected). Use an empty list (`[]`) to never automatically play. Some live providers (e.g. `webrtc-card`, `jsmpeg`) do not support the prevention of automatic play on initial load, but should still respect the value of this parameter on play-after-pause.                                                                                                                                                                                                                                                           |
| `auto_unmute`            | `[microphone]`                     | A list of conditions in which live camera feeds are unmuted. `selected` will automatically unmute when a camera is selected in a carousel or grid. `visible` will automatically unmute when a camera becomes visible (e.g. a browser/tab change, or visible in a grid but not selected). `microphone` will automatically unmute after the microphone is unmuted. Use an empty list (`[]`) to never automatically unmute. Some browsers will not allow automated unmute until the user has interacted with the page in some way -- if the user has not then the browser may pause the media instead.                                                                                                                                                                                                           |
| `controls`               |                                    | Configuration for the `live` view controls. See below.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `display`                |                                    | Controls whether to show a single or grid `live` view. See below.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `draggable`              | `true`                             | Whether or not the live carousel can be dragged left or right, via touch/swipe and mouse dragging.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `lazy_load`              | `true`                             | Whether or not to lazily load cameras in the camera carousel. Setting this will `false` will cause all cameras to load simultaneously when the `live` carousel is opened (or cause all cameras to load continually if both `lazy_load` and `preload` are `true`). This will result in a smoother carousel experience at a cost of (potentially) a substantial amount of continually streamed data.                                                                                                                                                                                                                                                                                                                                                                                                            |
| `lazy_unload`            | `[]`                               | A list of conditions in which live camera feeds are unloaded. `unselected` will unload a camera when it is not visible in the carousel/grid and `hidden` will unload a camera when the browser itself is minimized or the browser tab changes. An empty list (`[]`, the default) will never automatically unload a stream once loaded unless the user navigates away entirely, so that it's always instantly visible on carousel scroll. Once unloaded, subsequently revisiting the camera will cause a reloading delay. Some live providers (e.g. `webrtc-card`) implement their own lazy unloading independently which may occur regardless of the value of this setting.                                                                                                                                   |
| `microphone`             |                                    | See below.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `preload`                | `false`                            | Whether or not to preload the live view. Preloading causes the live view to render in the background regardless of what view is actually shown, so it's instantly available when requested. This consumes additional network/CPU resources continually.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `show_image_during_load` | `true`                             | If `true`, during the initial stream load, the `image` live provider will be shown instead of the loading video stream. This still image will auto-refresh and is replaced with the live stream once loaded.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `transition_effect`      | `slide`                            | Effect to apply as a transition between live cameras. Accepted values: `slide` or `none`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `zoomable`               | `true`                             | Whether or not the live carousel can be zoomed and panned, via touch/pinch and mouse scroll wheel with `ctrl` held.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

## `controls`

Configure the controls for the `live` view.

```yaml
live:
  controls:
    # [...]
```

| Option          | Default | Description                                                                            |
| --------------- | ------- | -------------------------------------------------------------------------------------- |
| `builtin`       | `true`  | Whether to show the built in (browser) video controls on live video.                   |
| `next_previous` |         | Configures how the "Next & Previous" controls are shown on the `live` view. See below. |
| `thumbnails`    |         | Configures how thumbnails are shown on the `live` view. See below.                     |
| `timeline`      |         | Configures how the mini-timeline is shown on the `live` view. See below.               |

### `next_previous`

Configures how the "Next & Previous" controls are shown on the live view.

```yaml
live:
  controls:
    next_previous:
      # [...]
```

| Option  | Default    | Description                                                                                                                                    |
| ------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `size`  | `48`       | The size of the next/previous controls in pixels. Must be &gt;= `20`.                                                                          |
| `style` | `chevrons` | When viewing live cameras, what kind of controls to show to move to the previous/next camera. Acceptable values: `chevrons`, `icons`, `none` . |

### `ptz`

Configures the PTZ (Pan Tilt Zoom) controls.

```yaml
live:
  controls:
    ptz:
      # [...]
```

| Option          | Default        | Description                                                                                                                                                                                                                     |
| --------------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `hide_home`     | `false`        | When `true` the Home and Presets buttons of the control are hidden                                                                                                                                                              |
| `hide_pan_tilt` | `false`        | When `true` the Pan & Tilt buttons of the control is hidden                                                                                                                                                                     |
| `hide_zoom`     | `false`        | When `true` the Zoom button of the control is hidden                                                                                                                                                                            |
| `mode`          | `auto`         | If `on` or `off`, by default will always or never show PTZ controls respectively, if `auto` will show PTZ controls only if the camera supports real PTZ.                                                                        |
| `orientation`   | `horizontal`   | Whether to show a `vertical` or `horizontal` PTZ control.                                                                                                                                                                       |
| `position`      | `bottom-right` | Whether to position the control on the `top-left`, `top-right`, `bottom-left` or `bottom-right`. This may be overridden by using the `style` parameter to precisely control placement.                                          |
| `style`         |                | Optionally position and style the element using CSS. Similar to [Picture Element styling](https://www.home-assistant.io/dashboards/picture-elements/#how-to-use-the-style-object), except without any default, e.g. `left: 42%` |

To configure the PTZ _actions_ taken for a particular camera, see [Camera PTZ Settings](./cameras/README.md?id=ptz).

### `thumbnails`

Configures how thumbnails are shown on the live view.

```yaml
live:
  controls:
    thumbnails:
      # [...]
```

| Option                  | Default  | Description                                                                                                                                                                   |
| ----------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `events_media_type`     | `all`    | Whether to show `clips`, `snapshots` or `all` in the thumbnail carousel in the `live` view. This setting is only relevant when the `media_type` parameter is set to `events`. |
| `media_type`            | `events` | Whether to load `events` or `recordings` media.                                                                                                                               |
| `mode`                  | `none`   | Whether to show the thumbnail carousel `below` the media, `above` the media, in a drawer to the `left` or `right` of the media or to hide it entirely (`none`).               |
| `show_details`          | `false`  | Whether to show event details (e.g. duration, start time, object detected, etc) alongside the thumbnail.                                                                      |
| `show_download_control` | `true`   | Whether to show the download control on each thumbnail.                                                                                                                       |
| `show_favorite_control` | `true`   | Whether to show the favorite ('star') control on each thumbnail.                                                                                                              |
| `show_timeline_control` | `true`   | Whether to show the timeline ('target') control on each thumbnail.                                                                                                            |
| `size`                  | `100`    | The size of the thumbnails in the thumbnail carousel in pixels. Must be &gt;= `75` and &lt;= `300`.                                                                           |

### `timeline`

Configures how the mini-timeline is shown on the live view.

```yaml
live:
  controls:
    timeline:
      # [...]
```

| Option                 | Default  | Description                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `clustering_threshold` | `3`      | The minimum number of overlapping events to allow prior to clustering/grouping them. Higher numbers cause clustering to happen less frequently. Depending on the timescale/zoom of the timeline, the underlying timeline library may still allow overlaps for low values of this parameter -- for a fully "flat" timeline use the `ribbon` style. `0` disables clustering entirely. Only used in the `stack` style of timeline. |
| `events_media_type`    | `all`    | Whether to show only events with `clips`, events with `snapshots` or `all` events. When `all` is used, `clips` are favored for events that have both a clip and a snapshot.                                                                                                                                                                                                                                                     |
| `format`               |          | Configuration for the timeline time & date format. See below.                                                                                                                                                                                                                                                                                                                                                                   |
| `mode`                 | `none`   | Whether to show the thumbnail carousel `below` the media, `above` the media, in a drawer to the `left` or `right` of the media or to hide it entirely (`none`).                                                                                                                                                                                                                                                                 |
| `pan_mode`             | `pan`    | See [timeline pan mode](timeline-pan-mode.md).                                                                                                                                                                                                                                                                                                                                                                                  |
| `show_recordings`      | `true`   | Whether to show recordings on the timeline (specifically: which hours have any recorded content).                                                                                                                                                                                                                                                                                                                               |
| `style`                | `ribbon` | Whether the timeline should show events as a single flat `ribbon` or a `stack` of events that are clustered using the `clustering_threshold`.                                                                                                                                                                                                                                                                                   |
| `window_seconds`       | `3600`   | The length of the default timeline in seconds. By default, 1 hour (`3600` seconds) is shown in the timeline.                                                                                                                                                                                                                                                                                                                    |

[](common/timeline-seek-info.md ':include')

#### `format`

Configure the date and time format for the `timeline` view.

```yaml
live:
  controls:
    timeline:
      format:
        # [...]
```

| Option | Default | Description                                                                     |
| ------ | ------- | ------------------------------------------------------------------------------- |
| `24h`  | `true`  | If `true` shows time in 24-hour clock. If `false` otherwise uses 12-hour clock. |

## `display`

Controls whether to show a single or grid `live` view.

```yaml
live:
  display:
    # [...]
```

| Option                       | Default   | Description                                                                                                                                                                                                                                                                                                                      |
| ---------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `grid_columns`               |           | If specified the grid will always have exactly this number of columns.                                                                                                                                                                                                                                                           |
| `grid_max_columns`           | `4`       | If specified, and `grid_columns` is not specified, the grid will not render more than this number of columns.                                                                                                                                                                                                                    |
| `grid_selected_position`     | `default` | Controls where the selected item should be laid out in the grid. If `default`, the cameras are laid out in the order they are specified in the configuration and selecting a camera does not change this order. If `first`, the selected camera is moved to the start of the grid, if `last` it is moved to the end of the grid. |
| `grid_selected_width_factor` | `2`       | How much to scale up the selected media item in a grid. A value of `1` will not scale the selected item at all, the default value of `2` will scale the media item width to twice what it would otherwise be, etc.                                                                                                               |
| `mode`                       | `single`  | Whether to display a `single` live camera in a carousel, or all cameras in a `grid` configuration.                                                                                                                                                                                                                               |

See the [grid layout algorithm](grid-layout-algorithm.md) for more details on how the grid lays elements out.

## `microphone`

Controls the behavior of the microphone in the `live` view.

```yaml
live:
  microphone:
```

| Option                               | Default | Description                                                                                                                                                                                                                                                             |
| ------------------------------------ | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `always_connected`                   | `false` | Whether or not to keep the microphone stream continually connected while the card is running, or only when microphone is used (default). In the latter case there'll be a connection reset when the microphone is first used -- using this option can avoid that reset. |
| `disconnect_seconds`                 | `90`    | The number of seconds after microphone usage to disconnect the microphone from the stream. `0` implies never. Not relevant if `always_connected` is `true`.                                                                                                             |
| `mute_after_microphone_mute_seconds` | `60`    | The number of seconds after the microphone mutes to automatically mute the inbound audio when `live.auto_mute` includes `microphone`.                                                                                                                                   |

See [Using 2-way audio](../usage/2-way-audio.md) for more information about the very particular requirements that must be followed for 2-way audio to work.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
live:
  auto_play:
    - selected
    - visible
  auto_pause: []
  auto_mute:
    - unselected
    - hidden
  auto_unmute:
    - microphone
  preload: false
  lazy_load: true
  lazy_unload: []
  draggable: true
  zoomable: true
  transition_effect: slide
  controls:
    builtin: true
    next_previous:
      style: chevrons
      size: 48
    ptz:
      mode: auto
      position: bottom-right
      orientation: horizontal
      hide_pan_tilt: false
      hide_zoom: false
      hide_home: false
      style:
        # Optionally override the default style.
        right: 5%
    thumbnails:
      media_type: events
      events_media_type: all
      size: 100
      show_details: false
      show_download_control: true
      show_favorite_control: true
      show_timeline_control: true
      mode: none
    timeline:
      style: ribbon
      mode: none
      pan_mode: pan
      clustering_threshold: 3
      events_media_type: all
      show_recordings: true
      window_seconds: 3600
      format:
        24h: true
  microphone:
    always_connected: false
    disconnect_seconds: 90
    mute_after_microphone_mute_seconds: 60
  display:
    mode: single
    grid_selected_position: default
    grid_selected_width_factor: 2
    grid_max_columns: 4
  actions:
    entity: light.office_main_lights
    tap_action:
      action: none
    hold_action:
      action: none
    double_tap_action:
      action: none
    start_tap_action:
      action: none
    end_tap_action:
      action: none
```



================================================
FILE: docs/configuration/media-gallery.md
================================================
# `media_gallery`

The `media_gallery` is used for providing an overview of all `clips`,
`snapshots`, `recordings` and `folder` contents in a thumbnail gallery.

```yaml
media_gallery:
  # [...]
```

| Option     | Default | Description                                                                                                                         |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `actions`  |         | [Actions](actions/README.md) to use for all views that use the `media_gallery` (e.g. `clips`, `folder`, `snapshots`, `recordings`). |
| `controls` |         | Configuration for the Media Gallery controls. See below.                                                                            |

## `controls`

### `filter`

Configure the media gallery filter.

```yaml
media_gallery:
  controls:
    filter:
      # [...]
```

| Option | Default | Description                                                                                                                                               |
| ------ | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `mode` | `right` | Whether to show the gallery media filter to the `left`, to the `right` or `none` for no media filter. The `folder` view does not support media filtering. |

### `thumbnails`

Configure the media gallery thumbnails.

```yaml
media_gallery:
  controls:
    thumbnails:
      # [...]
```

| Option                  | Default | Description                                                                                              |
| ----------------------- | ------- | -------------------------------------------------------------------------------------------------------- |
| `show_details`          | `false` | Whether to show media details (e.g. duration, start time, object detected, etc) alongside the thumbnail. |
| `show_download_control` | `true`  | Whether to show the download control on each thumbnail.                                                  |
| `show_favorite_control` | `true`  | Whether to show the favorite ('star') control on each thumbnail.                                         |
| `show_timeline_control` | `true`  | Whether to show the timeline ('target') control on each thumbnail.                                       |
| `size`                  | `100`   | The size of the thumbnails in the gallery. Must be &gt;= `75` and &lt;= `300`.                           |

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
media_gallery:
  controls:
    filter:
      mode: 'right'
    thumbnails:
      size: 100
      show_details: false
      show_download_control: true
      show_favorite_control: true
      show_timeline_control: true
  actions:
    entity: light.office_main_lights
    tap_action:
      action: none
    hold_action:
      action: none
    double_tap_action:
      action: none
    start_tap_action:
      action: none
    end_tap_action:
      action: none
```



================================================
FILE: docs/configuration/media-viewer.md
================================================
# `media_viewer`

The `media_player` section configures viewing all `clip`, `snapshot` or `recording` media, in either a media carousel or grid.

```yaml
media_viewer:
  # [...]
```

| Option                      | Default                | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| --------------------------- | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `actions`                   |                        | [Actions](actions/README.md) to use for all views that use the `media_viewer` (e.g. `clip`, `snapshot`).                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `auto_mute`                 | `[unselected, hidden]` | A list of conditions in which media items are muted. `unselected` will automatically mute when a media item is unselected in the carousel or grid. `hidden` will automatically mute when the browser/tab becomes hidden. Use an empty list (`[]`) to never automatically mute.                                                                                                                                                                                                                                                |
| `auto_pause`                | `[unselected, hidden]` | A list of conditions in which media items are automatically paused. `unselected` will automatically pause when a media item is unselected in the carousel or grid. `hidden` will automatically pause when the browser/tab becomes hidden. Use an empty list (`[]`) to never automatically pause.                                                                                                                                                                                                                              |
| `auto_play`                 | `[selected, visible]`  | A list of conditions in which media items are automatically played. `selected` will automatically play when a media item is selected in a carousel or grid. `visible` will automatically play when a media item becomes visible (e.g. browser tab change, or visible in a grid but not selected). Use an empty list (`[]`) to never automatically play.                                                                                                                                                                       |
| `auto_unmute`               | `[]`                   | A list of conditions in which media items are unmuted. `selected` will automatically unmute when a media item is selected in a carousel or grid. `visible` will automatically unmute when a media item becomes visible (e.g. a browser/tab change, or visible in a grid but not selected). Use an empty list (`[]`) to never automatically unmute. Some browsers will not allow automated unmute until the user has interacted with the page in some way -- if the user has not then the browser may pause the media instead. |
| `controls`                  |                        | Configuration for the Media viewer controls. See below.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `draggable`                 | `true`                 | Whether or not the Media viewer carousel can be dragged left or right, via touch/swipe and mouse dragging.                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `lazy_load`                 | `true`                 | Whether or not to lazily load media in the Media viewer carousel. Setting this will false will fetch all media immediately which may make the carousel experience smoother at a cost of (potentially) a substantial number of simultaneous media fetches on load.                                                                                                                                                                                                                                                             |
| `snapshot_click_plays_clip` | `true`                 | Whether clicking on a snapshot in the media viewer should play a related clip.                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `transition_effect`         | `slide`                | Effect to apply as a transition between event media. Accepted values: `slide` or `none`.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `zoomable`                  | `true`                 | Whether or not the Media Viewer can be zoomed and panned, via touch/pinch and mouse scroll wheel with `ctrl` held.                                                                                                                                                                                                                                                                                                                                                                                                            |

## `controls`

Configure the controls for the media player views.

```yaml
media_viewer:
  controls:
    # [...]
```

| Option          | Default | Description                                                                             |
| --------------- | ------- | --------------------------------------------------------------------------------------- |
| `builtin`       | `true`  | Whether to show the built in (browser) video controls on media viewer videos.           |
| `next_previous` |         | Configures how the "Next & Previous" controls are shown on the media viewer. See below. |
| `thumbnails`    |         | Configures how thumbnails are shown on the media viewer. See below.                     |
| `timeline`      |         | Configures how the mini-timeline is shown on the media viewer. See below.               |

### `next_previous`

Configures how the "Next & Previous" controls are shown on the media viewer.

```yaml
media_viewer:
  controls:
    next_previous:
      # [...]
```

| Option  | Default      | Description                                                                                                                                      |
| ------- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| `size`  | `48`         | The size of the next/previous controls in pixels. Must be &gt;= `20`.                                                                            |
| `style` | `thumbnails` | When viewing media, what kind of controls to show to move to the previous/next media item. Acceptable values: `thumbnails`, `chevrons`, `none` . |

### `ptz`

Configures the PTZ (Pan Tilt Zoom) controls. As the media viewer is never
viewing live view, the PTZ controls in this context always refer to digital (vs
real) panning and zooming.

```yaml
media_viewer:
  controls:
    ptz:
      # [...]
```

| Option          | Default        | Description                                                                                                                                                                                                                     |
| --------------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `hide_home`     | `false`        | When `true` the Home button of the control is hidden                                                                                                                                                                            |
| `hide_pan_tilt` | `false`        | When `true` the Pan & Tilt buttons of the control is hidden                                                                                                                                                                     |
| `hide_zoom`     | `false`        | When `true` the Zoom button of the control is hidden                                                                                                                                                                            |
| `mode`          | `off`          | If `on` or `off` will always or never show PTZ controls respectively.                                                                                                                                                           |
| `orientation`   | `horizontal`   | Whether to show a `vertical` or `horizontal` PTZ control.                                                                                                                                                                       |
| `position`      | `bottom-right` | Whether to position the control on the `top-left`, `top-right`, `bottom-left` or `bottom-right`. This may be overridden by using the `style` parameter to precisely control placement.                                          |
| `style`         |                | Optionally position and style the element using CSS. Similar to [Picture Element styling](https://www.home-assistant.io/dashboards/picture-elements/#how-to-use-the-style-object), except without any default, e.g. `left: 42%` |

### `thumbnails`

Configures how thumbnails are shown on the media viewer.

```yaml
media_viewer:
  controls:
    thumbnails:
      # [...]
```

| Option                  | Default | Description                                                                                                                                                     |
| ----------------------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `mode`                  | `none`  | Whether to show the thumbnail carousel `below` the media, `above` the media, in a drawer to the `left` or `right` of the media or to hide it entirely (`none`). |
| `show_details`          | `false` | Whether to show event details (e.g. duration, start time, object detected, etc) alongside the thumbnail.                                                        |
| `show_download_control` | `true`  | Whether to show the download control on each thumbnail.                                                                                                         |
| `show_favorite_control` | `true`  | Whether to show the favorite ('star') control on each thumbnail.                                                                                                |
| `show_timeline_control` | `true`  | Whether to show the timeline ('target') control on each thumbnail.                                                                                              |
| `size`                  | `100`   | The size of the thumbnails in the thumbnail carousel pixels. Must be &gt;= `75` and &lt;= `300`.                                                                |

### `timeline`

Configures how the mini-timeline is shown on the media viewer.

```yaml
media_viewer:
  controls:
    timeline:
      # [...]
```

| Option                 | Default  | Description                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `clustering_threshold` | `3`      | The minimum number of overlapping events to allow prior to clustering/grouping them. Higher numbers cause clustering to happen less frequently. Depending on the timescale/zoom of the timeline, the underlying timeline library may still allow overlaps for low values of this parameter -- for a fully "flat" timeline use the `ribbon` style. `0` disables clustering entirely. Only used in the `stack` style of timeline. |
| `events_media_type`    | `all`    | Whether to show only events with `clips`, events with `snapshots` or `all` events. When `all` is used, `clips` are favored for events that have both a clip and a snapshot.                                                                                                                                                                                                                                                     |
| `format`               |          | Configuration for the timeline time & date format. See below.                                                                                                                                                                                                                                                                                                                                                                   |
| `mode`                 | `none`   | Whether to show the thumbnail carousel `below` the media, `above` the media, in a drawer to the `left` or `right` of the media or to hide it entirely (`none`).                                                                                                                                                                                                                                                                 |
| `pan_mode`             | `pan`    | See [timeline pan mode](timeline-pan-mode.md).                                                                                                                                                                                                                                                                                                                                                                                  |
| `show_recordings`      | `true`   | Whether to show recordings on the timeline (specifically: which hours have any recorded content).                                                                                                                                                                                                                                                                                                                               |
| `style`                | `ribbon` | Whether the timeline should show events as a single flat `ribbon` or a `stack` of events that are clustered using the `clustering_threshold`.                                                                                                                                                                                                                                                                                   |
| `window_seconds`       | `3600`   | The length of the default timeline in seconds. By default, 1 hour (`3600` seconds) is shown in the timeline.                                                                                                                                                                                                                                                                                                                    |

[](common/timeline-seek-info.md ':include')

#### `format`

Configure the date and time format for the `timeline` view.

```yaml
media_viewer:
  controls:
    timeline:
      format:
        # [...]
```

| Option | Default | Description                                                                     |
| ------ | ------- | ------------------------------------------------------------------------------- |
| `24h`  | `true`  | If `true` shows time in 24-hour clock. If `false` otherwise uses 12-hour clock. |

## `display`

Controls whether to show a single media item or grid in the media viewer.

```yaml
media_viewer:
  display:
    # [...]
```

| Option                       | Default   | Description                                                                                                                                                                                                                                                                                                                      |
| ---------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `grid_columns`               |           | If specified the grid will always have exactly this number of columns.                                                                                                                                                                                                                                                           |
| `grid_max_columns`           | `4`       | If specified, and `grid_columns` is not specified, the grid will not render more than this number of columns.                                                                                                                                                                                                                    |
| `grid_selected_position`     | `default` | Controls where the selected item should be laid out in the grid. If `default`, the cameras are laid out in the order they are specified in the configuration and selecting a camera does not change this order. If `first`, the selected camera is moved to the start of the grid, if `last` it is moved to the end of the grid. |
| `grid_selected_width_factor` | `2`       | How much to scale up the selected media item in a grid. A value of `1` will not scale the selected item at all, the default value of `2` will scale the media item width to twice what it would otherwise be, etc.                                                                                                               |
| `mode`                       | `single`  | Whether to display a `single` media item at a time, or a media item for all cameras in a `grid` configuration.                                                                                                                                                                                                                   |

See the [grid layout algorithm](grid-layout-algorithm.md) for more details on how the grid lays elements out.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
media_viewer:
  auto_play:
    - selected
    - visible
  auto_pause:
    - unselected
    - hidden
  auto_mute:
    - unselected
    - hidden
  auto_unmute: []
  lazy_load: true
  draggable: true
  zoomable: true
  snapshot_click_plays_clip: true
  transition_effect: slide
  controls:
    builtin: true
    next_previous:
      size: 48
      style: thumbnails
    ptz:
      mode: off
      position: bottom-right
      orientation: horizontal
      hide_pan_tilt: false
      hide_zoom: false
      hide_home: false
      style:
        # Optionally override the default style.
        right: 5%
    thumbnails:
      size: 100
      mode: none
      show_details: false
      show_download_control: true
      show_favorite_control: true
      show_timeline_control: true
    timeline:
      style: ribbon
      mode: none
      pan_mode: pan
      clustering_threshold: 3
      events_media_type: all
      show_recordings: true
      window_seconds: 3600
      format:
        24h: true
  display:
    mode: single
    grid_selected_position: default
    grid_selected_width_factor: 2
    grid_max_columns: 4
  actions:
    entity: light.office_main_lights
    tap_action:
      action: none
    hold_action:
      action: none
    double_tap_action:
      action: none
    start_tap_action:
      action: none
    end_tap_action:
      action: none
```



================================================
FILE: docs/configuration/menu.md
================================================
# `menu`

Configures how the card menu behaves.

```yaml
menu:
  # [...]
```

| Option        | Default  | Description                                                                                                                                                                                                                                                  |
| ------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `alignment`   | `left`   | Whether to align the menu buttons to the `left`, `right`, `top` or `bottom` of the menu. Some selections may have no effect depending on the value of `position` (e.g. it doesn't make sense to `left` align icons on a menu with `position` to the `left`). |
| `button_size` | `40`     | The size of the menu buttons in pixels. Must be &gt;= `20`.                                                                                                                                                                                                  |
| `buttons`     |          | Whether to show or hide built-in buttons. See below.                                                                                                                                                                                                         |
| `position`    | `top`    | Whether to show the menu on the `left`, `right`, `top` or `bottom` side of the card. Note that for the `outside` style only the `top` and `bottom` positions have an effect.                                                                                 |
| `style`       | `hidden` | The menu style to show by default, one of `none`, `hidden`, `hover`, `hover-card`, `overlay`, or `outside`. See below.                                                                                                                                       |

## `buttons`

All configuration is under:

```yaml
menu:
  buttons:
    [button]:
      # [...]
```

### Available Buttons

| Button name    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `camera_ui`    | The `camera_ui` menu button: brings the user to a context-appropriate page on the UI of their camera engine (e.g. the Frigate camera homepage). Will only appear if the camera engine supports a camera UI (e.g. if `frigate.url` option is set for `frigate` engine users).                                                                                                                                                                                                                          |
| `cameras`      | The camera selection submenu. Will only appear if multiple cameras are configured.                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `clips`        | The `clips` view menu button: brings the user to the `clips` view on tap and the most-recent `clip` view on hold.                                                                                                                                                                                                                                                                                                                                                                                     |
| `display_mode` | The `display_mode` button allows changing between single and grid views.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `download`     | The `download` menu button: allow direct download of the media being displayed.                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `expand`       | The `expand` menu button: expand the card into a popup/dialog.                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `folders`      | The `folders` menu button: brings the user to a [gallery](./media-gallery.md) of folders on tap and to the media viewer with media from the folder on hold. Will only appear if [`folders`](./folders.md) are configured.                                                                                                                                                                                                                                                                             |
| `fullscreen`   | The `fullscreen` menu button: expand the card to consume the fullscreen. Please note that fullscreen behavior on iPhone is limited, see [troubleshooting](../troubleshooting.md?id=fullscreen-doesn39t-work-on-iphone).                                                                                                                                                                                                                                                                               |
| `image`        | The `image` view menu button: brings the user to the static `image` view.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `iris`         | The main Advanced Camera Card `iris` menu button: brings the user to the default configured view (`view.default`), or collapses/expands the menu if the `menu.style` is `hidden` .                                                                                                                                                                                                                                                                                                                    |
| `live`         | The `live` view menu button: brings the user to the `live` view.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `media_player` | The `media_player` menu button: sends the visible media to a remote media player. Supports Frigate clips, snapshots and live camera (only for cameras that specify a `camera_entity` and only using the default HA stream (equivalent to the `ha` live provider)). `jsmpeg` or `webrtc-card` are not supported, although live can still be played as long as `camera_entity` is specified. In the player list, a `tap` will send the media to the player, a `hold` will stop the media on the player. |
| `microphone`   | The `microphone` button allows usage of 2-way audio in certain configurations. See [Using 2-way audio](../usage/2-way-audio.md).                                                                                                                                                                                                                                                                                                                                                                      |
| `ptz_controls` | The `ptz_controls` button shows or hides the PTZ controls.                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `ptz_home`     | The `ptz_home` button allows easily returning the camera to default home position.                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `recordings`   | The `recordings` view menu button: brings the user to the `recordings` view on tap and the most-recent `recording` view on hold.                                                                                                                                                                                                                                                                                                                                                                      |
| `screenshot`   | The `screenshot` menu button: take a screenshot of the loaded media (e.g. a still from a video).                                                                                                                                                                                                                                                                                                                                                                                                      |
| `snapshots`    | The `snapshots` view menu button: brings the user to the `clips` view on tap and the most-recent `snapshot` view on hold.                                                                                                                                                                                                                                                                                                                                                                             |
| `timeline`     | The `timeline` menu button: show the event timeline.                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

### Options for each button

| Option      | Default                                                                                                                                                                                                                                                                             | Description                                                                                                                                                                                                                                                                                                                  |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `alignment` | `matching`                                                                                                                                                                                                                                                                          | Whether this menu item should have an alignment that is `matching` the menu alignment or `opposing` the menu alignment. Can be used to create two separate groups of buttons on the menu. The `priority` option orders buttons within a given `alignment`.                                                                   |
| `enabled`   | `true` for `iris`, `cameras`, `substreams`, `live`, `clips`, `snapshots`, `timeline`, `download`, `camera_ui`, `fullscreen`, `media_player`, `display_mode` and `ptz_home`. `false` for `image`, `expand`, `microphone`, `mute`, `play`, `recordings`, `screenshot`, `ptz_controls` | Whether or not to show the button.                                                                                                                                                                                                                                                                                           |
| `icon`      |                                                                                                                                                                                                                                                                                     | An icon to overriding the default for that button, e.g. `mdi:camera-front`. See also [custom icons](../usage/custom-icons.md).                                                                                                                                                                                               |
| `permanent` | `false`                                                                                                                                                                                                                                                                             | If `false` the menu item is hidden when the menu has the `hidden` style and the menu is closed, otherwise it is shown (and sorted to the front).                                                                                                                                                                             |
| `priority`  | `50`                                                                                                                                                                                                                                                                                | The menu item priority. Higher priority items are ordered closer to the start of the menu alignment (i.e. a button with priority `70` will order further to the left than a button with priority `60`). Priority applies separately to `matching` and `opposing` groups (see `alignment` above). Minimum `0`, maximum `100`. |

## `style`

This card supports several menu styles.

| Key          | Description                                                                                                                                               | Screenshot                                                       |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| `hidden`     | Hide the menu by default. It may be toggled open as needed with the `iris` button.                                                                        | ![](../images/menu-mode-hidden.png 'Menu hidden :size=400')      |
| `hover-card` | Overlay the menu over the card contents when the mouse is over the **card**, otherwise it is not shown. The `iris` button shows the default view.         | ![](../images/menu-mode-overlay.png 'Menu hover-card :size=400') |
| `hover`      | Overlay the menu over the card contents when the mouse is over the **menu**, otherwise it is not shown. The `iris` button shows the default view.         | ![](../images/menu-mode-overlay.png 'Menu hover :size=400')      |
| `none`       | No menu is shown.                                                                                                                                         | ![](../images/menu-mode-none.png 'No menu :size=400')            |
| `outside`    | Render the menu outside the card (i.e. above it if `position` is `top`, or below it if `position` is `bottom`). The `iris` button shows the default view. | ![](../images/menu-mode-above.png 'Menu outside :size=400')      |
| `overlay`    | Overlay the menu over the card contents. The `iris` button shows the default view.                                                                        | ![](../images/menu-mode-overlay.png 'Menu hidden :size=400')     |

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
menu:
  alignment: left
  buttons:
    camera_ui:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:web
    cameras:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:video-switch
    clips:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:filmstrip
    download:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:download
    expand:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:arrow-expand-all
    folders:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:folder-multiple
    fullscreen:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:fullscreen
    image:
      priority: 50
      enabled: false
      alignment: matching
      icon: mdi:image
    iris:
      priority: 50
      enabled: true
      alignment: matching
      icon: iris
    live:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:cctv
    media_player:
      priority: 50
      enabled: false
      alignment: matching
      icon: mdi:cast
    microphone:
      priority: 50
      enabled: false
      alignment: matching
      icon: mdi:microphone
      type: momentary
    mute:
      priority: 50
      enabled: false
      alignment: matching
      icon: mdi:volume-off
    play:
      priority: 50
      enabled: false
      alignment: matching
      icon: mdi:play
    ptz_controls:
      priority: 50
      enabled: false
      alignment: matching
      icon: mdi:pan
    ptz_home:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:home
    snapshots:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:camera
    substreams:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:video-input-component
    timeline:
      priority: 50
      enabled: true
      alignment: matching
      icon: mdi:chart-gantt
  button_size: 40
  position: top
  style: hidden
```



================================================
FILE: docs/configuration/overrides.md
================================================
# `overrides`

The card configuration may [conditionally](conditions.md) be overridden (e.g. to
hide the menu in fullscreen mode).

```yaml
overrides:
  - conditions:
      - [condition]
    # [...]
```

!> Whilst all configuration parameters are theoretically overridable, in some instances a configuration variable may only be consulted on startup or changing its value may negatively impact behavior -- override results may vary!

The top-level `overrides` configuration block expects a list, with each list
item containing `conditions` and at least one of `merge`, `delete` or `set` specified.

| Option       | Default | Description                                                                                                  |
| ------------ | ------- | ------------------------------------------------------------------------------------------------------------ |
| `conditions` |         | A list of [conditions](conditions.md) that must evaluate to `true` in order for the overrides to be applied. |
| `delete`     |         | An array of configuration paths to delete. See below.                                                        |
| `merge`      |         | A dictionary of configuration paths to merge. See below.                                                     |
| `set`        |         | A dictionary of configuration paths to set. See below.                                                       |

## Configuration Paths

The `delete`, `merge` and `set` parameters take configuration paths. Paths are dot-separated references to particular configuration parameters. To refer to list elements use `[n]` notation.

For example the path `cameras[1].dimensions.aspect_ratio` refers to the `aspect_ratio` parameter below:

```yaml
cameras:
  - camera_entity: camera.other
  - camera_entity: camera.relevant
    dimensions:
      aspect_ratio: '16:9'
```

## `delete`

An array of configuration paths to delete.

```yaml
overrides:
  - conditions:
      - [condition]
    delete:
      - [path_1]
      - [path_2]
```

### Examples

Delete the 3rd camera (it indexes from 0):

```yaml
overrides:
  - conditions:
      - [condition]
    delete:
      - 'cameras[2]'
```

Delete the menu style parameter, thus falling back to the default:

```yaml
overrides:
  - conditions:
      - [condition]
    delete:
      - 'menu.style'
```

## `merge`

Specifies an object to recursively merge into existing configuration.

| Option               | Default | Description                                                                            |
| -------------------- | ------- | -------------------------------------------------------------------------------------- |
| [configuration path] |         | Arbitrary configuration object to merge. Must be an object (i.e. not a literal value). |

### Examples

Hide the menu when a given condition is met:

```yaml
overrides:
  - conditions:
      - [condition]
    merge:
      menu: { style: 'hidden' }
```

Enable thumbnails below the `live` feed:

```yaml
overrides:
  - conditions:
      - [condition]
    merge:
      'live.controls.thumbnails': { mode: 'below' }
```

Also enables thumbnails below the `live` feed, but without using the dot-separated notation:

```yaml
overrides:
  - conditions:
      - [condition]
    merge:
      live: { controls: { thumbnails: { mode: 'below' } } }
```

## `set`

Specifies a value to set in the configuration. This differs from `merge` in that the existing value is entirely replaced.

| Option               | Default | Description                                           |
| -------------------- | ------- | ----------------------------------------------------- |
| [configuration path] |         | Arbitrary configuration value / object / list to set. |

### Examples

Set the entire menu configuration to defaults with the exception of the `style` which is set to `overlay`.

```yaml
overrides:
  - conditions:
      - [condition]
    set:
      menu: { style: 'overlay' }
```

Set the menu style but without touching the other `menu` parameters:

```yaml
overrides:
  - conditions:
      - [condition]
    set:
      'menu.style': 'overlay'
```

That is equivalent to merging the following:

```yaml
overrides:
  - conditions:
      - [condition]
    merge:
      menu: { style: 'overlay' }
```



================================================
FILE: docs/configuration/performance.md
================================================
# `performance`

Configure the card performance settings to enable the card to run (more) smoothly on lower end devices.

```yaml
performance:
  # [...]
```

| Option     | Default | Description                                         |
| ---------- | ------- | --------------------------------------------------- |
| `features` |         | Configure feature settings that impact performance. |
| `style`    |         | Configure style settings that impact performance.   |

### `features`

Controls card-wide functionality that may impact performance.

```yaml
performance:
  features:
    # [...]
```

| Option                             | Default    | Description                                                                                                                                                                                                                                                                                                                                                                                                         |
| ---------------------------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `animated_progress_indicator`      | `true`     | Will show the animated progress indicator 'spinners' when `true`.                                                                                                                                                                                                                                                                                                                                                   |
| `card_loading_indicator`           | `true`     | Will show the card loading indicator (spinner & version number) when `true`.                                                                                                                                                                                                                                                                                                                                        |
| `media_chunk_size`                 | `50`       | How many media items to fetch and render at a time (e.g. thumbnails under a live view, or number of snapshots to load in the media viewer). This may only make partial sense in some contexts (e.g. the 'infinite gallery' is still infinite, it just loads thumbnails this many items at a time) or not at all (e.g. the timeline will show the number of events dictated by the time span the user navigates to). |
| `max_simultaneous_engine_requests` | _Infinity_ | How many camera engine requests to allow occur in parallel. Setting lower values will slow the card down since more requests will run in sequence, but it will increase the chances of positive cache hit rates and reduce the chances of overwhelming the backend.                                                                                                                                                 |

### `style`

Style performance options request the card minimize certain expensive CSS
stylings. This does not necessarily disable these stylings _entirely_ since that
may break the basic expected visuals of the card (e.g. menu icons need curves),
but rather avoids use of them in high item-count situations (e.g. avoiding
shadows on timeline items, or curves in the media gallery items).

```yaml
performance:
  style:
    # [...]
```

| Option          | Default | Description                                        |
| --------------- | ------- | -------------------------------------------------- |
| `border_radius` | `true`  | If `false` minimizes the usage of rounded corners. |
| `box_shadow`    | `true`  | If `false` minimizes the usage of shadows.         |

### The `low-performance` profile

For low end devices, the `low-performance` profile will adjust card defaults to attempt to improve performance. See the [profiles](profiles.md) configuration option for details on how to select profiles.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
performance:
  features:
    animated_progress_indicator: true
    card_loading_indicator: true
    media_chunk_size: 50
    max_simultaneous_engine_requests: 100
  style:
    border_radius: true
    box_shadow: true
```



================================================
FILE: docs/configuration/profiles.md
================================================
# `profiles`

Apply pre-configured sets of defaults to ease card configuration.

```yaml
profiles:
  - [profile_1]
  - [profile_2]
```

?> Since the profiles change the _default_ value of options, setting a profile
on a pre-existing card could have limited effect if there are options already set by
the user.

?> Profiles are applied top to bottom. If multiple profiles change a configuration default, then the last one "wins"

| Profile name      | Purpose                                        |
| ----------------- | ---------------------------------------------- |
| `casting`         | Configure the card to be casted.               |
| `low-performance` | Configure the card for lower end devices.      |
| `scrubbing`       | Configure the card to allow "video scrubbing". |

## `casting`

To aid casting the card to Chromecast devices, the `casting` profile will adjust card defaults to better suit casting. You may wish to combine this the `low-performance` profile below, since Chromecast devices tend to lower performance. To combine, list `low-performance` first, to allow `casting` to take precedence:

```yaml
profiles:
  - low-performance
  - casting
```

## `low-performance`

For low end devices, the `low-performance` profile will adjust card defaults to attempt to increase performance.

Principles used in the selection of options set by `low-performance` profile mode:

- Get 'out of the box' performance similar to the basic "Home Assistant Picture Glance" card.
- Do not break the visual aesthetic of the card.

See the [source code](https://github.com/dermotduffy/advanced-camera-card/blob/main/src/config/profiles/low-performance.ts) for an exhaustive list of defaults set by this profile.

## `scrubbing`

Configures the `live` view and media viewer to allow media "scrubbing" as the timeline is dragged back and forth.

See the [source code](https://github.com/dermotduffy/advanced-camera-card/blob/main/src/config/profiles/scrubbing.ts) for an exhaustive list of options set by this profile.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
profiles:
  - casting
  - low-performance
  - scrubbing
```



================================================
FILE: docs/configuration/remote-control.md
================================================
# `remote_control`

The `remote_control` configuration options control how a card instance can be remotely controlled.

```yaml
remote_control:
  # [...]
```

## `entities`

Sets entities that are used to control different aspects of the card.

```yaml
remote_control:
  entities:
    # [...]
```

| Option            | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ----------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `camera`          |         | An `input_select` entity that the card will use for bidirectional control. When the selected camera on the card changes the entity will be updated to match. Likewise, when the entity state changes, the selected camera on the card will be updated to match. When the card is first started, the `input_select` entity will be updated to only have valid camera IDs from this card and the selected camera on the card will be updated to the existing entity value. Entities used for camera remote control must start with `input_select.`. |
| `camera_priority` | `card`  | Controls whether the `card` or the `entity` has priority on initial card load. If `card`, the entity state is updated to match the camera shown on load. If `entity`, the card will select the camera shown by the entity on load.                                                                                                                                                                                                                                                                                                                |

?> To create an `input_select` entity to use in this manner, in the visual card editor, under `Remote Control -> Remote Control Entities`, choose `Create a new Dropdown helper`. Give the new entity an entity name (e.g. `my_selected_camera`) and an optional icon. You must specify at least one option -- you can use any placeholder value (e.g. `camera`) then choose `Add` (the card will automatically reset the allowable options on start). Finally, click `Create`.

## Related Topics

- [Passing actions to the card in the URL](../usage/url-actions.md).

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
remote_control:
  entities:
    camera: input_select.my_selected_camera
    camera_priority: card
```



================================================
FILE: docs/configuration/status-bar.md
================================================
# `status_bar`

Configures the card status bar.

```yaml
status_bar:
  # [...]
```

| Option          | Default  | Description                                                                                                                |
| --------------- | -------- | -------------------------------------------------------------------------------------------------------------------------- |
| `position`      | `bottom` | Whether to place the status bar at the `top` or `bottom` of the card.                                                      |
| `popup_seconds` | `3`      | The number of seconds to display the status bar when using the `popup` style.                                              |
| `height`        | `46`     | The height of the status bar in pixels.                                                                                    |
| `items`         |          | Whether to show or hide built-in status bar items. See below.                                                              |
| `style`         | `popup`  | The status bar style to show by default, one of `none`, `hover`, `hover-card`, `overlay`, `outside` or `popup`. See below. |

## `items`

All configuration is under:

```yaml
status_bar:
  items:
    [item]:
      # [...]
```

### Available Items

| Button name  | Description                                            |
| ------------ | ------------------------------------------------------ |
| `engine`     | The icon of the camera engine for the relevant camera. |
| `resolution` | The detected media resolution (if any).                |
| `technology` | The detected media technology (if any).                |
| `title`      | The media title.                                       |

### Options for each item

| Option     | Default | Description                                                                                                                                                                                                              |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `enabled`  | `true`  | Whether or not to show the item.                                                                                                                                                                                         |
| `priority` | `50`    | The item priority. Higher priority items are ordered closer to the start of the status bar (i.e. an item with priority `70` will order further to the left than an item with priority `60`). Minimum `0`, maximum `100`. |

## `style`

This card supports several menu styles.

| Key          | Description                                                                                                           |
| ------------ | --------------------------------------------------------------------------------------------------------------------- |
| `hover-card` | Overlay the status bar over the card contents when the mouse is over the **card**, otherwise it is not shown.         |
| `hover`      | Overlay the status bar over the card contents when the mouse is over the **status bar**, otherwise it is not shown.   |
| `none`       | No status bar is shown.                                                                                               |
| `outside`    | Render the status bar outside the card (i.e. above it if `position` is `top`, or below it if `position` is `bottom`). |
| `overlay`    | Overlay the status bar over the card contents.                                                                        |

## Fully expanded reference

?> To add custom status bar contents, see [status bar custom elements](elements/custom/README.md?id=status-bar-icon).

[](common/expanded-warning.md ':include')

```yaml
status_bar:
  position: bottom
  popup_seconds: 3
  height: 46
  style: popup
  items:
    engine:
      enabled: true
      priority: 50
    resolution:
      enabled: true
      priority: 50
    technology:
      enabled: true
      priority: 50
    title:
      enabled: true
      priority: 50
```



================================================
FILE: docs/configuration/templates.md
================================================
# Templates

Templates may be used in a certain places to allow template values (if present)
to be dynamically replaced. This allows a variety of Home Assistant data, and
Advanced Camera Card data, to be accessible. Templates may be used in:

- [Actions / Automations](./actions/README.md)
- [Folder Media Matchers](./folders.md?id=matchers)

## Stock Templates

The Advanced Camera Card uses
[ha-nunjucks](https://github.com/Nerwyn/ha-nunjucks) to process templates.
Consult its documentation for the wide variety of different template values
supported.

See [an example](../examples.md?id=accessing-home-assistant-state) that
accesses Home Assistant state.

## Custom Templates

Custom template values must be proceeded by `advanced_camera_card` (or `acc` for
short).

| Template | Replaced with                                     |
| -------- | ------------------------------------------------- |
| `camera` | The currently selected camera.                    |
| `view`   | The current [view](./view.md?id=supported-views). |

See [an example](../examples.md?id=accessing-advanced-camera-card-state) that
accesses Advanced Camera Card state.

### Media Matching

If templates are used for [Folder Media Matching](./folders.md?id=matchers) an
additional `media` variable is available with these properties:

Media template values must be proceeded by `advanced_camera_card.media` (or
`acc.media` for short).

| Template    | Replaced with                                                                     |
| ----------- | --------------------------------------------------------------------------------- |
| `title`     | The media title being matched.                                                    |
| `is_folder` | Whether the media item is a folder that may be expanded (vs a single media item). |

### Triggers

If the action is called by an [Advanced Camera Card
Automation](./automations.md), additional data is available representing the
current and prior state of whatever triggered the action.

Trigger template values must be proceeded by `advanced_camera_card.trigger` (or
`acc.trigger` for short).

| Template       | Replaced with                                                                                    |
| -------------- | ------------------------------------------------------------------------------------------------ |
| `camera.to`    | For [camera conditions](./conditions.md?id=camera), the currently selected camera.               |
| `camera.from`  | For [camera conditions](./conditions.md?id=camera), the previously selected camera.              |
| `view.to`      | For [view conditions](./conditions.md?id=view), the currently selected view.                     |
| `view.from`    | For [view conditions](./conditions.md?id=view), the previously selected view.                    |
| `state.entity` | For [state conditions](./conditions.md?id=state), the entity state that triggered the condition. |
| `state.to`     | For [state conditions](./conditions.md?id=state), the current state of the entity.               |
| `state.from`   | For [state conditions](./conditions.md?id=state), the previous state of the entity.              |

!> If an action is triggered with multiple [state
conditions](./conditions.md?id=state), only data from the last listed state
condition is available.

!> If you use an [`or`](./conditions.md?id=or) condition, only the trigger data
for the first matching trigger will be included.

Please [request](https://github.com/dermotduffy/advanced-camera-card/issues) if
you need data from additional conditions.

See [an example](../examples.md?id=accessing-trigger-state) that accesses
trigger state.



================================================
FILE: docs/configuration/timeline-pan-mode.md
================================================
# Timeline Pan Mode

The behavior of the timeline during seeking/dragging can be controlled by means of the icon on the bottom-right of the timeline, or by using the `pan_mode` configuration variable for the relevant timeline controls (e.g. `live.controls.timeline.pan_mode`).

| Configuration name | UI Icon                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Behavior                                                                                                                                                                                                     |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `pan`              | <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>pan-horizontal</title><path d="M7,8L2.5,12L7,16V8M17,8V16L21.5,12L17,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10Z" /></svg>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Dragging the timeline will pan only without selected or seeking any media.                                                                                                                                   |
| `seek-in-camera`   | <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>camera-lock</title><path d="M4 4H7L9 2H15L17 4H20C21.11 4 22 4.89 22 6V12C21.16 11.37 20.13 11 19 11C18.21 11 17.46 11.18 16.79 11.5C16.18 9.22 14.27 7 12 7C9.24 7 7 9.24 7 12C7 14.76 9.24 17 12 17C12.42 17 12.84 16.95 13.23 16.85C13.08 17.2 13 17.59 13 18V20H4C2.9 20 2 19.11 2 18V6C2 4.89 2.9 4 4 4M12 9C13.66 9 15 10.34 15 12C15 13.66 13.66 15 12 15C10.34 15 9 13.66 9 12C9 10.34 10.34 9 12 9M23 18.3V21.8C23 22.4 22.4 23 21.7 23H16.2C15.6 23 15 22.4 15 21.7V18.2C15 17.6 15.6 17 16.2 17V15.5C16.2 14.1 17.6 13 19 13C20.4 13 21.8 14.1 21.8 15.5V17C22.4 17 23 17.6 23 18.3M20.5 15.5C20.5 14.7 19.8 14.2 19 14.2C18.2 14.2 17.5 14.7 17.5 15.5V17H20.5V15.5Z" /></svg> | Dragging the timeline will seek / select across all available media from the selected camera only, selecting the media item with the longest duration.                                                       |
| `seek-in-media`    | <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>play-box-lock</title><path d="M23 17.3V20.8C23 21.4 22.4 22 21.7 22H16.2C15.6 22 15 21.4 15 20.7V17.2C15 16.6 15.6 16 16.2 16V14.5C16.2 13.1 17.6 12 19 12C20.4 12 21.8 13.1 21.8 14.5V16C22.4 16 23 16.6 23 17.3M13 19V21H4C2.89 21 2 20.1 2 19V5C2 3.89 2.89 3 4 3H18C19.1 3 20 3.89 20 5V10.1L19 10L18 10.1C15.79 10.55 14.12 12.45 14 14.76C13.39 15.31 13 16.11 13 17V19M20.5 14.5C20.5 13.7 19.8 13.2 19 13.2C18.2 13.2 17.5 13.7 17.5 14.5V16H20.5V14.5M9 8V16L14 12L9 8Z" /></svg>                                                                                                                                                                                                 | Dragging the timeline will seek within the selected media item only.                                                                                                                                         |
| `seek`             | <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>filmstrip-box-multiple</title><path d="M4,6H2V20A2,2 0 0,0 4,22H18V20H4V6M20,2H8A2,2 0 0,0 6,4V16A2,2 0 0,0 8,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M10,15H8V13H10V15M10,11H8V9H10V11M10,7H8V5H10V7M20,15H18V13H20V15M20,11H18V9H20V11M20,7H18V5H20V7Z" /></svg>                                                                                                                                                                                                                                                                                                                                                                                                                           | Dragging the timeline will seek / select across all available media from all cameras, selecting the media item with the longest duration whilst favoring (but not limited to) the currently selected camera. |



================================================
FILE: docs/configuration/timeline.md
================================================
# `timeline`

Configures a `timeline` view used to show the timing sequence of events and
recordings across multiple cameras.

```yaml
timeline:
  # [...]
```

You can interact with the timeline in a number of ways:

- Clicking on an event will take you to the media viewer for that event.
- Clicking on the "background", or a camera title, will take you to the recordings for that camera (seeking to the clicked time).
- Clicking on the time axis will take you to recordings for all cameras (seeking to the clicked time).

| Option                 | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `clustering_threshold` | `3`     | The minimum number of overlapping events to allow prior to clustering/grouping them. Higher numbers cause clustering to happen less frequently. Depending on the timescale/zoom of the timeline, the underlying timeline library may still allow overlaps for low values of this parameter -- for a fully "flat" timeline use the `ribbon` style. `0` disables clustering entirely. Only used in the `stack` style of timeline. |
| `controls`             |         | Configuration for the timeline controls. See below.                                                                                                                                                                                                                                                                                                                                                                             |
| `events_media_type`    | `all`   | Whether to show only events with `clips`, events with `snapshots` or `all` events. When `all` is used, `clips` are favored for events that have both a clip and a snapshot.                                                                                                                                                                                                                                                     |
| `format`               |         | Configuration for the timeline time & date format. See below.                                                                                                                                                                                                                                                                                                                                                                   |
| `show_recordings`      | `true`  | Whether to show recordings on the timeline (specifically: which hours have any recorded content).                                                                                                                                                                                                                                                                                                                               |
| `style`                | `stack` | Whether the timeline should show events as a single flat `ribbon` or a `stack` of events that are clustered using the `clustering_threshold`.                                                                                                                                                                                                                                                                                   |
| `window_seconds`       | `3600`  | The length of the default timeline in seconds. By default, 1 hour (`3600` seconds) is shown in the timeline.                                                                                                                                                                                                                                                                                                                    |

## `controls`

Configure the controls for the `timeline` view.

```yaml
timeline:
  controls:
    # [...]
```

| Option       | Default | Description                                                            |
| ------------ | ------- | ---------------------------------------------------------------------- |
| `thumbnails` |         | Configures how thumbnails are shown on the `timeline` view. See below. |

## `format`

Configure the date and time format for the `timeline` view.

```yaml
timeline:
  format:
    # [...]
```

| Option | Default | Description                                                                     |
| ------ | ------- | ------------------------------------------------------------------------------- |
| `24h`  | `true`  | If `true` shows time in 24-hour clock. If `false` otherwise uses 12-hour clock. |

### `thumbnails`

Configures how thumbnails are shown on the timeline.

```yaml
timeline:
  controls:
    thumbnails:
      # [...]
```

| Option                  | Default | Description                                                                                                                                                     |
| ----------------------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `mode`                  | `none`  | Whether to show the thumbnail carousel `below` the media, `above` the media, in a drawer to the `left` or `right` of the media or to hide it entirely (`none`). |
| `show_details`          | `false` | Whether to show event details (e.g. duration, start time, object detected, etc) alongside the thumbnail.                                                        |
| `show_download_control` | `true`  | Whether to show the download control on each thumbnail.                                                                                                         |
| `show_favorite_control` | `true`  | Whether to show the favorite ('star') control on each thumbnail.                                                                                                |
| `show_timeline_control` | `true`  | Whether to show the timeline ('target') control on each thumbnail.                                                                                              |
| `size`                  | `100`   | The size of the thumbnails in the thumbnail carousel in pixels. Must be &gt;= `75` and &lt;= `300`.                                                             |

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
timeline:
  style: stack
  clustering_threshold: 3
  events_media_type: all
  show_recordings: true
  window_seconds: 3600
  format:
    24h: true
  controls:
    thumbnails:
      mode: left
      size: 100
      show_details: true
      show_download_control: true
      show_favorite_control: true
      show_timeline_control: true
```



================================================
FILE: docs/configuration/view.md
================================================
# `view`

The `view` configuration options control how the default view of the card behaves.

```yaml
view:
  # [...]
```

| Option                    | Default                                                   | Description                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `actions`                 |                                                           | [Actions](actions/README.md) to use for all views, individual actions may be overriden by view-specific actions.                                                                                                                                                                                                                                                                                |
| `camera_select`           | `current`                                                 | The [view](view.md?id=supported-views) to show when a new camera is selected (e.g. in the camera menu). If `current` the view is unchanged when a new camera is selected.                                                                                                                                                                                                                       |
| `dim`                     | `false`                                                   | Whether or not to 'dim' the brightness of the card (by 25%) if the card `interaction_seconds` has expired (i.e. card has been left unattended for that period of time).                                                                                                                                                                                                                         |
| `default`                 | `live`                                                    | The view to show in the card by default. The default camera is the first one listed. See [Supported Views](view.md?id=supported-views) below.                                                                                                                                                                                                                                                   |
| `default_reset`           |                                                           | The circumstances and behavior that cause the card to reset to the default view. See below.                                                                                                                                                                                                                                                                                                     |
| `interaction_seconds`     | `300`                                                     | After a mouse/touch interaction with the card, it will be considered "interacted with" until this number of seconds elapses without further interaction. May be used as part of an [interaction condition](conditions.md?id=interaction) or with `reset_after_interaction` to reset the view after the interaction is complete.                                                                 |
| `keyboard_shortcuts`      | See [usage](../usage/keyboard-shortcuts.md) for defaults. | Configure keyboard shortcuts. See below.                                                                                                                                                                                                                                                                                                                                                        |
| `render_entities`         |                                                           | **YAML only**: A list of entity ids that should cause the card to re-render 'in-place'. The view/camera is not changed. This should **very** rarely be needed, but could be useful if the card is both setting and changing HA state of the same object as could be the case for some complex `card_mod` scenarios ([example](https://github.com/dermotduffy/advanced-camera-card/issues/343)). |
| `reset_after_interaction` | `true`                                                    | If `true` the card will reset to the default configured view (i.e. 'screensaver' functionality) after `interaction_seconds` has elapsed after user interaction.                                                                                                                                                                                                                                 |
| `theme`                   |                                                           | How the card is themed. See below.                                                                                                                                                                                                                                                                                                                                                              |
| `triggers`                |                                                           | How to react when a camera is [triggered](cameras/README.md?id=triggers).                                                                                                                                                                                                                                                                                                                       |
| `default_cycle_camera`    | `false`                                                   | When set to `true` the selected camera is cycled on each default view change.                                                                                                                                                                                                                                                                                                                   |

## `default_reset`

Configure the circumstances and behavior that cause the card to reset to the default view. All configuration is under:

```yaml
view:
  default_reset: [...]
```

| Option              | Default    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ------------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `after_interaction` | `true`     | If `true` the card will reset to the default configured view (i.e. 'screensaver' functionality) after `interaction_seconds` has elapsed after user interaction.                                                                                                                                                                                                                                                                                                                                                       |
| `entities`          |            | A list of entities that should cause the view to reset to the default (if the entity only pertains to a particular camera use [`triggers`](cameras/README.md?id=triggers) for the selected camera instead).                                                                                                                                                                                                                                                                                                           |
| `interaction_mode`  | `inactive` | Whether the default reset should happen when the card is being interacted with. If `all`, the reset will always happen regardless. If `inactive` the reset will only be taken if the card has _not_ had human interaction recently (as defined by `view.interaction_seconds`). If `active` the reset will only be happen if the card _has_ had human interaction recently. This controls resets triggered by `entities` and `every_seconds`, but not `after_interaction` which by definition requires no interaction. |
| `every_seconds`     | `0`        | A number of seconds after which to automatically reset to the default view. `0` disables this functionality.                                                                                                                                                                                                                                                                                                                                                                                                          |

## `keyboard_shortcuts`

All configuration is under:

```yaml
view:
  keyboard_shortcuts: [...]
```

Configure the key-bindings for the builtin keyboard shortcuts. See [usage](../usage/keyboard-shortcuts.md) information for defaults on keyboard shortcuts.

| Option                                                                                   | Default                                                   | Description                                                                             |
| ---------------------------------------------------------------------------------------- | --------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| `enabled`                                                                                | `true`                                                    | If `true`, keyboard shortcuts are enabled. If `false`, they are disabled.               |
| `ptz_left`, `ptz_right`, `ptz_up`, `ptz_down`, `ptz_zoom_in`, `ptz_zoom_out`, `ptz_home` | See [usage](../usage/keyboard-shortcuts.md) for defaults. | An object that configures the key binding for a given pre-configured action. See below. |

### Keyboard Shortcut Configuration

| Option | Default | Description                                                                                                                      |
| ------ | ------- | -------------------------------------------------------------------------------------------------------------------------------- |
| key    |         | Any [keyboard key value](https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values), e.g. `ArrowLeft` |
| ctrl   | `false` | If `true` requires the `ctrl` key to be held.                                                                                    |
| shift  | `false` | If `true` requires the `shift` key to be held.                                                                                   |
| alt    | `false` | If `true` requires the `alt` key to be held.                                                                                     |
| meta   | `false` | If `true` requires the `meta` key to be held.                                                                                    |

## `theme` 🎨

All configuration is under:

```yaml
view:
  theme: [...]
```

Configure the theming/colors applied to the card.

| Option      | Default         | Description                                                                                                                                                            |
| ----------- | --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `themes`    | `[traditional]` | A list of themes that are applied sequentially. Valid themes are shown below. Usually only a single value is needed. An empty list is treated the same as the default. |
| `overrides` |                 | A list of CSS keys that can be used to tweak the theming.                                                                                                              |

### `themes`

| Theme         | Description                                                                                                                                   |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `dark`        | Use a dark theme that is identical to the HA dark theme.                                                                                      |
| `ha`          | Uses HA-prescribed theming. Respects HA choice of dark or light colors.                                                                       |
| `light`       | Use a light theme that is similar to the HA light theme (there are some differences if you do not use the standard choices of primary color). |
| `traditional` | A theme based on the default Advanced Camera Card theme before full theming support was added. Respects HA color theme choices.               |

### `overrides`

Allows overriding of any CSS value, can be used to tweak theming parameters.

| Option                                                                                                                                                                                                                                                          | Description                                            |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| Any CSS key. Overriding the [Advanced Camera Card](https://github.com/dermotduffy/advanced-camera-card/tree/main/src/scss/themes/base.scss) CSS variables allows changing individual theming parameters, e.g. `--advanced-camera-card-menu-override-background` | Any CSS value, e.g. `red` or `rgba(10, 11, 12, 0.64)`. |

## `triggers`

The `triggers` block controls how the card reacts when a camera is triggered (note that _what_ triggers the camera is controlled by the [`triggers`](cameras/README.md?id=triggers) block within the config for a given camera). This can be used for a variety of purposes, such as allowing the card to automatically change to `live` for a camera that triggers.

All configuration is under:

```yaml
view:
  triggers:
    # [...]
```

When a camera untriggers (e.g. an entity state returning to something other than
`on` or `open`), an action can also be taken with an optional number of seconds
to wait prior to the acting (see `untrigger_seconds`). By default, triggering is
only allowed when there is no ongoing human interaction with the card. This
behavior can be controlled by the `interaction_mode` parameter.

If the card starts when a trigger entity is already in a triggered state, the
action will be taken on card startup.

| Option                   | Default | Description                                                                                                                        |
| ------------------------ | ------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `actions`                |         | The actions to take when a camera is triggered. See below.                                                                         |
| `filter_selected_camera` | `false` | If set to `true` will only trigger on the currently selected camera.                                                               |
| `show_trigger_status`    | `false` | Whether or not the `live` view should show a visual indication that it is triggered (a pulsing border around the camera edge).     |
| `untrigger_seconds`      | `0`     | The number of seconds to wait after a camera untriggers before considering the card untriggered and taking the `untrigger` action. |

### Trigger action configuration

| Option             | Default    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------ | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `interaction_mode` | `inactive` | Whether actions should be taken when the card is being interacted with. If `all`, actions will always left be taken regardless. If `inactive` actions will only be taken if the card has _not_ had human interaction recently (as defined by `view.interaction_seconds`). If `active` actions will only be taken if the card _has_ had human interaction recently. This does not stop triggering itself (i.e. border will still pulse if `show_trigger_status` is true) but rather just prevents the actions being performed. |
| `trigger`          | `update`   | If set to `update` the current view is updated in place. If set to `default` the default view of the card will be reloaded. If set to `live` the triggered camera will be selected in `live` view. If set to `media` the appropriate media view (e.g. `clip` or `snapshot`) will be chosen to match a newly available media item (please note that only some [camera engines](cameras/engine.md) support new media detection, e.g. `frigate`). If set to `none` no action is taken.                                           |
| `untrigger`        | `none`     | If set to `default` the the default view of the card will be reloaded. If set to `none` no action will be taken.                                                                                                                                                                                                                                                                                                                                                                                                              |

## Supported views

This card supports several different views.

| Key          | Description                                                                                                                                        |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `clip`       | Shows a viewer for the most recent clip for this camera. Can also be accessed by holding down the `clips` menu icon.                               |
| `clips`      | Shows a gallery of clips for this camera.                                                                                                          |
| `folder`     | Shows a viewer for the media from the default [`folder`](./folders.md).                                                                            |
| `folders`    | Shows a gallery of media and subfolders from the default [`folder`](./folders.md).                                                                 |
| `image`      | Shows a static image specified by the `image` parameter, can be used as a discrete default view or a screensaver (via `view.interaction_seconds`). |
| `live`       | Shows the live camera view with the configured [live provider](./cameras/live-provider.md).                                                        |
| `recording`  | Shows a viewer for the most recent recording for this camera. Can also be accessed by holding down the `recordings` menu icon.                     |
| `recordings` | Shows a gallery of recent (last day) recordings for this camera and its dependents.                                                                |
| `snapshot`   | Shows a viewer for the most recent snapshot for this camera. Can also be accessed by holding down the `snapshots` menu icon.                       |
| `snapshots`  | Shows a gallery of snapshots for this camera.                                                                                                      |
| `timeline`   | Shows an event timeline.                                                                                                                           |

The default view is `live`, but can be configured by the `view.default` parameter.

## Fully expanded reference

[](common/expanded-warning.md ':include')

```yaml
view:
  default: live
  camera_select: current
  interaction_seconds: 300
  default_cycle_camera: false
  default_reset:
    after_interaction: false
    entities:
      - binary_sensor.my_motion_sensor
    every_seconds: 0
    interaction_mode: inactive
  render_entities:
    - switch.render_card
  dim: false
  triggers:
    show_trigger_status: false
    filter_selected_camera: true
    untrigger_seconds: 0
    actions:
      interaction_mode: inactive
      trigger: update
      untrigger: none
  keyboard_shortcuts:
    enabled: true
    ptz_left:
      key: 'ArrowLeft'
    ptz_right:
      key: 'ArrowRight'
    ptz_up:
      key: 'ArrowUp'
    ptz_down:
      key: 'ArrowDown'
    ptz_zoom_in:
      key: '+'
    ptz_zoom_out:
      key: '-'
    ptz_home:
      key: 'h'
  theme:
    themes:
      - ha
    overrides:
      '--advanced-camera-card-menu-button-active-color': red
      '--advanced-camera-card-menu-position-left-style-overlay-alignment-left-background': pink
  actions:
    entity: light.office_main_lights
    tap_action:
      action: none
    hold_action:
      action: none
    double_tap_action:
      action: none
    start_tap_action:
      action: none
    end_tap_action:
      action: none
```



================================================
FILE: docs/configuration/actions/README.md
================================================
# `actions`

## Introduction to actions <!-- {docsify-ignore} -->

`actions` is not a top-level configuration block, but can be used as part of
multiple other blocks.

Actions are pre-configured activities that can be triggered in response to a
variety of circumstances (e.g. tapping on a menu icon, double tapping on an
[element](../elements/README.md) or holding the mouse/tap down on a particular
[view](../view.md?id=supported-views)).

### Differences in actions between Advanced Camera Card and Home Assistant

Both the Home Assistant frontend and the Advanced Camera Card cooperate to provide
action functionality. In general, the Advanced Camera Card functionality is a superset
of that offered by stock Home Assistant.

Stock action functionality is used for Stock [Home Assistant picture
elements](https://www.home-assistant.io/lovelace/picture-elements/). Extended
Advanced Camera Card behavior covers all other interactions on the Advanced Camera Card (e.g.
menu icon elements, submenus and actions on the card or views).

#### Custom action types: `start_tap` and `end_tap`

The card has partial support for two special action types `start_tap` and
`end_tap` which occur when a tap is started (e.g. mouse is pressed down /
touch begins), and ended (e.g. mouse released / touch ends) respectively. This
might be useful for PTZ cameras cameras to start/stop movement on touch. Network
latency may introduce unavoidable imprecision between `end_tap` and action
actually occurring.

#### Multiple actions

Extended Advanced Camera Card behavior supports a list of actions instead of a single
action, all of which will be handled. See [an example of multiple
actions](../../examples.md?id=multiple-actions).

## Card and view actions <!-- {docsify-ignore} -->

Actions may be attached to the card itself, to trigger action when the card
experiences a `tap`, `double_tap`, `hold`, `start_tap` or `end_tap` event.
Alternatively they can be configured on a per group-of-views basis, e.g. only
when `live` view is tapped.

| Configuration path      | Views to which it refers               |
| ----------------------- | -------------------------------------- |
| `image.actions`         | `image`                                |
| `live.actions`          | `live`                                 |
| `media_gallery.actions` | `clips`, `snapshots`, `recordings`     |
| `media_viewer.actions`  | `clip`, `snapshot`, `recording`        |
| `view.actions`          | All except `timeline` and `diagnostic` |

If an action is configured for both the whole card (`view.actions`) and a more
specific view (e.g. `live.actions`) then the actions are merged, with the more
specific overriding the less specific.

!> The card itself relies on user interactions to function (e.g. `tap` on
the menu should activate that button). Card or View actions are prevented from
being activated through standard interaction with menu buttons, next/previous
controls, thumbnails, etc, but in some cases this prevention is not possible
(e.g. embedded WebRTC card controls) -- in these cases duplicate actions may
occur with certain configurations (e.g. `tap`).

!> Card-wide actions are not supported on the `timeline` view, `diagnostics`
view nor when a info/error message is being displayed.

## Actions <!-- {docsify-ignore} -->

| Option                               | Description                         |
| ------------------------------------ | ----------------------------------- |
| [Custom Actions](./custom/README.md) | Custom actions to control the card. |
| [Stock Actions](./stock/README.md)   | Standard Home Assistant actions.    |



================================================
FILE: docs/configuration/actions/_sidebar.md
================================================
- [Getting Started](../../README.md)
- [Configuration](../README.md)
  - [`actions`](README.md)
    - [Custom Actions](./custom/README.md)
    - [Stock Actions](./stock/README.md)
  - [`automations`](../automations.md)
  - [`cameras`](../cameras/README.md)
  - [`conditions`](../conditions.md)
  - [`dimensions`](../dimensions.md)
  - [`elements`](../elements/README.md)
  - [`folders`](../folders.md)
  - [`image`](../image.md)
  - [`live`](../live.md)
  - [`media_gallery`](../media-gallery.md)
  - [`media_viewer`](../media-viewer.md)
  - [`menu`](../menu.md)
  - [`overrides`](../overrides.md)
  - [`performance`](../performance.md)
  - [`profiles`](../profiles.md)
  - [`remote_control`](../remote-control.md)
  - [`status_bar`](../status-bar.md)
  - [`timeline`](../timeline.md)
  - [`view`](../view.md)
  - [Templates](../templates.md)
- [Examples](../../examples.md)
- [Screenshots](../../screenshots.md)
- [Troubleshooting](../../troubleshooting.md)
- [Usage](../../usage/README.md)

---

- [Developing](../../developing.md)



================================================
FILE: docs/configuration/actions/custom/README.md
================================================
# `custom:advanced-camera-card-action`

Execute an Advanced Camera Card action.

```yaml
action: custom:advanced-camera-card-action
# [...]
```

| Parameter                     | Description                                         |
| ----------------------------- | --------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.       |
| `advanced_camera_card_action` | A supported Advanced Camera Card action. See below. |

## `camera_select`

Select a given camera.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: camera_select
# [...]
```

| Parameter                     | Description                                                                                         |
| ----------------------------- | --------------------------------------------------------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.                                                       |
| `advanced_camera_card_action` | Must be `camera_select`.                                                                            |
| `camera`                      | The [camera ID](../../cameras/README.md?id=cameras) of the camera to select.                        |
| `triggered`                   | If `true` instead of `camera` being specified then a triggered camera (if any) is selected instead. |

This action will respect the value of the `view.camera_select` to choose the appropriate view on the new camera. See [`view` configuration](../../view.md).

## `camera_ui`

Download the displayed media.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: camera_ui
```

Open the UI for the selected camera engine (e.g. the Frigate UI).

## `clip`

Change to the `clip` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: clip
```

## `clips`

Change to the `clips` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: clips
```

## `default`

Change to the default view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: default
```

## `diagnostics`

Show the card diagnostics.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: diagnostics
```

## `display_mode_select`

Select a display mode (e.g. view a `single` camera or a `grid` of cameras).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: display_mode_select
# [...]
```

| Parameter                     | Description                                                                                    |
| ----------------------------- | ---------------------------------------------------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.                                                  |
| `advanced_camera_card_action` | Must be `display_mode_select`.                                                                 |
| `display_mode`                | `single` to show a single camera at a time in a carousel, or `grid` to show a grid of cameras. |

## `download`

Download the displayed media.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: download
```

## `expand`

Expand the card into a dialog/popup.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: expand
```

## `folder`

Show media from a given folder in the media viewer.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: folder
# [...]
```

| Parameter | Default                                                            | Description                                                                                                     |
| --------- | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| `folder`  | The first configured folder (under [`folders`](../../folders.md)). | An optional id of the folder to show, see the `id` parameter under [`folders` configuration](../../folders.md). |

## `folders`

Show a given folder in the folders gallery.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: folders
# [...]
```

| Parameter | Default                                                            | Description                                                                                                     |
| --------- | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| `folder`  | The first configured folder (under [`folders`](../../folders.md)). | An optional id of the folder to show, see the `id` parameter under [`folders` configuration](../../folders.md). |

## `fullscreen`

Toggle fullscreen.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: fullscreen
```

## `image`

Change to the `image` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: image
```

## `live`

Change to the `live` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: live
```

## `live_substream_off`

Turn off the substream (if on).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: live_substream_on
```

| Parameter                     | Description                                   |
| ----------------------------- | --------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`. |
| `advanced_camera_card_action` | Must be `live_substream_on`.                  |

## `live_substream_on`

Turn on the first available substream. Use [Camera dependency configuration](../../cameras/README.md?id=dependencies) to configure substreams.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: live_substream_on
```

| Parameter                     | Description                                   |
| ----------------------------- | --------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`. |
| `advanced_camera_card_action` | Must be `live_substream_on`.                  |

## `live_substream_select`

Select a substream. Use [Camera dependency configuration](../../cameras/README.md?id=dependencies) to configure substreams.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: live_substream_select
# [...]
```

| Parameter                     | Description                                                                     |
| ----------------------------- | ------------------------------------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.                                   |
| `advanced_camera_card_action` | Must be `live_substream_select`.                                                |
| `camera`                      | The [camera ID](../../cameras/README.md?id=cameras) of the substream to select. |

## `log`

Log a message to the Javascript console.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: log
# [...]
```

| Parameter                     | Default | Description                                                                    |
| ----------------------------- | ------- | ------------------------------------------------------------------------------ |
| `action`                      |         | Must be `custom:advanced-camera-card-action`.                                  |
| `advanced_camera_card_action` |         | Must be `log`.                                                                 |
| `message`                     |         | The message to log.                                                            |
| `level`                       | `info`  | The console logging level to use. One of `['debug', 'info', 'warn', 'error']`. |

## `media_player`

Perform a media player action.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: media_player
# [...]
```

| Parameter                     | Description                                                       |
| ----------------------------- | ----------------------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.                     |
| `advanced_camera_card_action` | Must be `media_player`.                                           |
| `media_player`                | The entity ID of the media_player on which to perform the action. |
| `media_player_action`         | Either `play` or `stop` to play or stop the media in question.    |

## `menu_toggle`

Show/hide the menu (for the `hidden` mode style).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: menu_toggle
```

## `microphone_connect`

Connect the microphone for [2-way audio](../../../usage/2-way-audio.md).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: microphone_connect
```

## `microphone_disconnect`

Disconnect the microphone during [2-way audio](../../../usage/2-way-audio.md).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: microphone_disconnect
```

## `microphone_mute`

Mute the microphone during [2-way audio](../../../usage/2-way-audio.md).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: microphone_mute
```

## `microphone_unmute`

Unmute the microphone during [2-way audio](../../../usage/2-way-audio.md).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: microphone_unmute
```

## `mute`

Mute the selected media.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: mute
```

## `pause`

Pause the selected media.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: pause
```

## `play`

Play the selected media.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: play
```

## `ptz`

Execute a real PTZ action, whether configured manually (see [Camera PTZ configuration](../../cameras/README.md?id=ptz)) or auto-detected.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: ptz
# [...]
```

| Parameter                     |                           | Description                                                                                   |
| ----------------------------- | ------------------------- | --------------------------------------------------------------------------------------------- |
| `action`                      |                           | Must be `custom:advanced-camera-card-action`.                                                 |
| `advanced_camera_card_action` |                           | Must be `ptz`.                                                                                |
| `camera`                      | Currently selected camera | An optional camera ID to execute the action on.                                               |
| `ptz_action`                  |                           | Optional action that is of `left`, `right`, `up`, `down`, `zoom_in`, `zoom_out` or `preset`.  |
| `ptz_phase`                   |                           | Optional parameter that is one of `start` or `stop` to start or stop the movement separately. |
| `ptz_preset`                  |                           | Optional preset to execute when the `ptz_action` is `preset`.                                 |

?> If no `ptz_action` is specified, the camera returns to its "home" position. For a real PTZ camera, the "home" position is the first available preset. If there are no presets, there is no home position.

## `ptz_controls`

Show or hide the PTZ controls.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: ptz_controls
# [...]
```

| Parameter                     | Description                                              |
| ----------------------------- | -------------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.            |
| `advanced_camera_card_action` | Must be `ptz_controls`.                                  |
| `show`                        | If `true` shows the PTZ controls, if `false` hides them. |

## `ptz_digital`

Execute a digital PTZ action.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: ptz_digital
# [...]
```

| Parameter                     | Default                                                                                       | Description                                                                                                                                                |
| ----------------------------- | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `action`                      |                                                                                               | Must be `custom:advanced-camera-card-action`.                                                                                                              |
| `advanced_camera_card_action` |                                                                                               | Must be `ptz_digital`.                                                                                                                                     |
| `target_id`                   | The currently selected camera or media                                                        | The target (camera or media) to execute a digital PTZ action on. Can be a camera ID, or another media ID (e.g. for Frigate, can specify a media/event ID). |
| `ptz_action`                  | Optional action that is one of `left`, `right`, `up`, `down`, `zoom_in` or `zoom_out`.        |
| `ptz_phase`                   | Optional parameter that is one of `start` or `stop` to start or stop the movement separately. |
| `absolute`                    | Optional parameter to specify exact absolute pan and zoom settings. See below.                |

?> If no `ptz_action` is specified and no `absolute` value is specified, the camera returns to its "home" position. See [Camera layout configuration](../../cameras/README.md?id=layout-configuration) to configure the default "home" position for digital PTZ.

See [example of automatically zoom/panning based on state](../../../examples.md?id=automatically-zoom-based-on-state).

### `absolute`

Set exact digital PTZ pan and zoom parameters.

| Parameter | Description                                                                                                                              |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `pan`     | Control camera digital pan. See the `pan` parameter in [Camera layout configuration](../../cameras/README.md?id=layout-configuration).   |
| `zoom`    | Control camera digital zoom. See the `zoom` parameter in [Camera layout configuration](../../cameras/README.md?id=layout-configuration). |

## `ptz_multi`

Execute a PTZ action that intelligently chooses between a real and digital PTZ
action. If the media in question is a live camera with real PTZ support, a real
PTZ action will execute (equivalent to using the [`ptz`](README.md?id=ptz)
action), otherwise a digital PTZ action will be run (equivalent to using the
[`ptz_digital`](README.md?id=ptz_digital) action).

?> If the camera supports _any_ real PTZ action, _all_ actions will attempt to make real PTZ calls.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: ptz_multi
# [...]
```

| Parameter                     | Description                                                                                   |
| ----------------------------- | --------------------------------------------------------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`.                                                 |
| `advanced_camera_card_action` | Must be `ptz_multi`.                                                                          |
| `ptz_action`                  | Optional action that is one of `left`, `right`, `up`, `down`, `zoom_in` or `zoom_out`.        |
| `ptz_phase`                   | Optional parameter that is one of `start` or `stop` to start or stop the movement separately. |
| `ptz_preset`                  | Optional preset to execute when the `ptz_action` is `preset`.                                 |

?> If no `ptz_action` is specified, the camera returns to its "home" position.

## `recording`

Change to the `recording` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: recording
```

## `recordings`

Change to the `recordings` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: recordings
```

## `screenshot`

Take a screenshot of the selected media (e.g. a still from a video).

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: screenshot
```

## `sleep`

Take no action for a given duration. Useful to pause between multiple other actions.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: sleep
```

| Parameter                     | Description                                   |
| ----------------------------- | --------------------------------------------- |
| `action`                      | Must be `custom:advanced-camera-card-action`. |
| `advanced_camera_card_action` | Must be `sleep`.                              |
| `duration`                    | A duration object. See below.                 |

### `duration`

The `duration` block configures how long the `sleep` should last.

| Parameter | Description                |
| --------- | -------------------------- |
| `h`       | Hours to sleep for.        |
| `m`       | Minutes to sleep for.      |
| `s`       | Seconds to sleep for.      |
| `ms`      | Milliseconds to sleep for. |

?> Multiple values can be combined, e.g. `{ m: 2, s: 30}` will sleep for `2.5` minutes.

## `snapshot`

Change to the `snapshot` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: snapshot
```

## `status_bar`

Add or remove items from the status bar.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: status_bar
# [...]
```

| Parameter           | Default | Description                                                                                                                                             |
| ------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `status_bar_action` |         | If `add` adds `items` to the status bar, if `remove` removes items and if `reset` resets the status bar entirely (removes all dynamically added items). |
| `items`             |         | The items to `add` or `remove`. See below.                                                                                                              |

### `items`

The items parameter is a list of items to `add` or `remove`. See [`custom:advanced-camera-card-status-bar-icon`](../../elements/custom/README.md?id=status-bar-icon), [`custom:advanced-camera-card-status-bar-image`](../../elements/custom/README.md?id=status-bar-image), [`custom:advanced-camera-card-status-bar-string`](../../elements/custom/README.md?id=status-bar-string) for the allowable items and their parameters. See the [fully expanded reference](./README.md?fully-expanded-reference) below for a complete example.

## `timeline`

Change to the `timeline` view.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: timeline
```

## `unmute`

Unmute the selected media.

```yaml
action: custom:advanced-camera-card-action
advanced_camera_card_action: unmute
```

## Fully expanded reference

[](../../common/expanded-warning.md ':include')

```yaml
elements:
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-a-circle
    title: Select Front Door
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: camera_select
      camera: camera.front_door
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-b-circle
    title: Open Camera UI
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: camera_ui
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-d-circle
    title: Show most recent clip
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: clip
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-e-circle
    title: Show clips
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: clips
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-f-circle
    title: Show default view
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: default
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-g-circle
    title: Show diagnostics
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: diagnostics
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-h-circle
    title: Show  grid
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: display_mode_select
      display_mode: grid
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-i-circle
    title: Download media
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: download
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-j-circle
    title: Expand
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: expand
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-k-circle
    title: Fullscreen
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: fullscreen
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-l-circle
    title: Show image view
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: image
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-m-circle
    title: Show live view
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: live
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-n-circle
    title: Turn off substream
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: live_substream_off
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-o-circle
    title: Turn on substream
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: live_substream_on
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-n-circle
    title: Select HD substream
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: live_substream_select
      camera: camera.front_door_hd
  - type: custom:advanced-camera-card-menu-icon
      icon: mdi:alpha-o-circle
      title: Log to console
      tap_action:
        action: custom:advanced-camera-card-action
        advanced_camera_card_action: log
        message: "Hello, world!"
        level: debug
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-m-circle
    title: Media player play
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: media_player
      media_player: media_player.nesthub50be
      media_player_action: play
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-n-circle
    title: Media player stop
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: media_player
      media_player: media_player.nesthub
      media_player_action: stop
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-o-circle
    title: Toggle hidden menu
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: menu_toggle
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-p-circle
    title: Microphone connect
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: microphone_connect
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-q-circle
    title: Microphone disconnect
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: microphone_disconnect
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-r-circle
    title: Microphone mute
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: microphone_mute
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-s-circle
    title: Microphone unmute
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: microphone_unmute
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-t-circle
    title: Mute
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: mute
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-u-circle
    title: Pause
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: pause
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-v-circle
    title: Play
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: play
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-x-circle
    title: Real PTZ Preset
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: ptz
      ptz_action: preset
      ptz_preset: doorway
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-y-circle
    title: Show PTZ Controls
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: ptz_controls
      enabled: true
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-z-circle
    title: Go to precise digital location
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: ptz_digital
      absolute:
        zoom: 5
        pan:
          x: 58
          y: 14
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-a-circle-outline
    title: Smart select between real and digital PTZ
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: ptz_multi
      ptz_action: left
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-b-circle-outline
    title: Show most recent recording
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: recording
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-c-circle-outline
    title: Show recordings
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: recordings
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-d-circle-outline
    title: Screenshot
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: screenshot
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-e-circle-outline
    title: Sleep
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: sleep
      duration:
        h: 1
        m: 20
        s: 56
        ms: 422
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-f-circle-outline
    title: Show most recent snapshot
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: snapshot
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-g-circle-outline
    title: Show snapshots
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: snapshots
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-h-circle-outline
    title: Show timeline
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: timeline
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-i-circle-outline
    title: Unmute
    tap_action:
      action: custom:advanced-camera-card-action
      advanced_camera_card_action: unmute
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-j-circle-outline
    title: Add status bar contents
    tap_action:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: status_bar
        status_bar_action: add
        items:
          - type: custom:advanced-camera-card-status-bar-string
            enabled: true
            exclusive: false
            expand: false
            string: 'Intruder alert!'
            priority: 50
            sufficient: false
          - type: custom:advanced-camera-card-status-bar-icon
            enabled: true
            exclusive: false
            expand: false
            icon: 'mdi:cow'
            priority: 50
            sufficient: false
          - type: custom:advanced-camera-card-status-bar-image
            enabled: true
            exclusive: false
            expand: false
            image: https://my.site.com/status.png
            priority: 50
            sufficient: false
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-k-circle-outline
    title: Remove status bar contents
    tap_action:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: status_bar
        status_bar_action: remove
        items:
          - type: custom:advanced-camera-card-status-bar-string
            enabled: true
            exclusive: false
            expand: false
            string: 'Intruder alert!'
            priority: 50
            sufficient: false
          - type: custom:advanced-camera-card-status-bar-icon
            enabled: true
            exclusive: false
            expand: false
            icon: 'mdi:cow'
            priority: 50
            sufficient: false
          - type: custom:advanced-camera-card-status-bar-image
            enabled: true
            exclusive: false
            expand: false
            image: https://my.site.com/status.png
            priority: 50
            sufficient: false
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-l-circle-outline
    title: Reset status bar contents
    tap_action:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: status_bar
        status_bar_action: reset
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-m-circle-outline
    title: View Folder Media
    tap_action:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: folder
        folder: my-folder
  - type: custom:advanced-camera-card-menu-icon
    icon: mdi:alpha-n-circle-outline
    title: View Folders Gallery
    tap_action:
      - action: custom:advanced-camera-card-action
        advanced_camera_card_action: folders
        folder: my-folder
```



================================================
FILE: docs/configuration/actions/custom/_sidebar.md
================================================
- [Getting Started](../../../README.md)
- [Configuration](../../README.md)
  - [`actions`](../README.md)
    - [Custom Actions](README.md)
    - [Stock Actions](../stock/README.md)
  - [`automations`](../../automations.md)
  - [`cameras`](../../cameras/README.md)
  - [`conditions`](../../conditions.md)
  - [`dimensions`](../../dimensions.md)
  - [`elements`](../../elements/README.md)
  - [`folders`](../../folders.md)
  - [`image`](../../image.md)
  - [`live`](../../live.md)
  - [`media_gallery`](../../media-gallery.md)
  - [`media_viewer`](../../media-viewer.md)
  - [`menu`](../../menu.md)
  - [`overrides`](../../overrides.md)
  - [`performance`](../../performance.md)
  - [`profiles`](../../profiles.md)
  - [`remote_control`](../../remote-control.md)
  - [`status_bar`](../../status-bar.md)
  - [`timeline`](../../timeline.md)
  - [`view`](../../view.md)
  - [Templates](../../templates.md)
- [Examples](../../../examples.md)
- [Screenshots](../../../screenshots.md)
- [Troubleshooting](../../../troubleshooting.md)
- [Usage](../../../usage/README.md)

---

- [Developing](../../../developing.md)



================================================
FILE: docs/configuration/actions/stock/README.md
================================================
# Stock Actions

## `more-info`

Open the "more-info" dialog for an entity. See [Home Assistant actions documentation](https://www.home-assistant.io/dashboards/actions/).

```yaml
action: more-info
# [...]
```

## `navigate`

Navigate to a particular dashboard path. See [Home Assistant actions documentation](https://www.home-assistant.io/dashboards/actions/).

```yaml
action: navigate
# [...]
```

## `perform-action`

Perform a Home Assistant action. See [Home Assistant actions documentation](https://www.home-assistant.io/dashboards/actions/).

```yaml
action: perform-action
# [...]
```

## `toggle`

Toggle an entity. See [Home Assistant actions documentation](https://www.home-assistant.io/dashboards/actions/).

```yaml
action: toggle
# [...]
```

## `url`

Navigate to an arbitrary URL. See [Home Assistant actions documentation](https://www.home-assistant.io/dashboards/actions/).

```yaml
action: url
# [...]
```

## Fully expanded reference

[](../../common/expanded-warning.md ':include')

Reference: [Home Assistant Actions](https://www.home-assistant.io/dashboards/actions/).

```yaml
elements:
  - type: icon
    icon: mdi:numeric-1-box
    title: More info action
    style:
      left: 200px
      top: 50px
    entity: light.office_main_lights
    tap_action:
      action: more-info
  - type: icon
    icon: mdi:numeric-2-box
    title: Toggle action
    style:
      left: 200px
      top: 100px
    entity: light.office_main_lights
    tap_action:
      action: toggle
  - type: icon
    icon: mdi:numeric-3-box
    title: Perform Action / Call Service action
    style:
      left: 200px
      top: 150px
    tap_action:
      action: perform-action
      perform_action: homeassistant.toggle
      data:
        entity_id: light.office_main_lights
  - type: icon
    icon: mdi:numeric-4-box
    title: Navigate action
    style:
      left: 200px
      top: 200px
    tap_action:
      action: navigate
      navigation_path: /lovelace/2
  - type: icon
    icon: mdi:numeric-5-box
    title: URL action
    style:
      left: 200px
      top: 250px
    tap_action:
      action: url
      url_path: https://www.home-assistant.io/
  - type: icon
    icon: mdi:numeric-6-box
    title: None action
    style:
      left: 200px
      top: 300px
    tap_action:
      action: none
  - type: icon
    icon: mdi:numeric-7-box
    title: Custom action
    style:
      left: 200px
      top: 350px
    tap_action:
      action: fire-dom-event
      key: value
```



================================================
FILE: docs/configuration/actions/stock/_sidebar.md
================================================
- [Getting Started](../../../README.md)
- [Configuration](../../README.md)
  - [`actions`](../README.md)
    - [Custom Actions](../custom/README.md)
    - [Stock Actions](README.md)
  - [`automations`](../../automations.md)
  - [`cameras`](../../cameras/README.md)
  - [`conditions`](../../conditions.md)
  - [`dimensions`](../../dimensions.md)
  - [`elements`](../../elements/README.md)
  - [`folders`](../../folders.md)
  - [`image`](../../image.md)
  - [`live`](../../live.md)
  - [`media_gallery`](../../media-gallery.md)
  - [`media_viewer`](../../media-viewer.md)
  - [`menu`](../../menu.md)
  - [`overrides`](../../overrides.md)
  - [`performance`](../../performance.md)
  - [`profiles`](../../profiles.md)
  - [`remote_control`](../../remote-control.md)
  - [`status_bar`](../../status-bar.md)
  - [`timeline`](../../timeline.md)
  - [`view`](../../view.md)
  - [Templates](../../templates.md)
- [Examples](../../../examples.md)
- [Screenshots](../../../screenshots.md)
- [Troubleshooting](../../../troubleshooting.md)
- [Usage](../../../usage/README.md)

---

- [Developing](../../../developing.md)



================================================
FILE: docs/configuration/cameras/README.md
================================================
# Cameras

The `cameras` block configures a list of cameras the card should support. The first listed camera is the default.

```yaml
cameras:
  - [...camera 0 (default camera)...]
  - [...camera 1...]
  - [...camera 2...]
```

The `cameras_global` block can be used to set defaults across multiple cameras.

```yaml
cameras_global:
  # [...]
```

| Option                               | Default                                                                                           | Description                                                                                                                                                                                                                                                      |
| ------------------------------------ | ------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `always_error_if_entity_unavailable` | `false`                                                                                           | When `true` and when `camera_entity` is specified, attempting to live stream this camera will always error out if the entity state is `unavailable`, even if the `live_provider` does not actually need the `camera_entity`.                                     |
| `camera_entity`                      |                                                                                                   | The Home Assistant camera entity to use with the `frigate` live provider view. Also used to automatically detect the name of the underlying Frigate camera, and the title/icon of the camera.                                                                    |
| `capabilities`                       |                                                                                                   | Allows selective disabling of camera capabilities. See below.                                                                                                                                                                                                    |
| `cast`                               |                                                                                                   | Configuration that controls how this camera is "casted" / sent to media players. See below.                                                                                                                                                                      |
| `dependencies`                       |                                                                                                   | Other cameras that this camera should depend upon. See below.                                                                                                                                                                                                    |
| `dimensions`                         |                                                                                                   | Controls the dimensions and layout for media from this camera. See below.                                                                                                                                                                                        |
| `engine`                             | `auto`                                                                                            | The camera engine to use. If `auto` the card will attempt to choose the correct engine from the specified options. See [Engine](engine.md).                                                                                                                      |
| `frigate`                            |                                                                                                   | Options for Frigate cameras. See [Frigate camera engine configuration](engine.md?id=frigate).                                                                                                                                                                    |
| `icon`                               | Autodetected from `camera_entity` if that is specified.                                           | The icon to use for this camera in the camera menu and in the next & previous controls when using the `icon` style.                                                                                                                                              |
| `id`                                 | `camera_entity`, `webrtc_card.entity` or `frigate.camera_name` if set (in that preference order). | An optional identifier to use throughout the card configuration to refer unambiguously to this camera. This `id` may be used in [conditions](../conditions.md), dependencies or custom [actions](../actions/README.md) to refer to a given camera unambiguously. |
| `live_provider`                      | `auto`                                                                                            | The choice of live stream provider. See [Live Provider](live-provider.md).                                                                                                                                                                                       |
| `proxy`                              |                                                                                                   | Controls whether/how content is proxied via [hass-web-proxy-integration](https://github.com/dermotduffy/hass-web-proxy-integration) (must be installed separately). See below.                                                                                   |
| `title`                              | Autodetected from `camera_entity` if that is specified.                                           | A friendly name for this camera to use in the card.                                                                                                                                                                                                              |
| `triggers`                           |                                                                                                   | Define what should cause this camera to update/trigger. See below.                                                                                                                                                                                               |
| `webrtc_card`                        |                                                                                                   | The WebRTC entity/URL to use for this camera with the `webrtc-card` live provider. See below.                                                                                                                                                                    |

## `capabilities`

The `capabilities` block allows selected disabling of auto-detected camera capabilities. This is rarely used, with substreams being a notable exception.

```yaml
cameras:
  - camera_entity: camera.office
    capabilities:
      # [...]
```

| Option           | Default | Description                                                                                                |
| ---------------- | ------- | ---------------------------------------------------------------------------------------------------------- |
| `disable`        |         | A list of camera capabilities to disable. By default all capabilities supported by the camera are enabled. |
| `disable_except` |         | A list of camera capabilities to leave enabled if supported. Everything else will be disabled.             |

### Capabilities

| Capability              | Purpose                                                                                           |
| ----------------------- | ------------------------------------------------------------------------------------------------- |
| `clips`                 | Clips can be fetched from the camera.                                                             |
| `remote-control-entity` | The camera can be selected by a [Camera Remote Control Entity](../remote-control.md?id=entities). |
| `favorite-events`       | Events can be favorited.                                                                          |
| `favorite-recordings`   | Recordings can be favorited.                                                                      |
| `live`                  | Live video can be received from the camera.                                                       |
| `menu`                  | The camera should show up in the card camera menu.                                                |
| `ptz`                   | The camera can be PTZ controlled.                                                                 |
| `recordings`            | Recordings can be fetched from the camera.                                                        |
| `seek`                  | Clips can be seeked / scrubbed by the timeline.                                                   |
| `snapshots`             | Snapshots can be fetched from the camera.                                                         |
| `substream`             | The camera can be used as a substream on another camera.                                          |
| `trigger`               | The camera can be triggered.                                                                      |

?> If using a camera only as a `substream`, don't forget to keep both the
`substream` and `ptz` capabilities enabled if you wish to use PTZ controls for
the substream.

## `cast`

The `cast` block configures how a camera is cast / sent to media players.

```yaml
cameras:
  - camera_entity: camera.office
    cast:
      # [...]
```

| Option      | Default    | Description                                                                                                                                                                                                                                                                                                                  |
| ----------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dashboard` |            | Configuration for the dashboard to cast. See below.                                                                                                                                                                                                                                                                          |
| `method`    | `standard` | Whether to use `standard` media casting to send the live view to your media player, or to instead cast a `dashboard` you have manually setup. Casting a dashboard supports a much wider variety of video media, including low latency video providers (e.g. `go2rtc`). This setting has no effect on casting non-live media. |

See the [dashboard method cast example](../../examples.md?id=cast-a-dashboard).

### Dashboard Configuration

```yaml
cameras:
  - camera_entity: camera.office
    cast:
      dashboard:
        # [...]
```

| Option           | Default | Description                                                                                                                                                               |
| ---------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dashboard_path` |         | A required field that specifies the name of the dashboard to cast. You can see this name in your HA URL when you visit the dashboard.                                     |
| `view_path`      |         | A required field that specifies view/"tab" on that dashboard to cast. This is the value you have specified in the `url` field of the view configuration on the dashboard. |

## `dependencies`

The `dependencies` block configures other cameras as dependents of this camera. Dependent cameras have their media fetched and merged with this camera by default, and offer their respective live views as 'substreams' of the main (depended upon) camera. Configuration is under:

```yaml
cameras:
  - camera_entity: camera.office
    dependencies:
      # [...]
```

| Option        | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `all_cameras` | `false` | Shortcut to specify all other cameras as dependent cameras.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `cameras`     |         | An optional list of other camera identifiers (see `id` parameter). If specified the card will fetch media for this camera and _also_ recursively for the named cameras by default. Live views for the involved cameras will be available as 'substreams' of the main (depended upon) camera. All dependent cameras must themselves be a configured camera in the card. This can be useful to group events for cameras that are close together, to show multiple related live views, to always have clips/snapshots show fully merged events across all cameras or to show events for the `birdseye` camera that otherwise would not have events itself. |

## `dimensions`

The `dimensions` block configures the dimensions and layout of media of a given camera (see [Card Dimensions](../dimensions.md) to set the dimensions of the whole card and not just a single camera).

```yaml
cameras:
  - camera_entity: camera.office
    dimensions:
      # [...]
```

| Option         | Default | Description                                                                                                                                                                                                                                                                                                                  |
| -------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `aspect_ratio` |         | An optional aspect ratio for media from this camera which will be used in `live` or media viewer related views (e.g. `clip`, `snapshot` and `recording`). Format is the same as the parameter of the same name under the [dimensions block](../dimensions.md) (which controls dimensions for the whole card), e.g. `16 / 9`. |
| `layout`       |         | How the media should be laid out _within_ the camera dimensions. See below.                                                                                                                                                                                                                                                  |

### Layout Configuration

The `layout` block configures the fit and position of the media _within_ the camera dimensions (in order to control the dimensions for the whole card see [the card dimensions configuration](../dimensions.md) ).

```yaml
cameras:
  - camera_entity: camera.office
    dimensions:
      layout:
        # [...]
```

| Option     | Default   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `fit`      | `contain` | If `contain`, the media is contained within the card and letterboxed if necessary. If `cover`, the media is expanded proportionally (i.e. maintaining the media aspect ratio) until the camera/card dimensions are fully covered. If `fill`, the media is stretched to fill the camera/card dimensions (i.e. ignoring the media aspect ratio). See [CSS object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) for technical details and a visualization.                                                                                                                                                                                                                                                                                                                                                    |
| `pan`      |           | A dictionary that may contain an `x` and `y` percentage (`0` - `100`) to control the position of the media when "digitally zoomed in" (see `zoom` parameter). This can be effectively used to "pan"/cut the media shown. A value of `0` means maximally to the left or top of the media, a value of `100` means maximally to the right or bottom of the media. See visualizations below.                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `position` |           | A dictionary that may contain an `x` and `y` percentage (`0` - `100`) to control the position of the media when the fit is `cover` (for other values of `fit` this option has no effect). This can be effectively used to "pan"/cut the media shown. At any given time, only one of `x` and `y` will have an effect, depending on whether media width is larger than the camera/card dimensions (in which case `x` controls the position) or the media height is larger than the camera/card dimensions (in which case `y` controls the position). A value of `0` means maximally to the left or top of the media, a value of `100` means maximally to the right or bottom of the media. See [CSS object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) for technicals. See visualizations below. |
| `view_box` |           | A dictionary that may contain a `top`, `bottom`, `left` and `right` percentage (`0` - `100`) to precisely crop what part of the media to show by specifying a % inset value from each side. Browsers apply this cropping after `position` and `fit` have been applied. Unlike `zoom`, the user cannot dynamically zoom back out -- however the builtin media controls will work as normal. See visualizations below. Limited [browser support](https://caniuse.com/mdn-css_properties_object-view-box): ![](../../images/browsers/chrome_16x16.png 'Google Chrome :no-zoom') ![](../../images/browsers/chromium_16x16.png 'Chromium :no-zoom') ![](../../images/browsers/edge_16x16.png 'Microsoft Edge :no-zoom')                                                                                                             |
| `zoom`     | `1.0`     | A value between `1.0` and `10.0` inclusive that defines how much additional "digital zoom" to apply to this camera by default. Unlike with `view_box` the user can easily "zoom back out". Often used in conjuction with `pan`. When zoomed in the [builtin browser media controls](../live.md?id=controls) will automatically be disabled (as otherwise they would be enlarged also).                                                                                                                                                                                                                                                                                                                                                                                                                                         |

?> Layout operations are effectively applied in this order: `fit`, `position`, `view_box`, `zoom` then `pan`.

See [media layout examples](../../examples.md?id=media-layout).

#### Layout **Visualizations**

##### `fit`

![](../../images/media_layout/fit.png 'Media Layout Fit :size=400')

##### `position`: When media is shorter than dimensions height

![](../../images/media_layout/position-shorter-than-height.png 'Media Layout Position: Wider than taller :size=400')

##### `position`: When media is thinner than dimensions width

![](../../images/media_layout/position-thinner-than-width.png 'Media Layout Position: Taller than wider :size=400')

#### `view_box`: Precise media cropping

![](../../images/media_layout/view-box.png 'Media Layout Position: Taller than wider :size=400')

#### `pan` and `zoom`: Predefined panning and zooming

![](../../images/media_layout/pan-zoom.png 'Panning and zooming :size=400')

## `ptz`

Configure the PTZ actions taken for a camera (not to be confused with configuration of the PTZ _controls_, see [Live PTZ Controls](../live.md?id=ptz) or [Media Viewer PTZ Controls](../media-viewer.md?id=ptz)). Manually configured actions override any auto-detected actions.

```yaml
cameras:
  - camera_entity: camera.office
    ptz:
      # [...]
```

### Movement types

Generally PTZ cameras/integrations may support two kinds of PTZ actions:

- `relative`: Single relative steps, e.g. "Pan to the left one step".
- `continuous`: Separate start and stop, e.g. "Start panning to the left", following by a later command "Stop panning".

The card supports both, and with the help of the
`r2c_delay_between_calls_seconds` and `c2r_delay_between_calls_seconds` can
translate between them where necessary. See the [ONVIF
specification](https://www.onvif.org/specs/srv/ptz/ONVIF-PTZ-Service-Spec.pdf)
for more details on the distinction between `relative` and `continuous`.

The card UI (e.g. PTZ controls) will always try to call the `continuous` variety
to allow for precise/smooth controls, and if unavailable will translate multiple
`relative` steps with optional delays between each step. Manually configured
[actions](../actions/README.md) may be configured to call either variety.

When PTZ actions are manually set in the config, they will replace the
auto-detected actions. For example if `actions_left` is set for a Frigate
camera, it will be used for all `left` PTZ actions even though Frigate cameras
natively support continuous actions (`actions_left_start`, `actions_left_stop`).

?> Frigate auto-detected PTZ actions will always be `continuous` as this is what
the integration currently offers.

### Parameters

| Option                                                                                                                                                                                                                                                                   | Default                                                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `actions_left`, `actions_right`, `actions_up`, `actions_down`, `actions_zoom_in`, `actions_zoom_out`, `actions_home`                                                                                                                                                     | Set by camera [engine](./engine.md) of the selected camera | The [perform-action](../actions/stock/README.md?id=perform-action) action that will be called for each PTZ action for relative movements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `actions_left_start`, `actions_left_stop`, `actions_right_start`, `actions_right_stop`,`actions_up_start`, `actions_up_stop`,`actions_down_start`, `actions_down_stop`,`actions_zoom_in_start`, `actions_zoom_in_stop`,`actions_zoom_out_start`, `actions_zoom_out_stop` | Set by camera [engine](./engine.md) of the selected camera | The [perform-action](../actions/stock/README.md?id=perform-action) action that will be called for each PTZ action for continous movements. Both a `_start` and `_stop` variety must be provided for an action to be usable.                                                                                                                                                                                                                                                                                                                                                                                             |
| `c2r_delay_between_calls_seconds`                                                                                                                                                                                                                                        | `0.2`                                                      | When the camera is configured with continuous actions only (e.g. `left_start` and `left_stop`, but not `left`), if something requests a relative action (e.g. a manually configured [action](../actions/README.md)), then `start` will be called, followed by a delay of this number of seconds and finally `stop` will be called. Cameras / integrations that are slower to respond to continuous steps may need to increase this value to avoid the continuous motion being too small. Cameras / integrations that are rapid to respond may need to decrease this value to avoid the "relative step" being too large. |
| `data_left`, `data_right`, `data_up`, `data_down`, `data_zoom_in`, `data_zoom_out`, `data_home`                                                                                                                                                                          |                                                            | Shorthand for relative actions that call the service defined by the `service` parameter, with the data provided in this argument. Internally, this is just translated into the longer-form `actions_[action]`. If both `actions_X` and `data_X` are specified, `actions_X` takes priority. This is compatible with [AlexxIT's WebRTC Card PTZ configuration](https://github.com/AlexxIT/WebRTC/wiki/PTZ-Config-Examples).                                                                                                                                                                                               |
| `data_left_start`, `data_left_stop`, `data_right_start`, `data_right_stop`, `data_up_start`, `data_up_stop`, `data_down_start`, `data_down_stop`, `data_zoom_in_start`, `data_zoom_in_stop`, `data_zoom_out_start`, `data_zoom_out_stop`                                 |                                                            | Shorthand for continuous actions that call the service defined by the `service` parameter, with the data provided in this argument. Internally, this is just translated into the longer-form `actions_[action]_start` and `actions_[action]_stop`. If both `actions_X_*` and `data_X_*` are specified, `actions_X_*` takes priority. This is compatible with [AlexxIT's WebRTC Card PTZ configuration](https://github.com/AlexxIT/WebRTC/wiki/PTZ-Config-Examples). Both a `_start` and `_stop` variety must be provided for an action to be usable.                                                                    |
| `presets`                                                                                                                                                                                                                                                                |                                                            | PTZ preset actions. See below.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `r2c_delay_between_calls_seconds`                                                                                                                                                                                                                                        | `0.5`                                                      | When the camera is configured with relative actions only (e.g. `left` but not `left_start` and `left_stop`), if something requests a continuous action (e.g. the card PTZ controls have a button held down), then a delay of this number of seconds will be inserted between each call of the relative action. Cameras / integrations that are slower to respond to relative steps may need to increase this value to avoid multiple simultaneous actions being sent. Cameras / integrations that are rapid to respond may need to decrease this value to increase the appearance of one single continuous motion.      |
| `service`                                                                                                                                                                                                                                                                |                                                            | An optional Home Assistant service to call when the `data_` parameters are used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |

### `presets`

Configures named PTZ presets. If a preset of this name is auto-detected, these configured actions will take precedence.

```yaml
cameras:
  - camera_entity: camera.office
    ptz:
      presets:
        [preset_name]:
          ? [action]
```

`[action]` is any [perform-action](../actions/stock/README.md?id=perform-action) action.

## `proxy`

Configures whether and how the content is proxied via
[hass-web-proxy-integration](https://github.com/dermotduffy/hass-web-proxy-integration)
(this must be installed separately). This allows fetching media **through** the
Home Assistant process itself, allowing the card to access resources it
otherwise would not be able to directly access. There are [security and
performance
implications](https://github.com/dermotduffy/hass-web-proxy-integration?tab=readme-ov-file#considerations)
to consider before installing
[hass-web-proxy-integration](https://github.com/dermotduffy/hass-web-proxy-integration)
and using this functionality.

```yaml
cameras:
  - camera_entity: camera.office
    proxy:
      # [...]
```

![Camera Proxying](../../images/proxy.png 'Camera Proxying :size=400')

Not all [engines](./engine.md) benefit from proxying:

| Engine                 | Purpose of proxying                                                                                                                                                                                                                                                                            |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `frigate`              | The Frigate integration already comes with a built-in proxy, so this functionality does not serve any purpose for `frigate`.                                                                                                                                                                   |
| `reolink`, `motioneye` | May be used to fetch videos in cases where the browser may not be able to access the camera/NVR, or the camera/NVR may use a self-signed SSL certificate that your browser would otherwise reject due to [mixed content](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content). |
| `generic`              | `generic` cameras do not have media, so proxying currently would serve no purpose.                                                                                                                                                                                                             |

Regardless of the parameters, the integration will never attempt to proxy
content if the
[hass-web-proxy-integration](https://github.com/dermotduffy/hass-web-proxy-integration)
is not detected.

Proxying parameters:

| Option             | Default | Description                                                                                                                                                                                                                                                                                                                      |
| ------------------ | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `media`            | `auto`  | Whether or not to proxy media items. `true` to proxy, `false` to not proxy, or `auto` to allow the camera engine to decide whether to proxy or not.                                                                                                                                                                              |
| `dynamic`          | `true`  | Whether to dynamically (at the time) request proxying of the required media item, or rely on statically user-configured pre-existing proxying. See the [hass-web-proxy-integration documentation](https://github.com/dermotduffy/hass-web-proxy-integration).                                                                    |
| `ssl_verification` | `auto`  | Whether to verify the validity of SSL certificates. If `true` always verifies, if `false` never verifies and if `auto` the [engine](./engine.md) decides the best setting for that camera ecosystem.                                                                                                                             |
| `ssl_ciphers`      | `auto`  | Whether to use `default`, `intermediate`, `insecure` or `modern` SSL ciphers. See the [Home Assistant code](https://github.com/home-assistant/core/blob/dev/homeassistant/util/ssl.py) for the precise list of SSL ciphers each implies. If `auto` the [engine](./engine.md) decides the best setting for that camera ecosystem. |

## `triggers`

The `triggers` block configures what triggers a camera. Triggering can be used
to activate an action (e.g. view a camera in live, reset the card to the default
view). See [`view.triggers`](../view.md?id=triggers) to control what happens when a
camera is triggered.

```yaml
cameras:
  - camera_entity: camera.office
    triggers:
      # [...]
```

| Option      | Default                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ----------- | ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `entities`  |                              | Whether to not to trigger the camera when the state of any Home Assistant entity becomes active (i.e. state becomes `on` or `open`). This works for Frigate or non-Frigate cameras.                                                                                                                                                                                                                                                                                                                                                                                                       |
| `events`    | `[events, clips, snapshots]` | Whether to trigger the camera when `events` occur (whether or not media is available) or whenever updated `clips` or `snapshots` are detected. Detection support varies by camera [engine](engine.md).                                                                                                                                                                                                                                                                                                                                                                                    |
| `motion`    | `false`                      | Whether to not to trigger the camera by automatically detecting and using the motion `binary_sensor` for this camera. This autodetection only works for Frigate cameras, and only when the motion `binary_sensor` entity has been enabled in Home Assistant.                                                                                                                                                                                                                                                                                                                              |
| `occupancy` | `false`                      | Whether to not to trigger the camera by automatically detecting and using the occupancy `binary_sensor` for this camera and its configured zones and labels. This autodetection only works for Frigate cameras, and only when the occupancy `binary_sensor` entity has been enabled in Home Assistant. If this camera has configured zones, only occupancy sensors for those zones are used -- if the overall _camera_ occupancy sensor is also required, it can be manually added to `entities`. If this camera has configured labels, only occupancy sensors for those labels are used. |

## Fully expanded reference

[](../common/expanded-warning.md ':include')

See [Engines](engine.md) and [Live Providers](live-provider.md) for other options nested under `cameras`.

```yaml
cameras:
  - camera_entity: camera.front_Door
    # Show events for camera-2 when this camera is viewed.
    dependencies:
      all_cameras: false
      cameras:
        - camera-2
    triggers:
      motion: false
      occupancy: true
      entities:
        - binary_sensor.front_door_sensor
    cast:
      method: standard
    dimensions:
      aspect_ratio: 16:9
      layout:
        fit: contain
        position:
          x: 50
          y: 50
    always_error_if_entity_unavailable: false
  - camera_entity: camera.entrance
    icon: 'mdi:car'
    title: 'Front entrance'
    # Custom identifier for the camera to refer to it above.
    id: 'camera-2'
    triggers:
      motion: false
      occupancy: true
      entities:
        - binary_sensor.entrance_sensor
    dependencies:
      all_cameras: false
  - camera_entity: camera.zoomed
    dimensions:
      layout:
        zoom: 2.0
        pan:
          x: 50
          y: 50
  - camera_entity: camera.manual-ptz
    ptz:
      c2r_delay_between_calls_seconds: 0.2
      r2c_delay_between_calls_seconds: 0.5
      # Relative action (only `left` shown)
      actions_left:
        action: perform-action
        perform_action: service.of_your_choice
        data:
          device: '048123'
          cmd: left
      # Continuous action (only `right` shown)
      actions_right_start:
        action: perform-action
        perform_action: service.of_your_choice
        data:
          device: '048123'
          cmd: right
          phase: start
      actions_right_stop:
        action: perform-action
        perform_action: service.of_your_choice
        data:
          device: '048123'
          phase: stop
      # Equivalent relative short form (only `up` shown)
      service: service.send_command
      data_up:
        device: '048123'
        cmd: up
      # Equivalent continuous short form (only `down` shown)
      service: service.send_command
      data_up_start:
        device: '048123'
        cmd: down
        phase: start
      data_up_stop:
        device: '048123'
        cmd: down
        phase: stop
      presets:
        # Preset using long form.
        armchair:
        action: perform-action
        perform_action: service.of_your_choice
          data:
            device: '048123'
            cmd: preset
            preset: armchair
        # Preset using short form.
        service: service.of_your_choice
        window:
          device: '048123'
          cmd: preset
          preset: window
  - camera_entity: camera.needs_proxy
    proxy:
      media: auto
      dynamic: true
      ssl_verification: auto
      ssl_ciphers: auto
  - camera_entity: camera.capabilities_reference
    capabilities:
      disable_except:
        - clips
        - favorite-events
        - favorite-recordings
        - live
        - menu
        - ptz
        - recordings
        - seek
        - snapshots
        - substream
        - trigger
      disable:
        # Capabilities to selectively disable.
cameras_global:
  triggers:
    motion: false
```



================================================
FILE: docs/configuration/cameras/_sidebar.md
================================================
- [Getting Started](../../README.md)
- [Configuration](../README.md)
  - [`actions`](../actions/README.md)
  - [`automations`](../automations.md)
  - [`cameras`](README.md)
    - [`live_provider`](live-provider.md)
    - [`engine`](engine.md)
  - [`conditions`](../conditions.md)
  - [`dimensions`](../dimensions.md)
  - [`folders`](../folders.md)
  - [`elements`](../elements/README.md)
  - [`image`](../image.md)
  - [`live`](../live.md)
  - [`media_gallery`](../media-gallery.md)
  - [`media_viewer`](../media-viewer.md)
  - [`menu`](../menu.md)
  - [`overrides`](../overrides.md)
  - [`performance`](../performance.md)
  - [`profiles`](../profiles.md)
  - [`remote_control`](../remote-control.md)
  - [`status_bar`](../status-bar.md)
  - [`timeline`](../timeline.md)
  - [`view`](../view.md)
  - [Templates](../templates.md)
- [Examples](../../examples.md)
- [Screenshots](../../screenshots.md)
- [Troubleshooting](../../troubleshooting.md)
- [Usage](../../usage/README.md)

---

- [Developing](../../developing.md)



================================================
FILE: docs/configuration/cameras/engine.md
================================================
# `engine`

## Overview

A "Camera Engine" defines what "type" of camera is being configured (e.g. `frigate`), each engine offers different capabilities:

| Engine      | Live               | Supports clips           | Supports Snapshots       | Supports Recordings      | Supports Timeline        | Supports PTZ out of the box | Supports manually configured PTZ | Favorite events          | Favorite recordings      | Detect new events        | Detect new snapshots     | Detect new clips         | May requiring [proxying](./README.md?id=proxy) | Thumbnails               |
| ----------- | ------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | --------------------------- | -------------------------------- | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ---------------------------------------------- | ------------------------ |
| `frigate`   | :white_check_mark: | :white_check_mark:       | :white_check_mark:       | :white_check_mark:       | :white_check_mark:       | :white_check_mark:          | :white_check_mark:               | :white_check_mark:       | :heavy_multiplication_x: | :white_check_mark:       | :white_check_mark:       | :white_check_mark:       | :heavy_multiplication_x:                       | :white_check_mark:       |
| `generic`   | :white_check_mark: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x:    | :white_check_mark:               | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x:                       | :heavy_multiplication_x: |
| `motioneye` | :white_check_mark: | :white_check_mark:       | :white_check_mark:       | :heavy_multiplication_x: | :white_check_mark:       | :heavy_multiplication_x:    | :white_check_mark:               | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :white_check_mark:                             | :white_check_mark:       |
| `reolink`   | :white_check_mark: | :white_check_mark:       | :heavy_multiplication_x: | :heavy_multiplication_x: | :white_check_mark:       | :eight_spoked_asterisk:     | :white_check_mark:               | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :white_check_mark:                             | :heavy_multiplication_x: |

### Live providers supported per Engine

| Engine / Live Provider | `ha`               | `image`            | `jsmpeg`                 | `go2rtc`           | `webrtc-card`            |
| ---------------------- | ------------------ | ------------------ | ------------------------ | ------------------ | ------------------------ |
| `frigate`              | :white_check_mark: | :white_check_mark: | :white_check_mark:       | :white_check_mark: | :white_check_mark:       |
| `generic`              | :white_check_mark: | :white_check_mark: | :heavy_multiplication_x: | :white_check_mark: | :white_check_mark:       |
| `motioneye`            | :white_check_mark: | :white_check_mark: | :heavy_multiplication_x: | :white_check_mark: | :heavy_multiplication_x: |
| `reolink`              | :white_check_mark: | :white_check_mark: | :heavy_multiplication_x: | :white_check_mark: | :heavy_multiplication_x: |

See [Live Provider Configuration](live-provider.md) for more details on live providers.

## `frigate`

The `frigate` block configures options for a Frigate camera.

```yaml
cameras:
  - camera_entity: camera.office
    frigate:
      # [...]
```

| Option        | Default                                                 | Description                                                                                                                                                                                                                                                                                                                                                       |
| ------------- | ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `camera_name` | Autodetected from `camera_entity` if that is specified. | The Frigate camera name to use when communicating with the Frigate server, e.g. for viewing clips/snapshots or the JSMPEG live view.                                                                                                                                                                                                                              |
| `client_id`   | `frigate`                                               | The Frigate client id to use. If this Home Assistant server has multiple Frigate server backends configured, this selects which server should be used. It should be set to the MQTT client id configured for this server, see [Frigate Integration Multiple Instance Support](https://docs.frigate.video/integrations/home-assistant/#multiple-instance-support). |
| `labels`      |                                                         | A list of Frigate labels used to filter events (clips & snapshots), e.g. [`person`, `car`].                                                                                                                                                                                                                                                                       |
| `url`         |                                                         | The URL of the frigate server. If set, this value will be (exclusively) used for a `Camera UI` menu button. All other communication with Frigate goes via Home Assistant.                                                                                                                                                                                         |
| `zones`       |                                                         | A list of Frigates zones used to filter events (clips & snapshots), e.g. [`front_door`, `front_steps`].                                                                                                                                                                                                                                                           |

## `motioneye`

The `motioneye` block configures options for a MotionEye camera.

```yaml
cameras:
  - camera_entity: camera.office
    motioneye:
      # [...]
```

| Option   | Default | Description                                                                                                   |
| -------- | ------- | ------------------------------------------------------------------------------------------------------------- |
| `images` |         | Configure how MotionEye images are consumed. See below.                                                       |
| `movies` |         | Configure how MotionEye movies are consumed. See below.                                                       |
| `url`    |         | The URL of the MotionEye server. If set, this value will be (exclusively) used for a `Camera UI` menu button. |

### `images` / `movies`

The `images` and `movies` block configures how images and movies respectively are fetched from motionEye. The options for both blocks are the same.

```yaml
cameras:
  - camera_entity: camera.office
    motioneye:
      images:
        # [...]
```

```yaml
cameras:
  - camera_entity: camera.office
    motioneye:
      movies:
        # [...]
```

| Option              | Default    | Description                                                                                                                                                                                                                                                                                                                               |
| ------------------- | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `directory_pattern` | `%Y-%m-%d` | The directory that motionEye is configured to store media into. May contain multiple sub-directories separated by `/`. Path must encode the date of the media using MotionEye patterns such as `%Y`, `%m`, `%d`, `%H`, `%M`, `%S` (at least one pattern is required). Consult MotionEye help text for information on these substitutions. |
| `file_pattern`      | `%H-%M-%S` | Within a directory (as matched by `directory_pattern`) the media items must exist and match this pattern. `file_pattern` must encode the time of the media using MotionEye patterns such as `%Y`, `%m`, `%d`, `%H`, `%M`, `%S` (at least one pattern is required). Consult MotionEye help text for information on these substitutions.    |

## `reolink`

[](../common/experimental-warning.md ':include')

The `reolink` block configures options for a Reolink camera.

```yaml
cameras:
  - camera_entity: camera.office
    reolink:
      # [...]
```

| Option             | Default                                     | Description                                                                                                                                                                                                                                                                                                                                                         |
| ------------------ | ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `channel`          | autodetected (direct), or `0` (via NVR/Hub) | The channel number for the Reolink camera, used by the Reolink integration to identify different cameras. For cameras directly connected to Home Assistant (w/o an NVR), this value will be autodetected and need not be set. For cameras connected via a Hub/NVR, this value cannot currently be autodetected -- a default value of `0` will be used in this case. |
| `media_resolution` | `low`                                       | Whether to retrieve `high` or `low` resolution media items.                                                                                                                                                                                                                                                                                                         |
| `url`              |                                             | The URL of the Reolink camera/NVR UI. If set, this value will be (exclusively) used for a `Camera UI` menu button.                                                                                                                                                                                                                                                  |

?> If media for the "wrong" Reolink camera is showing up and you have an NVR connected camera, your `channel` value is likely incorrect. Try increasing it until you find the correct camera.

### PTZ Support

Zero-configuration PTZ support is available for Reolink if your camera supports it.

!> For Home Assistant control of Reolink camera PTZ functions, the relevent `button` entities must be enabled. To verify, navigate to `Settings -> Devices & services -> Reolink -> [Choose Device]`, and ensure the `PTZ` entities are enabled. Disabled entities are shown under the `+X disabled entities` label. :eight_spoked_asterisk:

## Fully expanded reference

[](../common/expanded-warning.md ':include')

```yaml
cameras:
  - camera_entity: camera.office_auto
    engine: auto
  - camera_entity: camera.office_frigate
    frigate:
      url: http://my.frigate.local
      client_id: frigate
      camera_name: front_door
      labels:
        - person
      zones:
        - steps
  - camera_entity: camera.office_motioneye
    motioneye:
      images:
        directory_pattern: '%Y-%m-%d'
        file_pattern: '%H-%M-%S'
      movies:
        directory_pattern: '%Y-%m-%d'
        file_pattern: '%H-%M-%S'
  - camera_entity: camera.office_generic
    engine: generic
  - camera_entity: camera.office_reolink
    reolink:
      url: http://my.reolink.local
      media_resolution: low
```



================================================
FILE: docs/configuration/cameras/live-provider.md
================================================
# `live_provider`

## Overview

The `live_provider` parameter determines what provides the live stream for a camera. Each provider offers different capabilities:

| Live Provider                      | Latency | Frame Rate | Loading Time | Installation                   | Description                                                                                                                                                                                                     |
| ---------------------------------- | ------- | ---------- | ------------ | ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `go2rtc`                           | Best    | High       | Better       | Builtin                        | Uses [go2rtc](https://github.com/AlexxIT/go2rtc) to stream live feeds. This is supported by Frigate &gt;= `0.12`.                                                                                               |
| `ha` (default HA configuration)    | Poor    | High       | Better       | Builtin                        | Use the built-in Home Assistant camera stream.                                                                                                                                                                  |
| `ha` (Native WebRTC)               | Best    | High       | Better       | Builtin                        | Use the built-in Home Assistant camera streams -- can be configured to use [native WebRTC](https://www.home-assistant.io/integrations/rtsp_to_webrtc/) offering a very low-latency feed direct to your browser. |
| `ha` (when configured with LL-HLS) | Better  | High       | Better       | Builtin                        | Use the built-in Home Assistant camera streams -- can be configured to use an [LL-HLS](https://www.home-assistant.io/integrations/stream/#ll-hls) feed for lower latency.                                       |
| `image`                            | Poor    | Poor       | Best         | Builtin                        | Use refreshing snapshots of the built-in Home Assistant camera streams.                                                                                                                                         |
| `jsmpeg`                           | Better  | Low        | Poor         | Builtin                        | Use a the JSMPEG stream.                                                                                                                                                                                        |
| `webrtc-card`                      | Best    | High       | Better       | Separate installation required | Embed's [AlexxIT's WebRTC Card](https://github.com/AlexxIT/WebRTC) to stream live feed, requires manual extra setup. See below. Not to be confused with native Home Assistant WebRTC (use the `ha` provider).   |

## `go2rtc`

The `go2rtc` block configures use of the `go2rtc` live provider. This configuration is included as part of a camera entry in the `cameras` list.

```yaml
cameras:
  - camera_entity: camera.office
    live_provider: go2rtc
    go2rtc:
      # [...]
```

| Option   | Default                                                                                                                                              | Description                                                                                                                                                                      |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `modes`  | `[webrtc, mse, mp4, mjpeg]`                                                                                                                          | An ordered list of `go2rtc` modes to use. Valid values are `webrtc`, `mse`, `mp4` or `mjpeg` values.                                                                             |
| `stream` | Determined by camera engine (e.g. `frigate` camera name).                                                                                            | A valid `go2rtc` stream name.                                                                                                                                                    |
| `url`    | Determined by camera engine (e.g. the `frigate` engine will automatically generate a URL for the go2rtc backend that runs in the Frigate container). | The root `go2rtc` URL the card should stream the video from. This is only needed for non-Frigate usecases, or advanced Frigate usecases. Example: `http://my-custom-go2rtc:1984` |

## `image`

All configuration is under:

```yaml
cameras:
  - camera_entity: camera.office
    live_provider: image
    image:
      # [...]
```

| Option              | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `entity`            |         | The entity to use when `mode` is set to `entity`. This entity is expected to have an `entity_picture` attribute that specifies the image URL.                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `entity_parameters` |         | Optional URL parameters to add to the URL generated for entity-based modes (i.e. when `mode` is `camera` or `entity`).                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `mode`              | `auto`  | Value must be one of `url` (to fetch an arbitrary image URL), `camera` (to show a still of the currently selected camera entity using either `camera_entity` or `webrtc_card.entity` in that order of precedence), `entity` to show an image associated with a named entity (see the `entity` parameter below), or `screensaver` (to show an [embedded image](https://github.com/dermotduffy/advanced-camera-card/blob/main/src/images/iris-screensaver.jpg)). If `auto`, the mode is chosen automatically based on whether `url` or `entity` parameters have been specified. |
| `refresh_seconds`   | 1       | The image will be refreshed at least every `refresh_seconds` (it may refresh more frequently, e.g. whenever Home Assistant updates its camera security token). `0` implies no refreshing.                                                                                                                                                                                                                                                                                                                                                                                     |
| `url`               |         | A static image URL to be used when the `mode` is set to `url` or when a temporary image is required (e.g. may appear momentarily prior to load of a camera snapshot in the `camera` mode). Note that a `_t=[timestsamp]` query parameter will be automatically added to all URLs such that the image will not be cached by the browser.                                                                                                                                                                                                                                       |

## `jsmpeg`

All configuration is under:

```yaml
cameras:
  - camera_entity: camera.office
    live_provider: jsmpeg
    jsmpeg:
      # [...]
```

| Option    | Default | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `options` |         | **Advanced users only**: Control the underlying [JSMPEG library options](https://github.com/phoboslab/jsmpeg#usage). Supports setting these JSMPEG options `{audio, video, pauseWhenHidden, disableGl, disableWebAssembly, preserveDrawingBuffer, progressive, throttled, chunkSize, maxAudioLag, videoBufferSize, audioBufferSize}`. This is not necessary for the vast majority of users: only set these flags if you know what you're doing, as you may entirely break video rendering in the card. |

## `webrtc_card`

WebRTC Card support blends the use of the ultra-realtime [WebRTC card live
view](https://github.com/AlexxIT/WebRTC) with convenient access to Frigate
events/snapshots/UI. AlexxIT's WebRTC Integration/Card must be installed and configured separately (see [details](https://github.com/AlexxIT/WebRTC)) before it can be used with this card.

?> The `webrtc_card` default configuration disables the WebRTC card's `intersection` parameter (which auto-stops the media when a certain fraction of the video is no longer visible), since it interferes with the card pan & zoom. Instead, see the [`auto_pause`](../live.md) parameter.

```yaml
cameras:
  - camera_entity: camera.office
    live_provider: webrtc-card
    webrtc_card:
      # [...]
```

| Option   | Default                                                                                                                                                                                                             | Description                                                                                                                                                                                                                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `entity` |                                                                                                                                                                                                                     | The RTSP camera entity to pass to the WebRTC Card for this camera.                                                                                                                                                                                                                              |
| `url`    | Depends on the camera engine (e.g. Frigate cameras will automatically use the camera name since this is the [recommended setup](https://deploy-preview-4055--frigate-docs.netlify.app/guides/configuring_go2rtc/)). | The RTSP url to pass to the WebRTC Card, e.g. `rtsp://USERNAME:PASSWORD@CAMERA:554/RTSP_PATH`                                                                                                                                                                                                   |
| `*`      |                                                                                                                                                                                                                     | Any options specified in the `webrtc_card:` YAML dictionary are silently passed through to the AlexxIT's WebRTC Card. See [WebRTC Configuration](https://github.com/AlexxIT/WebRTC#configuration) for full details this external card provides, e.g. `ui: true` will enable the WebRTC Card UI. |

## Fully expanded reference

[](../common/expanded-warning.md ':include')

```yaml
cameras:
  - camera_entity: camera.office_ha
    live_provider: ha
  - camera_entity: camera.office_webrtc_card
    live_provider: webrtc-card
    webrtc_card:
      entity: camera.office_rtsp
      url: 'rtsp://username:password@camera:554/av_stream/ch0'
      # Arbitrary WebRTC Card options, see https://github.com/AlexxIT/WebRTC#configuration .
      ui: true
  - camera_entity: camera.office_go2rtc
    live_provider: go2rtc
    go2rtc:
      modes:
        - webrtc
        - mse
        - mp4
        - mjpeg
      stream: sitting_room
      url: 'https://my.custom.go2rtc.backend'
  - camera_entity: camera.office_jsmpeg
    live_provider: jsmpeg
    jsmpeg:
      options:
        audio: false
        video: true
        pauseWhenHidden: false
        disableGl: false
        disableWebAssembly: false
        preserveDrawingBuffer: false
        progressive: true
        throttled: true
        chunkSize: 1048576
        maxAudioLag: 10
        videoBufferSize: 524288
        audioBufferSize: 131072
  - camera_entity: camera.office_image
    live_provider: image
    image:
      mode: auto
      refresh_seconds: 1
      url: 'https://path/to/image.png'
      entity: image.office_person
      entity_parameters: 'width=400&height=200'
cameras_global:
  live_provider: go2rtc
```



================================================
FILE: docs/configuration/common/expanded-warning.md
================================================
!> Just copying this full reference into your configuration will cause you a significant maintenance burden. Don't do it! Only specify what you need, everything shown here are either default or illustrative values.



================================================
FILE: docs/configuration/common/experimental-warning.md
================================================
!> This functionality is experimental. It may be broken, slow or change without warning or major version number change.



================================================
FILE: docs/configuration/common/timeline-seek-info.md
================================================
?> For optimal UX, keep the settings for the mini-timeline in the `live` and
`media_viewer` identical. Dragging the timeline may cause the card to change
between the `live` view and `media_viewer` based views as the user pans between
the past and present -- if the settings are different the timeline must "reset".



================================================
FILE: docs/configuration/elements/README.md
================================================
# `elements`

## Introduction to elements <!-- {docsify-ignore} -->

This card supports the [Picture Elements configuration
syntax](https://www.home-assistant.io/lovelace/picture-elements/) to seamlessly
allow the user to add custom elements to the card.

```yaml
elements:
  - [element_1]
  - [element_2]
```

?> The Advanced Camera Card allows either a single [action](../actions/README.md) (as in stock Home
Assistant) or list of [actions](../actions/README.md) to be defined for each class of user interaction
(e.g. `tap`, `double_tap`, `hold`, etc). See [an example of multiple actions](../../examples.md?id=multiple-actions).

## Elements <!-- {docsify-ignore} -->

| Option                                | Description                       |
| ------------------------------------- | --------------------------------- |
| [Custom Elements](./custom/README.md) | Custom elements.                  |
| [Stock Elements](./stock/README.md)   | Standard Home Assistant elements. |



================================================
FILE: docs/configuration/elements/_sidebar.md
================================================
- [Getting Started](../../README.md)
- [Configuration](../README.md)
  - [`actions`](../actions/README.md)
  - [`automations`](../automations.md)
  - [`cameras`](../cameras/README.md)
  - [`conditions`](../conditions.md)
  - [`dimensions`](../dimensions.md)
  - [`elements`](README.md)
    - [Custom Elements](./custom/README.md)
    - [Stock Elements](./stock/README.md)
  - [`folders`](../folders.md)
  - [`image`](../image.md)
  - [`live`](../live.md)
  - [`media_gallery`](../media-gallery.md)
  - [`media_viewer`](../media-viewer.md)
  - [`menu`](../menu.md)
  - [`overrides`](../overrides.md)
  - [`performance`](../performance.md)
  - [`profiles`](../profiles.md)
  - [`remote_control`](../remote-control.md)
  - [`status_bar`](../status-bar.md)
  - [`timeline`](../timeline.md)
  - [`view`](../view.md)
  - [Templates](../templates.md)
- [Examples](../../examples.md)
- [Screenshots](../../screenshots.md)
- [Troubleshooting](../../troubleshooting.md)
- [Usage](../../usage/README.md)

---

- [Developing](../../developing.md)



================================================
FILE: docs/configuration/elements/custom/README.md
================================================
# Custom Elements

## `conditional`

Restrict a set of elements to only render when the card is matches a set of [conditions](../../conditions.md). This is analogous to the stock [`conditional`](../stock/README.md?id=conditional) element except supporting a rich set of Advanced Camera Card [conditions](../../conditions.md).

```yaml
elements:
  - type: custom:advanced-camera-card-conditional
    # [...]
```

Parameters for the `custom:advanced-camera-card-conditional` element:

| Parameter    | Description                                                                                                      |
| ------------ | ---------------------------------------------------------------------------------------------------------------- |
| `type`       | Must be `custom:advanced-camera-card-conditional`.                                                               |
| `conditions` | A list of [conditions](../../conditions.md) that must evaluate to true in order for the elements to be rendered. |
| `elements`   | The elements to render. Can be any supported element.                                                            |

See the [conditional elements example](../../../examples.md?id=conditional-elements).

## `menu-icon`

Add an arbitrary icon to the Advanced Camera Card menu.

```yaml
elements:
  - type: custom:advanced-camera-card-menu-icon
    # [...]
```

Configuration is similar to a stock [Picture Elements Icon](https://www.home-assistant.io/lovelace/picture-elements/#icon-element).

| Parameter                                                                | Default    | Description                                                                                                                                                                                                                                                                                                                  |
| ------------------------------------------------------------------------ | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`                                                                   |            | Must be `custom:advanced-camera-card-menu-icon`.                                                                                                                                                                                                                                                                             |
| `alignment`                                                              | `matching` | Whether this menu item should have an alignment that is `matching` the menu alignment or `opposing` the menu alignment. Can be used to create two separate groups of buttons on the menu. The `priority` option orders buttons within a given `alignment`.                                                                   |
| `enabled`                                                                | `true`     | Whether or not to show this menu item.                                                                                                                                                                                                                                                                                       |
| `entity`                                                                 |            | An optional Home Assistant entity for use with actions.                                                                                                                                                                                                                                                                      |
| `icon`                                                                   |            | An required icon to display, e.g. `mdi:car`. See also [custom icons](../../../usage/custom-icons.md).                                                                                                                                                                                                                        |
| `permanent`                                                              | `false`    | If `false` the menu item is hidden when the menu has the `hidden` style and the menu is closed, otherwise it is shown (and sorted to the front).                                                                                                                                                                             |
| `priority`                                                               | `50`       | The menu item priority. Higher priority items are ordered closer to the start of the menu alignment (i.e. a button with priority `70` will order further to the left than a button with priority `60`). Priority applies separately to `matching` and `opposing` groups (see `alignment` above). Minimum `0`, maximum `100`. |
| `style`                                                                  |            | Position and style the element using CSS.                                                                                                                                                                                                                                                                                    |
| `tap_action`, `double_tap_action`, `hold_action`, `start_tap`, `end_tap` |            | The [actions](../../actions/README.md) to take when this item is interacted with.                                                                                                                                                                                                                                            |
| `title`                                                                  |            | An optional title to display.                                                                                                                                                                                                                                                                                                |

## `menu-submenu`

Add a configurable submenu dropdown.

```yaml
elements:
  - type: custom:advanced-camera-card-menu-submenu
    # [...]
```

| Parameter                                                                | Default    | Description                                                                                                                                                                                                                                                                                                                  |
| ------------------------------------------------------------------------ | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`                                                                   |            | Must be `custom:advanced-camera-card-menu-submenu`.                                                                                                                                                                                                                                                                          |
| `alignment`                                                              | `matching` | Whether this menu item should have an alignment that is `matching` the menu alignment or `opposing` the menu alignment. Can be used to create two separate groups of buttons on the menu. The `priority` option orders buttons within a given `alignment`.                                                                   |
| `enabled`                                                                | `true`     | Whether or not to show this menu item.                                                                                                                                                                                                                                                                                       |
| `entity`                                                                 |            | An optional Home Assistant entity for use with actions.                                                                                                                                                                                                                                                                      |
| `icon`                                                                   |            | An required icon to display, e.g. `mdi:car`. See also [custom icons](../../../usage/custom-icons.md).                                                                                                                                                                                                                        |
| `items`                                                                  |            | A list of menu items, as described below.                                                                                                                                                                                                                                                                                    |
| `permanent`                                                              | `false`    | If `false` the menu item is hidden when the menu has the `hidden` style and the menu is closed, otherwise it is shown (and sorted to the front).                                                                                                                                                                             |
| `priority`                                                               | `50`       | The menu item priority. Higher priority items are ordered closer to the start of the menu alignment (i.e. a button with priority `70` will order further to the left than a button with priority `60`). Priority applies separately to `matching` and `opposing` groups (see `alignment` above). Minimum `0`, maximum `100`. |
| `style`                                                                  |            | Position and style the element using CSS.                                                                                                                                                                                                                                                                                    |
| `tap_action`, `double_tap_action`, `hold_action`, `start_tap`, `end_tap` |            | The [actions](../../actions/README.md) to take when this item is interacted with.                                                                                                                                                                                                                                            |
| `title`                                                                  |            | An optional title to display.                                                                                                                                                                                                                                                                                                |

### Submenu items

| Parameter                                                                | Default | Description                                                                                                |
| ------------------------------------------------------------------------ | ------- | ---------------------------------------------------------------------------------------------------------- |
| `enabled`                                                                | `true`  | Whether or not to show this item as enabled / selectable.                                                  |
| `entity`                                                                 |         | An optional Home Assistant entity from which title, icon and style can be automatically computed.          |
| `icon`                                                                   |         | An optional item icon to display, e.g. `mdi:car`. See also [custom icons](../../../usage/custom-icons.md). |
| `selected`                                                               | `false` | Whether or not to show this item as selected.                                                              |
| `state_color`                                                            | `true`  | Whether or not the title and icon should be stylized based on state.                                       |
| `style`                                                                  |         | Position and style the element using CSS.                                                                  |
| `tap_action`, `double_tap_action`, `hold_action`, `start_tap`, `end_tap` |         | The [actions](../../actions/README.md) to take when this item is interacted with.                          |
| `title`                                                                  |         | An optional title to display.                                                                              |

## `menu-submenu-select`

Add a submenu based on a `select` or `input_select`. This element allows you to convert a [Home Assistant Select Entity](https://www.home-assistant.io/integrations/select/) or [Home Assistant Input Select Entity](https://www.home-assistant.io/integrations/input_select/) (an entity either starting with `select` or `input_select`) into an overridable submenu. This _could_ be done by hand using a regular submenu (above) -- this element is a convenience.

```yaml
elements:
  - type: custom:advanced-camera-card-menu-submenu-select
    # [...]
```

| Parameter                                                                | Default    | Description                                                                                                                                                                                                                                                                                                                  |
| ------------------------------------------------------------------------ | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`                                                                   |            | Must be `custom:advanced-camera-card-menu-submenu-select`.                                                                                                                                                                                                                                                                   |
| `alignment`                                                              | `matching` | Whether this menu item should have an alignment that is `matching` the menu alignment or `opposing` the menu alignment. Can be used to create two separate groups of buttons on the menu. The `priority` option orders buttons within a given `alignment`.                                                                   |
| `enabled`                                                                | `true`     | Whether or not to show this menu item.                                                                                                                                                                                                                                                                                       |
| `entity`                                                                 |            | An optional Home Assistant entity for use with actions.                                                                                                                                                                                                                                                                      |
| `icon`                                                                   |            | An required icon to display, e.g. `mdi:car`. See also [custom icons](../../../usage/custom-icons.md).                                                                                                                                                                                                                        |
| `options`                                                                |            | An optional dictionary of overrides keyed by the option name that the given select entity supports. These options can be used to set or override submenu item parameters on a per-option basis. The format is as described in [Submenu Items](./README.md?id=submenu-items) above.                                           |
| `permanent`                                                              | `false`    | If `false` the menu item is hidden when the menu has the `hidden` style and the menu is closed, otherwise it is shown (and sorted to the front).                                                                                                                                                                             |
| `priority`                                                               | `50`       | The menu item priority. Higher priority items are ordered closer to the start of the menu alignment (i.e. a button with priority `70` will order further to the left than a button with priority `60`). Priority applies separately to `matching` and `opposing` groups (see `alignment` above). Minimum `0`, maximum `100`. |
| `style`                                                                  |            | Position and style the element using CSS.                                                                                                                                                                                                                                                                                    |
| `tap_action`, `double_tap_action`, `hold_action`, `start_tap`, `end_tap` |            | The [actions](../../actions/README.md) to take when this item is interacted with.                                                                                                                                                                                                                                            |
| `title`                                                                  |            | An optional title to display.                                                                                                                                                                                                                                                                                                |

See the `select` [submenu example](../../../examples.md?id=select-submenu).

## `menu-state-icon`

Add a state icon to the Advanced Camera Card menu that represents the state of a Home Assistant entity.

```yaml
elements:
  - type: custom:advanced-camera-card-menu-state-icon
    # [...]
```

Configuration is similar to a stock [Picture Elements State Icon](https://www.home-assistant.io/lovelace/picture-elements/#state-icon).

| Parameter                                                                | Default    | Description                                                                                                                                                                                                                                                                                                                  |
| ------------------------------------------------------------------------ | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`                                                                   |            | Must be `custom:advanced-camera-card-menu-state-icon`.                                                                                                                                                                                                                                                                       |
| `alignment`                                                              | `matching` | Whether this menu item should have an alignment that is `matching` the menu alignment or `opposing` the menu alignment. Can be used to create two separate groups of buttons on the menu. The `priority` option orders buttons within a given `alignment`.                                                                   |
| `enabled`                                                                | `true`     | Whether or not to show this menu item.                                                                                                                                                                                                                                                                                       |
| `entity`                                                                 |            | An optional Home Assistant entity for use with actions.                                                                                                                                                                                                                                                                      |
| `icon`                                                                   |            | An required icon to display, e.g. `mdi:car`. See also [custom icons](../../../usage/custom-icons.md).                                                                                                                                                                                                                        |
| `permanent`                                                              | `false`    | If `false` the menu item is hidden when the menu has the `hidden` style and the menu is closed, otherwise it is shown (and sorted to the front).                                                                                                                                                                             |
| `priority`                                                               | `50`       | The menu item priority. Higher priority items are ordered closer to the start of the menu alignment (i.e. a button with priority `70` will order further to the left than a button with priority `60`). Priority applies separately to `matching` and `opposing` groups (see `alignment` above). Minimum `0`, maximum `100`. |
| `tap_action`, `double_tap_action`, `hold_action`, `start_tap`, `end_tap` |            | The [actions](../../actions/README.md) to take when this item is interacted with.                                                                                                                                                                                                                                            |
| `state_color`                                                            | `true`     | Set to true to have icons colored when entity is active.                                                                                                                                                                                                                                                                     |
| `style`                                                                  |            | Position and style the element using CSS.                                                                                                                                                                                                                                                                                    |
| `title`                                                                  |            | An optional title to display.                                                                                                                                                                                                                                                                                                |

## `status-bar-icon`

Add an arbitrary icon to the status bar.

```yaml
elements:
  - type: custom:advanced-camera-card-status-bar-icon
    # [...]
```

| Parameter    | Default | Description                                                                                                                                                                                                              |
| ------------ | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `type`       |         | Must be `custom:advanced-camera-card-status-bar-icon`.                                                                                                                                                                   |
| `actions`    |         | Actions to performs when the status bar item is interacted with. See [actions](../../actions/README.md).                                                                                                                 |
| `enabled`    | `true`  | `true` to enable this status bar item, `false` to disable.                                                                                                                                                               |
| `exclusive`  | `false` | Whether or not this item should evict non-exclusive items from the status bar.                                                                                                                                           |
| `expand`     | `false` | If `false` this status bar item will consume the minimum possible space, if `true` will expand to the available space.                                                                                                   |
| `icon`       |         | The icon to show in the status bar, e.g. `mdi:camera-front`. See also [custom icons](../../../usage/custom-icons.md).                                                                                                    |
| `priority`   | `50`    | The item priority. Higher priority items are ordered closer to the start of the status bar (i.e. an item with priority `70` will order further to the left than an item with priority `60`). Minimum `0`, maximum `100`. |
| `sufficient` | `false` | Whether or not this item is sufficient to display the status bar if it's otherwise hidden (e.g. with the `popup` [status bar style](../../status-bar.md)).                                                               |

## `status-bar-image`

Add an arbitrary image to the status bar.

```yaml
elements:
  - type: custom:advanced-camera-card-status-bar-image
    # [...]
```

| Parameter    | Default | Description                                                                                                                                                                                                              |
| ------------ | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `type`       |         | Must be `custom:advanced-camera-card-status-bar-image`.                                                                                                                                                                  |
| `actions`    |         | Actions to performs when the status bar item is interacted with. See [actions](../../actions/README.md).                                                                                                                 |
| `enabled`    | `true`  | `true` to enable this status bar item, `false` to disable.                                                                                                                                                               |
| `exclusive`  | `false` | Whether or not this item should evict non-exclusive items from the status bar.                                                                                                                                           |
| `expand`     | `false` | If `false` this status bar item will consume the minimum possible space, if `true` will expand to the available space.                                                                                                   |
| `image`      |         | The image to show in the status bar, e.g. `https://my.site.com/status.png`.                                                                                                                                              |
| `priority`   | `50`    | The item priority. Higher priority items are ordered closer to the start of the status bar (i.e. an item with priority `70` will order further to the left than an item with priority `60`). Minimum `0`, maximum `100`. |
| `sufficient` | `false` | Whether or not this item is sufficient to display the status bar if it's otherwise hidden (e.g. with the `popup` [status bar style](../../status-bar.md)).                                                               |

## `status-bar-string`

Add an arbitrary string to the status bar.

```yaml
elements:
  - type: custom:advanced-camera-card-status-bar-string
    # [...]
```

| Parameter    | Default | Description                                                                                                                                                                                                              |
| ------------ | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `type`       |         | Must be `custom:advanced-camera-card-status-bar-string`.                                                                                                                                                                 |
| `actions`    |         | Actions to performs when the status bar item is interacted with. See [actions](../../actions/README.md).                                                                                                                 |
| `enabled`    | `true`  | `true` to enable this status bar item, `false` to disable.                                                                                                                                                               |
| `exclusive`  | `false` | Whether or not this item should evict non-exclusive items from the status bar.                                                                                                                                           |
| `expand`     | `false` | If `false` this status bar item will consume the minimum possible space, if `true` will expand to the available space.                                                                                                   |
| `string`     |         | The string to show in the status bar, e.g. `Intruder detected!`                                                                                                                                                          |
| `priority`   | `50`    | The item priority. Higher priority items are ordered closer to the start of the status bar (i.e. an item with priority `70` will order further to the left than an item with priority `60`). Minimum `0`, maximum `100`. |
| `sufficient` | `false` | Whether or not this item is sufficient to display the status bar if it's otherwise hidden (e.g. with the `popup` [status bar style](../../status-bar.md)).                                                               |

## Fully expanded reference

?> [Actions](../../actions/README.md) are omitted for simplicity.

[](../../common/expanded-warning.md ':include')

```yaml
elements:
  - type: custom:advanced-camera-card-menu-icon
    alignment: matching
    enabled: true
    entity: light.office_main_lights
    icon: mdi:car
    permanent: false
    priority: 50
    style:
      color: white
    title: Vroom
  - type: custom:advanced-camera-card-menu-state-icon
    alignment: matching
    enabled: true
    entity: light.office_main_lights
    icon: mdi:chair-rolling
    permanent: false
    priority: 50
    state_color: true
    style:
      color: white
    title: Office lights
  - type: custom:advanced-camera-card-menu-submenu
    alignment: matching
    enabled: true
    entity: light.office_main_lights
    icon: mdi:menu
    items:
      - enabled: true
        entity: light.office_main_lights
        icon: mdi:lightbulb
        selected: false
        state_color: true
        style:
          color: white
        tap_action:
          action: toggle
        title: Lights
      - enabled: true
        icon: mdi:google
        selected: false
        state_color: false
        style:
          color: white
        tap_action:
          action: url
          url_path: https://www.google.com
        title: Google
    permanent: false
    priority: 50
    style:
      color: white
    title: Office lights
  - type: custom:advanced-camera-card-menu-submenu-select
    alignment: matching
    enabled: true
    entity: input_select.kitchen_scene
    icon: mdi:lamps
    options:
    items:
      scene.kitchen_cooking_scene:
        enabled: true
        icon: mdi:chef-hat
        selected: false
        state_color: true
        style:
          color: white
        title: Cooking time!
      scene.kitchen_tv_scene:
        icon: mdi:television
        title: TV!
    permanent: false
    priority: 50
    style:
      color: white
    title: 'Kitchen Scene'
    # Show a pig icon if a variety of conditions are met.
  - type: custom:advanced-camera-card-conditional
    elements:
      - type: icon
        icon: mdi:pig
        title: Oink
        style:
          left: 300px
          top: 100px
    conditions:
      - condition: view
        views:
          - live
      - condition: fullscreen
        fullscreen: true
      - condition: expand
        expand: true
      - condition: camera
        cameras: camera.front_door
      - condition: media_loaded
        media_loaded: true
      - condition: display_mode
        display_mode: single
      - condition: triggered
        triggered:
          - camera.front_door
      - condition: interaction
        interaction: true
      - condition: microphone
        muted: true
        connected: true
      - condition: state
        entity: light.office_main_lights
        state: on
        state_not: off
      - condition: numeric_state
        entity: sensor.light_level
        above: 20
        below: 100
      - condition: user
        users:
          - 581fca7fdc014b8b894519cc531f9a04
  - type: custom:advanced-camera-card-status-bar-string
    enabled: true
    exclusive: false
    expand: false
    string: 'Intruder alert!'
    priority: 50
    sufficient: false
  - type: custom:advanced-camera-card-status-bar-icon
    enabled: true
    exclusive: false
    expand: false
    icon: 'mdi:cow'
    priority: 50
    sufficient: false
  - type: custom:advanced-camera-card-status-bar-image
    enabled: true
    exclusive: false
    expand: false
    image: https://my.site.com/status.png
    priority: 50
    sufficient: false
```



================================================
FILE: docs/configuration/elements/custom/_sidebar.md
================================================
- [Getting Started](../../../README.md)
- [Configuration](../../README.md)
  - [`actions`](../README.md)
  - [`automations`](../../automations.md)
  - [`cameras`](../../cameras/README.md)
  - [`conditions`](../../conditions.md)
  - [`dimensions`](../../dimensions.md)
  - [`elements`](../../elements/README.md)
    - [Custom Actions](README.md)
    - [Stock Actions](../stock/README.md)
  - [`folders`](../../folders.md)
  - [`image`](../../image.md)
  - [`live`](../../live.md)
  - [`media_gallery`](../../media-gallery.md)
  - [`media_viewer`](../../media-viewer.md)
  - [`menu`](../../menu.md)
  - [`overrides`](../../overrides.md)
  - [`performance`](../../performance.md)
  - [`profiles`](../../profiles.md)
  - [`remote_control`](../../remote-control.md)
  - [`status_bar`](../../status-bar.md)
  - [`timeline`](../../timeline.md)
  - [`view`](../../view.md)
  - [Templates](../../templates.md)
- [Examples](../../../examples.md)
- [Screenshots](../../../screenshots.md)
- [Troubleshooting](../../../troubleshooting.md)
- [Usage](../../../usage/README.md)

---

- [Developing](../../../developing.md)



================================================
FILE: docs/configuration/elements/stock/README.md
================================================
# Stock Elements

## `conditional`

This element will let you show its sub-elements based on entity states. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#conditional-element).

```yaml
elements:
  - type: conditional
    # [...]
```

## `custom`

Custom elements provided by a card. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#custom-elements).

```yaml
elements:
  - type: custom
    # [...]
```

?> See [Advanced Camera Card custom elements](../custom//README.md) for the custom elements offered by _this_ card.

## `icon`

This element creates a static icon that is not linked to the state of an entity. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#icon-element).

```yaml
elements:
  - type: icon
    # [...]
```

## `image`

This creates an image element that overlays the background image. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#image-element).

```yaml
elements:
  - type: image
    # [...]
```

## `service-button`

This entity creates a button (with arbitrary text) that can be used to call a service. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#service-call-button).

```yaml
elements:
  - type: service-button
    # [...]
```

## `state-badge`

This element creates a badge representing the state of an entity. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#state-badge).

```yaml
elements:
  - type: state-badge
    # [...]
```

## `state-icon`

This element represents an entity state using an icon. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#state-icon).

```yaml
elements:
  - type: state-icon
    # [...]
```

## `state-label`

This element represents an entity’s state via text. See [Home Assistant elements documentation](https://www.home-assistant.io/dashboards/picture-elements/#state-label).

```yaml
elements:
  - type: state-label
    # [...]
```

## Fully expanded reference

> [Actions](../../actions/README.md) are omitted for simplicity.

[](../../common/expanded-warning.md ':include')

Reference: [Home Assistant Picture Elements](https://www.home-assistant.io/dashboards/picture-elements/)

```yaml
elements:
  - type: state-badge
    entity: sensor.kitchen_dining_multisensor_air_temperature
    style:
      left: 100px
      top: 50px
    title: 'Temperature'
  - type: state-icon
    entity: light.office_main_lights
    icon: mdi:lamp
    state_color: true
    style:
      left: 100px
      top: 100px
  - type: state-label
    entity: sensor.kitchen_motion_sensor_battery
    attribute: battery_voltage
    prefix: Volts
    title: Battery Voltage
    style:
      left: 100px
      top: 150px
  - type: state-label
    entity: sensor.kitchen_motion_sensor_battery
    attribute: battery_voltage
    prefix: 'Volts: '
    title: Battery Voltage
    style:
      background-color: black
      left: 100px
      top: 200px
  - type: service-button
    title: Light on
    service: homeassistant.turn_on
    service_data:
      entity: light.office_main_lights
    style:
      left: 100px
      top: 250px
  - type: icon
    icon: mdi:cow
    title: Moo
    style:
      left: 100px
      top: 300px
  - type: image
    entity: light.office_main_lights
    title: Image
    state_image:
      on: 'https://picsum.photos/id/1003/1181/1772'
      off: 'https://picsum.photos/id/102/4320/3240'
    state_filter:
      'on': brightness(110%) saturate(1.2)
      'off': brightness(50%) hue-rotate(45deg)
    style:
      left: 100px
      top: 350px
      height: 50px
      width: 100px
  - type: conditional
    conditions:
      - condition: state
        entity: light.office_main_lights
        state: on
        state_not: off
      - condition: numeric_state
        entity: sensor.light_level
        above: 20
        below: 100
      - condition: user
        users:
          - 581fca7fdc014b8b894519cc531f9a04
    elements:
      - type: icon
        icon: mdi:dog
        title: Woof
        style:
          left: 100px
          top: 400px
```



================================================
FILE: docs/configuration/elements/stock/_sidebar.md
================================================
- [Getting Started](../../../README.md)
- [Configuration](../../README.md)
  - [`actions`](../README.md)
  - [`automations`](../../automations.md)
  - [`cameras`](../../cameras/README.md)
  - [`conditions`](../../conditions.md)
  - [`dimensions`](../../dimensions.md)
  - [`elements`](../../elements/README.md)
    - [Custom Actions](../custom/README.md)
    - [Stock Actions](README.md)
  - [`folders`](../../folders.md)
  - [`image`](../../image.md)
  - [`live`](../../live.md)
  - [`media_gallery`](../../media-gallery.md)
  - [`media_viewer`](../../media-viewer.md)
  - [`menu`](../../menu.md)
  - [`overrides`](../../overrides.md)
  - [`performance`](../../performance.md)
  - [`profiles`](../../profiles.md)
  - [`remote_control`](../../remote-control.md)
  - [`status_bar`](../../status-bar.md)
  - [`timeline`](../../timeline.md)
  - [`view`](../../view.md)
  - [Templates](../../templates.md)
- [Examples](../../../examples.md)
- [Screenshots](../../../screenshots.md)
- [Troubleshooting](../../../troubleshooting.md)
- [Usage](../../../usage/README.md)

---

- [Developing](../../../developing.md)



================================================
FILE: docs/css/theme-simple-dark.css
================================================
.github-corner {
  position: absolute;
  z-index: 40;
  top: 0;
  right: 0;
  border-bottom: 0;
  text-decoration: none;
}
.github-corner svg {
  height: 70px;
  width: 70px;
  fill: var(--theme-color);
  color: var(--base-background-color);
}
.github-corner:hover .octo-arm {
  -webkit-animation: octocat-wave 560ms ease-in-out;
  animation: octocat-wave 560ms ease-in-out;
}
@-webkit-keyframes octocat-wave {
  0%,
  100% {
    transform: rotate(0);
  }
  20%,
  60% {
    transform: rotate(-25deg);
  }
  40%,
  80% {
    transform: rotate(10deg);
  }
}
@keyframes octocat-wave {
  0%,
  100% {
    transform: rotate(0);
  }
  20%,
  60% {
    transform: rotate(-25deg);
  }
  40%,
  80% {
    transform: rotate(10deg);
  }
}
.progress {
  position: fixed;
  z-index: 2147483647;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  width: 0;
  background-color: var(--theme-color);
  transition:
    width var(--duration-fast),
    opacity calc(var(--duration-fast) * 2);
}
body.ready-transition:after,
body.ready-transition > *:not(.progress) {
  opacity: 0;
  transition: opacity var(--spinner-transition-duration);
}
body.ready-transition:after {
  content: '';
  position: absolute;
  z-index: 1000;
  top: calc(50% - var(--spinner-size) / 2);
  left: calc(50% - var(--spinner-size) / 2);
  height: var(--spinner-size);
  width: var(--spinner-size);
  border: var(--spinner-track-width, 0) solid var(--spinner-track-color);
  border-left-color: var(--theme-color);
  border-left-color: var(--theme-color);
  border-radius: 50%;
  -webkit-animation: spinner var(--duration-slow) infinite linear;
  animation: spinner var(--duration-slow) infinite linear;
}
body.ready-transition.ready-spinner:after {
  opacity: 1;
}
body.ready-transition.ready-fix:after {
  opacity: 0;
}
body.ready-transition.ready-fix > *:not(.progress) {
  opacity: 1;
  transition-delay: var(--spinner-transition-duration);
}
@-webkit-keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
*,
*:before,
*:after {
  box-sizing: inherit;
  font-size: inherit;
  -webkit-overflow-scrolling: touch;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-text-size-adjust: none;
  -webkit-touch-callout: none;
}
:root {
  box-sizing: border-box;
  background-color: var(--base-background-color);
  font-size: var(--base-font-size);
  font-weight: var(--base-font-weight);
  line-height: var(--base-line-height);
  letter-spacing: var(--base-letter-spacing);
  color: var(--base-color);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-smoothing: antialiased;
}
html,
button,
input,
optgroup,
select,
textarea {
  font-family: var(--base-font-family);
}
button,
input,
optgroup,
select,
textarea {
  font-size: 100%;
  margin: 0;
}
a {
  text-decoration: none;
  -webkit-text-decoration-skip: ink;
  text-decoration-skip-ink: auto;
}
body {
  margin: 0;
}
hr {
  height: 0;
  margin: 2em 0;
  border: none;
  border-bottom: var(--hr-border, 0);
}
img {
  max-width: 100%;
  border: 0;
}
main {
  display: block;
}
main.hidden {
  display: none;
}
mark {
  background: var(--mark-background);
  color: var(--mark-color);
}
pre {
  font-family: var(--pre-font-family);
  font-size: var(--pre-font-size);
  font-weight: var(--pre-font-weight);
  line-height: var(--pre-line-height);
}
small {
  display: inline-block;
  font-size: var(--small-font-size);
}
strong {
  font-weight: var(--strong-font-weight);
  color: var(--strong-color, currentColor);
}
sub,
sup {
  font-size: var(--subsup-font-size);
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
body:not([data-platform^='Mac']) * {
  scrollbar-color: hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.3)
    hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.1);
  scrollbar-width: thin;
}
body:not([data-platform^='Mac']) * ::-webkit-scrollbar {
  width: 5px;
  height: 5px;
}
body:not([data-platform^='Mac']) * ::-webkit-scrollbar-thumb {
  background: hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.3);
}
body:not([data-platform^='Mac']) * ::-webkit-scrollbar-track {
  background: hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.1);
}
::-moz-selection {
  background: var(--selection-color);
}
::selection {
  background: var(--selection-color);
}
.emoji {
  height: var(--emoji-size);
  vertical-align: middle;
}
.task-list-item {
  list-style: none;
}
.task-list-item input {
  margin-right: 0.5em;
  margin-left: 0;
  vertical-align: 0.075em;
}
.markdown-section code[class*='lang-'],
.markdown-section pre[data-lang] {
  font-family: var(--code-font-family);
  font-size: var(--code-font-size);
  font-weight: var(--code-font-weight);
  letter-spacing: normal;
  line-height: var(--code-block-line-height);
  -moz-tab-size: var(--code-tab-size);
  -o-tab-size: var(--code-tab-size);
  tab-size: var(--code-tab-size);
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-wrap: normal;
  word-break: normal;
  -webkit-hyphens: none;
  hyphens: none;
}
.markdown-section pre[data-lang] {
  position: relative;
  overflow: hidden;
  margin: var(--code-block-margin);
  padding: 0;
  border-radius: var(--code-block-border-radius);
}
.markdown-section pre[data-lang]::after {
  content: attr(data-lang);
  position: absolute;
  top: 0.75em;
  right: 0.75em;
  opacity: 0.6;
  color: inherit;
  font-size: var(--font-size-s);
  line-height: 1;
}
.markdown-section pre[data-lang] code {
  display: block;
  overflow: auto;
  padding: var(--code-block-padding);
}
code[class*='lang-'],
pre[data-lang] {
  color: var(--code-theme-text);
}
pre[data-lang]::-moz-selection,
pre[data-lang] ::-moz-selection,
code[class*='lang-']::-moz-selection,
code[class*='lang-'] ::-moz-selection {
  background: var(--code-theme-selection, var(--selection-color));
}
pre[data-lang]::-moz-selection,
pre[data-lang] ::-moz-selection,
code[class*='lang-']::-moz-selection,
code[class*='lang-'] ::-moz-selection {
  background: var(--code-theme-selection, var(--selection-color));
}
pre[data-lang]::selection,
pre[data-lang] ::selection,
code[class*='lang-']::selection,
code[class*='lang-'] ::selection {
  background: var(--code-theme-selection, var(--selection-color));
}
:not(pre) > code[class*='lang-'],
pre[data-lang] {
  background: var(--code-theme-background);
}
.namespace {
  opacity: 0.7;
}
.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: var(--code-theme-comment);
}
.token.punctuation {
  color: var(--code-theme-punctuation);
}
.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: var(--code-theme-tag);
}
.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: var(--code-theme-selector);
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: var(--code-theme-operator);
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: var(--code-theme-keyword);
}
.token.function {
  color: var(--code-theme-function);
}
.token.regex,
.token.important,
.token.variable {
  color: var(--code-theme-variable);
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
.markdown-section {
  position: relative;
  max-width: var(--content-max-width);
  margin: 0 auto;
  padding: 2rem 45px;
}
.app-nav:not(:empty) ~ main .markdown-section {
  padding-top: 3.5rem;
}
.markdown-section figure,
.markdown-section p,
.markdown-section ol,
.markdown-section ul {
  margin: 1em 0;
}
.markdown-section ol,
.markdown-section ul {
  padding-left: 1.5rem;
}
.markdown-section ol ol,
.markdown-section ol ul,
.markdown-section ul ol,
.markdown-section ul ul {
  margin-top: 0.15rem;
  margin-bottom: 0.15rem;
}
.markdown-section a {
  border-bottom: var(--link-border-bottom);
  color: var(--link-color);
  -webkit-text-decoration: var(--link-text-decoration);
  text-decoration: var(--link-text-decoration);
  -webkit-text-decoration-color: var(--link-text-decoration-color);
  text-decoration-color: var(--link-text-decoration-color);
}
.markdown-section a:hover {
  border-bottom: var(--link-border-bottom--hover, var(--link-border-bottom, 0));
  color: var(--link-color--hover, var(--link-color));
  -webkit-text-decoration: var(
    --link-text-decoration--hover,
    var(--link-text-decoration)
  );
  text-decoration: var(--link-text-decoration--hover, var(--link-text-decoration));
  -webkit-text-decoration-color: var(
    --link-text-decoration-color--hover,
    var(--link-text-decoration-color)
  );
  text-decoration-color: var(
    --link-text-decoration-color--hover,
    var(--link-text-decoration-color)
  );
}
.markdown-section a.anchor {
  border-bottom: 0;
  color: inherit;
  text-decoration: none;
}
.markdown-section a.anchor:hover {
  text-decoration: underline;
}
.markdown-section blockquote {
  overflow: visible;
  margin: 2em 0;
  padding: var(--blockquote-padding);
  border-width: var(--blockquote-border-width, 0);
  border-style: var(--blockquote-border-style);
  border-color: var(--blockquote-border-color);
  border-radius: var(--blockquote-border-radius);
  background: var(--blockquote-background);
  color: var(--blockquote-color);
  font-family: var(--blockquote-font-family);
  font-size: var(--blockquote-font-size);
  font-style: var(--blockquote-font-style);
  font-weight: var(--blockquote-font-weight);
  quotes: '“' '”' '‘' '’';
}
.markdown-section blockquote em {
  font-family: var(--blockquote-em-font-family);
  font-size: var(--blockquote-em-font-size);
  font-style: var(--blockquote-em-font-style);
  font-weight: var(--blockquote-em-font-weight);
}
.markdown-section blockquote p:first-child {
  margin-top: 0;
}
.markdown-section blockquote p:first-child:before,
.markdown-section blockquote p:first-child:after {
  color: var(--blockquote-quotes-color);
  font-family: var(--blockquote-quotes-font-family);
  font-size: var(--blockquote-quotes-font-size);
  line-height: 0;
}
.markdown-section blockquote p:first-child:before {
  content: var(--blockquote-quotes-open);
  margin-right: 0.15em;
  vertical-align: -0.45em;
}
.markdown-section blockquote p:first-child:after {
  content: var(--blockquote-quotes-close);
  margin-left: 0.15em;
  vertical-align: -0.55em;
}
.markdown-section blockquote p:last-child {
  margin-bottom: 0;
}
.markdown-section code {
  font-family: var(--code-font-family);
  font-size: var(--code-font-size);
  font-weight: var(--code-font-weight);
  line-height: inherit;
}
.markdown-section code:not([class*='lang-']):not([class*='language-']) {
  margin: var(--code-inline-margin);
  padding: var(--code-inline-padding);
  border-radius: var(--code-inline-border-radius);
  background: var(--code-inline-background);
  color: var(--code-inline-color, currentColor);
  white-space: nowrap;
}
.markdown-section h1:first-child,
.markdown-section h2:first-child,
.markdown-section h3:first-child,
.markdown-section h4:first-child,
.markdown-section h5:first-child,
.markdown-section h6:first-child {
  margin-top: 0;
}
.markdown-section h1 a[data-id],
.markdown-section h2 a[data-id],
.markdown-section h3 a[data-id],
.markdown-section h4 a[data-id],
.markdown-section h5 a[data-id],
.markdown-section h6 a[data-id] {
  display: inline-block;
}
.markdown-section h1 code,
.markdown-section h2 code,
.markdown-section h3 code,
.markdown-section h4 code,
.markdown-section h5 code,
.markdown-section h6 code {
  font-size: 0.875em;
}
.markdown-section h1 + h2,
.markdown-section h1 + h3,
.markdown-section h1 + h4,
.markdown-section h1 + h5,
.markdown-section h1 + h6,
.markdown-section h2 + h3,
.markdown-section h2 + h4,
.markdown-section h2 + h5,
.markdown-section h2 + h6,
.markdown-section h3 + h4,
.markdown-section h3 + h5,
.markdown-section h3 + h6,
.markdown-section h4 + h5,
.markdown-section h4 + h6,
.markdown-section h5 + h6 {
  margin-top: 1rem;
}
.markdown-section h1 {
  margin: var(--heading-h1-margin, var(--heading-margin));
  padding: var(--heading-h1-padding, var(--heading-padding));
  border-width: var(--heading-h1-border-width, 0);
  border-style: var(--heading-h1-border-style);
  border-color: var(--heading-h1-border-color);
  font-family: var(--heading-h1-font-family, var(--heading-font-family));
  font-size: var(--heading-h1-font-size);
  font-weight: var(--heading-h1-font-weight, var(--heading-font-weight));
  line-height: var(--base-line-height);
  color: var(--heading-h1-color, var(--heading-color));
}
.markdown-section h2 {
  margin: var(--heading-h2-margin, var(--heading-margin));
  padding: var(--heading-h2-padding, var(--heading-padding));
  border-width: var(--heading-h2-border-width, 0);
  border-style: var(--heading-h2-border-style);
  border-color: var(--heading-h2-border-color);
  font-family: var(--heading-h2-font-family, var(--heading-font-family));
  font-size: var(--heading-h2-font-size);
  font-weight: var(--heading-h2-font-weight, var(--heading-font-weight));
  line-height: var(--base-line-height);
  color: var(--heading-h2-color, var(--heading-color));
}
.markdown-section h3 {
  margin: var(--heading-h3-margin, var(--heading-margin));
  padding: var(--heading-h3-padding, var(--heading-padding));
  border-width: var(--heading-h3-border-width, 0);
  border-style: var(--heading-h3-border-style);
  border-color: var(--heading-h3-border-color);
  font-family: var(--heading-h3-font-family, var(--heading-font-family));
  font-size: var(--heading-h3-font-size);
  font-weight: var(--heading-h3-font-weight, var(--heading-font-weight));
  color: var(--heading-h3-color, var(--heading-color));
}
.markdown-section h4 {
  margin: var(--heading-h4-margin, var(--heading-margin));
  padding: var(--heading-h4-padding, var(--heading-padding));
  border-width: var(--heading-h4-border-width, 0);
  border-style: var(--heading-h4-border-style);
  border-color: var(--heading-h4-border-color);
  font-family: var(--heading-h4-font-family, var(--heading-font-family));
  font-size: var(--heading-h4-font-size);
  font-weight: var(--heading-h4-font-weight, var(--heading-font-weight));
  color: var(--heading-h4-color, var(--heading-color));
}
.markdown-section h5 {
  margin: var(--heading-h5-margin, var(--heading-margin));
  padding: var(--heading-h5-padding, var(--heading-padding));
  border-width: var(--heading-h5-border-width, 0);
  border-style: var(--heading-h5-border-style);
  border-color: var(--heading-h5-border-color);
  font-family: var(--heading-h5-font-family, var(--heading-font-family));
  font-size: var(--heading-h5-font-size);
  font-weight: var(--heading-h5-font-weight, var(--heading-font-weight));
  color: var(--heading-h5-color, var(--heading-color));
}
.markdown-section h6 {
  margin: var(--heading-h6-margin, var(--heading-margin));
  padding: var(--heading-h6-padding, var(--heading-padding));
  border-width: var(--heading-h6-border-width, 0);
  border-style: var(--heading-h6-border-style);
  border-color: var(--heading-h6-border-color);
  font-family: var(--heading-h6-font-family, var(--heading-font-family));
  font-size: var(--heading-h6-font-size);
  font-weight: var(--heading-h6-font-weight, var(--heading-font-weight));
  color: var(--heading-h6-color, var(--heading-color));
}
.markdown-section iframe {
  margin: 1em 0;
}
.markdown-section img {
  max-width: 100%;
}
.markdown-section kbd {
  display: inline-block;
  min-width: var(--kbd-min-width);
  margin: var(--kbd-margin);
  padding: var(--kbd-padding);
  border: var(--kbd-border);
  border-radius: var(--kbd-border-radius);
  background: var(--kbd-background);
  font-family: inherit;
  font-size: var(--kbd-font-size);
  text-align: center;
  letter-spacing: 0;
  line-height: 1;
  color: var(--kbd-color);
}
.markdown-section kbd + kbd {
  margin-left: -0.15em;
}
.markdown-section table {
  display: block;
  overflow: auto;
  margin: 1rem 0;
  border-spacing: 0;
  border-collapse: collapse;
}
.markdown-section th,
.markdown-section td {
  padding: var(--table-cell-padding);
}
.markdown-section th:not([align]) {
  text-align: left;
}
.markdown-section thead {
  border-color: var(--table-head-border-color);
  border-style: solid;
  border-width: var(--table-head-border-width, 0);
  background: var(--table-head-background);
}
.markdown-section th {
  font-weight: var(--table-head-font-weight);
  color: var(--strong-color);
}
.markdown-section td {
  border-color: var(--table-cell-border-color);
  border-style: solid;
  border-width: var(--table-cell-border-width, 0);
}
.markdown-section tbody {
  border-color: var(--table-body-border-color);
  border-style: solid;
  border-width: var(--table-body-border-width, 0);
}
.markdown-section tbody tr:nth-child(odd) {
  background: var(--table-row-odd-background);
}
.markdown-section tbody tr:nth-child(even) {
  background: var(--table-row-even-background);
}
.markdown-section > ul .task-list-item {
  margin-left: -1.25em;
}
.markdown-section > ul .task-list-item .task-list-item {
  margin-left: 0;
}
.markdown-section .table-wrapper {
  overflow-x: auto;
}
.markdown-section .table-wrapper table {
  display: table;
  width: 100%;
}
.markdown-section .table-wrapper td::before {
  display: none;
}
@media (max-width: 30em) {
  .markdown-section .table-wrapper tbody,
  .markdown-section .table-wrapper tr,
  .markdown-section .table-wrapper td {
    display: block;
  }
  .markdown-section .table-wrapper th,
  .markdown-section .table-wrapper td {
    border: none;
  }
  .markdown-section .table-wrapper thead {
    display: none;
  }
  .markdown-section .table-wrapper tr {
    border-color: var(--table-cell-border-color);
    border-style: solid;
    border-width: var(--table-cell-border-width, 0);
    padding: var(--table-cell-padding);
  }
  .markdown-section .table-wrapper tr:not(:last-child) {
    border-bottom: 0;
  }
  .markdown-section .table-wrapper td {
    padding: 0.15em 0 0.15em 8em;
  }
  .markdown-section .table-wrapper td::before {
    display: inline-block;
    float: left;
    width: 8em;
    margin-left: -8em;
    font-weight: bold;
    text-align: left;
  }
}
.markdown-section .tip,
.markdown-section .warn {
  position: relative;
  margin: 2em 0;
  padding: var(--notice-padding);
  border-width: var(--notice-border-width, 0);
  border-style: var(--notice-border-style);
  border-color: var(--notice-border-color);
  border-radius: var(--notice-border-radius);
  background: var(--notice-background);
  font-family: var(--notice-font-family);
  font-weight: var(--notice-font-weight);
  color: var(--notice-color);
}
.markdown-section .tip:before,
.markdown-section .warn:before {
  display: inline-block;
  position: var(--notice-before-position, relative);
  top: var(--notice-before-top);
  left: var(--notice-before-left);
  height: var(--notice-before-height);
  width: var(--notice-before-width);
  margin: var(--notice-before-margin);
  padding: var(--notice-before-padding);
  border-radius: var(--notice-before-border-radius);
  line-height: var(--notice-before-line-height);
  font-family: var(--notice-before-font-family);
  font-size: var(--notice-before-font-size);
  font-weight: var(--notice-before-font-weight);
  text-align: center;
}
.markdown-section .tip {
  border-width: var(--notice-important-border-width, var(--notice-border-width, 0));
  border-style: var(--notice-important-border-style, var(--notice-border-style));
  border-color: var(--notice-important-border-color, var(--notice-border-color));
  background: var(--notice-important-background, var(--notice-background));
  color: var(--notice-important-color, var(--notice-color));
}
.markdown-section .tip:before {
  content: var(--notice-important-before-content, var(--notice-before-content));
  background: var(--notice-important-before-background, var(--notice-before-background));
  color: var(--notice-important-before-color, var(--notice-before-color));
}
.markdown-section .warn {
  border-width: var(--notice-tip-border-width, var(--notice-border-width, 0));
  border-style: var(--notice-tip-border-style, var(--notice-border-style));
  border-color: var(--notice-tip-border-color, var(--notice-border-color));
  background: var(--notice-tip-background, var(--notice-background));
  color: var(--notice-tip-color, var(--notice-color));
}
.markdown-section .warn:before {
  content: var(--notice-tip-before-content, var(--notice-before-content));
  background: var(--notice-tip-before-background, var(--notice-before-background));
  color: var(--notice-tip-before-color, var(--notice-before-color));
}
.cover {
  display: none;
  position: relative;
  z-index: 20;
  min-height: 100vh;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: calc(var(--cover-border-inset, 0px) + var(--cover-border-width, 0px));
  color: var(--cover-color);
  text-align: var(--cover-text-align);
}
.cover:before,
.cover:after {
  content: '';
  position: absolute;
}
.cover:before {
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background-blend-mode: var(--cover-background-blend-mode);
  background-color: var(--cover-background-color);
  background-image: var(--cover-background-image);
  background-position: var(--cover-background-position);
  background-repeat: var(--cover-background-repeat);
  background-size: var(--cover-background-size);
}
.cover:after {
  top: var(--cover-border-inset, 0);
  bottom: var(--cover-border-inset, 0);
  left: var(--cover-border-inset, 0);
  right: var(--cover-border-inset, 0);
  border-width: var(--cover-border-width, 0);
  border-style: solid;
  border-color: var(--cover-border-color);
}
.cover a {
  border-bottom: var(--cover-link-border-bottom);
  color: var(--cover-link-color);
  -webkit-text-decoration: var(--cover-link-text-decoration);
  text-decoration: var(--cover-link-text-decoration);
  -webkit-text-decoration-color: var(--cover-link-text-decoration-color);
  text-decoration-color: var(--cover-link-text-decoration-color);
}
.cover a:hover {
  border-bottom: var(--cover-link-border-bottom--hover, var(--cover-link-border-bottom));
  color: var(--cover-link-color--hover, var(--cover-link-color));
  -webkit-text-decoration: var(
    --cover-link-text-decoration--hover,
    var(--cover-link-text-decoration)
  );
  text-decoration: var(
    --cover-link-text-decoration--hover,
    var(--cover-link-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --cover-link-text-decoration-color--hover,
    var(--cover-link-text-decoration-color)
  );
  text-decoration-color: var(
    --cover-link-text-decoration-color--hover,
    var(--cover-link-text-decoration-color)
  );
}
.cover h1 {
  color: var(--cover-heading-color);
  position: relative;
  margin: 0;
  font-size: var(--cover-heading-font-size);
  font-weight: var(--cover-heading-font-weight);
  line-height: 1.2;
}
.cover h1 a,
.cover h1 a:hover {
  display: block;
  border-bottom: none;
  color: inherit;
  text-decoration: none;
}
.cover h1 small {
  position: absolute;
  bottom: 0;
  margin-left: 0.5em;
}
.cover h1 span {
  font-size: calc(var(--cover-heading-font-size-min) * 1px);
}
@media (min-width: 26em) {
  .cover h1 span {
    font-size: calc(
      var(--cover-heading-font-size-min) * 1px +
        (var(--cover-heading-font-size-max) - var(--cover-heading-font-size-min)) *
        (100vw - 420px) / 604
    );
  }
}
@media (min-width: 64em) {
  .cover h1 span {
    font-size: calc(var(--cover-heading-font-size-max) * 1px);
  }
}
.cover blockquote {
  margin: 0;
  color: var(--cover-blockquote-color);
  font-size: var(--cover-blockquote-font-size);
}
.cover blockquote a {
  color: inherit;
}
.cover ul {
  padding: 0;
  list-style-type: none;
}
.cover .cover-main {
  position: relative;
  z-index: 1;
  max-width: var(--cover-max-width);
  margin: var(--cover-margin);
  padding: 0 45px;
}
.cover .cover-main > p:last-child {
  margin: 1.25em -0.25em;
}
.cover .cover-main > p:last-child a {
  display: block;
  margin: 0.375em 0.25em;
  padding: var(--cover-button-padding);
  border: var(--cover-button-border);
  border-radius: var(--cover-button-border-radius);
  box-shadow: var(--cover-button-box-shadow);
  background: var(--cover-button-background);
  text-align: center;
  -webkit-text-decoration: var(--cover-button-text-decoration);
  text-decoration: var(--cover-button-text-decoration);
  -webkit-text-decoration-color: var(--cover-button-text-decoration-color);
  text-decoration-color: var(--cover-button-text-decoration-color);
  color: var(--cover-button-color);
  white-space: nowrap;
  transition: var(--cover-button-transition);
}
.cover .cover-main > p:last-child a:hover {
  border: var(--cover-button-border--hover, var(--cover-button-border));
  box-shadow: var(--cover-button-box-shadow--hover, var(--cover-button-box-shadow));
  background: var(--cover-button-background--hover, var(--cover-button-background));
  -webkit-text-decoration: var(
    --cover-button-text-decoration--hover,
    var(--cover-button-text-decoration)
  );
  text-decoration: var(
    --cover-button-text-decoration--hover,
    var(--cover-button-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --cover-button-text-decoration-color--hover,
    var(--cover-button-text-decoration-color)
  );
  text-decoration-color: var(
    --cover-button-text-decoration-color--hover,
    var(--cover-button-text-decoration-color)
  );
  color: var(--cover-button-color--hover, var(--cover-button-color));
}
.cover .cover-main > p:last-child a:first-child {
  border: var(--cover-button-primary-border, var(--cover-button-border));
  box-shadow: var(--cover-button-primary-box-shadow, var(--cover-button-box-shadow));
  background: var(--cover-button-primary-background, var(--cover-button-background));
  -webkit-text-decoration: var(
    --cover-button-primary-text-decoration,
    var(--cover-button-text-decoration)
  );
  text-decoration: var(
    --cover-button-primary-text-decoration,
    var(--cover-button-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --cover-button-primary-text-decoration-color,
    var(--cover-button-text-decoration-color)
  );
  text-decoration-color: var(
    --cover-button-primary-text-decoration-color,
    var(--cover-button-text-decoration-color)
  );
  color: var(--cover-button-primary-color, var(--cover-button-color));
}
.cover .cover-main > p:last-child a:first-child:hover {
  border: var(
    --cover-button-primary-border--hover,
    var(
      --cover-button-border--hover,
      var(--cover-button-primary-border, var(--cover-button-border))
    )
  );
  box-shadow: var(
    --cover-button-primary-box-shadow--hover,
    var(
      --cover-button-box-shadow--hover,
      var(--cover-button-primary-box-shadow, var(--cover-button-box-shadow))
    )
  );
  background: var(
    --cover-button-primary-background--hover,
    var(
      --cover-button-background--hover,
      var(--cover-button-primary-background, var(--cover-button-background))
    )
  );
  -webkit-text-decoration: var(
    --cover-button-primary-text-decoration--hover,
    var(
      --cover-button-text-decoration--hover,
      var(--cover-button-primary-text-decoration, var(--cover-button-text-decoration))
    )
  );
  text-decoration: var(
    --cover-button-primary-text-decoration--hover,
    var(
      --cover-button-text-decoration--hover,
      var(--cover-button-primary-text-decoration, var(--cover-button-text-decoration))
    )
  );
  -webkit-text-decoration-color: var(
    --cover-button-primary-text-decoration-color--hover,
    var(
      --cover-button-text-decoration-color--hover,
      var(
        --cover-button-primary-text-decoration-color,
        var(--cover-button-text-decoration-color)
      )
    )
  );
  text-decoration-color: var(
    --cover-button-primary-text-decoration-color--hover,
    var(
      --cover-button-text-decoration-color--hover,
      var(
        --cover-button-primary-text-decoration-color,
        var(--cover-button-text-decoration-color)
      )
    )
  );
  color: var(
    --cover-button-primary-color--hover,
    var(
      --cover-button-color--hover,
      var(--cover-button-primary-color, var(--cover-button-color))
    )
  );
}
@media (min-width: 30.01em) {
  .cover .cover-main > p:last-child a {
    display: inline-block;
  }
}
.cover .mask {
  visibility: var(--cover-background-mask-visibility, hidden);
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: var(--cover-background-mask-color);
  opacity: var(--cover-background-mask-opacity);
}
.cover.has-mask .mask {
  visibility: visible;
}
.cover.show {
  display: flex;
}
.app-nav {
  position: absolute;
  z-index: 30;
  top: calc(35px - 0.5em * var(--base-line-height));
  left: 45px;
  right: 80px;
  text-align: right;
}
.app-nav.no-badge {
  right: 45px;
}
.app-nav li > img,
.app-nav li > a > img {
  margin-top: -0.25em;
  vertical-align: middle;
}
.app-nav li > img:first-child,
.app-nav li > a > img:first-child {
  margin-right: 0.5em;
}
.app-nav ul,
.app-nav li {
  margin: 0;
  padding: 0;
  list-style: none;
}
.app-nav li {
  position: relative;
}
.app-nav li a {
  display: block;
  line-height: 1;
  transition: var(--navbar-root-transition);
}
.app-nav > ul > li {
  display: inline-block;
  margin: var(--navbar-root-margin);
}
.app-nav > ul > li:first-child {
  margin-left: 0;
}
.app-nav > ul > li:last-child {
  margin-right: 0;
}
.app-nav > ul > li > a,
.app-nav > ul > li > span {
  padding: var(--navbar-root-padding);
  border-width: var(--navbar-root-border-width, 0);
  border-style: var(--navbar-root-border-style);
  border-color: var(--navbar-root-border-color);
  border-radius: var(--navbar-root-border-radius);
  background: var(--navbar-root-background);
  color: var(--navbar-root-color);
  -webkit-text-decoration: var(--navbar-root-text-decoration);
  text-decoration: var(--navbar-root-text-decoration);
  -webkit-text-decoration-color: var(--navbar-root-text-decoration-color);
  text-decoration-color: var(--navbar-root-text-decoration-color);
}
.app-nav > ul > li > a:hover,
.app-nav > ul > li > span:hover {
  background: var(--navbar-root-background--hover, var(--navbar-root-background));
  border-style: var(--navbar-root-border-style--hover, var(--navbar-root-border-style));
  border-color: var(--navbar-root-border-color--hover, var(--navbar-root-border-color));
  color: var(--navbar-root-color--hover, var(--navbar-root-color));
  -webkit-text-decoration: var(
    --navbar-root-text-decoration--hover,
    var(--navbar-root-text-decoration)
  );
  text-decoration: var(
    --navbar-root-text-decoration--hover,
    var(--navbar-root-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-root-text-decoration-color--hover,
    var(--navbar-root-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-root-text-decoration-color--hover,
    var(--navbar-root-text-decoration-color)
  );
}
.app-nav > ul > li > a:not(:last-child),
.app-nav > ul > li > span:not(:last-child) {
  padding: var(--navbar-menu-root-padding, var(--navbar-root-padding));
  background: var(--navbar-menu-root-background, var(--navbar-root-background));
}
.app-nav > ul > li > a:not(:last-child):hover,
.app-nav > ul > li > span:not(:last-child):hover {
  background: var(
    --navbar-menu-root-background--hover,
    var(
      --navbar-menu-root-background,
      var(--navbar-root-background--hover, var(--navbar-root-background))
    )
  );
}
.app-nav > ul > li > a.active {
  background: var(--navbar-root-background--active, var(--navbar-root-background));
  border-style: var(--navbar-root-border-style--active, var(--navbar-root-border-style));
  border-color: var(--navbar-root-border-color--active, var(--navbar-root-border-color));
  color: var(--navbar-root-color--active, var(--navbar-root-color));
  -webkit-text-decoration: var(
    --navbar-root-text-decoration--active,
    var(--navbar-root-text-decoration)
  );
  text-decoration: var(
    --navbar-root-text-decoration--active,
    var(--navbar-root-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-root-text-decoration-color--active,
    var(--navbar-root-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-root-text-decoration-color--active,
    var(--navbar-root-text-decoration-color)
  );
}
.app-nav > ul > li > a.active:not(:last-child):hover {
  background: var(
    --navbar-menu-root-background--active,
    var(
      --navbar-menu-root-background,
      var(--navbar-root-background--active, var(--navbar-root-background))
    )
  );
}
.app-nav > ul > li ul {
  visibility: hidden;
  position: absolute;
  top: 100%;
  right: 50%;
  overflow-y: auto;
  box-sizing: border-box;
  max-height: 50vh;
  padding: var(--navbar-menu-padding);
  border-width: var(--navbar-menu-border-width, 0);
  border-style: solid;
  border-color: var(--navbar-menu-border-color);
  border-radius: var(--navbar-menu-border-radius);
  background: var(--navbar-menu-background);
  box-shadow: var(--navbar-menu-box-shadow);
  text-align: left;
  white-space: nowrap;
  opacity: 0;
  transform: translate(50%, -0.35em);
  transition: var(--navbar-menu-transition);
}
.app-nav > ul > li ul li {
  white-space: nowrap;
}
.app-nav > ul > li ul a {
  margin: var(--navbar-menu-link-margin);
  padding: var(--navbar-menu-link-padding);
  border-width: var(--navbar-menu-link-border-width, 0);
  border-style: var(--navbar-menu-link-border-style);
  border-color: var(--navbar-menu-link-border-color);
  border-radius: var(--navbar-menu-link-border-radius);
  background: var(--navbar-menu-link-background);
  color: var(--navbar-menu-link-color);
  -webkit-text-decoration: var(--navbar-menu-link-text-decoration);
  text-decoration: var(--navbar-menu-link-text-decoration);
  -webkit-text-decoration-color: var(--navbar-menu-link-text-decoration-color);
  text-decoration-color: var(--navbar-menu-link-text-decoration-color);
}
.app-nav > ul > li ul a:hover {
  background: var(
    --navbar-menu-link-background--hover,
    var(--navbar-menu-link-background)
  );
  border-style: var(
    --navbar-menu-link-border-style--hover,
    var(--navbar-menu-link-border-style)
  );
  border-color: var(
    --navbar-menu-link-border-color--hover,
    var(--navbar-menu-link-border-color)
  );
  color: var(--navbar-menu-link-color--hover, var(--navbar-menu-link-color));
  -webkit-text-decoration: var(
    --navbar-menu-link-text-decoration--hover,
    var(--navbar-menu-link-text-decoration)
  );
  text-decoration: var(
    --navbar-menu-link-text-decoration--hover,
    var(--navbar-menu-link-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--hover,
    var(--navbar-menu-link-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--hover,
    var(--navbar-menu-link-text-decoration-color)
  );
}
.app-nav > ul > li ul a.active {
  background: var(
    --navbar-menu-link-background--active,
    var(--navbar-menu-link-background)
  );
  border-style: var(
    --navbar-menu-link-border-style--active,
    var(--navbar-menu-link-border-style)
  );
  border-color: var(
    --navbar-menu-link-border-color--active,
    var(--navbar-menu-link-border-color)
  );
  color: var(--navbar-menu-link-color--active, var(--navbar-menu-link-color));
  -webkit-text-decoration: var(
    --navbar-menu-link-text-decoration--active,
    var(--navbar-menu-link-text-decoration)
  );
  text-decoration: var(
    --navbar-menu-link-text-decoration--active,
    var(--navbar-menu-link-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--active,
    var(--navbar-menu-link-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--active,
    var(--navbar-menu-link-text-decoration-color)
  );
}
.app-nav > ul > li:hover ul,
.app-nav > ul > li:focus ul,
.app-nav > ul > li.focus-within ul {
  visibility: visible;
  opacity: 1;
  transform: translate(50%, 0);
}
@media (min-width: 48em) {
  nav.app-nav {
    margin-left: var(--sidebar-width);
  }
}
main {
  position: relative;
  overflow-x: hidden;
  min-height: 100vh;
}
.sidebar,
.sidebar-toggle,
.sidebar + .content {
  transition: all var(--sidebar-transition-duration) ease-out;
}
@media (min-width: 48em) {
  .sidebar + .content {
    margin-left: var(--sidebar-width);
  }
}
.sidebar {
  display: flex;
  flex-direction: column;
  position: fixed;
  z-index: 10;
  top: 0;
  right: 100%;
  overflow-x: hidden;
  overflow-y: auto;
  height: 100vh;
  width: var(--sidebar-width);
  padding: var(--sidebar-padding);
  border-width: var(--sidebar-border-width);
  border-style: solid;
  border-color: var(--sidebar-border-color);
  background: var(--sidebar-background);
}
.sidebar > h1 {
  margin: 0;
  margin: var(--sidebar-name-margin);
  padding: var(--sidebar-name-padding);
  background: var(--sidebar-name-background);
  color: var(--sidebar-name-color);
  font-family: var(--sidebar-name-font-family);
  font-size: var(--sidebar-name-font-size);
  font-weight: var(--sidebar-name-font-weight);
  text-align: var(--sidebar-name-text-align);
}
.sidebar > h1 img {
  max-width: 100%;
}
.sidebar > h1 .app-name-link {
  color: var(--sidebar-name-color);
}
body:not([data-platform^='Mac']) .sidebar::-webkit-scrollbar {
  width: 5px;
}
body:not([data-platform^='Mac']) .sidebar::-webkit-scrollbar-thumb {
  border-radius: 50vw;
}
@media (min-width: 48em) {
  .sidebar {
    position: absolute;
    transform: translateX(var(--sidebar-width));
  }
}
@media print {
  .sidebar {
    display: none;
  }
}
.sidebar-nav,
.sidebar nav {
  order: 1;
  margin: var(--sidebar-nav-margin);
  padding: var(--sidebar-nav-padding);
  background: var(--sidebar-nav-background);
}
.sidebar-nav ul,
.sidebar nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
.sidebar-nav ul ul,
.sidebar nav ul ul {
  margin-left: var(--sidebar-nav-indent);
}
.sidebar-nav a,
.sidebar nav a {
  display: block;
  overflow: hidden;
  margin: var(--sidebar-nav-link-margin);
  padding: var(--sidebar-nav-link-padding);
  border-width: var(--sidebar-nav-link-border-width, 0);
  border-style: var(--sidebar-nav-link-border-style);
  border-color: var(--sidebar-nav-link-border-color);
  border-radius: var(--sidebar-nav-link-border-radius);
  background: var(--sidebar-nav-link-background);
  color: var(--sidebar-nav-link-color);
  font-weight: var(--sidebar-nav-link-font-weight);
  white-space: nowrap;
  -webkit-text-decoration: var(--sidebar-nav-link-text-decoration);
  text-decoration: var(--sidebar-nav-link-text-decoration);
  -webkit-text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-overflow: ellipsis;
  transition: var(--sidebar-nav-link-transition);
}
.sidebar-nav a img,
.sidebar nav a img {
  margin-top: -0.25em;
  vertical-align: middle;
}
.sidebar-nav a img:first-child,
.sidebar nav a img:first-child {
  margin-right: 0.5em;
}
.sidebar-nav a:hover,
.sidebar nav a:hover {
  border-width: var(
    --sidebar-nav-link-border-width--hover,
    var(--sidebar-nav-link-border-width, 0)
  );
  border-style: var(
    --sidebar-nav-link-border-style--hover,
    var(--sidebar-nav-link-border-style)
  );
  border-color: var(
    --sidebar-nav-link-border-color--hover,
    var(--sidebar-nav-link-border-color)
  );
  background: var(
    --sidebar-nav-link-background--hover,
    var(--sidebar-nav-link-background)
  );
  color: var(--sidebar-nav-link-color--hover, var(--sidebar-nav-link-color));
  font-weight: var(
    --sidebar-nav-link-font-weight--hover,
    var(--sidebar-nav-link-font-weight)
  );
  -webkit-text-decoration: var(
    --sidebar-nav-link-text-decoration--hover,
    var(--sidebar-nav-link-text-decoration)
  );
  text-decoration: var(
    --sidebar-nav-link-text-decoration--hover,
    var(--sidebar-nav-link-text-decoration)
  );
  -webkit-text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
}
.sidebar-nav ul > li > span,
.sidebar-nav ul > li > strong,
.sidebar nav ul > li > span,
.sidebar nav ul > li > strong {
  display: block;
  margin: var(--sidebar-nav-strong-margin);
  padding: var(--sidebar-nav-strong-padding);
  border-width: var(--sidebar-nav-strong-border-width, 0);
  border-style: solid;
  border-color: var(--sidebar-nav-strong-border-color);
  color: var(--sidebar-nav-strong-color);
  font-size: var(--sidebar-nav-strong-font-size);
  font-weight: var(--sidebar-nav-strong-font-weight);
  text-transform: var(--sidebar-nav-strong-text-transform);
}
.sidebar-nav ul > li > span + ul,
.sidebar-nav ul > li > strong + ul,
.sidebar nav ul > li > span + ul,
.sidebar nav ul > li > strong + ul {
  margin-left: 0;
}
.sidebar-nav ul > li:first-child > span,
.sidebar-nav ul > li:first-child > strong,
.sidebar nav ul > li:first-child > span,
.sidebar nav ul > li:first-child > strong {
  margin-top: 0;
}
.sidebar-nav::-webkit-scrollbar,
.sidebar nav::-webkit-scrollbar {
  width: 0;
}
@supports (width: env(safe-area-inset)) {
  @media only screen and (orientation: landscape) {
    .sidebar-nav,
    .sidebar nav {
      margin-left: calc(env(safe-area-inset-left) / 2);
    }
  }
}
.sidebar-nav li > a:before,
.sidebar-nav li > strong:before {
  display: inline-block;
}
.sidebar-nav li > a {
  background-repeat: var(--sidebar-nav-pagelink-background-repeat);
  background-size: var(--sidebar-nav-pagelink-background-size);
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']),
.sidebar-nav li > a[href^='#/']:not([href*='?id=']) {
  transition: var(--sidebar-nav-pagelink-transition);
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']),
.sidebar-nav li > a[href^='/']:not([href*='?id=']) ~ ul a,
.sidebar-nav li > a[href^='#/']:not([href*='?id=']),
.sidebar-nav li > a[href^='#/']:not([href*='?id=']) ~ ul a {
  padding: var(--sidebar-nav-pagelink-padding, var(--sidebar-nav-link-padding));
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']):only-child,
.sidebar-nav li > a[href^='#/']:not([href*='?id=']):only-child {
  background: var(--sidebar-nav-pagelink-background);
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']):not(:only-child),
.sidebar-nav li > a[href^='#/']:not([href*='?id=']):not(:only-child) {
  background: var(
    --sidebar-nav-pagelink-background--loaded,
    var(--sidebar-nav-pagelink-background)
  );
}
.sidebar-nav li.active > a,
.sidebar-nav li.collapse > a {
  border-width: var(
    --sidebar-nav-link-border-width--active,
    var(--sidebar-nav-link-border-width)
  );
  border-style: var(
    --sidebar-nav-link-border-style--active,
    var(--sidebar-nav-link-border-style)
  );
  border-color: var(
    --sidebar-nav-link-border-color--active,
    var(--sidebar-nav-link-border-color)
  );
  background: var(
    --sidebar-nav-link-background--active,
    var(--sidebar-nav-link-background)
  );
  color: var(--sidebar-nav-link-color--active, var(--sidebar-nav-link-color));
  font-weight: var(
    --sidebar-nav-link-font-weight--active,
    var(--sidebar-nav-link-font-weight)
  );
  -webkit-text-decoration: var(
    --sidebar-nav-link-text-decoration--active,
    var(--sidebar-nav-link-text-decoration)
  );
  text-decoration: var(
    --sidebar-nav-link-text-decoration--active,
    var(--sidebar-nav-link-text-decoration)
  );
  -webkit-text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
}
.sidebar-nav li.active > a[href^='/']:not([href*='?id=']):not(:only-child),
.sidebar-nav li.active > a[href^='#/']:not([href*='?id=']):not(:only-child) {
  background: var(
    --sidebar-nav-pagelink-background--active,
    var(
      --sidebar-nav-pagelink-background--loaded,
      var(--sidebar-nav-pagelink-background)
    )
  );
}
.sidebar-nav li.collapse > a[href^='/']:not([href*='?id=']):not(:only-child),
.sidebar-nav li.collapse > a[href^='#/']:not([href*='?id=']):not(:only-child) {
  background: var(
    --sidebar-nav-pagelink-background--collapse,
    var(
      --sidebar-nav-pagelink-background--loaded,
      var(--sidebar-nav-pagelink-background)
    )
  );
}
.sidebar-nav li.collapse .app-sub-sidebar {
  display: none;
}
.sidebar-nav > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l1,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l1,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l1, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l1--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l1, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l1--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l1, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > ul > li > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l2,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l2,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l2, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l2--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l2, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l2--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l2, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > ul > li > ul > li > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l3,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l3,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l3, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li > ul > li > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l3--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l3, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l3--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l3, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > ul > li > ul > li > ul > li > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l4,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l4,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l4, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li > ul > li > ul > li > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l4--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l4, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l4--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l4, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > :last-child {
  margin-bottom: 2rem;
}
.sidebar-toggle,
.sidebar-toggle-button {
  width: var(--sidebar-toggle-width);
  outline: none;
}
.sidebar-toggle {
  position: fixed;
  z-index: 11;
  top: 0;
  bottom: 0;
  left: 0;
  max-width: 40px;
  margin: 0;
  padding: 0;
  border: 0;
  background: rgba(0, 0, 0, 0);
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  cursor: pointer;
}
.sidebar-toggle .sidebar-toggle-button {
  position: absolute;
  top: var(--sidebar-toggle-offset-top);
  left: var(--sidebar-toggle-offset-left);
  height: var(--sidebar-toggle-height);
  border-radius: var(--sidebar-toggle-border-radius);
  border-width: var(--sidebar-toggle-border-width);
  border-style: var(--sidebar-toggle-border-style);
  border-color: var(--sidebar-toggle-border-color);
  background: var(--sidebar-toggle-background, transparent);
  color: var(--sidebar-toggle-icon-color);
}
.sidebar-toggle span {
  position: absolute;
  top: calc(50% - var(--sidebar-toggle-icon-stroke-width) / 2);
  left: calc(50% - var(--sidebar-toggle-icon-width) / 2);
  height: var(--sidebar-toggle-icon-stroke-width);
  width: var(--sidebar-toggle-icon-width);
  background-color: currentColor;
}
.sidebar-toggle span:nth-child(1) {
  margin-top: calc(0px - var(--sidebar-toggle-icon-height) / 2);
}
.sidebar-toggle span:nth-child(3) {
  margin-top: calc(var(--sidebar-toggle-icon-height) / 2);
}
@media (min-width: 48em) {
  .sidebar-toggle {
    position: absolute;
    overflow: visible;
    top: var(--sidebar-toggle-offset-top);
    bottom: auto;
    left: 0;
    height: var(--sidebar-toggle-height);
    transform: translateX(var(--sidebar-width));
  }
  .sidebar-toggle .sidebar-toggle-button {
    top: 0;
  }
}
@media print {
  .sidebar-toggle {
    display: none;
  }
}
@media (max-width: 47.99em) {
  body.close .sidebar,
  body.close .sidebar-toggle,
  body.close .sidebar + .content {
    transform: translateX(var(--sidebar-width));
  }
}
@media (min-width: 48em) {
  body.close .sidebar + .content {
    transform: translateX(0);
  }
}
@media (max-width: 47.99em) {
  body.close nav.app-nav,
  body.close .github-corner {
    display: none;
  }
}
@media (min-width: 48em) {
  body.close .sidebar,
  body.close .sidebar-toggle {
    transform: translateX(0);
  }
}
@media (min-width: 48em) {
  body.close nav.app-nav {
    margin-left: 0;
  }
}
@media (max-width: 47.99em) {
  body.close .sidebar-toggle {
    width: 100%;
    max-width: none;
  }
  body.close .sidebar-toggle span {
    margin-top: 0;
  }
  body.close .sidebar-toggle span:nth-child(1) {
    transform: rotate(45deg);
  }
  body.close .sidebar-toggle span:nth-child(2) {
    display: none;
  }
  body.close .sidebar-toggle span:nth-child(3) {
    transform: rotate(-45deg);
  }
}
@media (min-width: 48em) {
  body.close .sidebar + .content {
    margin-left: 0;
  }
}
@media (min-width: 48em) {
  body.sticky .sidebar,
  body.sticky .sidebar-toggle {
    position: fixed;
  }
}
body .docsify-copy-code-button,
body .docsify-copy-code-button:after {
  border-radius: var(--border-radius-m, 0);
  border-top-left-radius: 0;
  border-bottom-right-radius: 0;
  background: var(--copycode-background);
  color: var(--copycode-color);
}
body .docsify-copy-code-button span {
  border-radius: var(--border-radius-s, 0);
}
body .docsify-pagination-container {
  border-top: var(--pagination-border-top);
  color: var(--pagination-color);
}
body .pagination-item-label {
  font-size: var(--pagination-label-font-size);
}
body .pagination-item-label svg {
  color: var(--pagination-label-color);
  height: var(--pagination-chevron-height);
  stroke: var(--pagination-chevron-stroke);
  stroke-linecap: var(--pagination-chevron-stroke-linecap);
  stroke-linejoin: var(--pagination-chevron-stroke-linecap);
  stroke-width: var(--pagination-chevron-stroke-width);
}
body .pagination-item-title {
  color: var(--pagination-title-color);
  font-size: var(--pagination-title-font-size);
}
body .app-name.hide {
  display: block;
}
body .sidebar {
  padding: var(--sidebar-padding);
}
.sidebar .search {
  margin: 0;
  padding: 0;
  border: 0;
}
.sidebar .search input {
  padding: 0;
  line-height: 1;
  font-size: inherit;
}
.sidebar .search .clear-button {
  width: auto;
}
.sidebar .search .clear-button svg {
  transform: scale(1);
}
.sidebar .search .matching-post {
  border: none;
}
.sidebar .search p {
  font-size: inherit;
}
.sidebar .search {
  order: var(--search-flex-order);
  margin: var(--search-margin);
  padding: var(--search-padding);
  background: var(--search-background);
}
.sidebar .search a {
  color: inherit;
}
.sidebar .search h2 {
  margin: var(--search-result-heading-margin);
  font-size: var(--search-result-heading-font-size);
  font-weight: var(--search-result-heading-font-weight);
  color: var(--search-result-heading-color);
}
.sidebar .search .input-wrap {
  align-items: stretch;
  margin: var(--search-input-margin);
  background-color: var(--search-input-background-color);
  border-width: var(--search-input-border-width, 0);
  border-style: solid;
  border-color: var(--search-input-border-color);
  border-radius: var(--search-input-border-radius);
}
.sidebar .search input[type='search'] {
  min-width: 0;
  padding: var(--search-input-padding);
  border: none;
  background-color: rgba(0, 0, 0, 0);
  background-image: var(--search-input-background-image);
  background-position: var(--search-input-background-position);
  background-repeat: var(--search-input-background-repeat);
  background-size: var(--search-input-background-size);
  font-size: var(--search-input-font-size);
  color: var(--search-input-color);
  transition: var(--search-input-transition);
}
.sidebar .search input[type='search']::-ms-clear {
  display: none;
}
.sidebar .search input[type='search']::-moz-placeholder {
  color: var(--search-input-placeholder-color, #808080);
}
.sidebar .search input[type='search']::placeholder {
  color: var(--search-input-placeholder-color, #808080);
}
.sidebar .search input[type='search']::-webkit-input-placeholder {
  line-height: normal;
}
.sidebar .search input[type='search']:focus {
  background-color: var(
    --search-input-background-color--focus,
    var(--search-input-background-color)
  );
  background-image: var(
    --search-input-background-image--focus,
    var(--search-input-background-image)
  );
  background-position: var(
    --search-input-background-position--focus,
    var(--search-input-background-position)
  );
  background-size: var(
    --search-input-background-size--focus,
    var(--search-input-background-size)
  );
}
@supports (width: env(safe-area-inset)) {
  @media only screen and (orientation: landscape) {
    .sidebar .search input[type='search'] {
      margin-left: calc(env(safe-area-inset-left) / 2);
    }
  }
}
.sidebar .search p {
  overflow: hidden;
  text-overflow: ellipsis;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}
.sidebar .search p:empty {
  text-align: center;
}
.sidebar .search .clear-button {
  margin: 0;
  padding: 0 10px;
  border: none;
  line-height: 1;
  background: rgba(0, 0, 0, 0);
  cursor: pointer;
}
.sidebar .search .clear-button svg circle {
  fill: var(--search-clear-icon-color1, #808080);
}
.sidebar .search .clear-button svg path {
  stroke: var(--search-clear-icon-color2, #fff);
}
.sidebar .search.show ~ *:not(h1) {
  display: none;
}
.sidebar .search .results-panel {
  display: none;
  color: var(--search-result-item-color);
  font-size: var(--search-result-item-font-size);
  font-weight: var(--search-result-item-font-weight);
}
.sidebar .search .results-panel.show {
  display: block;
}
.sidebar .search .matching-post {
  margin: var(--search-result-item-margin);
  padding: var(--search-result-item-padding);
}
.sidebar .search .matching-post,
.sidebar .search .matching-post:last-child {
  border-width: var(--search-result-item-border-width, 0) !important;
  border-style: var(--search-result-item-border-style);
  border-color: var(--search-result-item-border-color);
}
.sidebar .search .matching-post p {
  margin: 0;
}
.sidebar .search .search-keyword {
  margin: var(--search-result-keyword-margin);
  padding: var(--search-result-keyword-padding);
  border-radius: var(--search-result-keyword-border-radius);
  background-color: var(--search-result-keyword-background);
  color: var(--search-result-keyword-color, currentColor);
  font-style: normal;
  font-weight: var(--search-result-keyword-font-weight);
}
.medium-zoom-overlay,
.medium-zoom-image--open,
.medium-zoom-image--opened {
  z-index: 2147483646 !important;
}
.medium-zoom-overlay {
  background: var(--zoomimage-overlay-background) !important;
}
:root {
  --mono-hue: 113;
  --mono-saturation: 0%;
  --mono-shade3: hsl(var(--mono-hue), var(--mono-saturation), 20%);
  --mono-shade2: hsl(var(--mono-hue), var(--mono-saturation), 30%);
  --mono-shade1: hsl(var(--mono-hue), var(--mono-saturation), 40%);
  --mono-base: hsl(var(--mono-hue), var(--mono-saturation), 50%);
  --mono-tint1: hsl(var(--mono-hue), var(--mono-saturation), 70%);
  --mono-tint2: hsl(var(--mono-hue), var(--mono-saturation), 89%);
  --mono-tint3: hsl(var(--mono-hue), var(--mono-saturation), 97%);
  --theme-hue: 204;
  --theme-saturation: 90%;
  --theme-lightness: 45%;
  --theme-color: hsl(var(--theme-hue), var(--theme-saturation), var(--theme-lightness));
  --modular-scale: 1.333;
  --modular-scale--2: calc(var(--modular-scale--1) / var(--modular-scale));
  --modular-scale--1: calc(var(--modular-scale-1) / var(--modular-scale));
  --modular-scale-1: 1rem;
  --modular-scale-2: calc(var(--modular-scale-1) * var(--modular-scale));
  --modular-scale-3: calc(var(--modular-scale-2) * var(--modular-scale));
  --modular-scale-4: calc(var(--modular-scale-3) * var(--modular-scale));
  --modular-scale-5: calc(var(--modular-scale-4) * var(--modular-scale));
  --font-size-xxxl: var(--modular-scale-5);
  --font-size-xxl: var(--modular-scale-4);
  --font-size-xl: var(--modular-scale-3);
  --font-size-l: var(--modular-scale-2);
  --font-size-m: var(--modular-scale-1);
  --font-size-s: var(--modular-scale--1);
  --font-size-xs: var(--modular-scale--2);
  --duration-slow: 1s;
  --duration-medium: 0.5s;
  --duration-fast: 0.25s;
  --spinner-size: 60px;
  --spinner-track-width: 4px;
  --spinner-track-color: rgba(0, 0, 0, 0.15);
  --spinner-transition-duration: var(--duration-medium);
}
:root {
  --base-background-color: #fff;
  --base-color: var(--mono-shade2);
  --base-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial,
    sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  --base-font-size: 16px;
  --base-font-weight: normal;
  --base-line-height: 1.7;
  --emoji-size: calc(var(--base-line-height) * 1em);
  --hr-border: 1px solid var(--mono-tint2);
  --mark-background: #ffecb3;
  --pre-font-family: var(--code-font-family);
  --pre-font-size: var(--code-font-size);
  --pre-font-weight: normal;
  --selection-color: #b4d5fe;
  --small-font-size: var(--font-size-s);
  --strong-color: var(--heading-color);
  --strong-font-weight: 600;
  --subsup-font-size: var(--font-size-s);
}
:root {
  --content-max-width: 55em;
  --blockquote-background: var(--mono-tint3);
  --blockquote-border-style: solid;
  --blockquote-border-radius: var(--border-radius-m);
  --blockquote-em-font-weight: normal;
  --blockquote-font-weight: normal;
  --blockquote-padding: 1.5em;
  --code-font-family: Inconsolata, Consolas, Menlo, Monaco, 'Andale Mono WT',
    'Andale Mono', 'Lucida Console', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono',
    'Courier New', Courier, monospace;
  --code-font-size: calc(var(--font-size-m) * 0.95);
  --code-font-weight: normal;
  --code-tab-size: 4;
  --code-block-border-radius: var(--border-radius-m);
  --code-block-line-height: var(--base-line-height);
  --code-block-margin: 1em 0;
  --code-block-padding: 1.75em 1.5em 1.5em 1.5em;
  --code-inline-background: var(--code-theme-background);
  --code-inline-border-radius: var(--border-radius-s);
  --code-inline-color: var(--code-theme-text);
  --code-inline-margin: 0 0.15em;
  --code-inline-padding: 0.125em 0.4em;
  --code-theme-background: var(--mono-tint3);
  --heading-color: var(--mono-shade3);
  --heading-margin: 2.5rem 0 0;
  --heading-h1-border-style: solid;
  --heading-h1-font-size: var(--font-size-xxl);
  --heading-h2-border-style: solid;
  --heading-h2-font-size: var(--font-size-xl);
  --heading-h3-border-style: solid;
  --heading-h3-font-size: var(--font-size-l);
  --heading-h4-border-style: solid;
  --heading-h4-font-size: var(--font-size-m);
  --heading-h5-border-style: solid;
  --heading-h5-font-size: var(--font-size-s);
  --heading-h6-border-style: solid;
  --heading-h6-font-size: var(--font-size-xs);
  --kbd-background: var(--mono-tint3);
  --kbd-border-radius: var(--border-radius-m);
  --kbd-margin: 0 0.3em;
  --kbd-min-width: 2.5em;
  --kbd-padding: 0.65em 0.5em;
  --link-text-decoration: underline;
  --notice-background: var(--mono-tint3);
  --notice-border-radius: var(--border-radius-m);
  --notice-border-style: solid;
  --notice-font-weight: normal;
  --notice-padding: 1em 1.5em;
  --notice-before-font-weight: normal;
  --table-cell-padding: 0.75em 0.5em;
  --table-head-border-color: var(--table-cell-border-color);
  --table-head-font-weight: var(--strong-font-weight);
  --table-row-odd-background: var(--mono-tint3);
}
:root {
  --cover-margin: 0 auto;
  --cover-max-width: 40em;
  --cover-text-align: center;
  --cover-background-color: var(--base-background-color);
  --cover-background-mask-color: var(--base-background-color);
  --cover-background-mask-opacity: 0.8;
  --cover-background-position: center center;
  --cover-background-repeat: no-repeat;
  --cover-background-size: cover;
  --cover-blockquote-font-size: var(--font-size-l);
  --cover-border-color: var(--theme-color);
  --cover-button-border: 1px solid var(--theme-color);
  --cover-button-border-radius: var(--border-radius-m);
  --cover-button-color: var(--theme-color);
  --cover-button-padding: 0.5em 2rem;
  --cover-button-text-decoration: none;
  --cover-button-transition: all var(--duration-fast) ease-in-out;
  --cover-button-primary-background: var(--theme-color);
  --cover-button-primary-border: 1px solid var(--theme-color);
  --cover-button-primary-color: #fff;
  --cover-heading-color: var(--theme-color);
  --cover-heading-font-size: var(--font-size-xxl);
  --cover-heading-font-weight: normal;
  --cover-link-text-decoration: underline;
}
:root {
  --navbar-root-border-style: solid;
  --navbar-root-margin: 0 0 0 1.5em;
  --navbar-root-transition: all var(--duration-fast);
  --navbar-menu-background: var(--base-background-color);
  --navbar-menu-border-radius: var(--border-radius-m);
  --navbar-menu-box-shadow: rgba(45, 45, 45, 0.05) 0px 0px 1px,
    rgba(49, 49, 49, 0.05) 0px 1px 2px, rgba(42, 42, 42, 0.05) 0px 2px 4px,
    rgba(32, 32, 32, 0.05) 0px 4px 8px, rgba(49, 49, 49, 0.05) 0px 8px 16px,
    rgba(35, 35, 35, 0.05) 0px 16px 32px;
  --navbar-menu-padding: 0.5em;
  --navbar-menu-transition: all var(--duration-fast);
  --navbar-menu-link-border-style: solid;
  --navbar-menu-link-margin: 0.75em 0.5em;
  --navbar-menu-link-padding: 0.2em 0;
}
:root {
  --copycode-background: #808080;
  --copycode-color: #fff;
}
:root {
  --docsifytabs-border-color: var(--mono-tint2);
  --docsifytabs-border-radius-px: var(--border-radius-s);
  --docsifytabs-tab-background: var(--mono-tint3);
  --docsifytabs-tab-color: var(--mono-tint1);
}
:root {
  --pagination-border-top: 1px solid var(--mono-tint2);
  --pagination-chevron-height: 0.8em;
  --pagination-chevron-stroke: currentColor;
  --pagination-chevron-stroke-linecap: round;
  --pagination-chevron-stroke-width: 1px;
  --pagination-label-font-size: var(--font-size-s);
  --pagination-title-font-size: var(--font-size-l);
}
:root {
  --search-margin: 1.5rem 0 0;
  --search-input-background-repeat: no-repeat;
  --search-input-border-color: var(--mono-tint1);
  --search-input-border-width: 1px;
  --search-input-padding: 0.5em;
  --search-flex-order: 1;
  --search-result-heading-color: var(--heading-color);
  --search-result-heading-font-size: var(--base-font-size);
  --search-result-heading-font-weight: normal;
  --search-result-heading-margin: 0 0 0.25em;
  --search-result-item-border-color: var(--mono-tint2);
  --search-result-item-border-style: solid;
  --search-result-item-border-width: 0 0 1px 0;
  --search-result-item-font-weight: normal;
  --search-result-item-padding: 1em 0;
  --search-result-keyword-background: var(--mark-background);
  --search-result-keyword-border-radius: var(--border-radius-s);
  --search-result-keyword-color: var(--mark-color);
  --search-result-keyword-font-weight: normal;
  --search-result-keyword-margin: 0 0.1em;
  --search-result-keyword-padding: 0.2em 0;
}
:root {
  --zoomimage-overlay-background: rgba(0, 0, 0, 0.875);
}
:root {
  --sidebar-background: var(--base-background-color);
  --sidebar-border-width: 0;
  --sidebar-padding: 0 25px;
  --sidebar-transition-duration: var(--duration-fast);
  --sidebar-width: 17rem;
  --sidebar-name-font-size: var(--font-size-l);
  --sidebar-name-font-weight: normal;
  --sidebar-name-margin: 1.5rem 0 0;
  --sidebar-name-text-align: center;
  --sidebar-nav-strong-border-color: var(--sidebar-border-color);
  --sidebar-nav-strong-color: var(--heading-color);
  --sidebar-nav-strong-font-weight: var(--strong-font-weight);
  --sidebar-nav-strong-margin: 1.5em 0 0.5em;
  --sidebar-nav-strong-padding: 0.25em 0;
  --sidebar-nav-indent: 1em;
  --sidebar-nav-margin: 1.5rem 0 0;
  --sidebar-nav-link-border-style: solid;
  --sidebar-nav-link-border-width: 0;
  --sidebar-nav-link-color: var(--base-color);
  --sidebar-nav-link-font-weight: normal;
  --sidebar-nav-link-padding: 0.25em 0;
  --sidebar-nav-link-text-decoration--active: underline;
  --sidebar-nav-link-text-decoration--hover: underline;
  --sidebar-nav-link-before-margin: 0 0.35em 0 0;
  --sidebar-nav-pagelink-transition: var(--sidebar-nav-link-transition);
  --sidebar-toggle-border-radius: var(--border-radius-s);
  --sidebar-toggle-border-style: solid;
  --sidebar-toggle-border-width: 0;
  --sidebar-toggle-height: 36px;
  --sidebar-toggle-icon-color: var(--base-color);
  --sidebar-toggle-icon-height: 10px;
  --sidebar-toggle-icon-stroke-width: 1px;
  --sidebar-toggle-icon-width: 16px;
  --sidebar-toggle-offset-left: 0;
  --sidebar-toggle-offset-top: calc(35px - (var(--sidebar-toggle-height) / 2));
  --sidebar-toggle-width: 44px;
}
:root {
  --code-theme-background: #f3f3f3;
  --code-theme-comment: #6e8090;
  --code-theme-function: #dd4a68;
  --code-theme-keyword: #07a;
  --code-theme-operator: #a67f59;
  --code-theme-punctuation: #999;
  --code-theme-selector: #690;
  --code-theme-tag: #905;
  --code-theme-text: #333;
  --code-theme-variable: #e90;
}
:root {
  --border-radius-s: 2px;
  --border-radius-m: 4px;
  --border-radius-l: 8px;
  --strong-font-weight: 600;
  --blockquote-border-color: var(--theme-color);
  --blockquote-border-radius: 0 var(--border-radius-m) var(--border-radius-m) 0;
  --blockquote-border-width: 0 0 0 4px;
  --code-inline-background: var(--mono-tint2);
  --code-theme-background: var(--mono-tint3);
  --heading-font-weight: var(--strong-font-weight);
  --heading-h1-font-weight: 400;
  --heading-h2-font-weight: 400;
  --heading-h2-border-color: var(--mono-tint2);
  --heading-h2-border-width: 0 0 1px 0;
  --heading-h2-margin: 2.5rem 0 1.5rem;
  --heading-h2-padding: 0 0 1rem 0;
  --kbd-border: 1px solid var(--mono-tint2);
  --notice-border-radius: 0 var(--border-radius-m) var(--border-radius-m) 0;
  --notice-border-width: 0 0 0 4px;
  --notice-padding: 1em 1.5em 1em 3em;
  --notice-before-border-radius: 100%;
  --notice-before-font-weight: bold;
  --notice-before-height: 1.5em;
  --notice-before-left: 0.75em;
  --notice-before-line-height: 1.5;
  --notice-before-margin: 0 0.25em 0 0;
  --notice-before-position: absolute;
  --notice-before-width: var(--notice-before-height);
  --notice-important-background: hsl(340, 60%, 96%);
  --notice-important-border-color: hsl(340, 90%, 45%);
  --notice-important-before-background: var(--notice-important-border-color)
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23fff'%3E%3Cpath d='M10 14C10 15.1 9.1 16 8 16 6.9 16 6 15.1 6 14 6 12.9 6.9 12 8 12 9.1 12 10 12.9 10 14Z'/%3E%3Cpath d='M10 1.6C10 1.2 9.8 0.9 9.6 0.7 9.2 0.3 8.6 0 8 0 7.4 0 6.8 0.2 6.5 0.6 6.2 0.9 6 1.2 6 1.6 6 1.7 6 1.8 6 1.9L6.8 9.6C6.9 9.9 7 10.1 7.2 10.2 7.4 10.4 7.7 10.5 8 10.5 8.3 10.5 8.6 10.4 8.8 10.3 9 10.1 9.1 9.9 9.2 9.6L10 1.9C10 1.8 10 1.7 10 1.6Z'/%3E%3C/svg%3E")
    center / 0.875em no-repeat;
  --notice-important-before-color: #fff;
  --notice-important-before-content: '';
  --notice-tip-background: hsl(204, 60%, 96%);
  --notice-tip-border-color: hsl(204, 90%, 45%);
  --notice-tip-before-background: var(--notice-tip-border-color)
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23fff'%3E%3Cpath d='M9.1 0C10.2 0 10.7 0.7 10.7 1.6 10.7 2.6 9.8 3.6 8.6 3.6 7.6 3.6 7 3 7 2 7 1.1 7.7 0 9.1 0Z'/%3E%3Cpath d='M5.8 16C5 16 4.4 15.5 5 13.2L5.9 9.1C6.1 8.5 6.1 8.2 5.9 8.2 5.7 8.2 4.6 8.6 3.9 9.1L3.5 8.4C5.6 6.6 7.9 5.6 8.9 5.6 9.8 5.6 9.9 6.6 9.5 8.2L8.4 12.5C8.2 13.2 8.3 13.5 8.5 13.5 8.7 13.5 9.6 13.2 10.4 12.5L10.9 13.2C8.9 15.2 6.7 16 5.8 16Z'/%3E%3C/svg%3E")
    center / 0.875em no-repeat;
  --notice-tip-before-color: #fff;
  --notice-tip-before-content: '';
  --table-cell-border-color: var(--mono-tint2);
  --table-cell-border-width: 1px 0;
  --cover-background-color: hsl(var(--theme-hue), 25%, 60%);
  --cover-background-image: radial-gradient(
    ellipse at center 115%,
    rgba(255, 255, 255, 0.9),
    transparent
  );
  --cover-blockquote-color: var(--strong-color);
  --cover-heading-color: #fff;
  --cover-heading-font-size-max: 56;
  --cover-heading-font-size-min: 34;
  --cover-heading-font-weight: 200;
  --navbar-root-color--active: var(--theme-color);
  --navbar-menu-border-radius: var(--border-radius-m);
  --navbar-menu-root-background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='9.6' height='6' viewBox='0 0 9.6 6'%3E%3Cpath d='M1.5 1.5l3.3 3 3.3-3' stroke-width='1.5' stroke='rgb%28179, 179, 179%29' fill='none' stroke-linecap='square' stroke-linejoin='miter' vector-effect='non-scaling-stroke'/%3E%3C/svg%3E")
    right no-repeat;
  --navbar-menu-root-padding: 0 18px 0 0;
  --search-input-background-color: #fff;
  --search-input-background-image: url("data:image/svg+xml,%3Csvg height='20px' width='20px' viewBox='0 0 24 24' fill='none' stroke='rgba(0, 0, 0, 0.3)' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round' preserveAspectRatio='xMidYMid meet' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='10.5' cy='10.5' r='7.5' vector-effect='non-scaling-stroke'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='15.8' y2='15.8' vector-effect='non-scaling-stroke'%3E%3C/line%3E%3C/svg%3E");
  --search-input-background-position: 21px center;
  --search-input-border-color: var(--sidebar-border-color);
  --search-input-border-width: 1px 0;
  --search-input-margin: 0 -25px;
  --search-input-padding: 0.65em 1em 0.65em 50px;
  --search-input-placeholder-color: rgba(0, 0, 0, 0.4);
  --search-clear-icon-color1: rgba(0, 0, 0, 0.3);
  --search-result-heading-font-weight: var(--strong-font-weight);
  --search-result-item-border-color: var(--sidebar-border-color);
  --search-result-keyword-border-radius: var(--border-radius-s);
  --sidebar-background: var(--mono-tint3);
  --sidebar-border-color: var(--mono-tint2);
  --sidebar-border-width: 0 1px 0 0;
  --sidebar-name-color: var(--theme-color);
  --sidebar-name-font-weight: 300;
  --sidebar-nav-strong-border-width: 0 0 1px 0;
  --sidebar-nav-strong-font-size: smaller;
  --sidebar-nav-strong-margin: 2em -25px 0.75em 0;
  --sidebar-nav-strong-padding: 0.25em 0 0.75em 0;
  --sidebar-nav-strong-text-transform: uppercase;
  --sidebar-nav-link-border-color: transparent;
  --sidebar-nav-link-border-color--active: var(--theme-color);
  --sidebar-nav-link-border-width: 0 4px 0 0;
  --sidebar-nav-link-color--active: var(--theme-color);
  --sidebar-nav-link-margin: 0 -25px 0 0;
  --sidebar-nav-link-text-decoration: none;
  --sidebar-nav-link-text-decoration--active: none;
  --sidebar-nav-link-text-decoration--hover: underline;
  --sidebar-nav-pagelink-background: no-repeat 2px calc(50% - 2.5px) / 6px 5px
      linear-gradient(
        45deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4px
      ),
    no-repeat 2px calc(50% + 2.5px) / 6px 5px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4px
      );
  --sidebar-nav-pagelink-background--active: no-repeat 0px center / 5px 6px
      linear-gradient(
        225deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4.25px
      ),
    no-repeat 5px center / 5px 6px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4.25px
      );
  --sidebar-nav-pagelink-background--collapse: no-repeat 2px calc(50% - 2.5px) / 6px 5px
      linear-gradient(
        45deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4px
      ),
    no-repeat 2px calc(50% + 2.5px) / 6px 5px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4px
      );
  --sidebar-nav-pagelink-background--loaded: no-repeat 0px center / 5px 6px
      linear-gradient(
        225deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4.25px
      ),
    no-repeat 5px center / 5px 6px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4.25px
      );
  --sidebar-nav-pagelink-padding: 0.25em 0 0.25em 20px;
  --sidebar-nav-pagelink-transition: none;
  --sidebar-toggle-background: var(--sidebar-border-color);
  --sidebar-toggle-border-radius: 0 var(--border-radius-s) var(--border-radius-s) 0;
  --sidebar-toggle-width: 32px;
}
:root {
  --code-theme-background: #222;
  --code-theme-comment: #516e7a;
  --code-theme-function: #f07178;
  --code-theme-keyword: #c2e78c;
  --code-theme-operator: #ffcb6b;
  --code-theme-punctuation: #89ddff;
  --code-theme-selector: #ffcb6b;
  --code-theme-tag: #f07178;
  --code-theme-text: #f3f3f3;
  --code-theme-variable: #ffcb6b;
}
:root {
  --mono-hue: 201;
  --mono-saturation: 18%;
  --mono-shade3: hsl(var(--mono-hue), var(--mono-saturation), 13%);
  --mono-shade2: hsl(var(--mono-hue), var(--mono-saturation), 15%);
  --mono-shade1: hsl(var(--mono-hue), var(--mono-saturation), 17%);
  --mono-base: hsl(var(--mono-hue), var(--mono-saturation), 19%);
  --mono-tint1: hsl(var(--mono-hue), var(--mono-saturation), 25%);
  --mono-tint2: hsl(var(--mono-hue), var(--mono-saturation), 35%);
  --mono-tint3: hsl(var(--mono-hue), var(--mono-saturation), 43%);
  --spinner-track-color: rgba(255, 255, 255, 0.15);
  --base-background-color: var(--mono-base);
  --base-color: #d3d3d3;
  --hr-border: 1px solid var(--mono-tint2);
  --mark-background: #ffcb6b;
  --mark-color: var(--base-background-color);
  --selection-color: rgba(94, 131, 175, 0.75);
  --blockquote-background: var(--mono-shade2);
  --code-inline-background: var(--mono-tint1);
  --code-theme-background: var(--mono-shade2);
  --heading-color: #fff;
  --heading-h2-border-color: var(--mono-tint2);
  --kbd-background: var(--mono-shade2);
  --kbd-border: none;
  --kbd-color: var(--strong-color);
  --notice-important-background: var(--mono-shade2);
  --notice-tip-background: var(--mono-shade2);
  --table-cell-border-color: var(--mono-tint1);
  --table-row-odd-background: var(--mono-shade2);
  --cover-background-color: var(--base-background-color);
  --cover-background-image: radial-gradient(
    ellipse at center bottom,
    var(--mono-tint3),
    transparent
  );
  --cover-blockquote-color: var(--mark-background);
  --cover-button-border: 1px solid var(--mono-tint3);
  --cover-button-color: #fff;
  --navbar-menu-background: var(--mono-tint1);
  --navbar-menu-box-shadow: rgba(0, 0, 0, 0.05) 0px 0px 1px,
    rgba(0, 0, 0, 0.05) 0px 1px 2px, rgba(0, 0, 0, 0.05) 0px 2px 4px,
    rgba(0, 0, 0, 0.05) 0px 4px 8px, rgba(0, 0, 0, 0.05) 0px 8px 16px,
    rgba(0, 0, 0, 0.05) 0px 16px 32px;
  --copycode-background: var(--mono-tint1);
  --copycode-color: #fff;
  --docsifytabs-border-color: var(--mono-tint2);
  --docsifytabs-tab-background: var(--mono-shade1);
  --docsifytabs-tab-color: var(--mono-tint2);
  --pagination-border-top: 1px solid var(--mono-tint2);
  --pagination-title-color: #fff;
  --search-input-background-color: var(--mono-shade2);
  --search-input-background-image: url("data:image/svg+xml,%3Csvg height='20px' width='20px' viewBox='0 0 24 24' fill='none' stroke='rgba(255, 255, 255, 0.3)' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round' preserveAspectRatio='xMidYMid meet' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='10.5' cy='10.5' r='7.5' vector-effect='non-scaling-stroke'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='15.8' y2='15.8' vector-effect='non-scaling-stroke'%3E%3C/line%3E%3C/svg%3E");
  --search-input-border-color: var(--mono-tint1);
  --search-input-placeholder-color: rgba(255, 255, 255, 0.4);
  --search-clear-icon-color1: rgba(255, 255, 255, 0.3);
  --sidebar-background: var(--mono-shade1);
  --sidebar-border-color: var(--mono-tint1);
  --sidebar-nav-pagelink-background: no-repeat 2px calc(50% - 2.5px) / 6px 5px
      linear-gradient(
        45deg,
        transparent 2.75px,
        var(--mono-tint2) 2.75px 4.25px,
        transparent 4px
      ),
    no-repeat 2px calc(50% + 2.5px) / 6px 5px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--mono-tint2) 2.75px 4.25px,
        transparent 4px
      );
  --sidebar-nav-pagelink-background--loaded: no-repeat 0px center / 5px 6px
      linear-gradient(
        225deg,
        transparent 2.75px,
        var(--mono-tint2) 2.75px 4.25px,
        transparent 4.25px
      ),
    no-repeat 5px center / 5px 6px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--mono-tint2) 2.75px 4.25px,
        transparent 4.25px
      );
}

/*# sourceMappingURL=theme-simple-dark.css.map */



================================================
FILE: docs/css/theme-simple.css
================================================
.github-corner {
  position: absolute;
  z-index: 40;
  top: 0;
  right: 0;
  border-bottom: 0;
  text-decoration: none;
}
.github-corner svg {
  height: 70px;
  width: 70px;
  fill: var(--theme-color);
  color: var(--base-background-color);
}
.github-corner:hover .octo-arm {
  -webkit-animation: octocat-wave 560ms ease-in-out;
  animation: octocat-wave 560ms ease-in-out;
}
@-webkit-keyframes octocat-wave {
  0%,
  100% {
    transform: rotate(0);
  }
  20%,
  60% {
    transform: rotate(-25deg);
  }
  40%,
  80% {
    transform: rotate(10deg);
  }
}
@keyframes octocat-wave {
  0%,
  100% {
    transform: rotate(0);
  }
  20%,
  60% {
    transform: rotate(-25deg);
  }
  40%,
  80% {
    transform: rotate(10deg);
  }
}
.progress {
  position: fixed;
  z-index: 2147483647;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  width: 0;
  background-color: var(--theme-color);
  transition:
    width var(--duration-fast),
    opacity calc(var(--duration-fast) * 2);
}
body.ready-transition:after,
body.ready-transition > *:not(.progress) {
  opacity: 0;
  transition: opacity var(--spinner-transition-duration);
}
body.ready-transition:after {
  content: '';
  position: absolute;
  z-index: 1000;
  top: calc(50% - var(--spinner-size) / 2);
  left: calc(50% - var(--spinner-size) / 2);
  height: var(--spinner-size);
  width: var(--spinner-size);
  border: var(--spinner-track-width, 0) solid var(--spinner-track-color);
  border-left-color: var(--theme-color);
  border-left-color: var(--theme-color);
  border-radius: 50%;
  -webkit-animation: spinner var(--duration-slow) infinite linear;
  animation: spinner var(--duration-slow) infinite linear;
}
body.ready-transition.ready-spinner:after {
  opacity: 1;
}
body.ready-transition.ready-fix:after {
  opacity: 0;
}
body.ready-transition.ready-fix > *:not(.progress) {
  opacity: 1;
  transition-delay: var(--spinner-transition-duration);
}
@-webkit-keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
*,
*:before,
*:after {
  box-sizing: inherit;
  font-size: inherit;
  -webkit-overflow-scrolling: touch;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-text-size-adjust: none;
  -webkit-touch-callout: none;
}
:root {
  box-sizing: border-box;
  background-color: var(--base-background-color);
  font-size: var(--base-font-size);
  font-weight: var(--base-font-weight);
  line-height: var(--base-line-height);
  letter-spacing: var(--base-letter-spacing);
  color: var(--base-color);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-smoothing: antialiased;
}
html,
button,
input,
optgroup,
select,
textarea {
  font-family: var(--base-font-family);
}
button,
input,
optgroup,
select,
textarea {
  font-size: 100%;
  margin: 0;
}
a {
  text-decoration: none;
  -webkit-text-decoration-skip: ink;
  text-decoration-skip-ink: auto;
}
body {
  margin: 0;
}
hr {
  height: 0;
  margin: 2em 0;
  border: none;
  border-bottom: var(--hr-border, 0);
}
img {
  max-width: 100%;
  border: 0;
}
main {
  display: block;
}
main.hidden {
  display: none;
}
mark {
  background: var(--mark-background);
  color: var(--mark-color);
}
pre {
  font-family: var(--pre-font-family);
  font-size: var(--pre-font-size);
  font-weight: var(--pre-font-weight);
  line-height: var(--pre-line-height);
}
small {
  display: inline-block;
  font-size: var(--small-font-size);
}
strong {
  font-weight: var(--strong-font-weight);
  color: var(--strong-color, currentColor);
}
sub,
sup {
  font-size: var(--subsup-font-size);
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
body:not([data-platform^='Mac']) * {
  scrollbar-color: hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.3)
    hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.1);
  scrollbar-width: thin;
}
body:not([data-platform^='Mac']) * ::-webkit-scrollbar {
  width: 5px;
  height: 5px;
}
body:not([data-platform^='Mac']) * ::-webkit-scrollbar-thumb {
  background: hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.3);
}
body:not([data-platform^='Mac']) * ::-webkit-scrollbar-track {
  background: hsla(var(--mono-hue), var(--mono-saturation), 50%, 0.1);
}
::-moz-selection {
  background: var(--selection-color);
}
::selection {
  background: var(--selection-color);
}
.emoji {
  height: var(--emoji-size);
  vertical-align: middle;
}
.task-list-item {
  list-style: none;
}
.task-list-item input {
  margin-right: 0.5em;
  margin-left: 0;
  vertical-align: 0.075em;
}
.markdown-section code[class*='lang-'],
.markdown-section pre[data-lang] {
  font-family: var(--code-font-family);
  font-size: var(--code-font-size);
  font-weight: var(--code-font-weight);
  letter-spacing: normal;
  line-height: var(--code-block-line-height);
  -moz-tab-size: var(--code-tab-size);
  -o-tab-size: var(--code-tab-size);
  tab-size: var(--code-tab-size);
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-wrap: normal;
  word-break: normal;
  -webkit-hyphens: none;
  hyphens: none;
}
.markdown-section pre[data-lang] {
  position: relative;
  overflow: hidden;
  margin: var(--code-block-margin);
  padding: 0;
  border-radius: var(--code-block-border-radius);
}
.markdown-section pre[data-lang]::after {
  content: attr(data-lang);
  position: absolute;
  top: 0.75em;
  right: 0.75em;
  opacity: 0.6;
  color: inherit;
  font-size: var(--font-size-s);
  line-height: 1;
}
.markdown-section pre[data-lang] code {
  display: block;
  overflow: auto;
  padding: var(--code-block-padding);
}
code[class*='lang-'],
pre[data-lang] {
  color: var(--code-theme-text);
}
pre[data-lang]::-moz-selection,
pre[data-lang] ::-moz-selection,
code[class*='lang-']::-moz-selection,
code[class*='lang-'] ::-moz-selection {
  background: var(--code-theme-selection, var(--selection-color));
}
pre[data-lang]::-moz-selection,
pre[data-lang] ::-moz-selection,
code[class*='lang-']::-moz-selection,
code[class*='lang-'] ::-moz-selection {
  background: var(--code-theme-selection, var(--selection-color));
}
pre[data-lang]::selection,
pre[data-lang] ::selection,
code[class*='lang-']::selection,
code[class*='lang-'] ::selection {
  background: var(--code-theme-selection, var(--selection-color));
}
:not(pre) > code[class*='lang-'],
pre[data-lang] {
  background: var(--code-theme-background);
}
.namespace {
  opacity: 0.7;
}
.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: var(--code-theme-comment);
}
.token.punctuation {
  color: var(--code-theme-punctuation);
}
.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: var(--code-theme-tag);
}
.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: var(--code-theme-selector);
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: var(--code-theme-operator);
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: var(--code-theme-keyword);
}
.token.function {
  color: var(--code-theme-function);
}
.token.regex,
.token.important,
.token.variable {
  color: var(--code-theme-variable);
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
.markdown-section {
  position: relative;
  max-width: var(--content-max-width);
  margin: 0 auto;
  padding: 2rem 45px;
}
.app-nav:not(:empty) ~ main .markdown-section {
  padding-top: 3.5rem;
}
.markdown-section figure,
.markdown-section p,
.markdown-section ol,
.markdown-section ul {
  margin: 1em 0;
}
.markdown-section ol,
.markdown-section ul {
  padding-left: 1.5rem;
}
.markdown-section ol ol,
.markdown-section ol ul,
.markdown-section ul ol,
.markdown-section ul ul {
  margin-top: 0.15rem;
  margin-bottom: 0.15rem;
}
.markdown-section a {
  border-bottom: var(--link-border-bottom);
  color: var(--link-color);
  -webkit-text-decoration: var(--link-text-decoration);
  text-decoration: var(--link-text-decoration);
  -webkit-text-decoration-color: var(--link-text-decoration-color);
  text-decoration-color: var(--link-text-decoration-color);
}
.markdown-section a:hover {
  border-bottom: var(--link-border-bottom--hover, var(--link-border-bottom, 0));
  color: var(--link-color--hover, var(--link-color));
  -webkit-text-decoration: var(
    --link-text-decoration--hover,
    var(--link-text-decoration)
  );
  text-decoration: var(--link-text-decoration--hover, var(--link-text-decoration));
  -webkit-text-decoration-color: var(
    --link-text-decoration-color--hover,
    var(--link-text-decoration-color)
  );
  text-decoration-color: var(
    --link-text-decoration-color--hover,
    var(--link-text-decoration-color)
  );
}
.markdown-section a.anchor {
  border-bottom: 0;
  color: inherit;
  text-decoration: none;
}
.markdown-section a.anchor:hover {
  text-decoration: underline;
}
.markdown-section blockquote {
  overflow: visible;
  margin: 2em 0;
  padding: var(--blockquote-padding);
  border-width: var(--blockquote-border-width, 0);
  border-style: var(--blockquote-border-style);
  border-color: var(--blockquote-border-color);
  border-radius: var(--blockquote-border-radius);
  background: var(--blockquote-background);
  color: var(--blockquote-color);
  font-family: var(--blockquote-font-family);
  font-size: var(--blockquote-font-size);
  font-style: var(--blockquote-font-style);
  font-weight: var(--blockquote-font-weight);
  quotes: '“' '”' '‘' '’';
}
.markdown-section blockquote em {
  font-family: var(--blockquote-em-font-family);
  font-size: var(--blockquote-em-font-size);
  font-style: var(--blockquote-em-font-style);
  font-weight: var(--blockquote-em-font-weight);
}
.markdown-section blockquote p:first-child {
  margin-top: 0;
}
.markdown-section blockquote p:first-child:before,
.markdown-section blockquote p:first-child:after {
  color: var(--blockquote-quotes-color);
  font-family: var(--blockquote-quotes-font-family);
  font-size: var(--blockquote-quotes-font-size);
  line-height: 0;
}
.markdown-section blockquote p:first-child:before {
  content: var(--blockquote-quotes-open);
  margin-right: 0.15em;
  vertical-align: -0.45em;
}
.markdown-section blockquote p:first-child:after {
  content: var(--blockquote-quotes-close);
  margin-left: 0.15em;
  vertical-align: -0.55em;
}
.markdown-section blockquote p:last-child {
  margin-bottom: 0;
}
.markdown-section code {
  font-family: var(--code-font-family);
  font-size: var(--code-font-size);
  font-weight: var(--code-font-weight);
  line-height: inherit;
}
.markdown-section code:not([class*='lang-']):not([class*='language-']) {
  margin: var(--code-inline-margin);
  padding: var(--code-inline-padding);
  border-radius: var(--code-inline-border-radius);
  background: var(--code-inline-background);
  color: var(--code-inline-color, currentColor);
  white-space: nowrap;
}
.markdown-section h1:first-child,
.markdown-section h2:first-child,
.markdown-section h3:first-child,
.markdown-section h4:first-child,
.markdown-section h5:first-child,
.markdown-section h6:first-child {
  margin-top: 0;
}
.markdown-section h1 a[data-id],
.markdown-section h2 a[data-id],
.markdown-section h3 a[data-id],
.markdown-section h4 a[data-id],
.markdown-section h5 a[data-id],
.markdown-section h6 a[data-id] {
  display: inline-block;
}
.markdown-section h1 code,
.markdown-section h2 code,
.markdown-section h3 code,
.markdown-section h4 code,
.markdown-section h5 code,
.markdown-section h6 code {
  font-size: 0.875em;
}
.markdown-section h1 + h2,
.markdown-section h1 + h3,
.markdown-section h1 + h4,
.markdown-section h1 + h5,
.markdown-section h1 + h6,
.markdown-section h2 + h3,
.markdown-section h2 + h4,
.markdown-section h2 + h5,
.markdown-section h2 + h6,
.markdown-section h3 + h4,
.markdown-section h3 + h5,
.markdown-section h3 + h6,
.markdown-section h4 + h5,
.markdown-section h4 + h6,
.markdown-section h5 + h6 {
  margin-top: 1rem;
}
.markdown-section h1 {
  margin: var(--heading-h1-margin, var(--heading-margin));
  padding: var(--heading-h1-padding, var(--heading-padding));
  border-width: var(--heading-h1-border-width, 0);
  border-style: var(--heading-h1-border-style);
  border-color: var(--heading-h1-border-color);
  font-family: var(--heading-h1-font-family, var(--heading-font-family));
  font-size: var(--heading-h1-font-size);
  font-weight: var(--heading-h1-font-weight, var(--heading-font-weight));
  line-height: var(--base-line-height);
  color: var(--heading-h1-color, var(--heading-color));
}
.markdown-section h2 {
  margin: var(--heading-h2-margin, var(--heading-margin));
  padding: var(--heading-h2-padding, var(--heading-padding));
  border-width: var(--heading-h2-border-width, 0);
  border-style: var(--heading-h2-border-style);
  border-color: var(--heading-h2-border-color);
  font-family: var(--heading-h2-font-family, var(--heading-font-family));
  font-size: var(--heading-h2-font-size);
  font-weight: var(--heading-h2-font-weight, var(--heading-font-weight));
  line-height: var(--base-line-height);
  color: var(--heading-h2-color, var(--heading-color));
}
.markdown-section h3 {
  margin: var(--heading-h3-margin, var(--heading-margin));
  padding: var(--heading-h3-padding, var(--heading-padding));
  border-width: var(--heading-h3-border-width, 0);
  border-style: var(--heading-h3-border-style);
  border-color: var(--heading-h3-border-color);
  font-family: var(--heading-h3-font-family, var(--heading-font-family));
  font-size: var(--heading-h3-font-size);
  font-weight: var(--heading-h3-font-weight, var(--heading-font-weight));
  color: var(--heading-h3-color, var(--heading-color));
}
.markdown-section h4 {
  margin: var(--heading-h4-margin, var(--heading-margin));
  padding: var(--heading-h4-padding, var(--heading-padding));
  border-width: var(--heading-h4-border-width, 0);
  border-style: var(--heading-h4-border-style);
  border-color: var(--heading-h4-border-color);
  font-family: var(--heading-h4-font-family, var(--heading-font-family));
  font-size: var(--heading-h4-font-size);
  font-weight: var(--heading-h4-font-weight, var(--heading-font-weight));
  color: var(--heading-h4-color, var(--heading-color));
}
.markdown-section h5 {
  margin: var(--heading-h5-margin, var(--heading-margin));
  padding: var(--heading-h5-padding, var(--heading-padding));
  border-width: var(--heading-h5-border-width, 0);
  border-style: var(--heading-h5-border-style);
  border-color: var(--heading-h5-border-color);
  font-family: var(--heading-h5-font-family, var(--heading-font-family));
  font-size: var(--heading-h5-font-size);
  font-weight: var(--heading-h5-font-weight, var(--heading-font-weight));
  color: var(--heading-h5-color, var(--heading-color));
}
.markdown-section h6 {
  margin: var(--heading-h6-margin, var(--heading-margin));
  padding: var(--heading-h6-padding, var(--heading-padding));
  border-width: var(--heading-h6-border-width, 0);
  border-style: var(--heading-h6-border-style);
  border-color: var(--heading-h6-border-color);
  font-family: var(--heading-h6-font-family, var(--heading-font-family));
  font-size: var(--heading-h6-font-size);
  font-weight: var(--heading-h6-font-weight, var(--heading-font-weight));
  color: var(--heading-h6-color, var(--heading-color));
}
.markdown-section iframe {
  margin: 1em 0;
}
.markdown-section img {
  max-width: 100%;
}
.markdown-section kbd {
  display: inline-block;
  min-width: var(--kbd-min-width);
  margin: var(--kbd-margin);
  padding: var(--kbd-padding);
  border: var(--kbd-border);
  border-radius: var(--kbd-border-radius);
  background: var(--kbd-background);
  font-family: inherit;
  font-size: var(--kbd-font-size);
  text-align: center;
  letter-spacing: 0;
  line-height: 1;
  color: var(--kbd-color);
}
.markdown-section kbd + kbd {
  margin-left: -0.15em;
}
.markdown-section table {
  display: block;
  overflow: auto;
  margin: 1rem 0;
  border-spacing: 0;
  border-collapse: collapse;
}
.markdown-section th,
.markdown-section td {
  padding: var(--table-cell-padding);
}
.markdown-section th:not([align]) {
  text-align: left;
}
.markdown-section thead {
  border-color: var(--table-head-border-color);
  border-style: solid;
  border-width: var(--table-head-border-width, 0);
  background: var(--table-head-background);
}
.markdown-section th {
  font-weight: var(--table-head-font-weight);
  color: var(--strong-color);
}
.markdown-section td {
  border-color: var(--table-cell-border-color);
  border-style: solid;
  border-width: var(--table-cell-border-width, 0);
}
.markdown-section tbody {
  border-color: var(--table-body-border-color);
  border-style: solid;
  border-width: var(--table-body-border-width, 0);
}
.markdown-section tbody tr:nth-child(odd) {
  background: var(--table-row-odd-background);
}
.markdown-section tbody tr:nth-child(even) {
  background: var(--table-row-even-background);
}
.markdown-section > ul .task-list-item {
  margin-left: -1.25em;
}
.markdown-section > ul .task-list-item .task-list-item {
  margin-left: 0;
}
.markdown-section .table-wrapper {
  overflow-x: auto;
}
.markdown-section .table-wrapper table {
  display: table;
  width: 100%;
}
.markdown-section .table-wrapper td::before {
  display: none;
}
@media (max-width: 30em) {
  .markdown-section .table-wrapper tbody,
  .markdown-section .table-wrapper tr,
  .markdown-section .table-wrapper td {
    display: block;
  }
  .markdown-section .table-wrapper th,
  .markdown-section .table-wrapper td {
    border: none;
  }
  .markdown-section .table-wrapper thead {
    display: none;
  }
  .markdown-section .table-wrapper tr {
    border-color: var(--table-cell-border-color);
    border-style: solid;
    border-width: var(--table-cell-border-width, 0);
    padding: var(--table-cell-padding);
  }
  .markdown-section .table-wrapper tr:not(:last-child) {
    border-bottom: 0;
  }
  .markdown-section .table-wrapper td {
    padding: 0.15em 0 0.15em 8em;
  }
  .markdown-section .table-wrapper td::before {
    display: inline-block;
    float: left;
    width: 8em;
    margin-left: -8em;
    font-weight: bold;
    text-align: left;
  }
}
.markdown-section .tip,
.markdown-section .warn {
  position: relative;
  margin: 2em 0;
  padding: var(--notice-padding);
  border-width: var(--notice-border-width, 0);
  border-style: var(--notice-border-style);
  border-color: var(--notice-border-color);
  border-radius: var(--notice-border-radius);
  background: var(--notice-background);
  font-family: var(--notice-font-family);
  font-weight: var(--notice-font-weight);
  color: var(--notice-color);
}
.markdown-section .tip:before,
.markdown-section .warn:before {
  display: inline-block;
  position: var(--notice-before-position, relative);
  top: var(--notice-before-top);
  left: var(--notice-before-left);
  height: var(--notice-before-height);
  width: var(--notice-before-width);
  margin: var(--notice-before-margin);
  padding: var(--notice-before-padding);
  border-radius: var(--notice-before-border-radius);
  line-height: var(--notice-before-line-height);
  font-family: var(--notice-before-font-family);
  font-size: var(--notice-before-font-size);
  font-weight: var(--notice-before-font-weight);
  text-align: center;
}
.markdown-section .tip {
  border-width: var(--notice-important-border-width, var(--notice-border-width, 0));
  border-style: var(--notice-important-border-style, var(--notice-border-style));
  border-color: var(--notice-important-border-color, var(--notice-border-color));
  background: var(--notice-important-background, var(--notice-background));
  color: var(--notice-important-color, var(--notice-color));
}
.markdown-section .tip:before {
  content: var(--notice-important-before-content, var(--notice-before-content));
  background: var(--notice-important-before-background, var(--notice-before-background));
  color: var(--notice-important-before-color, var(--notice-before-color));
}
.markdown-section .warn {
  border-width: var(--notice-tip-border-width, var(--notice-border-width, 0));
  border-style: var(--notice-tip-border-style, var(--notice-border-style));
  border-color: var(--notice-tip-border-color, var(--notice-border-color));
  background: var(--notice-tip-background, var(--notice-background));
  color: var(--notice-tip-color, var(--notice-color));
}
.markdown-section .warn:before {
  content: var(--notice-tip-before-content, var(--notice-before-content));
  background: var(--notice-tip-before-background, var(--notice-before-background));
  color: var(--notice-tip-before-color, var(--notice-before-color));
}
.cover {
  display: none;
  position: relative;
  z-index: 20;
  min-height: 100vh;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: calc(var(--cover-border-inset, 0px) + var(--cover-border-width, 0px));
  color: var(--cover-color);
  text-align: var(--cover-text-align);
}
.cover:before,
.cover:after {
  content: '';
  position: absolute;
}
.cover:before {
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background-blend-mode: var(--cover-background-blend-mode);
  background-color: var(--cover-background-color);
  background-image: var(--cover-background-image);
  background-position: var(--cover-background-position);
  background-repeat: var(--cover-background-repeat);
  background-size: var(--cover-background-size);
}
.cover:after {
  top: var(--cover-border-inset, 0);
  bottom: var(--cover-border-inset, 0);
  left: var(--cover-border-inset, 0);
  right: var(--cover-border-inset, 0);
  border-width: var(--cover-border-width, 0);
  border-style: solid;
  border-color: var(--cover-border-color);
}
.cover a {
  border-bottom: var(--cover-link-border-bottom);
  color: var(--cover-link-color);
  -webkit-text-decoration: var(--cover-link-text-decoration);
  text-decoration: var(--cover-link-text-decoration);
  -webkit-text-decoration-color: var(--cover-link-text-decoration-color);
  text-decoration-color: var(--cover-link-text-decoration-color);
}
.cover a:hover {
  border-bottom: var(--cover-link-border-bottom--hover, var(--cover-link-border-bottom));
  color: var(--cover-link-color--hover, var(--cover-link-color));
  -webkit-text-decoration: var(
    --cover-link-text-decoration--hover,
    var(--cover-link-text-decoration)
  );
  text-decoration: var(
    --cover-link-text-decoration--hover,
    var(--cover-link-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --cover-link-text-decoration-color--hover,
    var(--cover-link-text-decoration-color)
  );
  text-decoration-color: var(
    --cover-link-text-decoration-color--hover,
    var(--cover-link-text-decoration-color)
  );
}
.cover h1 {
  color: var(--cover-heading-color);
  position: relative;
  margin: 0;
  font-size: var(--cover-heading-font-size);
  font-weight: var(--cover-heading-font-weight);
  line-height: 1.2;
}
.cover h1 a,
.cover h1 a:hover {
  display: block;
  border-bottom: none;
  color: inherit;
  text-decoration: none;
}
.cover h1 small {
  position: absolute;
  bottom: 0;
  margin-left: 0.5em;
}
.cover h1 span {
  font-size: calc(var(--cover-heading-font-size-min) * 1px);
}
@media (min-width: 26em) {
  .cover h1 span {
    font-size: calc(
      var(--cover-heading-font-size-min) * 1px +
        (var(--cover-heading-font-size-max) - var(--cover-heading-font-size-min)) *
        (100vw - 420px) / 604
    );
  }
}
@media (min-width: 64em) {
  .cover h1 span {
    font-size: calc(var(--cover-heading-font-size-max) * 1px);
  }
}
.cover blockquote {
  margin: 0;
  color: var(--cover-blockquote-color);
  font-size: var(--cover-blockquote-font-size);
}
.cover blockquote a {
  color: inherit;
}
.cover ul {
  padding: 0;
  list-style-type: none;
}
.cover .cover-main {
  position: relative;
  z-index: 1;
  max-width: var(--cover-max-width);
  margin: var(--cover-margin);
  padding: 0 45px;
}
.cover .cover-main > p:last-child {
  margin: 1.25em -0.25em;
}
.cover .cover-main > p:last-child a {
  display: block;
  margin: 0.375em 0.25em;
  padding: var(--cover-button-padding);
  border: var(--cover-button-border);
  border-radius: var(--cover-button-border-radius);
  box-shadow: var(--cover-button-box-shadow);
  background: var(--cover-button-background);
  text-align: center;
  -webkit-text-decoration: var(--cover-button-text-decoration);
  text-decoration: var(--cover-button-text-decoration);
  -webkit-text-decoration-color: var(--cover-button-text-decoration-color);
  text-decoration-color: var(--cover-button-text-decoration-color);
  color: var(--cover-button-color);
  white-space: nowrap;
  transition: var(--cover-button-transition);
}
.cover .cover-main > p:last-child a:hover {
  border: var(--cover-button-border--hover, var(--cover-button-border));
  box-shadow: var(--cover-button-box-shadow--hover, var(--cover-button-box-shadow));
  background: var(--cover-button-background--hover, var(--cover-button-background));
  -webkit-text-decoration: var(
    --cover-button-text-decoration--hover,
    var(--cover-button-text-decoration)
  );
  text-decoration: var(
    --cover-button-text-decoration--hover,
    var(--cover-button-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --cover-button-text-decoration-color--hover,
    var(--cover-button-text-decoration-color)
  );
  text-decoration-color: var(
    --cover-button-text-decoration-color--hover,
    var(--cover-button-text-decoration-color)
  );
  color: var(--cover-button-color--hover, var(--cover-button-color));
}
.cover .cover-main > p:last-child a:first-child {
  border: var(--cover-button-primary-border, var(--cover-button-border));
  box-shadow: var(--cover-button-primary-box-shadow, var(--cover-button-box-shadow));
  background: var(--cover-button-primary-background, var(--cover-button-background));
  -webkit-text-decoration: var(
    --cover-button-primary-text-decoration,
    var(--cover-button-text-decoration)
  );
  text-decoration: var(
    --cover-button-primary-text-decoration,
    var(--cover-button-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --cover-button-primary-text-decoration-color,
    var(--cover-button-text-decoration-color)
  );
  text-decoration-color: var(
    --cover-button-primary-text-decoration-color,
    var(--cover-button-text-decoration-color)
  );
  color: var(--cover-button-primary-color, var(--cover-button-color));
}
.cover .cover-main > p:last-child a:first-child:hover {
  border: var(
    --cover-button-primary-border--hover,
    var(
      --cover-button-border--hover,
      var(--cover-button-primary-border, var(--cover-button-border))
    )
  );
  box-shadow: var(
    --cover-button-primary-box-shadow--hover,
    var(
      --cover-button-box-shadow--hover,
      var(--cover-button-primary-box-shadow, var(--cover-button-box-shadow))
    )
  );
  background: var(
    --cover-button-primary-background--hover,
    var(
      --cover-button-background--hover,
      var(--cover-button-primary-background, var(--cover-button-background))
    )
  );
  -webkit-text-decoration: var(
    --cover-button-primary-text-decoration--hover,
    var(
      --cover-button-text-decoration--hover,
      var(--cover-button-primary-text-decoration, var(--cover-button-text-decoration))
    )
  );
  text-decoration: var(
    --cover-button-primary-text-decoration--hover,
    var(
      --cover-button-text-decoration--hover,
      var(--cover-button-primary-text-decoration, var(--cover-button-text-decoration))
    )
  );
  -webkit-text-decoration-color: var(
    --cover-button-primary-text-decoration-color--hover,
    var(
      --cover-button-text-decoration-color--hover,
      var(
        --cover-button-primary-text-decoration-color,
        var(--cover-button-text-decoration-color)
      )
    )
  );
  text-decoration-color: var(
    --cover-button-primary-text-decoration-color--hover,
    var(
      --cover-button-text-decoration-color--hover,
      var(
        --cover-button-primary-text-decoration-color,
        var(--cover-button-text-decoration-color)
      )
    )
  );
  color: var(
    --cover-button-primary-color--hover,
    var(
      --cover-button-color--hover,
      var(--cover-button-primary-color, var(--cover-button-color))
    )
  );
}
@media (min-width: 30.01em) {
  .cover .cover-main > p:last-child a {
    display: inline-block;
  }
}
.cover .mask {
  visibility: var(--cover-background-mask-visibility, hidden);
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: var(--cover-background-mask-color);
  opacity: var(--cover-background-mask-opacity);
}
.cover.has-mask .mask {
  visibility: visible;
}
.cover.show {
  display: flex;
}
.app-nav {
  position: absolute;
  z-index: 30;
  top: calc(35px - 0.5em * var(--base-line-height));
  left: 45px;
  right: 80px;
  text-align: right;
}
.app-nav.no-badge {
  right: 45px;
}
.app-nav li > img,
.app-nav li > a > img {
  margin-top: -0.25em;
  vertical-align: middle;
}
.app-nav li > img:first-child,
.app-nav li > a > img:first-child {
  margin-right: 0.5em;
}
.app-nav ul,
.app-nav li {
  margin: 0;
  padding: 0;
  list-style: none;
}
.app-nav li {
  position: relative;
}
.app-nav li a {
  display: block;
  line-height: 1;
  transition: var(--navbar-root-transition);
}
.app-nav > ul > li {
  display: inline-block;
  margin: var(--navbar-root-margin);
}
.app-nav > ul > li:first-child {
  margin-left: 0;
}
.app-nav > ul > li:last-child {
  margin-right: 0;
}
.app-nav > ul > li > a,
.app-nav > ul > li > span {
  padding: var(--navbar-root-padding);
  border-width: var(--navbar-root-border-width, 0);
  border-style: var(--navbar-root-border-style);
  border-color: var(--navbar-root-border-color);
  border-radius: var(--navbar-root-border-radius);
  background: var(--navbar-root-background);
  color: var(--navbar-root-color);
  -webkit-text-decoration: var(--navbar-root-text-decoration);
  text-decoration: var(--navbar-root-text-decoration);
  -webkit-text-decoration-color: var(--navbar-root-text-decoration-color);
  text-decoration-color: var(--navbar-root-text-decoration-color);
}
.app-nav > ul > li > a:hover,
.app-nav > ul > li > span:hover {
  background: var(--navbar-root-background--hover, var(--navbar-root-background));
  border-style: var(--navbar-root-border-style--hover, var(--navbar-root-border-style));
  border-color: var(--navbar-root-border-color--hover, var(--navbar-root-border-color));
  color: var(--navbar-root-color--hover, var(--navbar-root-color));
  -webkit-text-decoration: var(
    --navbar-root-text-decoration--hover,
    var(--navbar-root-text-decoration)
  );
  text-decoration: var(
    --navbar-root-text-decoration--hover,
    var(--navbar-root-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-root-text-decoration-color--hover,
    var(--navbar-root-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-root-text-decoration-color--hover,
    var(--navbar-root-text-decoration-color)
  );
}
.app-nav > ul > li > a:not(:last-child),
.app-nav > ul > li > span:not(:last-child) {
  padding: var(--navbar-menu-root-padding, var(--navbar-root-padding));
  background: var(--navbar-menu-root-background, var(--navbar-root-background));
}
.app-nav > ul > li > a:not(:last-child):hover,
.app-nav > ul > li > span:not(:last-child):hover {
  background: var(
    --navbar-menu-root-background--hover,
    var(
      --navbar-menu-root-background,
      var(--navbar-root-background--hover, var(--navbar-root-background))
    )
  );
}
.app-nav > ul > li > a.active {
  background: var(--navbar-root-background--active, var(--navbar-root-background));
  border-style: var(--navbar-root-border-style--active, var(--navbar-root-border-style));
  border-color: var(--navbar-root-border-color--active, var(--navbar-root-border-color));
  color: var(--navbar-root-color--active, var(--navbar-root-color));
  -webkit-text-decoration: var(
    --navbar-root-text-decoration--active,
    var(--navbar-root-text-decoration)
  );
  text-decoration: var(
    --navbar-root-text-decoration--active,
    var(--navbar-root-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-root-text-decoration-color--active,
    var(--navbar-root-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-root-text-decoration-color--active,
    var(--navbar-root-text-decoration-color)
  );
}
.app-nav > ul > li > a.active:not(:last-child):hover {
  background: var(
    --navbar-menu-root-background--active,
    var(
      --navbar-menu-root-background,
      var(--navbar-root-background--active, var(--navbar-root-background))
    )
  );
}
.app-nav > ul > li ul {
  visibility: hidden;
  position: absolute;
  top: 100%;
  right: 50%;
  overflow-y: auto;
  box-sizing: border-box;
  max-height: 50vh;
  padding: var(--navbar-menu-padding);
  border-width: var(--navbar-menu-border-width, 0);
  border-style: solid;
  border-color: var(--navbar-menu-border-color);
  border-radius: var(--navbar-menu-border-radius);
  background: var(--navbar-menu-background);
  box-shadow: var(--navbar-menu-box-shadow);
  text-align: left;
  white-space: nowrap;
  opacity: 0;
  transform: translate(50%, -0.35em);
  transition: var(--navbar-menu-transition);
}
.app-nav > ul > li ul li {
  white-space: nowrap;
}
.app-nav > ul > li ul a {
  margin: var(--navbar-menu-link-margin);
  padding: var(--navbar-menu-link-padding);
  border-width: var(--navbar-menu-link-border-width, 0);
  border-style: var(--navbar-menu-link-border-style);
  border-color: var(--navbar-menu-link-border-color);
  border-radius: var(--navbar-menu-link-border-radius);
  background: var(--navbar-menu-link-background);
  color: var(--navbar-menu-link-color);
  -webkit-text-decoration: var(--navbar-menu-link-text-decoration);
  text-decoration: var(--navbar-menu-link-text-decoration);
  -webkit-text-decoration-color: var(--navbar-menu-link-text-decoration-color);
  text-decoration-color: var(--navbar-menu-link-text-decoration-color);
}
.app-nav > ul > li ul a:hover {
  background: var(
    --navbar-menu-link-background--hover,
    var(--navbar-menu-link-background)
  );
  border-style: var(
    --navbar-menu-link-border-style--hover,
    var(--navbar-menu-link-border-style)
  );
  border-color: var(
    --navbar-menu-link-border-color--hover,
    var(--navbar-menu-link-border-color)
  );
  color: var(--navbar-menu-link-color--hover, var(--navbar-menu-link-color));
  -webkit-text-decoration: var(
    --navbar-menu-link-text-decoration--hover,
    var(--navbar-menu-link-text-decoration)
  );
  text-decoration: var(
    --navbar-menu-link-text-decoration--hover,
    var(--navbar-menu-link-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--hover,
    var(--navbar-menu-link-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--hover,
    var(--navbar-menu-link-text-decoration-color)
  );
}
.app-nav > ul > li ul a.active {
  background: var(
    --navbar-menu-link-background--active,
    var(--navbar-menu-link-background)
  );
  border-style: var(
    --navbar-menu-link-border-style--active,
    var(--navbar-menu-link-border-style)
  );
  border-color: var(
    --navbar-menu-link-border-color--active,
    var(--navbar-menu-link-border-color)
  );
  color: var(--navbar-menu-link-color--active, var(--navbar-menu-link-color));
  -webkit-text-decoration: var(
    --navbar-menu-link-text-decoration--active,
    var(--navbar-menu-link-text-decoration)
  );
  text-decoration: var(
    --navbar-menu-link-text-decoration--active,
    var(--navbar-menu-link-text-decoration)
  );
  -webkit-text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--active,
    var(--navbar-menu-link-text-decoration-color)
  );
  text-decoration-color: var(
    --navbar-menu-link-text-decoration-color--active,
    var(--navbar-menu-link-text-decoration-color)
  );
}
.app-nav > ul > li:hover ul,
.app-nav > ul > li:focus ul,
.app-nav > ul > li.focus-within ul {
  visibility: visible;
  opacity: 1;
  transform: translate(50%, 0);
}
@media (min-width: 48em) {
  nav.app-nav {
    margin-left: var(--sidebar-width);
  }
}
main {
  position: relative;
  overflow-x: hidden;
  min-height: 100vh;
}
.sidebar,
.sidebar-toggle,
.sidebar + .content {
  transition: all var(--sidebar-transition-duration) ease-out;
}
@media (min-width: 48em) {
  .sidebar + .content {
    margin-left: var(--sidebar-width);
  }
}
.sidebar {
  display: flex;
  flex-direction: column;
  position: fixed;
  z-index: 10;
  top: 0;
  right: 100%;
  overflow-x: hidden;
  overflow-y: auto;
  height: 100vh;
  width: var(--sidebar-width);
  padding: var(--sidebar-padding);
  border-width: var(--sidebar-border-width);
  border-style: solid;
  border-color: var(--sidebar-border-color);
  background: var(--sidebar-background);
}
.sidebar > h1 {
  margin: 0;
  margin: var(--sidebar-name-margin);
  padding: var(--sidebar-name-padding);
  background: var(--sidebar-name-background);
  color: var(--sidebar-name-color);
  font-family: var(--sidebar-name-font-family);
  font-size: var(--sidebar-name-font-size);
  font-weight: var(--sidebar-name-font-weight);
  text-align: var(--sidebar-name-text-align);
}
.sidebar > h1 img {
  max-width: 100%;
}
.sidebar > h1 .app-name-link {
  color: var(--sidebar-name-color);
}
body:not([data-platform^='Mac']) .sidebar::-webkit-scrollbar {
  width: 5px;
}
body:not([data-platform^='Mac']) .sidebar::-webkit-scrollbar-thumb {
  border-radius: 50vw;
}
@media (min-width: 48em) {
  .sidebar {
    position: absolute;
    transform: translateX(var(--sidebar-width));
  }
}
@media print {
  .sidebar {
    display: none;
  }
}
.sidebar-nav,
.sidebar nav {
  order: 1;
  margin: var(--sidebar-nav-margin);
  padding: var(--sidebar-nav-padding);
  background: var(--sidebar-nav-background);
}
.sidebar-nav ul,
.sidebar nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
.sidebar-nav ul ul,
.sidebar nav ul ul {
  margin-left: var(--sidebar-nav-indent);
}
.sidebar-nav a,
.sidebar nav a {
  display: block;
  overflow: hidden;
  margin: var(--sidebar-nav-link-margin);
  padding: var(--sidebar-nav-link-padding);
  border-width: var(--sidebar-nav-link-border-width, 0);
  border-style: var(--sidebar-nav-link-border-style);
  border-color: var(--sidebar-nav-link-border-color);
  border-radius: var(--sidebar-nav-link-border-radius);
  background: var(--sidebar-nav-link-background);
  color: var(--sidebar-nav-link-color);
  font-weight: var(--sidebar-nav-link-font-weight);
  white-space: nowrap;
  -webkit-text-decoration: var(--sidebar-nav-link-text-decoration);
  text-decoration: var(--sidebar-nav-link-text-decoration);
  -webkit-text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-overflow: ellipsis;
  transition: var(--sidebar-nav-link-transition);
}
.sidebar-nav a img,
.sidebar nav a img {
  margin-top: -0.25em;
  vertical-align: middle;
}
.sidebar-nav a img:first-child,
.sidebar nav a img:first-child {
  margin-right: 0.5em;
}
.sidebar-nav a:hover,
.sidebar nav a:hover {
  border-width: var(
    --sidebar-nav-link-border-width--hover,
    var(--sidebar-nav-link-border-width, 0)
  );
  border-style: var(
    --sidebar-nav-link-border-style--hover,
    var(--sidebar-nav-link-border-style)
  );
  border-color: var(
    --sidebar-nav-link-border-color--hover,
    var(--sidebar-nav-link-border-color)
  );
  background: var(
    --sidebar-nav-link-background--hover,
    var(--sidebar-nav-link-background)
  );
  color: var(--sidebar-nav-link-color--hover, var(--sidebar-nav-link-color));
  font-weight: var(
    --sidebar-nav-link-font-weight--hover,
    var(--sidebar-nav-link-font-weight)
  );
  -webkit-text-decoration: var(
    --sidebar-nav-link-text-decoration--hover,
    var(--sidebar-nav-link-text-decoration)
  );
  text-decoration: var(
    --sidebar-nav-link-text-decoration--hover,
    var(--sidebar-nav-link-text-decoration)
  );
  -webkit-text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
}
.sidebar-nav ul > li > span,
.sidebar-nav ul > li > strong,
.sidebar nav ul > li > span,
.sidebar nav ul > li > strong {
  display: block;
  margin: var(--sidebar-nav-strong-margin);
  padding: var(--sidebar-nav-strong-padding);
  border-width: var(--sidebar-nav-strong-border-width, 0);
  border-style: solid;
  border-color: var(--sidebar-nav-strong-border-color);
  color: var(--sidebar-nav-strong-color);
  font-size: var(--sidebar-nav-strong-font-size);
  font-weight: var(--sidebar-nav-strong-font-weight);
  text-transform: var(--sidebar-nav-strong-text-transform);
}
.sidebar-nav ul > li > span + ul,
.sidebar-nav ul > li > strong + ul,
.sidebar nav ul > li > span + ul,
.sidebar nav ul > li > strong + ul {
  margin-left: 0;
}
.sidebar-nav ul > li:first-child > span,
.sidebar-nav ul > li:first-child > strong,
.sidebar nav ul > li:first-child > span,
.sidebar nav ul > li:first-child > strong {
  margin-top: 0;
}
.sidebar-nav::-webkit-scrollbar,
.sidebar nav::-webkit-scrollbar {
  width: 0;
}
@supports (width: env(safe-area-inset)) {
  @media only screen and (orientation: landscape) {
    .sidebar-nav,
    .sidebar nav {
      margin-left: calc(env(safe-area-inset-left) / 2);
    }
  }
}
.sidebar-nav li > a:before,
.sidebar-nav li > strong:before {
  display: inline-block;
}
.sidebar-nav li > a {
  background-repeat: var(--sidebar-nav-pagelink-background-repeat);
  background-size: var(--sidebar-nav-pagelink-background-size);
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']),
.sidebar-nav li > a[href^='#/']:not([href*='?id=']) {
  transition: var(--sidebar-nav-pagelink-transition);
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']),
.sidebar-nav li > a[href^='/']:not([href*='?id=']) ~ ul a,
.sidebar-nav li > a[href^='#/']:not([href*='?id=']),
.sidebar-nav li > a[href^='#/']:not([href*='?id=']) ~ ul a {
  padding: var(--sidebar-nav-pagelink-padding, var(--sidebar-nav-link-padding));
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']):only-child,
.sidebar-nav li > a[href^='#/']:not([href*='?id=']):only-child {
  background: var(--sidebar-nav-pagelink-background);
}
.sidebar-nav li > a[href^='/']:not([href*='?id=']):not(:only-child),
.sidebar-nav li > a[href^='#/']:not([href*='?id=']):not(:only-child) {
  background: var(
    --sidebar-nav-pagelink-background--loaded,
    var(--sidebar-nav-pagelink-background)
  );
}
.sidebar-nav li.active > a,
.sidebar-nav li.collapse > a {
  border-width: var(
    --sidebar-nav-link-border-width--active,
    var(--sidebar-nav-link-border-width)
  );
  border-style: var(
    --sidebar-nav-link-border-style--active,
    var(--sidebar-nav-link-border-style)
  );
  border-color: var(
    --sidebar-nav-link-border-color--active,
    var(--sidebar-nav-link-border-color)
  );
  background: var(
    --sidebar-nav-link-background--active,
    var(--sidebar-nav-link-background)
  );
  color: var(--sidebar-nav-link-color--active, var(--sidebar-nav-link-color));
  font-weight: var(
    --sidebar-nav-link-font-weight--active,
    var(--sidebar-nav-link-font-weight)
  );
  -webkit-text-decoration: var(
    --sidebar-nav-link-text-decoration--active,
    var(--sidebar-nav-link-text-decoration)
  );
  text-decoration: var(
    --sidebar-nav-link-text-decoration--active,
    var(--sidebar-nav-link-text-decoration)
  );
  -webkit-text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
  text-decoration-color: var(--sidebar-nav-link-text-decoration-color);
}
.sidebar-nav li.active > a[href^='/']:not([href*='?id=']):not(:only-child),
.sidebar-nav li.active > a[href^='#/']:not([href*='?id=']):not(:only-child) {
  background: var(
    --sidebar-nav-pagelink-background--active,
    var(
      --sidebar-nav-pagelink-background--loaded,
      var(--sidebar-nav-pagelink-background)
    )
  );
}
.sidebar-nav li.collapse > a[href^='/']:not([href*='?id=']):not(:only-child),
.sidebar-nav li.collapse > a[href^='#/']:not([href*='?id=']):not(:only-child) {
  background: var(
    --sidebar-nav-pagelink-background--collapse,
    var(
      --sidebar-nav-pagelink-background--loaded,
      var(--sidebar-nav-pagelink-background)
    )
  );
}
.sidebar-nav li.collapse .app-sub-sidebar {
  display: none;
}
.sidebar-nav > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l1,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l1,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l1, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l1--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l1, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l1--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l1, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > ul > li > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l2,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l2,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l2, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l2--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l2, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l2--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l2, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > ul > li > ul > li > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l3,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l3,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l3, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li > ul > li > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l3--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l3, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l3--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l3, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > ul > li > ul > li > ul > li > ul > li > a:before {
  content: var(
    --sidebar-nav-link-before-content-l4,
    var(--sidebar-nav-link-before-content)
  );
  margin: var(
    --sidebar-nav-link-before-margin-l4,
    var(--sidebar-nav-link-before-margin)
  );
  color: var(--sidebar-nav-link-before-color-l4, var(--sidebar-nav-link-before-color));
}
.sidebar-nav > ul > li > ul > li > ul > li > ul > li.active > a:before {
  content: var(
    --sidebar-nav-link-before-content-l4--active,
    var(
      --sidebar-nav-link-before-content--active,
      var(--sidebar-nav-link-before-content-l4, var(--sidebar-nav-link-before-content))
    )
  );
  color: var(
    --sidebar-nav-link-before-color-l4--active,
    var(
      --sidebar-nav-link-before-color--active,
      var(--sidebar-nav-link-before-color-l4, var(--sidebar-nav-link-before-color))
    )
  );
}
.sidebar-nav > :last-child {
  margin-bottom: 2rem;
}
.sidebar-toggle,
.sidebar-toggle-button {
  width: var(--sidebar-toggle-width);
  outline: none;
}
.sidebar-toggle {
  position: fixed;
  z-index: 11;
  top: 0;
  bottom: 0;
  left: 0;
  max-width: 40px;
  margin: 0;
  padding: 0;
  border: 0;
  background: rgba(0, 0, 0, 0);
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  cursor: pointer;
}
.sidebar-toggle .sidebar-toggle-button {
  position: absolute;
  top: var(--sidebar-toggle-offset-top);
  left: var(--sidebar-toggle-offset-left);
  height: var(--sidebar-toggle-height);
  border-radius: var(--sidebar-toggle-border-radius);
  border-width: var(--sidebar-toggle-border-width);
  border-style: var(--sidebar-toggle-border-style);
  border-color: var(--sidebar-toggle-border-color);
  background: var(--sidebar-toggle-background, transparent);
  color: var(--sidebar-toggle-icon-color);
}
.sidebar-toggle span {
  position: absolute;
  top: calc(50% - var(--sidebar-toggle-icon-stroke-width) / 2);
  left: calc(50% - var(--sidebar-toggle-icon-width) / 2);
  height: var(--sidebar-toggle-icon-stroke-width);
  width: var(--sidebar-toggle-icon-width);
  background-color: currentColor;
}
.sidebar-toggle span:nth-child(1) {
  margin-top: calc(0px - var(--sidebar-toggle-icon-height) / 2);
}
.sidebar-toggle span:nth-child(3) {
  margin-top: calc(var(--sidebar-toggle-icon-height) / 2);
}
@media (min-width: 48em) {
  .sidebar-toggle {
    position: absolute;
    overflow: visible;
    top: var(--sidebar-toggle-offset-top);
    bottom: auto;
    left: 0;
    height: var(--sidebar-toggle-height);
    transform: translateX(var(--sidebar-width));
  }
  .sidebar-toggle .sidebar-toggle-button {
    top: 0;
  }
}
@media print {
  .sidebar-toggle {
    display: none;
  }
}
@media (max-width: 47.99em) {
  body.close .sidebar,
  body.close .sidebar-toggle,
  body.close .sidebar + .content {
    transform: translateX(var(--sidebar-width));
  }
}
@media (min-width: 48em) {
  body.close .sidebar + .content {
    transform: translateX(0);
  }
}
@media (max-width: 47.99em) {
  body.close nav.app-nav,
  body.close .github-corner {
    display: none;
  }
}
@media (min-width: 48em) {
  body.close .sidebar,
  body.close .sidebar-toggle {
    transform: translateX(0);
  }
}
@media (min-width: 48em) {
  body.close nav.app-nav {
    margin-left: 0;
  }
}
@media (max-width: 47.99em) {
  body.close .sidebar-toggle {
    width: 100%;
    max-width: none;
  }
  body.close .sidebar-toggle span {
    margin-top: 0;
  }
  body.close .sidebar-toggle span:nth-child(1) {
    transform: rotate(45deg);
  }
  body.close .sidebar-toggle span:nth-child(2) {
    display: none;
  }
  body.close .sidebar-toggle span:nth-child(3) {
    transform: rotate(-45deg);
  }
}
@media (min-width: 48em) {
  body.close .sidebar + .content {
    margin-left: 0;
  }
}
@media (min-width: 48em) {
  body.sticky .sidebar,
  body.sticky .sidebar-toggle {
    position: fixed;
  }
}
body .docsify-copy-code-button,
body .docsify-copy-code-button:after {
  border-radius: var(--border-radius-m, 0);
  border-top-left-radius: 0;
  border-bottom-right-radius: 0;
  background: var(--copycode-background);
  color: var(--copycode-color);
}
body .docsify-copy-code-button span {
  border-radius: var(--border-radius-s, 0);
}
body .docsify-pagination-container {
  border-top: var(--pagination-border-top);
  color: var(--pagination-color);
}
body .pagination-item-label {
  font-size: var(--pagination-label-font-size);
}
body .pagination-item-label svg {
  color: var(--pagination-label-color);
  height: var(--pagination-chevron-height);
  stroke: var(--pagination-chevron-stroke);
  stroke-linecap: var(--pagination-chevron-stroke-linecap);
  stroke-linejoin: var(--pagination-chevron-stroke-linecap);
  stroke-width: var(--pagination-chevron-stroke-width);
}
body .pagination-item-title {
  color: var(--pagination-title-color);
  font-size: var(--pagination-title-font-size);
}
body .app-name.hide {
  display: block;
}
body .sidebar {
  padding: var(--sidebar-padding);
}
.sidebar .search {
  margin: 0;
  padding: 0;
  border: 0;
}
.sidebar .search input {
  padding: 0;
  line-height: 1;
  font-size: inherit;
}
.sidebar .search .clear-button {
  width: auto;
}
.sidebar .search .clear-button svg {
  transform: scale(1);
}
.sidebar .search .matching-post {
  border: none;
}
.sidebar .search p {
  font-size: inherit;
}
.sidebar .search {
  order: var(--search-flex-order);
  margin: var(--search-margin);
  padding: var(--search-padding);
  background: var(--search-background);
}
.sidebar .search a {
  color: inherit;
}
.sidebar .search h2 {
  margin: var(--search-result-heading-margin);
  font-size: var(--search-result-heading-font-size);
  font-weight: var(--search-result-heading-font-weight);
  color: var(--search-result-heading-color);
}
.sidebar .search .input-wrap {
  align-items: stretch;
  margin: var(--search-input-margin);
  background-color: var(--search-input-background-color);
  border-width: var(--search-input-border-width, 0);
  border-style: solid;
  border-color: var(--search-input-border-color);
  border-radius: var(--search-input-border-radius);
}
.sidebar .search input[type='search'] {
  min-width: 0;
  padding: var(--search-input-padding);
  border: none;
  background-color: rgba(0, 0, 0, 0);
  background-image: var(--search-input-background-image);
  background-position: var(--search-input-background-position);
  background-repeat: var(--search-input-background-repeat);
  background-size: var(--search-input-background-size);
  font-size: var(--search-input-font-size);
  color: var(--search-input-color);
  transition: var(--search-input-transition);
}
.sidebar .search input[type='search']::-ms-clear {
  display: none;
}
.sidebar .search input[type='search']::-moz-placeholder {
  color: var(--search-input-placeholder-color, #808080);
}
.sidebar .search input[type='search']::placeholder {
  color: var(--search-input-placeholder-color, #808080);
}
.sidebar .search input[type='search']::-webkit-input-placeholder {
  line-height: normal;
}
.sidebar .search input[type='search']:focus {
  background-color: var(
    --search-input-background-color--focus,
    var(--search-input-background-color)
  );
  background-image: var(
    --search-input-background-image--focus,
    var(--search-input-background-image)
  );
  background-position: var(
    --search-input-background-position--focus,
    var(--search-input-background-position)
  );
  background-size: var(
    --search-input-background-size--focus,
    var(--search-input-background-size)
  );
}
@supports (width: env(safe-area-inset)) {
  @media only screen and (orientation: landscape) {
    .sidebar .search input[type='search'] {
      margin-left: calc(env(safe-area-inset-left) / 2);
    }
  }
}
.sidebar .search p {
  overflow: hidden;
  text-overflow: ellipsis;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}
.sidebar .search p:empty {
  text-align: center;
}
.sidebar .search .clear-button {
  margin: 0;
  padding: 0 10px;
  border: none;
  line-height: 1;
  background: rgba(0, 0, 0, 0);
  cursor: pointer;
}
.sidebar .search .clear-button svg circle {
  fill: var(--search-clear-icon-color1, #808080);
}
.sidebar .search .clear-button svg path {
  stroke: var(--search-clear-icon-color2, #fff);
}
.sidebar .search.show ~ *:not(h1) {
  display: none;
}
.sidebar .search .results-panel {
  display: none;
  color: var(--search-result-item-color);
  font-size: var(--search-result-item-font-size);
  font-weight: var(--search-result-item-font-weight);
}
.sidebar .search .results-panel.show {
  display: block;
}
.sidebar .search .matching-post {
  margin: var(--search-result-item-margin);
  padding: var(--search-result-item-padding);
}
.sidebar .search .matching-post,
.sidebar .search .matching-post:last-child {
  border-width: var(--search-result-item-border-width, 0) !important;
  border-style: var(--search-result-item-border-style);
  border-color: var(--search-result-item-border-color);
}
.sidebar .search .matching-post p {
  margin: 0;
}
.sidebar .search .search-keyword {
  margin: var(--search-result-keyword-margin);
  padding: var(--search-result-keyword-padding);
  border-radius: var(--search-result-keyword-border-radius);
  background-color: var(--search-result-keyword-background);
  color: var(--search-result-keyword-color, currentColor);
  font-style: normal;
  font-weight: var(--search-result-keyword-font-weight);
}
.medium-zoom-overlay,
.medium-zoom-image--open,
.medium-zoom-image--opened {
  z-index: 2147483646 !important;
}
.medium-zoom-overlay {
  background: var(--zoomimage-overlay-background) !important;
}
:root {
  --mono-hue: 113;
  --mono-saturation: 0%;
  --mono-shade3: hsl(var(--mono-hue), var(--mono-saturation), 20%);
  --mono-shade2: hsl(var(--mono-hue), var(--mono-saturation), 30%);
  --mono-shade1: hsl(var(--mono-hue), var(--mono-saturation), 40%);
  --mono-base: hsl(var(--mono-hue), var(--mono-saturation), 50%);
  --mono-tint1: hsl(var(--mono-hue), var(--mono-saturation), 70%);
  --mono-tint2: hsl(var(--mono-hue), var(--mono-saturation), 89%);
  --mono-tint3: hsl(var(--mono-hue), var(--mono-saturation), 97%);
  --theme-hue: 204;
  --theme-saturation: 90%;
  --theme-lightness: 45%;
  --theme-color: hsl(var(--theme-hue), var(--theme-saturation), var(--theme-lightness));
  --modular-scale: 1.333;
  --modular-scale--2: calc(var(--modular-scale--1) / var(--modular-scale));
  --modular-scale--1: calc(var(--modular-scale-1) / var(--modular-scale));
  --modular-scale-1: 1rem;
  --modular-scale-2: calc(var(--modular-scale-1) * var(--modular-scale));
  --modular-scale-3: calc(var(--modular-scale-2) * var(--modular-scale));
  --modular-scale-4: calc(var(--modular-scale-3) * var(--modular-scale));
  --modular-scale-5: calc(var(--modular-scale-4) * var(--modular-scale));
  --font-size-xxxl: var(--modular-scale-5);
  --font-size-xxl: var(--modular-scale-4);
  --font-size-xl: var(--modular-scale-3);
  --font-size-l: var(--modular-scale-2);
  --font-size-m: var(--modular-scale-1);
  --font-size-s: var(--modular-scale--1);
  --font-size-xs: var(--modular-scale--2);
  --duration-slow: 1s;
  --duration-medium: 0.5s;
  --duration-fast: 0.25s;
  --spinner-size: 60px;
  --spinner-track-width: 4px;
  --spinner-track-color: rgba(0, 0, 0, 0.15);
  --spinner-transition-duration: var(--duration-medium);
}
:root {
  --base-background-color: #fff;
  --base-color: var(--mono-shade2);
  --base-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial,
    sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  --base-font-size: 16px;
  --base-font-weight: normal;
  --base-line-height: 1.7;
  --emoji-size: calc(var(--base-line-height) * 1em);
  --hr-border: 1px solid var(--mono-tint2);
  --mark-background: #ffecb3;
  --pre-font-family: var(--code-font-family);
  --pre-font-size: var(--code-font-size);
  --pre-font-weight: normal;
  --selection-color: #b4d5fe;
  --small-font-size: var(--font-size-s);
  --strong-color: var(--heading-color);
  --strong-font-weight: 600;
  --subsup-font-size: var(--font-size-s);
}
:root {
  --content-max-width: 55em;
  --blockquote-background: var(--mono-tint3);
  --blockquote-border-style: solid;
  --blockquote-border-radius: var(--border-radius-m);
  --blockquote-em-font-weight: normal;
  --blockquote-font-weight: normal;
  --blockquote-padding: 1.5em;
  --code-font-family: Inconsolata, Consolas, Menlo, Monaco, 'Andale Mono WT',
    'Andale Mono', 'Lucida Console', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono',
    'Courier New', Courier, monospace;
  --code-font-size: calc(var(--font-size-m) * 0.95);
  --code-font-weight: normal;
  --code-tab-size: 4;
  --code-block-border-radius: var(--border-radius-m);
  --code-block-line-height: var(--base-line-height);
  --code-block-margin: 1em 0;
  --code-block-padding: 1.75em 1.5em 1.5em 1.5em;
  --code-inline-background: var(--code-theme-background);
  --code-inline-border-radius: var(--border-radius-s);
  --code-inline-color: var(--code-theme-text);
  --code-inline-margin: 0 0.15em;
  --code-inline-padding: 0.125em 0.4em;
  --code-theme-background: var(--mono-tint3);
  --heading-color: var(--mono-shade3);
  --heading-margin: 2.5rem 0 0;
  --heading-h1-border-style: solid;
  --heading-h1-font-size: var(--font-size-xxl);
  --heading-h2-border-style: solid;
  --heading-h2-font-size: var(--font-size-xl);
  --heading-h3-border-style: solid;
  --heading-h3-font-size: var(--font-size-l);
  --heading-h4-border-style: solid;
  --heading-h4-font-size: var(--font-size-m);
  --heading-h5-border-style: solid;
  --heading-h5-font-size: var(--font-size-s);
  --heading-h6-border-style: solid;
  --heading-h6-font-size: var(--font-size-xs);
  --kbd-background: var(--mono-tint3);
  --kbd-border-radius: var(--border-radius-m);
  --kbd-margin: 0 0.3em;
  --kbd-min-width: 2.5em;
  --kbd-padding: 0.65em 0.5em;
  --link-text-decoration: underline;
  --notice-background: var(--mono-tint3);
  --notice-border-radius: var(--border-radius-m);
  --notice-border-style: solid;
  --notice-font-weight: normal;
  --notice-padding: 1em 1.5em;
  --notice-before-font-weight: normal;
  --table-cell-padding: 0.75em 0.5em;
  --table-head-border-color: var(--table-cell-border-color);
  --table-head-font-weight: var(--strong-font-weight);
  --table-row-odd-background: var(--mono-tint3);
}
:root {
  --cover-margin: 0 auto;
  --cover-max-width: 40em;
  --cover-text-align: center;
  --cover-background-color: var(--base-background-color);
  --cover-background-mask-color: var(--base-background-color);
  --cover-background-mask-opacity: 0.8;
  --cover-background-position: center center;
  --cover-background-repeat: no-repeat;
  --cover-background-size: cover;
  --cover-blockquote-font-size: var(--font-size-l);
  --cover-border-color: var(--theme-color);
  --cover-button-border: 1px solid var(--theme-color);
  --cover-button-border-radius: var(--border-radius-m);
  --cover-button-color: var(--theme-color);
  --cover-button-padding: 0.5em 2rem;
  --cover-button-text-decoration: none;
  --cover-button-transition: all var(--duration-fast) ease-in-out;
  --cover-button-primary-background: var(--theme-color);
  --cover-button-primary-border: 1px solid var(--theme-color);
  --cover-button-primary-color: #fff;
  --cover-heading-color: var(--theme-color);
  --cover-heading-font-size: var(--font-size-xxl);
  --cover-heading-font-weight: normal;
  --cover-link-text-decoration: underline;
}
:root {
  --navbar-root-border-style: solid;
  --navbar-root-margin: 0 0 0 1.5em;
  --navbar-root-transition: all var(--duration-fast);
  --navbar-menu-background: var(--base-background-color);
  --navbar-menu-border-radius: var(--border-radius-m);
  --navbar-menu-box-shadow: rgba(45, 45, 45, 0.05) 0px 0px 1px,
    rgba(49, 49, 49, 0.05) 0px 1px 2px, rgba(42, 42, 42, 0.05) 0px 2px 4px,
    rgba(32, 32, 32, 0.05) 0px 4px 8px, rgba(49, 49, 49, 0.05) 0px 8px 16px,
    rgba(35, 35, 35, 0.05) 0px 16px 32px;
  --navbar-menu-padding: 0.5em;
  --navbar-menu-transition: all var(--duration-fast);
  --navbar-menu-link-border-style: solid;
  --navbar-menu-link-margin: 0.75em 0.5em;
  --navbar-menu-link-padding: 0.2em 0;
}
:root {
  --copycode-background: #808080;
  --copycode-color: #fff;
}
:root {
  --docsifytabs-border-color: var(--mono-tint2);
  --docsifytabs-border-radius-px: var(--border-radius-s);
  --docsifytabs-tab-background: var(--mono-tint3);
  --docsifytabs-tab-color: var(--mono-tint1);
}
:root {
  --pagination-border-top: 1px solid var(--mono-tint2);
  --pagination-chevron-height: 0.8em;
  --pagination-chevron-stroke: currentColor;
  --pagination-chevron-stroke-linecap: round;
  --pagination-chevron-stroke-width: 1px;
  --pagination-label-font-size: var(--font-size-s);
  --pagination-title-font-size: var(--font-size-l);
}
:root {
  --search-margin: 1.5rem 0 0;
  --search-input-background-repeat: no-repeat;
  --search-input-border-color: var(--mono-tint1);
  --search-input-border-width: 1px;
  --search-input-padding: 0.5em;
  --search-flex-order: 1;
  --search-result-heading-color: var(--heading-color);
  --search-result-heading-font-size: var(--base-font-size);
  --search-result-heading-font-weight: normal;
  --search-result-heading-margin: 0 0 0.25em;
  --search-result-item-border-color: var(--mono-tint2);
  --search-result-item-border-style: solid;
  --search-result-item-border-width: 0 0 1px 0;
  --search-result-item-font-weight: normal;
  --search-result-item-padding: 1em 0;
  --search-result-keyword-background: var(--mark-background);
  --search-result-keyword-border-radius: var(--border-radius-s);
  --search-result-keyword-color: var(--mark-color);
  --search-result-keyword-font-weight: normal;
  --search-result-keyword-margin: 0 0.1em;
  --search-result-keyword-padding: 0.2em 0;
}
:root {
  --zoomimage-overlay-background: rgba(0, 0, 0, 0.875);
}
:root {
  --sidebar-background: var(--base-background-color);
  --sidebar-border-width: 0;
  --sidebar-padding: 0 25px;
  --sidebar-transition-duration: var(--duration-fast);
  --sidebar-width: 17rem;
  --sidebar-name-font-size: var(--font-size-l);
  --sidebar-name-font-weight: normal;
  --sidebar-name-margin: 1.5rem 0 0;
  --sidebar-name-text-align: center;
  --sidebar-nav-strong-border-color: var(--sidebar-border-color);
  --sidebar-nav-strong-color: var(--heading-color);
  --sidebar-nav-strong-font-weight: var(--strong-font-weight);
  --sidebar-nav-strong-margin: 1.5em 0 0.5em;
  --sidebar-nav-strong-padding: 0.25em 0;
  --sidebar-nav-indent: 1em;
  --sidebar-nav-margin: 1.5rem 0 0;
  --sidebar-nav-link-border-style: solid;
  --sidebar-nav-link-border-width: 0;
  --sidebar-nav-link-color: var(--base-color);
  --sidebar-nav-link-font-weight: normal;
  --sidebar-nav-link-padding: 0.25em 0;
  --sidebar-nav-link-text-decoration--active: underline;
  --sidebar-nav-link-text-decoration--hover: underline;
  --sidebar-nav-link-before-margin: 0 0.35em 0 0;
  --sidebar-nav-pagelink-transition: var(--sidebar-nav-link-transition);
  --sidebar-toggle-border-radius: var(--border-radius-s);
  --sidebar-toggle-border-style: solid;
  --sidebar-toggle-border-width: 0;
  --sidebar-toggle-height: 36px;
  --sidebar-toggle-icon-color: var(--base-color);
  --sidebar-toggle-icon-height: 10px;
  --sidebar-toggle-icon-stroke-width: 1px;
  --sidebar-toggle-icon-width: 16px;
  --sidebar-toggle-offset-left: 0;
  --sidebar-toggle-offset-top: calc(35px - (var(--sidebar-toggle-height) / 2));
  --sidebar-toggle-width: 44px;
}
:root {
  --code-theme-background: #f3f3f3;
  --code-theme-comment: #6e8090;
  --code-theme-function: #dd4a68;
  --code-theme-keyword: #07a;
  --code-theme-operator: #a67f59;
  --code-theme-punctuation: #999;
  --code-theme-selector: #690;
  --code-theme-tag: #905;
  --code-theme-text: #333;
  --code-theme-variable: #e90;
}
:root {
  --border-radius-s: 2px;
  --border-radius-m: 4px;
  --border-radius-l: 8px;
  --strong-font-weight: 600;
  --blockquote-border-color: var(--theme-color);
  --blockquote-border-radius: 0 var(--border-radius-m) var(--border-radius-m) 0;
  --blockquote-border-width: 0 0 0 4px;
  --code-inline-background: var(--mono-tint2);
  --code-theme-background: var(--mono-tint3);
  --heading-font-weight: var(--strong-font-weight);
  --heading-h1-font-weight: 400;
  --heading-h2-font-weight: 400;
  --heading-h2-border-color: var(--mono-tint2);
  --heading-h2-border-width: 0 0 1px 0;
  --heading-h2-margin: 2.5rem 0 1.5rem;
  --heading-h2-padding: 0 0 1rem 0;
  --kbd-border: 1px solid var(--mono-tint2);
  --notice-border-radius: 0 var(--border-radius-m) var(--border-radius-m) 0;
  --notice-border-width: 0 0 0 4px;
  --notice-padding: 1em 1.5em 1em 3em;
  --notice-before-border-radius: 100%;
  --notice-before-font-weight: bold;
  --notice-before-height: 1.5em;
  --notice-before-left: 0.75em;
  --notice-before-line-height: 1.5;
  --notice-before-margin: 0 0.25em 0 0;
  --notice-before-position: absolute;
  --notice-before-width: var(--notice-before-height);
  --notice-important-background: hsl(340, 60%, 96%);
  --notice-important-border-color: hsl(340, 90%, 45%);
  --notice-important-before-background: var(--notice-important-border-color)
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23fff'%3E%3Cpath d='M10 14C10 15.1 9.1 16 8 16 6.9 16 6 15.1 6 14 6 12.9 6.9 12 8 12 9.1 12 10 12.9 10 14Z'/%3E%3Cpath d='M10 1.6C10 1.2 9.8 0.9 9.6 0.7 9.2 0.3 8.6 0 8 0 7.4 0 6.8 0.2 6.5 0.6 6.2 0.9 6 1.2 6 1.6 6 1.7 6 1.8 6 1.9L6.8 9.6C6.9 9.9 7 10.1 7.2 10.2 7.4 10.4 7.7 10.5 8 10.5 8.3 10.5 8.6 10.4 8.8 10.3 9 10.1 9.1 9.9 9.2 9.6L10 1.9C10 1.8 10 1.7 10 1.6Z'/%3E%3C/svg%3E")
    center / 0.875em no-repeat;
  --notice-important-before-color: #fff;
  --notice-important-before-content: '';
  --notice-tip-background: hsl(204, 60%, 96%);
  --notice-tip-border-color: hsl(204, 90%, 45%);
  --notice-tip-before-background: var(--notice-tip-border-color)
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23fff'%3E%3Cpath d='M9.1 0C10.2 0 10.7 0.7 10.7 1.6 10.7 2.6 9.8 3.6 8.6 3.6 7.6 3.6 7 3 7 2 7 1.1 7.7 0 9.1 0Z'/%3E%3Cpath d='M5.8 16C5 16 4.4 15.5 5 13.2L5.9 9.1C6.1 8.5 6.1 8.2 5.9 8.2 5.7 8.2 4.6 8.6 3.9 9.1L3.5 8.4C5.6 6.6 7.9 5.6 8.9 5.6 9.8 5.6 9.9 6.6 9.5 8.2L8.4 12.5C8.2 13.2 8.3 13.5 8.5 13.5 8.7 13.5 9.6 13.2 10.4 12.5L10.9 13.2C8.9 15.2 6.7 16 5.8 16Z'/%3E%3C/svg%3E")
    center / 0.875em no-repeat;
  --notice-tip-before-color: #fff;
  --notice-tip-before-content: '';
  --table-cell-border-color: var(--mono-tint2);
  --table-cell-border-width: 1px 0;
  --cover-background-color: hsl(var(--theme-hue), 25%, 60%);
  --cover-background-image: radial-gradient(
    ellipse at center 115%,
    rgba(255, 255, 255, 0.9),
    transparent
  );
  --cover-blockquote-color: var(--strong-color);
  --cover-heading-color: #fff;
  --cover-heading-font-size-max: 56;
  --cover-heading-font-size-min: 34;
  --cover-heading-font-weight: 200;
  --navbar-root-color--active: var(--theme-color);
  --navbar-menu-border-radius: var(--border-radius-m);
  --navbar-menu-root-background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='9.6' height='6' viewBox='0 0 9.6 6'%3E%3Cpath d='M1.5 1.5l3.3 3 3.3-3' stroke-width='1.5' stroke='rgb%28179, 179, 179%29' fill='none' stroke-linecap='square' stroke-linejoin='miter' vector-effect='non-scaling-stroke'/%3E%3C/svg%3E")
    right no-repeat;
  --navbar-menu-root-padding: 0 18px 0 0;
  --search-input-background-color: #fff;
  --search-input-background-image: url("data:image/svg+xml,%3Csvg height='20px' width='20px' viewBox='0 0 24 24' fill='none' stroke='rgba(0, 0, 0, 0.3)' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round' preserveAspectRatio='xMidYMid meet' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='10.5' cy='10.5' r='7.5' vector-effect='non-scaling-stroke'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='15.8' y2='15.8' vector-effect='non-scaling-stroke'%3E%3C/line%3E%3C/svg%3E");
  --search-input-background-position: 21px center;
  --search-input-border-color: var(--sidebar-border-color);
  --search-input-border-width: 1px 0;
  --search-input-margin: 0 -25px;
  --search-input-padding: 0.65em 1em 0.65em 50px;
  --search-input-placeholder-color: rgba(0, 0, 0, 0.4);
  --search-clear-icon-color1: rgba(0, 0, 0, 0.3);
  --search-result-heading-font-weight: var(--strong-font-weight);
  --search-result-item-border-color: var(--sidebar-border-color);
  --search-result-keyword-border-radius: var(--border-radius-s);
  --sidebar-background: var(--mono-tint3);
  --sidebar-border-color: var(--mono-tint2);
  --sidebar-border-width: 0 1px 0 0;
  --sidebar-name-color: var(--theme-color);
  --sidebar-name-font-weight: 300;
  --sidebar-nav-strong-border-width: 0 0 1px 0;
  --sidebar-nav-strong-font-size: smaller;
  --sidebar-nav-strong-margin: 2em -25px 0.75em 0;
  --sidebar-nav-strong-padding: 0.25em 0 0.75em 0;
  --sidebar-nav-strong-text-transform: uppercase;
  --sidebar-nav-link-border-color: transparent;
  --sidebar-nav-link-border-color--active: var(--theme-color);
  --sidebar-nav-link-border-width: 0 4px 0 0;
  --sidebar-nav-link-color--active: var(--theme-color);
  --sidebar-nav-link-margin: 0 -25px 0 0;
  --sidebar-nav-link-text-decoration: none;
  --sidebar-nav-link-text-decoration--active: none;
  --sidebar-nav-link-text-decoration--hover: underline;
  --sidebar-nav-pagelink-background: no-repeat 2px calc(50% - 2.5px) / 6px 5px
      linear-gradient(
        45deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4px
      ),
    no-repeat 2px calc(50% + 2.5px) / 6px 5px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4px
      );
  --sidebar-nav-pagelink-background--active: no-repeat 0px center / 5px 6px
      linear-gradient(
        225deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4.25px
      ),
    no-repeat 5px center / 5px 6px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4.25px
      );
  --sidebar-nav-pagelink-background--collapse: no-repeat 2px calc(50% - 2.5px) / 6px 5px
      linear-gradient(
        45deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4px
      ),
    no-repeat 2px calc(50% + 2.5px) / 6px 5px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--theme-color) 2.75px 4.25px,
        transparent 4px
      );
  --sidebar-nav-pagelink-background--loaded: no-repeat 0px center / 5px 6px
      linear-gradient(
        225deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4.25px
      ),
    no-repeat 5px center / 5px 6px
      linear-gradient(
        135deg,
        transparent 2.75px,
        var(--mono-tint1) 2.75px 4.25px,
        transparent 4.25px
      );
  --sidebar-nav-pagelink-padding: 0.25em 0 0.25em 20px;
  --sidebar-nav-pagelink-transition: none;
  --sidebar-toggle-background: var(--sidebar-border-color);
  --sidebar-toggle-border-radius: 0 var(--border-radius-s) var(--border-radius-s) 0;
  --sidebar-toggle-width: 32px;
}

/*# sourceMappingURL=theme-simple.css.map */



================================================
FILE: docs/images/README.md
================================================
## favicon.ico

- https://pictogrammers.com/library/mdi/icon/camera-iris/
- $ convert camera-iris.png -define icon:auto-resize="256,128,96,64,48,32,16" favicon.ico



================================================
FILE: docs/js/search.js
================================================
(function () {
  /**
   * Converts a colon formatted string to a object with properties.
   *
   * This is process a provided string and look for any tokens in the format
   * of `:name[=value]` and then convert it to a object and return.
   * An example of this is ':include :type=code :fragment=demo' is taken and
   * then converted to:
   *
   * ```
   * {
   *  include: '',
   *  type: 'code',
   *  fragment: 'demo'
   * }
   * ```
   *
   * @param {string}   str   The string to parse.
   *
   * @return {object}  The original string and parsed object, { str, config }.
   */
  function getAndRemoveConfig(str) {
    if ( str === void 0 ) str = '';

    var config = {};

    if (str) {
      str = str
        .replace(/^('|")/, '')
        .replace(/('|")$/, '')
        .replace(/(?:^|\s):([\w-]+:?)=?([\w-%]+)?/g, function (m, key, value) {
          if (key.indexOf(':') === -1) {
            config[key] = (value && value.replace(/&quot;/g, '')) || true;
            return '';
          }

          return m;
        })
        .trim();
    }

    return { str: str, config: config };
  }

  function removeDocsifyIgnoreTag(str) {
    return str
      .replace(/<!-- {docsify-ignore} -->/, '')
      .replace(/{docsify-ignore}/, '')
      .replace(/<!-- {docsify-ignore-all} -->/, '')
      .replace(/{docsify-ignore-all}/, '')
      .trim();
  }

  /* eslint-disable no-unused-vars */

  var INDEXS = {};

  var LOCAL_STORAGE = {
    EXPIRE_KEY: 'docsify.search.expires',
    INDEX_KEY: 'docsify.search.index',
  };

  function resolveExpireKey(namespace) {
    return namespace
      ? ((LOCAL_STORAGE.EXPIRE_KEY) + "/" + namespace)
      : LOCAL_STORAGE.EXPIRE_KEY;
  }

  function resolveIndexKey(namespace) {
    return namespace
      ? ((LOCAL_STORAGE.INDEX_KEY) + "/" + namespace)
      : LOCAL_STORAGE.INDEX_KEY;
  }

  function escapeHtml(string) {
    var entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
    };

    return String(string).replace(/[&<>"']/g, function (s) { return entityMap[s]; });
  }

  function getAllPaths(router) {
    var paths = [];

    Docsify.dom
      .findAll('.sidebar-nav a:not(.section-link):not([data-nosearch])')
      .forEach(function (node) {
        var href = node.href;
        var originHref = node.getAttribute('href');
        var path = router.parse(href).path;

        if (
          path &&
          paths.indexOf(path) === -1 &&
          !Docsify.util.isAbsolutePath(originHref)
        ) {
          paths.push(path);
        }
      });

    return paths;
  }

  function getTableData(token) {
    if (!token.text && token.type === 'table') {
      token.cells.unshift(token.header);
      token.text = token.cells
        .map(function (rows) {
          return rows.join(' | ');
        })
        .join(' |\n ');
    }
    return token.text;
  }

  function getListData(token) {
    if (!token.text && token.type === 'list') {
      token.text = token.raw;
    }
    return token.text;
  }

  function saveData(maxAge, expireKey, indexKey) {
    localStorage.setItem(expireKey, Date.now() + maxAge);
    localStorage.setItem(indexKey, JSON.stringify(INDEXS));
  }

  function genIndex(path, content, router, depth) {
    if ( content === void 0 ) content = '';

    var tokens = window.marked.lexer(content);
    var slugify = window.Docsify.slugify;
    var index = {};
    var slug;
    var title = '';

    tokens.forEach(function (token, tokenIndex) {
      if (token.type === 'heading' && token.depth <= depth) {
        var ref = getAndRemoveConfig(token.text);
        var str = ref.str;
        var config = ref.config;

        var text = removeDocsifyIgnoreTag(token.text);

        if (config.id) {
          slug = router.toURL(path, { id: slugify(config.id) });
        } else {
          slug = router.toURL(path, { id: slugify(escapeHtml(text)) });
        }

        if (str) {
          title = removeDocsifyIgnoreTag(str);
        }

        index[slug] = { slug: slug, title: title, body: '' };
      } else {
        if (tokenIndex === 0) {
          slug = router.toURL(path);
          index[slug] = {
            slug: slug,
            title: path !== '/' ? path.slice(1) : 'Home Page',
            body: token.text || '',
          };
        }

        if (!slug) {
          return;
        }

        if (!index[slug]) {
          index[slug] = { slug: slug, title: '', body: '' };
        } else if (index[slug].body) {
          token.text = getTableData(token);
          token.text = getListData(token);

          index[slug].body += '\n' + (token.text || '');
        } else {
          token.text = getTableData(token);
          token.text = getListData(token);

          index[slug].body = token.text || '';
        }
      }
    });
    slugify.clear();
    return index;
  }

  function ignoreDiacriticalMarks(keyword) {
    if (keyword && keyword.normalize) {
      return keyword.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }
    return keyword;
  }

  /**
   * @param {String} query Search query
   * @returns {Array} Array of results
   */
  function search(query) {
    var matchingResults = [];
    var data = [];
    Object.keys(INDEXS).forEach(function (key) {
      data = data.concat(Object.keys(INDEXS[key]).map(function (page) { return INDEXS[key][page]; }));
    });

    query = query.trim();
    var keywords = query.split(/[\s\-，\\/]+/);
    if (keywords.length !== 1) {
      keywords = [].concat(query, keywords);
    }

    var loop = function ( i ) {
      var post = data[i];
      var matchesScore = 0;
      var resultStr = '';
      var handlePostTitle = '';
      var handlePostContent = '';
      var postTitle = post.title && post.title.trim();
      var postContent = post.body && post.body.trim();
      var postUrl = post.slug || '';

      if (postTitle) {
        keywords.forEach(function (keyword) {
          // From https://github.com/sindresorhus/escape-string-regexp
          var regEx = new RegExp(
            escapeHtml(ignoreDiacriticalMarks(keyword)).replace(
              /[|\\{}()[\]^$+*?.]/g,
              '\\$&'
            ),
            'gi'
          );
          var indexTitle = -1;
          var indexContent = -1;
          handlePostTitle = postTitle
            ? escapeHtml(ignoreDiacriticalMarks(postTitle))
            : postTitle;
          handlePostContent = postContent
            ? escapeHtml(ignoreDiacriticalMarks(postContent))
            : postContent;

          indexTitle = postTitle ? handlePostTitle.search(regEx) : -1;
          indexContent = postContent ? handlePostContent.search(regEx) : -1;

          if (indexTitle >= 0 || indexContent >= 0) {
            matchesScore += indexTitle >= 0 ? 3 : indexContent >= 0 ? 2 : 0;
            if (indexContent < 0) {
              indexContent = 0;
            }

            var start = 0;
            var end = 0;

            start = indexContent < 11 ? 0 : indexContent - 10;
            end = start === 0 ? 70 : indexContent + keyword.length + 60;

            if (postContent && end > postContent.length) {
              end = postContent.length;
            }

            var matchContent =
              handlePostContent &&
              '...' +
                handlePostContent
                  .substring(start, end)
                  .replace(
                    regEx,
                    function (word) { return ("<em class=\"search-keyword\">" + word + "</em>"); }
                  ) +
                '...';

            resultStr += matchContent;
          }
        });

        if (matchesScore > 0) {
          var matchingPost = {
            title: handlePostTitle,
            content: postContent ? resultStr : '',
            url: postUrl,
            score: matchesScore,
          };

          matchingResults.push(matchingPost);
        }
      }
    };

    for (var i = 0; i < data.length; i++) loop( i );

    return matchingResults.sort(function (r1, r2) { return r2.score - r1.score; });
  }

  function init(config, vm) {
    var isAuto = config.paths === 'auto';
    var paths = isAuto ? getAllPaths(vm.router) : config.paths;

    var namespaceSuffix = '';

    // only in auto mode
    if (paths.length && isAuto && config.pathNamespaces) {
      var path = paths[0];

      if (Array.isArray(config.pathNamespaces)) {
        namespaceSuffix =
          config.pathNamespaces.filter(
            function (prefix) { return path.slice(0, prefix.length) === prefix; }
          )[0] || namespaceSuffix;
      } else if (config.pathNamespaces instanceof RegExp) {
        var matches = path.match(config.pathNamespaces);

        if (matches) {
          namespaceSuffix = matches[0];
        }
      }
      var isExistHome = paths.indexOf(namespaceSuffix + '/') === -1;
      var isExistReadme = paths.indexOf(namespaceSuffix + '/README') === -1;
      if (isExistHome && isExistReadme) {
        paths.unshift(namespaceSuffix + '/');
      }
    } else if (paths.indexOf('/') === -1 && paths.indexOf('/README') === -1) {
      paths.unshift('/');
    }

    var expireKey = resolveExpireKey(config.namespace) + namespaceSuffix;
    var indexKey = resolveIndexKey(config.namespace) + namespaceSuffix;

    var isExpired = localStorage.getItem(expireKey) < Date.now();

    INDEXS = JSON.parse(localStorage.getItem(indexKey));

    if (isExpired) {
      INDEXS = {};
    } else if (!isAuto) {
      return;
    }

    var len = paths.length;
    var count = 0;

    paths.forEach(function (path) {
      if (INDEXS[path]) {
        return count++;
      }

      Docsify.get(vm.router.getFile(path), false, vm.config.requestHeaders).then(
        function (result) {
          INDEXS[path] = genIndex(path, result, vm.router, config.depth);
          len === ++count && saveData(config.maxAge, expireKey, indexKey);
        }
      );
    });
  }

  /* eslint-disable no-unused-vars */

  var NO_DATA_TEXT = '';
  var options;

  function style() {
    var code = "\n.sidebar {\n  padding-top: 0;\n}\n\n.search {\n  margin-bottom: 20px;\n  padding: 6px;\n  border-bottom: 1px solid #eee;\n}\n\n.search .input-wrap {\n  display: flex;\n  align-items: center;\n}\n\n.search .results-panel {\n  display: none;\n}\n\n.search .results-panel.show {\n  display: block;\n}\n\n.search input {\n  outline: none;\n  border: none;\n  width: 100%;\n  padding: 0.6em 7px;\n  font-size: inherit;\n  border: 1px solid transparent;\n}\n\n.search input:focus {\n  box-shadow: 0 0 5px var(--theme-color, #42b983);\n  border: 1px solid var(--theme-color, #42b983);\n}\n\n.search input::-webkit-search-decoration,\n.search input::-webkit-search-cancel-button,\n.search input {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.search input::-ms-clear {\n  display: none;\n  height: 0;\n  width: 0;\n}\n\n.search .clear-button {\n  cursor: pointer;\n  width: 36px;\n  text-align: right;\n  display: none;\n}\n\n.search .clear-button.show {\n  display: block;\n}\n\n.search .clear-button svg {\n  transform: scale(.5);\n}\n\n.search h2 {\n  font-size: 17px;\n  margin: 10px 0;\n}\n\n.search a {\n  text-decoration: none;\n  color: inherit;\n}\n\n.search .matching-post {\n  border-bottom: 1px solid #eee;\n}\n\n.search .matching-post:last-child {\n  border-bottom: 0;\n}\n\n.search p {\n  font-size: 14px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n}\n\n.search p.empty {\n  text-align: center;\n}\n\n.app-name.hide, .sidebar-nav.hide {\n  display: none;\n}";

    Docsify.dom.style(code);
  }

  function tpl(defaultValue) {
    if ( defaultValue === void 0 ) defaultValue = '';

    var html = "<div class=\"input-wrap\">\n      <input type=\"search\" value=\"" + defaultValue + "\" aria-label=\"Search text\" />\n      <div class=\"clear-button\">\n        <svg width=\"26\" height=\"24\">\n          <circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"#ccc\" />\n          <path stroke=\"white\" stroke-width=\"2\" d=\"M8.25,8.25,15.75,15.75\" />\n          <path stroke=\"white\" stroke-width=\"2\"d=\"M8.25,15.75,15.75,8.25\" />\n        </svg>\n      </div>\n    </div>\n    <div class=\"results-panel\"></div>\n    </div>";
    var el = Docsify.dom.create('div', html);
    var aside = Docsify.dom.find('aside');

    Docsify.dom.toggleClass(el, 'search');
    Docsify.dom.before(aside, el);
  }

  function doSearch(value) {
    var $search = Docsify.dom.find('div.search');
    var $panel = Docsify.dom.find($search, '.results-panel');
    var $clearBtn = Docsify.dom.find($search, '.clear-button');
    var $sidebarNav = Docsify.dom.find('.sidebar-nav');
    var $appName = Docsify.dom.find('.app-name');

    if (!value) {
      $panel.classList.remove('show');
      $clearBtn.classList.remove('show');
      $panel.innerHTML = '';

      if (options.hideOtherSidebarContent) {
        $sidebarNav && $sidebarNav.classList.remove('hide');
        $appName && $appName.classList.remove('hide');
      }

      return;
    }

    var matchs = search(value);

    var html = '';
    matchs.forEach(function (post) {
      html += "<div class=\"matching-post\">\n<a href=\"" + (post.url) + "\">\n<h2>" + (post.title) + "</h2>\n<p>" + (post.content) + "</p>\n</a>\n</div>";
    });

    $panel.classList.add('show');
    $clearBtn.classList.add('show');
    $panel.innerHTML = html || ("<p class=\"empty\">" + NO_DATA_TEXT + "</p>");
    if (options.hideOtherSidebarContent) {
      $sidebarNav && $sidebarNav.classList.add('hide');
      $appName && $appName.classList.add('hide');
    }
  }

  function bindEvents() {
    var $search = Docsify.dom.find('div.search');
    var $input = Docsify.dom.find($search, 'input');
    var $inputWrap = Docsify.dom.find($search, '.input-wrap');

    var timeId;

    /**
      Prevent to Fold sidebar.

      When searching on the mobile end,
      the sidebar is collapsed when you click the INPUT box,
      making it impossible to search.
     */
    Docsify.dom.on(
      $search,
      'click',
      function (e) { return ['A', 'H2', 'P', 'EM'].indexOf(e.target.tagName) === -1 &&
        e.stopPropagation(); }
    );
    Docsify.dom.on($input, 'input', function (e) {
      clearTimeout(timeId);
      timeId = setTimeout(function (_) { return doSearch(e.target.value.trim()); }, 100);
    });
    Docsify.dom.on($inputWrap, 'click', function (e) {
      // Click input outside
      if (e.target.tagName !== 'INPUT') {
        $input.value = '';
        doSearch();
      }
    });
  }

  function updatePlaceholder(text, path) {
    var $input = Docsify.dom.getNode('.search input[type="search"]');

    if (!$input) {
      return;
    }

    if (typeof text === 'string') {
      $input.placeholder = text;
    } else {
      var match = Object.keys(text).filter(function (key) { return path.indexOf(key) > -1; })[0];
      $input.placeholder = text[match];
    }
  }

  function updateNoData(text, path) {
    if (typeof text === 'string') {
      NO_DATA_TEXT = text;
    } else {
      var match = Object.keys(text).filter(function (key) { return path.indexOf(key) > -1; })[0];
      NO_DATA_TEXT = text[match];
    }
  }

  function updateOptions(opts) {
    options = opts;
  }

  function init$1(opts, vm) {
    var keywords = vm.router.parse().query.s;

    updateOptions(opts);
    style();
    tpl(keywords);
    bindEvents();
    keywords && setTimeout(function (_) { return doSearch(keywords); }, 500);
  }

  function update(opts, vm) {
    updateOptions(opts);
    updatePlaceholder(opts.placeholder, vm.route.path);
    updateNoData(opts.noData, vm.route.path);
  }

  /* eslint-disable no-unused-vars */

  var CONFIG = {
    placeholder: 'Type to search',
    noData: 'No Results!',
    paths: 'auto',
    depth: 2,
    maxAge: 86400000, // 1 day
    hideOtherSidebarContent: false,
    namespace: undefined,
    pathNamespaces: undefined,
  };

  var install = function (hook, vm) {
    var util = Docsify.util;
    var opts = vm.config.search || CONFIG;

    if (Array.isArray(opts)) {
      CONFIG.paths = opts;
    } else if (typeof opts === 'object') {
      CONFIG.paths = Array.isArray(opts.paths) ? opts.paths : 'auto';
      CONFIG.maxAge = util.isPrimitive(opts.maxAge) ? opts.maxAge : CONFIG.maxAge;
      CONFIG.placeholder = opts.placeholder || CONFIG.placeholder;
      CONFIG.noData = opts.noData || CONFIG.noData;
      CONFIG.depth = opts.depth || CONFIG.depth;
      CONFIG.hideOtherSidebarContent =
        opts.hideOtherSidebarContent || CONFIG.hideOtherSidebarContent;
      CONFIG.namespace = opts.namespace || CONFIG.namespace;
      CONFIG.pathNamespaces = opts.pathNamespaces || CONFIG.pathNamespaces;
    }

    var isAuto = CONFIG.paths === 'auto';

    hook.mounted(function (_) {
      init$1(CONFIG, vm);
      !isAuto && init(CONFIG, vm);
    });
    hook.doneEach(function (_) {
      update(CONFIG, vm);
      isAuto && init(CONFIG, vm);
    });
  };

  $docsify.plugins = [].concat(install, $docsify.plugins);

}());



================================================
FILE: docs/usage/README.md
================================================
# Usage

The usage of the card is intended to be reasonably self-explanatory. Some more
complex situations / requirements are discussed here.

### 2-way audio

See [2-way audio](2-way-audio.md) for documentation on using 2-way audio.

### Casting

See [Casting](casting.md) for documentation on casting the card.

### Custom Icons

See [Custom Icons](custom-icons.md) for custom icons this card supports.

### URL Actions

See [URL Actions](url-actions.md) for documentation on acting based on URL contents.



================================================
FILE: docs/usage/2-way-audio.md
================================================
# 2-way Audio

This card supports 2-way audio (e.g. transmitting audio from a microphone to a
suitably equipped camera). In general, due to the myriad of different cameras,
security requirements and browser limitations getting 2-way to work may be
challenging.

## Requirements

### Environmental requirements

- Must have a camera that supports audio out (otherwise what's the point!)
- Camera must be supported by `go2rtc` for 2-way audio (see [supported cameras](https://github.com/AlexxIT/go2rtc#two-way-audio)).
- Must be accessing your Home Assistant instance over `https`. The browser will enforce this.

### Card requirements

- Only Frigate cameras are supported.
- Only the `go2rtc` live provider is supported.
- Only the `webrtc` mode supports 2-way audio:
- Must have microphone menu button enabled:

## Example configuration

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: go2rtc
    go2rtc:
      modes:
        - webrtc
menu:
  buttons:
    microphone:
      enabled: true
```

## Usage

- The camera will always load _without_ the microphone connected, unless the
  [`always_connected`](../configuration/live.md?id=microphone) microphone option is
  set to `true`.
- To speak, hold-down the microphone menu button.
  - On first press, this will reset the `webrtc` connection to include 2-way
    audio unless [`always_connected`](../configuration/live.md?id=microphone) has
    been used.
  - Thereafter hold the microphone button down to unmute/speak, let go to
    mute.
- The video will automatically reset to remove the microphone after the number
  of seconds specified by
  [`disconnect_seconds`](../configuration/live.md?id=microphone) configuration have
  elapsed since the last mute/unmute press.



================================================
FILE: docs/usage/_sidebar.md
================================================
- [Getting Started](../README.md)
- [Configuration](../configuration/README.md)
- [Examples](../examples.md)
- [Screenshots](../screenshots.md)
- [Troubleshooting](../troubleshooting.md)
- [Usage](README.md)
  - [2-way audio](2-way-audio.md)
  - [Casting](casting.md)
  - [Custom Icons](custom-icons.md)
  - [Keyboard Shortcuts](keyboard-shortcuts.md)
  - [URL Actions](url-actions.md)

---

- [Developing](../developing.md)



================================================
FILE: docs/usage/casting.md
================================================
# Casting

This card allows casting a camera stream to a Google Cast device. You can enable the cast button with:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: go2rtc
menu:
  media_player:
    enabled: true
```

Clicking this button will allow you to choose a Google Cast device to cast the camera stream to, or the clip that is currently playing.

There are two different casting methods for cameras: `standard` and `dashboard` (see below).

## Standard Casting

This is the default casting method.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: go2rtc
    cast:
      method: standard
menu:
  media_player:
    enabled: true
```

This will send the camera stream to the Google Cast device through the use of the [`media_player.play_media` Home Assistant action](https://www.home-assistant.io/integrations/media_source/#playing-media-from-a-media-source).

The main disadvantage of this method is that the stream will be played through HLS which has a **delay of around 10 seconds**, making it sub-optimal for live monitoring.

## Dashboard Casting

This method is powered by [Home Assistant Cast](https://cast.home-assistant.io) and requires additional configuration, but allows **low latency streaming** with go2rtc.

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: go2rtc
    cast:
      method: dashboard
      dashboard:
        dashboard_path: dashboard-cast
        view_path: office
```

When the cast button is clicked, the card will perform the following Home Assistant action:

```yaml
action: cast.show_lovelace_view
data:
  entity_id: media_player.kitchen
  dashboard_path: dashboard-cast
  view_path: office
```

Which in turn will cast the specified Home Assistant dashboard (and view) to the Google Cast device.

For the example above to work, a dashboard with `dashboard-cast` URL must exist:

![image](https://github.com/user-attachments/assets/67f0e145-df05-412a-8c6d-897feb5439d2)

Within that dashboard, create an `office` view and finally within that view you can place the Advanced Camera Card configured for that camera for a proper full-screen casting experience:

```yaml
views:
  - title: Office
    type: panel
    path: office
    cards:
      - type: custom:advanced-camera-card
        cameras:
          - camera_entity: camera.office
            live_provider: go2rtc
        profiles:
          - low-performance
          - casting
```

The `casting` profile pre-configures the card to be casted to a 16:9 screen (such as a TV), including hiding all interactive elements and the menu. The `low-performance` profile is also recommended, as normally casting devices have limited hardware capabilities.

![](https://github.com/user-attachments/assets/bd96c4ad-36f5-4501-9018-23b496e7edc5)

When casting to a Google Nest Hub, the following configuration can be used:

```yaml
type: custom:advanced-camera-card
cameras:
  - camera_entity: camera.office
    live_provider: go2rtc
profiles:
  - low-performance
  - casting
menu:
  style: hidden
dimensions:
  aspect_ratio: 1024:600
```

This restores the menu and sets the aspect ratio to 1024:600, which is the resolution of the Nest Hub.

![](../images/card-on-nest-hub.jpg 'Casting on a Nest Hub :size=400')

### Limitations

Casting Home Assistant dashboards comes with a number of caveats:

- Home Assistant Casting does not support the HA `streaming` component
  ([source](https://cast.home-assistant.io/faq.html)). This means clips playing
  and the `ha` live provider can not work. Other live providers such as `jsmpeg`
  and `webrtc-card` function correctly.
- The Javascript fullscreen API does not work, so the fullscreen button does not
  work (use a `panel` view instead).



================================================
FILE: docs/usage/custom-icons.md
================================================
# Custom Icons

The [`menu`](../configuration/menu.md) and
[`status_bar`](../configuration/status-bar.md) both support a small set of
builtin custom items not found in the traditional [Material Design Icons
(`mdi`)](https://pictogrammers.com/library/mdi/) set by setting the relevant `icon` paramter to the following values.

| Icon Name   | Resulting Icon                                                              |
| ----------- | --------------------------------------------------------------------------- |
| `frigate`   | ![Frigate Icon](../images/icons/frigate.svg ':size=24 :class=svg-icon')     |
| `iris`      | ![Iris Icon](../images/icons/iris.svg ':size=24 :class=svg-icon')           |
| `motioneye` | ![motionEye Icon](../images/icons/motioneye.svg ':size=24 :class=svg-icon') |
| `reolink`   | ![Reolink Icon](../images/icons/reolink.svg ':size=24 :class=svg-icon')     |



================================================
FILE: docs/usage/keyboard-shortcuts.md
================================================
# Keyboard Shortcuts

There are two ways to have the card respond to key input:

- As a convenience, the card supports a small number of built in shortcuts with pre-defined default bindings. See below for these built in shortcuts. Use the [`keyboard_shortcuts`](../configuration/view.md?id=keyboard_shortcuts) configuration to change their bindings.
- More generally, _any_ [action](../configuration/actions/README.md) can be configured to run in response to keyboard input as part of an [automation](../configuration/automations.md), even if that action does not have a pre-defined shortcut. See [keyboard automation example](../examples.md?id=responding-to-key-input) to show how to execute any arbitrary action(s) in response to keyboard activity.

## Built-in shortcuts

| Name           | Default key binding | Action                                                                | Description         |
| -------------- | ------------------- | --------------------------------------------------------------------- | ------------------- |
| `ptz_down`     | `ArrowDown`         | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ move down.      |
| `ptz_home`     | `h`                 | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ home / default. |
| `ptz_left`     | `ArrowLeft`         | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ move left.      |
| `ptz_right`    | `ArrowRight`        | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ move right.     |
| `ptz_up`       | `ArrowUp`           | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ move up.        |
| `ptz_zoom_in`  | `+`                 | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ zoom in.        |
| `ptz_zoom_out` | `-`                 | [`ptz_multi`](../configuration/actions/custom/README.md?id=ptz_multi) | PTZ zoom out.       |



================================================
FILE: docs/usage/url-actions.md
================================================
# URL Actions

It is possible to pass the Advanced Camera Card one or more
[actions](../configuration/actions/README.md) from the URL (e.g. select a particular
camera, open the live view in expanded mode, etc).

### When actions are executed

The Advanced Camera Card will execute these actions in the following circumstances:

- On initial card load.
- On 'tab' change in a dashboard.
- When a `navigate` [action](https://www.home-assistant.io/dashboards/actions/)
  is called on the dashboard (e.g. a button click requests navigation).
- When the user uses the `back` / `forward` browser buttons whilst viewing a
  dashboard.

## Instructions

To send an action to _all_ Advanced Camera Cards on a dashboard:

```
[PATH_TO_YOUR_HA_DASHBOARD]?advanced-camera-card-action.[ACTION]=[VALUE]
```

To send an action to a specific named Advanced Camera Card:

```
[PATH_TO_YOUR_HA_DASHBOARD]?advanced-camera-card-action.[CARD_ID].[ACTION]=[VALUE]
```

?> For backwards compatibility, the card will also respond to `frigate-card-action` as a query-parameter with the same syntax.

| Parameter | Description                                                                                       |
| --------- | ------------------------------------------------------------------------------------------------- |
| `ACTION`  | One of the supported Advanced Camera Card custom actions. See below.                              |
| `CARD_ID` | When specified only cards that have a [`card_id`](../configuration/README.md) parameter will act. |
| `VALUE`   | An optional value to use with the `camera_select` and `live_substream_select` actions.            |

?> Both `.` and `:` may be used as the delimiter. If you use `:` some
browsers may require it be escaped to `%3A`.

!> If a dashboard has multiple Advanced Camera Cards on it, even if they are on
different 'tabs' within that dashboard, they will all respond to the actions
unless the action is targeted with a `CARD_ID` as shown above.

## Supported Actions

Only a subset of all [actions](../configuration/actions/README.md) are supported in URL form.

| Action                                                                                | Supported in URL         | Explanation                                                                                                         |
| ------------------------------------------------------------------------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| `camera_select`                                                                       | :white_check_mark:       |                                                                                                                     |
| `camera_ui`                                                                           | :white_check_mark:       |                                                                                                                     |
| `clip`                                                                                | :white_check_mark:       |                                                                                                                     |
| `clips`                                                                               | :white_check_mark:       |                                                                                                                     |
| `default`                                                                             | :white_check_mark:       |                                                                                                                     |
| `download`                                                                            | :heavy_multiplication_x: | Latest media information is not available on initial render.                                                        |
| `expand`                                                                              | :white_check_mark:       |                                                                                                                     |
| `fullscreen`                                                                          | :heavy_multiplication_x: | Javascript does not support activating fullscreen without direct human interaction. Use `expand` as an alternative. |
| `image`                                                                               | :white_check_mark:       |                                                                                                                     |
| `live_substream_select`                                                               | :white_check_mark:       |                                                                                                                     |
| `live`                                                                                | :white_check_mark:       |                                                                                                                     |
| `media_player`                                                                        | :heavy_multiplication_x: | Please [request](https://github.com/dermotduffy/advanced-camera-card/issues) if you need this.                      |
| `menu_toggle`                                                                         | :white_check_mark:       |                                                                                                                     |
| `microphone_connect`, `microphone_disconnect`, `microphone_mute`, `microphone_unmute` | :heavy_multiplication_x: |                                                                                                                     |
| `mute`, `unmute`                                                                      | :heavy_multiplication_x: |                                                                                                                     |
| `play`, `pause`                                                                       | :heavy_multiplication_x: |                                                                                                                     |
| `ptz`                                                                                 | :heavy_multiplication_x: | Please [request](https://github.com/dermotduffy/advanced-camera-card/issues) if you need this.                      |
| `recording`                                                                           | :white_check_mark:       |                                                                                                                     |
| `recordings`                                                                          | :white_check_mark:       |                                                                                                                     |
| `screenshot`                                                                          | :heavy_multiplication_x: | Latest media information is not available on initial render.                                                        |
| `ptz_controls`                                                                        | :heavy_multiplication_x: | Please [request](https://github.com/dermotduffy/advanced-camera-card/issues) if you need this.                      |
| `snapshot`                                                                            | :white_check_mark:       |                                                                                                                     |
| `snapshots`                                                                           | :white_check_mark:       |                                                                                                                     |

## Examples

See [URL actions examples](../examples.md?id=url-actions).



================================================
FILE: project.inlang/project_id
================================================
d140b5c2bbb618a6441e874d987530122309f246beb56c7cc7db10099528a75b



================================================
FILE: project.inlang/settings.json
================================================
{
  "$schema": "https://inlang.com/schema/project-settings",
  "sourceLanguageTag": "en",
  "languageTags": ["en", "it", "pt-BR", "pt-PT"],
  "modules": [
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-json@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-identical-pattern@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@latest/dist/index.js"
  ],
  "plugin.inlang.json": {
    "pathPattern": "./src/localize/languages/{languageTag}.json",
    "variableReferencePattern": ["{", "}"]
  }
}



================================================
FILE: scripts/docs-update-dependencies.sh
================================================
#!/bin/bash

# This script downloads css/js docs dependencies into locally served files.

CSS_URLS="
  https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple.css
  https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple-dark.css
"

JS_URLS="
  https://docsify-preview.vercel.app/dist/docsify.min.js
  https://docsify-preview.vercel.app/dist/plugins/gtag.min.js
  https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/js/docsify-themeable.min.js
  https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-yaml.min.js
  https://cdn.jsdelivr.net/npm/docsify@4/lib/plugins/search.js
  https://cdn.jsdelivr.net/npm/docsify/lib/plugins/zoom-image.min.js
  https://cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js
  https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js
"

for URL in $CSS_URLS; do
  echo "Fetching css $URL..."
  wget -q -O "docs/css/$(basename $URL)" "$URL"
done

for URL in $JS_URLS; do
  echo "Fetching js $URL..."
  wget -q -O "docs/js/$(basename $URL)" "$URL"
done



================================================
FILE: scripts/docs-update-icons.sh
================================================
#!/bin/bash

# This script copies icons out of the source tree for documentation.

FRIGATE="./src/camera-manager/frigate/assets/frigate.svg"
IRIS="./src/images/iris.svg"
MOTIONEYE="./src/camera-manager/motioneye/assets/motioneye.svg"
REOLINK="./src/camera-manager/reolink/assets/reolink.svg"
DIR_ICONS="./docs/images/icons"

copy() {
  PATH="$1"
  echo "Copying image $PATH to $DIR_ICONS"
  /bin/cp "$PATH" "$DIR_ICONS"
}

copy "$FRIGATE"
copy "$IRIS"
copy "$MOTIONEYE"
copy "$REOLINK"



================================================
FILE: scripts/docs-update-images.sh
================================================
#!/bin/bash

# This script downloads Google drawings into locally served image files.

WIDTH=1200

URL_FIT="https://docs.google.com/drawings/d/e/2PACX-1vTq0SVS8HWs3jGC0jjNpJoYfMbZS6P27CYyPlDhSa9OhdB_3jEb0HTLLYwu8Nv3J1TdjAJppcjTiVNy/pub?w=$WIDTH"
URL_THINNER_THAN_WIDTH="https://docs.google.com/drawings/d/e/2PACX-1vRkMd89N0tkZt5IghPKhR6gs8zMhB-5_hx5QfP6BCxbsSIga_h44IczP06Sj_YnKkxhe0lRdeR-uh04/pub?w=$WIDTH"
URL_SHORTER_THAN_HEIGHT="https://docs.google.com/drawings/d/e/2PACX-1vTKVsXEWIbj9lYKrCeugdLKcK_rOwAZZDK8IzhPdHH4wMwV2v7kEI0nsn2Qgugb00qDVHsE7kE8CBIC/pub?w=$WIDTH"
URL_VIEW_BOX="https://docs.google.com/drawings/d/e/2PACX-1vRpPNsaStxW2ENmv1kfUQg41cua9XQ2sQziq2PC8LdRCtkvjHSKYH3CyPO1Pz7kOdiQ2yQKrBX88-TF/pub?w=$WIDTH"
URL_PAN_ZOOM="https://docs.google.com/drawings/d/e/2PACX-1vTcbuMiqKo7-w0my3jaht1xdEFUhLSur1nSxhkxbuX0eagwuisaNCBfKvDjFY4hzNVGRZoBy7YehaMn/pub?w=$WIDTH"
URL_PROXY="https://docs.google.com/drawings/d/e/2PACX-1vRrRftUrBnlBN1KVBJjovLPzu966uBKoj9GWz_vaKVHPyayKSl2lioQTWkM8Gqik2zsImiYdCy23Z_O/pub?w=$WIDTH"

DIR_IMAGES="./docs/images"
DIR_MEDIA_LAYOUT_IMAGES="$DIR_IMAGES/media_layout"

fetch() {
  URL="$1"
  BASENAME="$2"
  TARGET_DIR="$3"

  echo "Fetching image $BASENAME.png to $TARGET_DIR..."  
  wget -q -O "$TARGET_DIR/$BASENAME.png" "$URL"
}

fetch "$URL_FIT" "fit" "$DIR_MEDIA_LAYOUT_IMAGES"
fetch "$URL_THINNER_THAN_WIDTH" "position-thinner-than-width" "$DIR_MEDIA_LAYOUT_IMAGES"
fetch "$URL_SHORTER_THAN_HEIGHT" "position-shorter-than-height" "$DIR_MEDIA_LAYOUT_IMAGES"
fetch "$URL_VIEW_BOX" "view-box" "$DIR_MEDIA_LAYOUT_IMAGES"
fetch "$URL_PAN_ZOOM" "pan-zoom" "$DIR_MEDIA_LAYOUT_IMAGES"
fetch "$URL_PROXY" "proxy" "$DIR_IMAGES"



================================================
FILE: src/action-handler-directive.ts
================================================
import { noChange } from 'lit';
import {
  AttributePart,
  Directive,
  DirectiveParameters,
  directive,
} from 'lit/directive.js';
import { fireHASSEvent } from './ha/fire-hass-event.js';
import { ActionHandlerDetail, ActionHandlerOptions } from './ha/types.js';
import { stopEventFromActivatingCardWideActions } from './utils/action.js';
import { Timer } from './utils/timer.js';

interface ActionHandlerInterface extends HTMLElement {
  holdTime: number;
  bind(element: Element, options): void;
}
interface ActionHandlerElement extends HTMLElement {
  actionHandlerOptions?: AdvancedCameraCardActionHandlerOptions;
}

interface AdvancedCameraCardActionHandlerOptions extends ActionHandlerOptions {
  allowPropagation?: boolean;
}

class ActionHandler extends HTMLElement implements ActionHandlerInterface {
  public holdTime = 0.4;

  protected holdTimer = new Timer();
  protected doubleClickTimer = new Timer();

  protected held = false;
  protected started = false;

  public connectedCallback(): void {
    [
      'touchcancel',
      'mouseout',
      'mouseup',
      'touchmove',
      'mousewheel',
      'wheel',
      'scroll',
    ].forEach((ev) => {
      document.addEventListener(
        ev,
        () => {
          this.holdTimer.stop();
        },
        { passive: true },
      );
    });
  }

  public bind(
    element: ActionHandlerElement,
    options?: AdvancedCameraCardActionHandlerOptions,
  ): void {
    if (element.actionHandlerOptions) {
      // Reset the options on an existing actionHandler.
      element.actionHandlerOptions = options;
      return;
    }
    element.actionHandlerOptions = options;

    element.addEventListener('contextmenu', (ev: Event) => {
      const e = ev || window.event;
      if (e.preventDefault) {
        e.preventDefault();
      }
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    });

    const start = (): void => {
      this.held = false;
      this.holdTimer.start(this.holdTime, () => {
        this.held = true;
      });

      // Without this check we get double start_tap events from touchstart and
      // mousedown events (on Android).
      if (!this.started) {
        this.started = true;
        fireHASSEvent(element, 'action', { action: 'start_tap' });
      }
    };

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const endTap = (_ev: Event): void => {
      this.holdTimer.stop();

      if (this.started) {
        this.started = false;
        fireHASSEvent(element, 'action', { action: 'end_tap' });
      }
    };

    const end = (ev: Event): void => {
      const options = element.actionHandlerOptions;
      if (!options?.allowPropagation) {
        // This will ensure only 1 actionHandler is invoked for a given interaction.
        stopEventFromActivatingCardWideActions(ev);
      }

      if (
        ['touchend', 'touchcancel'].includes(ev.type) &&
        // This action handler by default relies on synthetic click events for
        // touch devices, in order to ensure that embedded cards (e.g. WebRTC)
        // can use stock click handlers. The exception is for hold events.
        !this.held
      ) {
        return;
      }

      endTap(ev);

      if (options?.hasHold && this.held) {
        fireHASSEvent(element, 'action', { action: 'hold' });
      } else if (options?.hasDoubleClick) {
        if (
          (ev.type === 'click' && (ev as MouseEvent).detail < 2) ||
          !this.doubleClickTimer.isRunning()
        ) {
          this.doubleClickTimer.start(0.25, () =>
            fireHASSEvent(element, 'action', { action: 'tap' }),
          );
        } else {
          this.doubleClickTimer.stop();
          fireHASSEvent(element, 'action', { action: 'double_tap' });
        }
      } else {
        fireHASSEvent(element, 'action', { action: 'tap' });
      }
    };

    const handleEnter = (ev: KeyboardEvent): void => {
      if (ev.key === 'Enter') {
        end(ev);
      }
    };

    element.addEventListener('touchstart', start, { passive: true });
    element.addEventListener('touchend', end);
    element.addEventListener('touchcancel', end);

    element.addEventListener('mousedown', start, { passive: true });
    element.addEventListener('click', end);

    element.addEventListener('keyup', handleEnter);

    // If the mouse leaves the element, this is considered the end of the interaction.
    element.addEventListener('mouseleave', endTap);
  }
}

customElements.define('action-handler-advanced-camera-card', ActionHandler);

const getActionHandler = (): ActionHandler => {
  const body = document.body;
  if (body.querySelector('action-handler-advanced-camera-card')) {
    return body.querySelector('action-handler-advanced-camera-card') as ActionHandler;
  }

  const actionhandler = document.createElement('action-handler-advanced-camera-card');
  body.appendChild(actionhandler);

  return actionhandler as ActionHandler;
};

const actionHandlerBind = (
  element: ActionHandlerElement,
  options?: AdvancedCameraCardActionHandlerOptions,
): void => {
  const actionhandler: ActionHandler = getActionHandler();
  if (!actionhandler) {
    return;
  }
  actionhandler.bind(element, options);
};

export const actionHandler = directive(
  class extends Directive {
    update(part: AttributePart, [options]: DirectiveParameters<this>) {
      actionHandlerBind(part.element as ActionHandlerElement, options);
      return noChange;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(_options?: AdvancedCameraCardActionHandlerOptions) {}
  },
);

export interface ActionEventTarget extends EventTarget {
  addEventListener(
    event: '@action',
    listener: (this: ActionEventTarget, ev: CustomEvent<ActionHandlerDetail>) => void,
    options?: AddEventListenerOptions | boolean,
  ): void;
  addEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: AddEventListenerOptions | boolean,
  ): void;
  removeEventListener(
    event: '@action',
    listener: (this: ActionEventTarget, ev: CustomEvent<ActionHandlerDetail>) => void,
    options?: boolean | EventListenerOptions,
  ): void;
  removeEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions,
  ): void;
}

declare global {
  interface HTMLElementTagNameMap {
    'action-handler-advanced-camera-card': ActionHandler;
  }
  interface HASSDomEvents {
    action: ActionHandlerDetail;
  }
}



================================================
FILE: src/card.ts
================================================
import { CSSResultGroup, LitElement, TemplateResult, html, unsafeCSS } from 'lit';
import { customElement } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { Ref, createRef, ref } from 'lit/directives/ref.js';
import { styleMap } from 'lit/directives/style-map.js';
import 'web-dialog';
import { actionHandler } from './action-handler-directive.js';
import { CardController } from './card-controller/controller';
import { MenuButtonController } from './components-lib/menu-button-controller';
import './components/elements.js';
import { AdvancedCameraCardElements } from './components/elements.js';
import './components/loading.js';
import './components/menu.js';
import { AdvancedCameraCardMenu } from './components/menu.js';
import './components/message.js';
import { renderMessage } from './components/message.js';
import './components/overlay.js';
import { AdvancedCameraCardOverlay } from './components/overlay.js';
import './components/status-bar';
import './components/thumbnail-carousel.js';
import './components/views.js';
import { AdvancedCameraCardViews } from './components/views.js';
import { ConditionStateManagerGetEvent } from './conditions/state-manager-via-event.js';
import { StatusBarItem } from './config/schema/actions/types.js';
import { MenuItem } from './config/schema/elements/custom/menu/types.js';
import { AdvancedCameraCardConfig } from './config/schema/types.js';
import { RawAdvancedCameraCardConfig } from './config/types.js';
import { REPO_URL } from './const.js';
import { HomeAssistant, LovelaceCardEditor } from './ha/types.js';
import { localize } from './localize/localize.js';
import cardStyle from './scss/card.scss';
import { MediaLoadedInfo, Message } from './types.js';
import { hasAction } from './utils/action.js';
import { getReleaseVersion } from './utils/diagnostics';

// ***************************************************************************
//                         General Card-Wide Notes
// ***************************************************************************

/** Media callbacks:
 *
 * Media elements (e.g. <video>, <img> or <canvas>) need to callback when:
 *  - Metadata is loaded / dimensions are known (for aspect-ratio)
 *  - Media is playing / paused (to avoid reloading)
 *
 * A number of different approaches used to attach event handlers to
 * get these callbacks (which need to be attached directly to the media
 * elements, which may be 'buried' down the DOM):
 *  - Extend the `ha-hls-player` and `ha-camera-stream` to specify the required
 *    hooks (as querySelecting the media elements after rendering was a fight
 *    with the Lit rendering engine and was very fragile) .
 *  - For non-Lit elements (e.g. WebRTC) query selecting after rendering.
 *  - Library provided hooks (e.g. JSMPEG)
 *  - Directly specifying hooks (e.g. for snapshot viewing with simple <img> tags)
 */

// ***************************************************************************
//                          Static Initializers
// ***************************************************************************

console.info(
  `%c 📷 Advanced Camera Card %c ${getReleaseVersion()} `,
  'padding: 3px; color: black; background: pink;',
  'padding: 3px; color: black; background: white;',
);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
(window as any).customCards = (window as any).customCards || [];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
(window as any).customCards.push({
  type: 'advanced-camera-card',
  name: localize('common.advanced_camera_card'),
  description: localize('common.advanced_camera_card_description'),
  preview: true,
  documentationURL: REPO_URL,
});

// ***************************************************************************
//                    Main AdvancedCameraCard WebComponent
//
// Any non-rendering / non-lit related functionality should be added to
// CardController instead of this file.
// ***************************************************************************

@customElement('advanced-camera-card')
class AdvancedCameraCard extends LitElement {
  protected _controller = new CardController(
    this,
    // Callback to scroll the main pane back to the top (example usecase: scrolling
    // half way down the gallery, then viewing diagnostics should result in
    // diagnostics starting at the top).
    () => this._refMain.value?.scroll({ top: 0 }),
    () => this._refMenu.value?.toggleMenu(),
  );

  protected _menuButtonController = new MenuButtonController();

  protected _refMenu: Ref<AdvancedCameraCardMenu> = createRef();
  protected _refOverlay: Ref<AdvancedCameraCardOverlay> = createRef();
  protected _refMain: Ref<HTMLElement> = createRef();
  protected _refElements: Ref<AdvancedCameraCardElements> = createRef();
  protected _refViews: Ref<AdvancedCameraCardViews> = createRef();

  // Convenience methods for very frequently accessed attributes.
  get _config(): AdvancedCameraCardConfig | null {
    return this._controller.getConfigManager().getConfig();
  }

  get _hass(): HomeAssistant | null {
    return this._controller.getHASSManager().getHASS();
  }

  set hass(hass: HomeAssistant) {
    this._controller.getHASSManager().setHASS(hass);

    // Manually set hass in the menu, elements and image. This is to allow these
    // to update, without necessarily re-rendering the entire card (re-rendering
    // is expensive).
    if (this._refMenu.value) {
      this._refMenu.value.hass = hass;
    }
    if (this._refElements.value) {
      this._refElements.value.hass = hass;
    }
    if (this._refViews.value) {
      this._refViews.value.hass = hass;
    }
  }

  public static async getConfigElement(): Promise<LovelaceCardEditor> {
    return await CardController.getConfigElement();
  }

  public static getStubConfig(
    _: HomeAssistant,
    entities: string[],
  ): AdvancedCameraCardConfig {
    return CardController.getStubConfig(entities);
  }

  public setConfig(config: RawAdvancedCameraCardConfig): void {
    this._controller.getConfigManager().setConfig(config);
  }

  protected shouldUpdate(): boolean {
    // Do not allow a disconnected element to update, as it may cause cameras to
    // reinitialize/subscribe for an element that is no longer part of the
    // document.
    if (!this.isConnected) {
      return false;
    }

    // Always allow messages to render, as a message may be generated during
    // initialization.
    if (this._controller.getMessageManager().hasMessage()) {
      return true;
    }

    if (!this._controller.getInitializationManager().isInitializedMandatory()) {
      this._controller.getInitializationManager().initializeMandatory();
    }
    return true;
  }

  protected _renderMenuStatusContainer(
    position: 'top' | 'bottom' | 'overlay',
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }

    const menuStyle = this._config.menu.style;
    const menuPosition = this._config.menu.position;
    const statusBarStyle = this._config.status_bar.style;
    const statusBarPosition = this._config.status_bar.position;

    if (
      // If there's nothing to render...
      (menuStyle === 'none' && statusBarStyle === 'none') ||
      // ... or the position I'm rendering does not contain the menu/status bar
      (position === 'overlay' &&
        menuStyle === 'outside' &&
        statusBarStyle === 'outside') ||
      (position !== 'overlay' &&
        (menuStyle !== 'outside' || menuPosition !== position) &&
        (statusBarStyle !== 'outside' || statusBarPosition !== position))
    ) {
      // ... then there's nothing to do.
      return;
    }

    const getContents = (kind: 'overlay' | 'outerlay'): TemplateResult => {
      const shouldRenderMenu =
        menuStyle !== 'none' &&
        ((menuStyle === 'outside' && kind === 'outerlay' && menuPosition === position) ||
          (menuStyle !== 'outside' && kind === 'overlay'));

      const shouldRenderStatusBar =
        statusBarStyle !== 'none' &&
        ((statusBarStyle === 'outside' &&
          kind === 'outerlay' &&
          statusBarPosition === position) ||
          (statusBarStyle !== 'outside' && kind === 'overlay'));

      // Complex logic to try to always put the menu in the right-looking place.
      const renderMenuFirst =
        menuPosition === 'left' ||
        menuPosition === 'right' ||
        (menuPosition === 'bottom' &&
          menuStyle === 'hidden' &&
          statusBarStyle !== 'popup') ||
        (menuPosition === 'top' && statusBarStyle === 'popup');

      return html`
        ${shouldRenderMenu && renderMenuFirst ? this._renderMenu(menuPosition) : ''}
        ${shouldRenderStatusBar ? this._renderStatusBar(statusBarPosition) : ''}
        ${shouldRenderMenu && !renderMenuFirst ? this._renderMenu(menuPosition) : ''}
      `;
    };

    return html`
      ${position === 'overlay'
        ? html`<advanced-camera-card-overlay
            >${getContents('overlay')}</advanced-camera-card-overlay
          >`
        : html`<div class="outerlay" data-position="${position}">
            ${getContents('outerlay')}
          </div>`}
    `;
  }

  protected _renderMenu(slot?: string): TemplateResult | void {
    const view = this._controller.getViewManager().getView();
    if (!this._hass || !this._config) {
      return;
    }
    return html`
      <advanced-camera-card-menu
        ${ref(this._refMenu)}
        slot=${ifDefined(slot)}
        .hass=${this._hass}
        .menuConfig=${this._config.menu}
        .buttons=${this._menuButtonController.calculateButtons(
          this._hass,
          this._config,
          this._controller.getCameraManager(),
          {
            currentMediaLoadedInfo: this._controller.getMediaLoadedInfoManager().get(),
            foldersManager: this._controller.getFoldersManager(),
            fullscreenManager: this._controller.getFullscreenManager(),
            inExpandedMode: this._controller.getExpandManager().isExpanded(),
            mediaPlayerController: this._controller.getMediaPlayerManager(),
            microphoneManager: this._controller.getMicrophoneManager(),
            showCameraUIButton: this._controller.getCameraURLManager().hasCameraURL(),
            view: view,
            viewManager: this._controller.getViewManager(),
          },
        )}
        .entityRegistryManager=${this._controller.getEntityRegistryManager()}
      ></advanced-camera-card-menu>
    `;
  }

  protected _renderStatusBar(slot?: string): TemplateResult | void {
    if (!this._config) {
      return;
    }

    return html`
      <advanced-camera-card-status-bar
        slot=${ifDefined(slot)}
        .items=${this._controller.getStatusBarItemManager().calculateItems({
          statusConfig: this._config.status_bar,
          cameraManager: this._controller.getCameraManager(),
          view: this._controller.getViewManager().getView(),
          mediaLoadedInfo: this._controller.getMediaLoadedInfoManager().get(),
        })}
        .config=${this._config.status_bar}
      ></advanced-camera-card-status-bar>
    `;
  }

  protected updated(): void {
    if (this._controller.getInitializationManager().isInitializedMandatory()) {
      this._controller.getQueryStringManager().executeIfNecessary();
    }
  }

  protected _renderInDialogIfNecessary(contents: TemplateResult): TemplateResult | void {
    if (this._controller.getExpandManager().isExpanded()) {
      return html` <web-dialog
        open
        center
        @close=${() => {
          this._controller.getExpandManager().setExpanded(false);
        }}
      >
        ${contents}
      </web-dialog>`;
    } else {
      return contents;
    }
  }

  protected render(): TemplateResult | void {
    if (!this._hass) {
      return;
    }

    const outerlayUsed =
      this._config?.menu.style === 'outside' ||
      this._config?.status_bar.style === 'outside';

    const mainClasses = {
      main: true,
      'curve-top':
        !outerlayUsed ||
        (this._config?.menu.position !== 'top' &&
          this._config?.status_bar.position !== 'top'),
      'curve-bottom':
        !outerlayUsed ||
        (this._config?.menu.position !== 'bottom' &&
          this._config?.status_bar.position !== 'bottom'),
    };

    const actions = this._controller.getActionsManager().getMergedActions();
    const cameraManager = this._controller.getCameraManager();

    const showLoading =
      this._config?.performance?.features.card_loading_indicator !== false &&
      !this._controller.getMessageManager().hasMessage();

    // Caution: Keep the main div and the menu next to one another in order to
    // ensure the hover menu styling continues to work.
    return this._renderInDialogIfNecessary(
      html` <ha-card
        id="ha-card"
        .actionHandler=${actionHandler({
          hasHold: hasAction(actions.hold_action),
          hasDoubleClick: hasAction(actions.double_tap_action),
        })}
        style="${styleMap(this._controller.getStyleManager().getAspectRatioStyle())}"
        @advanced-camera-card:message=${(ev: CustomEvent<Message>) =>
          this._controller.getMessageManager().setMessageIfHigherPriority(ev.detail)}
        @advanced-camera-card:media:loaded=${(ev: CustomEvent<MediaLoadedInfo>) =>
          this._controller.getMediaLoadedInfoManager().set(ev.detail)}
        @advanced-camera-card:media:unloaded=${() =>
          this._controller.getMediaLoadedInfoManager().clear()}
        @advanced-camera-card:media:volumechange=${
          () => this.requestUpdate() /* Refresh mute menu button */
        }
        @advanced-camera-card:media:play=${
          () => this.requestUpdate() /* Refresh play/pause menu button */
        }
        @advanced-camera-card:media:pause=${
          () => this.requestUpdate() /* Refresh play/pause menu button */
        }
        @advanced-camera-card:focus=${() => this.focus()}
      >
        ${showLoading
          ? html`<advanced-camera-card-loading
              ?loaded=${this._controller.getInitializationManager().wasEverInitialized()}
            ></advanced-camera-card-loading>`
          : ''}
        ${this._renderMenuStatusContainer('top')}
        ${this._renderMenuStatusContainer('overlay')}
        <div ${ref(this._refMain)} class="${classMap(mainClasses)}">
          <advanced-camera-card-views
            ${ref(this._refViews)}
            .hass=${this._hass}
            .viewManagerEpoch=${this._controller.getViewManager().getEpoch()}
            .cameraManager=${cameraManager}
            .viewItemManager=${this._controller.getViewItemManager()}
            .resolvedMediaCache=${this._controller.getResolvedMediaCache()}
            .config=${this._controller.getConfigManager().getConfig()}
            .cardWideConfig=${this._controller.getConfigManager().getCardWideConfig()}
            .rawConfig=${this._controller.getConfigManager().getRawConfig()}
            .configManager=${this._controller.getConfigManager()}
            .hide=${!!this._controller.getMessageManager().hasMessage()}
            .microphoneState=${this._controller.getMicrophoneManager().getState()}
            .triggeredCameraIDs=${this._config?.view.triggers.show_trigger_status
              ? this._controller.getTriggersManager().getTriggeredCameraIDs()
              : undefined}
            .deviceRegistryManager=${this._controller.getDeviceRegistryManager()}
          ></advanced-camera-card-views>
          ${this._controller.getMessageManager().hasMessage()
            ? // Keep message rendering to last to show messages that may have been
              // generated during the render.
              renderMessage(this._controller.getMessageManager().getMessage())
            : ''}
        </div>
        ${this._renderMenuStatusContainer('bottom')}
        ${this._config?.elements
          ? // Elements need to render after the main views so it can render 'on
            // top'.
            html` <advanced-camera-card-elements
              ${ref(this._refElements)}
              .hass=${this._hass}
              .elements=${this._config?.elements}
              @advanced-camera-card:menu:add=${(ev: CustomEvent<MenuItem>) => {
                this._menuButtonController.addDynamicMenuButton(ev.detail);
                this.requestUpdate();
              }}
              @advanced-camera-card:menu:remove=${(ev: CustomEvent<MenuItem>) => {
                this._menuButtonController.removeDynamicMenuButton(ev.detail);
                this.requestUpdate();
              }}
              @advanced-camera-card:status-bar:add=${(
                ev: CustomEvent<StatusBarItem>,
              ) => {
                this._controller
                  .getStatusBarItemManager()
                  .addDynamicStatusBarItem(ev.detail);
              }}
              @advanced-camera-card:status-bar:remove=${(
                ev: CustomEvent<StatusBarItem>,
              ) => {
                this._controller
                  .getStatusBarItemManager()
                  .removeDynamicStatusBarItem(ev.detail);
              }}
              @advanced-camera-card:condition-state-manager:get=${(
                ev: ConditionStateManagerGetEvent,
              ) => {
                ev.conditionStateManager = this._controller.getConditionStateManager();
              }}
            >
            </advanced-camera-card-elements>`
          : ``}
      </ha-card>`,
    );
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(cardStyle);
  }

  public getCardSize(): number {
    // This method is called before the card is rendered. As such, we don't
    // actually know what height the card will end up being, and for this card
    // it may change significantly with usage. As such, we just return a fixed
    // size guess (stock HA cards, such as the picture glance card, do similar).

    // Lovelace card size is expressed in units of 50px. A 16:9 aspect-ratio
    // camera will likely render as a 276.75px height masonary card => 5.52
    // units of 50, round up to 6.
    return 6;
  }
}

// Keep the old name around for backwards compatibility.
@customElement('frigate-card')
class FrigateCard extends AdvancedCameraCard {}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card': AdvancedCameraCard;
    'frigate-card': FrigateCard;
  }
}



================================================
FILE: src/const.ts
================================================
export const REPO_URL = 'https://github.com/dermotduffy/advanced-camera-card' as const;
const DOCS_URL = 'https://card.camera' as const;
export const TROUBLESHOOTING_URL = `${DOCS_URL}/#/troubleshooting` as const;
export const STREAM_TROUBLESHOOTING_URL =
  `${TROUBLESHOOTING_URL}?id=stream-does-not-load` as const;
const CONFIGURATION_URL = `${DOCS_URL}/#/configuration`;
export const FOLDERS_CONFIGURATION_URL = `${CONFIGURATION_URL}/folders`;

export const CONF_AUTOMATIONS = 'automations' as const;

export const CONF_CAMERAS = 'cameras' as const;

export const CONF_CAMERAS_ARRAY_ALWAYS_ERROR_IF_ENTITY_UNAVAILABLE =
  `${CONF_CAMERAS}.#.always_error_if_entity_unavailable` as const;
export const CONF_CAMERAS_ARRAY_CAMERA_ENTITY =
  `${CONF_CAMERAS}.#.camera_entity` as const;
export const CONF_CAMERAS_ARRAY_FRIGATE_CAMERA_NAME =
  `${CONF_CAMERAS}.#.frigate.camera_name` as const;
export const CONF_CAMERAS_ARRAY_CAPABILITIES_DISABLE =
  `${CONF_CAMERAS}.#.capabilities.disable` as const;
export const CONF_CAMERAS_ARRAY_CAPABILITIES_DISABLE_EXCEPT =
  `${CONF_CAMERAS}.#.capabilities.disable_except` as const;
export const CONF_CAMERAS_ARRAY_CAST_METHOD = `${CONF_CAMERAS}.#.cast.method` as const;
export const CONF_CAMERAS_ARRAY_CAST_DASHBOARD_DASHBOARD_PATH =
  `${CONF_CAMERAS}.#.cast.dashboard.dashboard_path` as const;
export const CONF_CAMERAS_ARRAY_CAST_DASHBOARD_VIEW_PATH =
  `${CONF_CAMERAS}.#.cast.dashboard.view_path` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_ASPECT_RATIO =
  `${CONF_CAMERAS}.#.dimensions.aspect_ratio` as const;
export const CONF_CAMERAS_ARRAY_FRIGATE_CLIENT_ID =
  `${CONF_CAMERAS}.#.frigate.client_id` as const;
export const CONF_CAMERAS_ARRAY_FRIGATE_LABELS =
  `${CONF_CAMERAS}.#.frigate.labels` as const;
export const CONF_CAMERAS_ARRAY_FRIGATE_URL = `${CONF_CAMERAS}.#.frigate.url` as const;
export const CONF_CAMERAS_ARRAY_FRIGATE_ZONES =
  `${CONF_CAMERAS}.#.frigate.zones` as const;
export const CONF_CAMERAS_ARRAY_GO2RTC_MODES = `${CONF_CAMERAS}.#.go2rtc.modes` as const;
export const CONF_CAMERAS_ARRAY_GO2RTC_STREAM =
  `${CONF_CAMERAS}.#.go2rtc.stream` as const;
export const CONF_CAMERAS_ARRAY_GO2RTC_URL = `${CONF_CAMERAS}.#.go2rtc.url` as const;
export const CONF_CAMERAS_ARRAY_ICON = `${CONF_CAMERAS}.#.icon` as const;
export const CONF_CAMERAS_ARRAY_ID = `${CONF_CAMERAS}.#.id` as const;
export const CONF_CAMERAS_ARRAY_IMAGE_ENTITY = `${CONF_CAMERAS}.#.image.entity` as const;
export const CONF_CAMERAS_ARRAY_IMAGE_ENTITY_PARAMETERS =
  `${CONF_CAMERAS}.#.image.entity_parameters` as const;
export const CONF_CAMERAS_ARRAY_IMAGE_MODE = `${CONF_CAMERAS}.#.image.mode` as const;
export const CONF_CAMERAS_ARRAY_IMAGE_REFRESH_SECONDS =
  `${CONF_CAMERAS}.#.image.refresh_seconds` as const;
export const CONF_CAMERAS_ARRAY_IMAGE_URL = `${CONF_CAMERAS}.#.image.url` as const;
export const CONF_CAMERAS_ARRAY_MOTIONEYE_IMAGES_DIRECTORY_PATTERN =
  `${CONF_CAMERAS}.#.motioneye.images.directory_pattern` as const;
export const CONF_CAMERAS_ARRAY_MOTIONEYE_IMAGES_FILE_PATTERN =
  `${CONF_CAMERAS}.#.motioneye.images.file_pattern` as const;
export const CONF_CAMERAS_ARRAY_MOTIONEYE_MOVIES_DIRECTORY_PATTERN =
  `${CONF_CAMERAS}.#.motioneye.movies.directory_pattern` as const;
export const CONF_CAMERAS_ARRAY_MOTIONEYE_MOVIES_FILE_PATTERN =
  `${CONF_CAMERAS}.#.motioneye.movies.file_pattern` as const;
export const CONF_CAMERAS_ARRAY_MOTIONEYE_URL =
  `${CONF_CAMERAS}.#.motioneye.url` as const;
export const CONF_CAMERAS_ARRAY_TITLE = `${CONF_CAMERAS}.#.title` as const;
export const CONF_CAMERAS_ARRAY_WEBRTC_CARD_ENTITY =
  `${CONF_CAMERAS}.#.webrtc_card.entity` as const;
export const CONF_CAMERAS_ARRAY_WEBRTC_CARD_URL =
  `${CONF_CAMERAS}.#.webrtc_card.url` as const;
export const CONF_CAMERAS_ARRAY_LIVE_PROVIDER =
  `${CONF_CAMERAS}.#.live_provider` as const;
export const CONF_CAMERAS_ARRAY_DEPENDENCIES_CAMERAS =
  `${CONF_CAMERAS}.#.dependencies.cameras` as const;
export const CONF_CAMERAS_ARRAY_DEPENDENCIES_ALL_CAMERAS =
  `${CONF_CAMERAS}.#.dependencies.all_cameras` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_FIT =
  `${CONF_CAMERAS}.#.dimensions.layout.fit` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_PAN_X =
  `${CONF_CAMERAS}.#.dimensions.layout.pan.x` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_PAN_Y =
  `${CONF_CAMERAS}.#.dimensions.layout.pan.y` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_POSITION_X =
  `${CONF_CAMERAS}.#.dimensions.layout.position.x` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_POSITION_Y =
  `${CONF_CAMERAS}.#.dimensions.layout.position.y` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_TOP =
  `${CONF_CAMERAS}.#.dimensions.layout.view_box.top` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_BOTTOM =
  `${CONF_CAMERAS}.#.dimensions.layout.view_box.bottom` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_LEFT =
  `${CONF_CAMERAS}.#.dimensions.layout.view_box.left` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_RIGHT =
  `${CONF_CAMERAS}.#.dimensions.layout.view_box.right` as const;
export const CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_ZOOM_FACTOR =
  `${CONF_CAMERAS}.#.dimensions.layout.zoom` as const;
export const CONF_CAMERAS_ARRAY_PROXY_DYNAMIC =
  `${CONF_CAMERAS}.#.proxy.dynamic` as const;
export const CONF_CAMERAS_ARRAY_PROXY_MEDIA = `${CONF_CAMERAS}.#.proxy.media` as const;
export const CONF_CAMERAS_ARRAY_PROXY_SSL_CIPHERS =
  `${CONF_CAMERAS}.#.proxy.ssl_ciphers` as const;
export const CONF_CAMERAS_ARRAY_PROXY_SSL_VERIFICATION =
  `${CONF_CAMERAS}.#.proxy.ssl_verification` as const;
export const CONF_CAMERAS_ARRAY_REOLINK_MEDIA_RESOLUTION =
  `${CONF_CAMERAS}.#.reolink.media_resolution` as const;
export const CONF_CAMERAS_ARRAY_REOLINK_URL = `${CONF_CAMERAS}.#.reolink.url` as const;
export const CONF_CAMERAS_ARRAY_TRIGGERS_MOTION =
  `${CONF_CAMERAS}.#.triggers.motion` as const;
export const CONF_CAMERAS_ARRAY_TRIGGERS_OCCUPANCY =
  `${CONF_CAMERAS}.#.triggers.occupancy` as const;
export const CONF_CAMERAS_ARRAY_TRIGGERS_ENTITIES =
  `${CONF_CAMERAS}.#.triggers.entities` as const;
export const CONF_CAMERAS_ARRAY_TRIGGERS_EVENTS =
  `${CONF_CAMERAS}.#.triggers.events` as const;

const CONF_CAMERAS_GLOBAL = 'cameras_global' as const;
export const CONF_CAMERAS_GLOBAL_LIVE_PROVIDER =
  `${CONF_CAMERAS_GLOBAL}.live_provider` as const;
export const CONF_CAMERAS_GLOBAL_TRIGGERS_OCCUPANCY =
  `${CONF_CAMERAS_GLOBAL}.triggers.occupancy` as const;
export const CONF_CAMERAS_GLOBAL_IMAGE_REFRESH_SECONDS =
  `${CONF_CAMERAS_GLOBAL}.image.refresh_seconds` as const;
export const CONF_CAMERAS_GLOBAL_DIMENSIONS_LAYOUT =
  `${CONF_CAMERAS_GLOBAL}.dimensions.layout` as const;
export const CONF_CAMERAS_GLOBAL_PTZ = `${CONF_CAMERAS_GLOBAL}.ptz` as const;

export const CONF_ELEMENTS = 'elements' as const;

export const CONF_FOLDERS = 'folders' as const;
export const CONF_FOLDERS_ARRAY_HA_URL = `${CONF_FOLDERS}.#.ha.url` as const;
export const CONF_FOLDERS_ARRAY_ICON = `${CONF_FOLDERS}.#.icon` as const;
export const CONF_FOLDERS_ARRAY_ID = `${CONF_FOLDERS}.#.id` as const;
export const CONF_FOLDERS_ARRAY_TITLE = `${CONF_FOLDERS}.#.title` as const;
export const CONF_FOLDERS_ARRAY_TYPE = `${CONF_FOLDERS}.#.type` as const;

const CONF_VIEW = 'view' as const;
export const CONF_VIEW_CAMERA_SELECT = `${CONF_VIEW}.camera_select` as const;
export const CONF_VIEW_DEFAULT = `${CONF_VIEW}.default` as const;
export const CONF_VIEW_DIM = `${CONF_VIEW}.dim` as const;
export const CONF_VIEW_INTERACTION_SECONDS = `${CONF_VIEW}.interaction_seconds` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS = `${CONF_VIEW}.keyboard_shortcuts` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_ENABLED =
  `${CONF_VIEW}.keyboard_shortcuts.enabled` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_LEFT =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_left` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_RIGHT =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_right` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_UP =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_up` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_DOWN =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_down` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_ZOOM_IN =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_zoom_in` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_ZOOM_OUT =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_zoom_out` as const;
export const CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_HOME =
  `${CONF_VIEW_KEYBOARD_SHORTCUTS}.ptz_home` as const;
export const CONF_VIEW_DEFAULT_CYCLE_CAMERA =
  `${CONF_VIEW}.default_cycle_camera` as const;
export const CONF_VIEW_DEFAULT_RESET = `${CONF_VIEW}.default_reset` as const;
export const CONF_VIEW_DEFAULT_RESET_INTERACTION_MODE =
  `${CONF_VIEW_DEFAULT_RESET}.interaction_mode` as const;
export const CONF_VIEW_DEFAULT_RESET_EVERY_SECONDS =
  `${CONF_VIEW_DEFAULT_RESET}.every_seconds` as const;
export const CONF_VIEW_DEFAULT_RESET_ENTITIES =
  `${CONF_VIEW_DEFAULT_RESET}.entities` as const;
export const CONF_VIEW_DEFAULT_RESET_AFTER_INTERACTION =
  `${CONF_VIEW_DEFAULT_RESET}.after_interaction` as const;
export const CONF_VIEW_THEME_THEMES = `${CONF_VIEW}.theme.themes` as const;
export const CONF_VIEW_TRIGGERS = `${CONF_VIEW}.triggers` as const;
export const CONF_VIEW_TRIGGERS_SHOW_TRIGGER_STATUS =
  `${CONF_VIEW_TRIGGERS}.show_trigger_status` as const;
export const CONF_VIEW_TRIGGERS_FILTER_SELECTED_CAMERA =
  `${CONF_VIEW_TRIGGERS}.filter_selected_camera` as const;
export const CONF_VIEW_TRIGGERS_UNTRIGGER_SECONDS =
  `${CONF_VIEW_TRIGGERS}.untrigger_seconds` as const;
export const CONF_VIEW_TRIGGERS_ACTIONS = `${CONF_VIEW_TRIGGERS}.actions` as const;
export const CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER =
  `${CONF_VIEW_TRIGGERS_ACTIONS}.trigger` as const;
export const CONF_VIEW_TRIGGERS_ACTIONS_UNTRIGGER =
  `${CONF_VIEW_TRIGGERS_ACTIONS}.untrigger` as const;
export const CONF_VIEW_TRIGGERS_ACTIONS_INTERACTION_MODE =
  `${CONF_VIEW_TRIGGERS_ACTIONS}.interaction_mode` as const;

const CONF_MEDIA_GALLERY = 'media_gallery' as const;
export const CONF_MEDIA_GALLERY_CONTROLS_FILTER_MODE =
  `${CONF_MEDIA_GALLERY}.controls.filter.mode` as const;
export const CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DETAILS =
  `${CONF_MEDIA_GALLERY}.controls.thumbnails.show_details` as const;
export const CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL =
  `${CONF_MEDIA_GALLERY}.controls.thumbnails.show_download_control` as const;
export const CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL =
  `${CONF_MEDIA_GALLERY}.controls.thumbnails.show_favorite_control` as const;
export const CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL =
  `${CONF_MEDIA_GALLERY}.controls.thumbnails.show_timeline_control` as const;
export const CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SIZE =
  `${CONF_MEDIA_GALLERY}.controls.thumbnails.size` as const;

const CONF_MEDIA_VIEWER = 'media_viewer' as const;
export const CONF_MEDIA_VIEWER_AUTO_PLAY = `${CONF_MEDIA_VIEWER}.auto_play` as const;
export const CONF_MEDIA_VIEWER_AUTO_PAUSE = `${CONF_MEDIA_VIEWER}.auto_pause` as const;
export const CONF_MEDIA_VIEWER_AUTO_MUTE = `${CONF_MEDIA_VIEWER}.auto_mute` as const;
export const CONF_MEDIA_VIEWER_AUTO_UNMUTE = `${CONF_MEDIA_VIEWER}.auto_unmute` as const;
export const CONF_MEDIA_VIEWER_DISPLAY_MODE =
  `${CONF_MEDIA_VIEWER}.display.mode` as const;
export const CONF_MEDIA_VIEWER_DISPLAY_GRID_COLUMNS =
  `${CONF_MEDIA_VIEWER}.display.grid_columns` as const;
export const CONF_MEDIA_VIEWER_DISPLAY_GRID_MAX_COLUMNS =
  `${CONF_MEDIA_VIEWER}.display.grid_max_columns` as const;
export const CONF_MEDIA_VIEWER_DISPLAY_GRID_SELECTED_POSITION =
  `${CONF_MEDIA_VIEWER}.display.grid_selected_position` as const;
export const CONF_MEDIA_VIEWER_DISPLAY_GRID_SELECTED_WIDTH_FACTOR =
  `${CONF_MEDIA_VIEWER}.display.grid_selected_width_factor` as const;
export const CONF_MEDIA_VIEWER_DRAGGABLE = `${CONF_MEDIA_VIEWER}.draggable` as const;
export const CONF_MEDIA_VIEWER_LAZY_LOAD = `${CONF_MEDIA_VIEWER}.lazy_load` as const;
export const CONF_MEDIA_VIEWER_SNAPSHOT_CLICK_PLAYS_CLIP =
  `${CONF_MEDIA_VIEWER}.snapshot_click_plays_clip` as const;
export const CONF_MEDIA_VIEWER_TRANSITION_EFFECT =
  `${CONF_MEDIA_VIEWER}.transition_effect` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_BUILTIN =
  `${CONF_MEDIA_VIEWER}.controls.builtin` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_STYLE =
  `${CONF_MEDIA_VIEWER}.controls.next_previous.style` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_SIZE =
  `${CONF_MEDIA_VIEWER}.controls.next_previous.size` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_MODE =
  `${CONF_MEDIA_VIEWER}.controls.thumbnails.mode` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DETAILS =
  `${CONF_MEDIA_VIEWER}.controls.thumbnails.show_details` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL =
  `${CONF_MEDIA_VIEWER}.controls.thumbnails.show_download_control` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL =
  `${CONF_MEDIA_VIEWER}.controls.thumbnails.show_favorite_control` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL =
  `${CONF_MEDIA_VIEWER}.controls.thumbnails.show_timeline_control` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SIZE =
  `${CONF_MEDIA_VIEWER}.controls.thumbnails.size` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_CLUSTERING_THRESHOLD =
  `${CONF_MEDIA_VIEWER}.controls.timeline.clustering_threshold` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE =
  `${CONF_MEDIA_VIEWER}.controls.timeline.events_media_type` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_FORMAT_24H =
  `${CONF_MEDIA_VIEWER}.controls.timeline.format.24h` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_MODE =
  `${CONF_MEDIA_VIEWER}.controls.timeline.mode` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_PAN_MODE =
  `${CONF_MEDIA_VIEWER}.controls.timeline.pan_mode` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_SHOW_RECORDINGS =
  `${CONF_MEDIA_VIEWER}.controls.timeline.show_recordings` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_STYLE =
  `${CONF_MEDIA_VIEWER}.controls.timeline.style` as const;
export const CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_WINDOW_SECONDS =
  `${CONF_MEDIA_VIEWER}.controls.timeline.window_seconds` as const;
export const CONF_MEDIA_VIEWER_ZOOMABLE = `${CONF_MEDIA_VIEWER}.zoomable` as const;

const CONF_LIVE = 'live' as const;
export const CONF_LIVE_AUTO_PLAY = `${CONF_LIVE}.auto_play` as const;
export const CONF_LIVE_AUTO_PAUSE = `${CONF_LIVE}.auto_pause` as const;
export const CONF_LIVE_AUTO_MUTE = `${CONF_LIVE}.auto_mute` as const;
export const CONF_LIVE_AUTO_UNMUTE = `${CONF_LIVE}.auto_unmute` as const;
export const CONF_LIVE_CONTROLS_BUILTIN = `${CONF_LIVE}.controls.builtin` as const;
export const CONF_LIVE_CONTROLS_NEXT_PREVIOUS_STYLE =
  `${CONF_LIVE}.controls.next_previous.style` as const;
export const CONF_LIVE_CONTROLS_NEXT_PREVIOUS_SIZE =
  `${CONF_LIVE}.controls.next_previous.size` as const;
export const CONF_LIVE_CONTROLS_PTZ_HIDE_HOME =
  `${CONF_LIVE}.controls.ptz.hide_home` as const;
export const CONF_LIVE_CONTROLS_PTZ_HIDE_PAN_TILT =
  `${CONF_LIVE}.controls.ptz.hide_pan_tilt` as const;
export const CONF_LIVE_CONTROLS_PTZ_HIDE_ZOOM =
  `${CONF_LIVE}.controls.ptz.hide_zoom` as const;
export const CONF_LIVE_CONTROLS_PTZ_MODE = `${CONF_LIVE}.controls.ptz.mode` as const;
export const CONF_LIVE_CONTROLS_PTZ_ORIENTATION =
  `${CONF_LIVE}.controls.ptz.orientation` as const;
export const CONF_LIVE_CONTROLS_PTZ_POSITION =
  `${CONF_LIVE}.controls.ptz.position` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_MEDIA_TYPE =
  `${CONF_LIVE}.controls.thumbnails.media_type` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_EVENTS_MEDIA_TYPE =
  `${CONF_LIVE}.controls.thumbnails.events_media_type` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_MODE =
  `${CONF_LIVE}.controls.thumbnails.mode` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_SIZE =
  `${CONF_LIVE}.controls.thumbnails.size` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DETAILS =
  `${CONF_LIVE}.controls.thumbnails.show_details` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL =
  `${CONF_LIVE}.controls.thumbnails.show_download_control` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL =
  `${CONF_LIVE}.controls.thumbnails.show_favorite_control` as const;
export const CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL =
  `${CONF_LIVE}.controls.thumbnails.show_timeline_control` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_CLUSTERING_THRESHOLD =
  `${CONF_LIVE}.controls.timeline.clustering_threshold` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE =
  `${CONF_LIVE}.controls.timeline.events_media_type` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_FORMAT_24H =
  `${CONF_LIVE}.controls.timeline.format.24h` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_MODE =
  `${CONF_LIVE}.controls.timeline.mode` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_PAN_MODE =
  `${CONF_LIVE}.controls.timeline.pan_mode` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_SHOW_RECORDINGS =
  `${CONF_LIVE}.controls.timeline.show_recordings` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_STYLE =
  `${CONF_LIVE}.controls.timeline.style` as const;
export const CONF_LIVE_CONTROLS_TIMELINE_WINDOW_SECONDS =
  `${CONF_LIVE}.controls.timeline.window_seconds` as const;
export const CONF_LIVE_DISPLAY_MODE = `${CONF_LIVE}.display.mode` as const;
export const CONF_LIVE_DISPLAY_GRID_COLUMNS =
  `${CONF_LIVE}.display.grid_columns` as const;
export const CONF_LIVE_DISPLAY_GRID_MAX_COLUMNS =
  `${CONF_LIVE}.display.grid_max_columns` as const;
export const CONF_LIVE_DISPLAY_GRID_SELECTED_POSITION =
  `${CONF_LIVE}.display.grid_selected_position` as const;
export const CONF_LIVE_DISPLAY_GRID_SELECTED_WIDTH_FACTOR =
  `${CONF_LIVE}.display.grid_selected_width_factor` as const;
export const CONF_LIVE_DRAGGABLE = `${CONF_LIVE}.draggable` as const;
export const CONF_LIVE_LAZY_LOAD = `${CONF_LIVE}.lazy_load` as const;
export const CONF_LIVE_LAZY_UNLOAD = `${CONF_LIVE}.lazy_unload` as const;
export const CONF_LIVE_PRELOAD = `${CONF_LIVE}.preload` as const;
export const CONF_LIVE_TRANSITION_EFFECT = `${CONF_LIVE}.transition_effect` as const;
export const CONF_LIVE_SHOW_IMAGE_DURING_LOAD =
  `${CONF_LIVE}.show_image_during_load` as const;
export const CONF_LIVE_MICROPHONE_DISCONNECT_SECONDS =
  `${CONF_LIVE}.microphone.disconnect_seconds` as const;
export const CONF_LIVE_MICROPHONE_MUTE_AFTER_MICROPHONE_MUTE_SECONDS =
  `${CONF_LIVE}.microphone.mute_after_microphone_mute_seconds` as const;
export const CONF_LIVE_MICROPHONE_ALWAYS_CONNECTED =
  `${CONF_LIVE}.microphone.always_connected` as const;
export const CONF_LIVE_ZOOMABLE = `${CONF_LIVE}.zoomable` as const;

const CONF_IMAGE = 'image' as const;
export const CONF_IMAGE_ENTITY = `${CONF_IMAGE}.entity` as const;
export const CONF_IMAGE_ENTITY_PARAMETERS = `${CONF_IMAGE}.entity_parameters` as const;
export const CONF_IMAGE_MODE = `${CONF_IMAGE}.mode` as const;
export const CONF_IMAGE_REFRESH_SECONDS = `${CONF_IMAGE}.refresh_seconds` as const;
export const CONF_IMAGE_URL = `${CONF_IMAGE}.url` as const;

const CONF_TIMELINE = 'timeline' as const;
export const CONF_TIMELINE_WINDOW_SECONDS = `${CONF_TIMELINE}.window_seconds` as const;
export const CONF_TIMELINE_CLUSTERING_THRESHOLD =
  `${CONF_TIMELINE}.clustering_threshold` as const;
export const CONF_TIMELINE_EVENTS_MEDIA_TYPE =
  `${CONF_TIMELINE}.events_media_type` as const;
export const CONF_TIMELINE_FORMAT_24H = `${CONF_TIMELINE}.format.24h` as const;
export const CONF_TIMELINE_SHOW_RECORDINGS = `${CONF_TIMELINE}.show_recordings` as const;
export const CONF_TIMELINE_STYLE = `${CONF_TIMELINE}.style` as const;
export const CONF_TIMELINE_CONTROLS_THUMBNAILS_MODE =
  `${CONF_TIMELINE}.controls.thumbnails.mode` as const;
export const CONF_TIMELINE_CONTROLS_THUMBNAILS_SIZE =
  `${CONF_TIMELINE}.controls.thumbnails.size` as const;
export const CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DETAILS =
  `${CONF_TIMELINE}.controls.thumbnails.show_details` as const;
export const CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL =
  `${CONF_TIMELINE}.controls.thumbnails.show_download_control` as const;
export const CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL =
  `${CONF_TIMELINE}.controls.thumbnails.show_favorite_control` as const;
export const CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL =
  `${CONF_TIMELINE}.controls.thumbnails.show_timeline_control` as const;

const CONF_MENU = 'menu' as const;
export const CONF_MENU_ALIGNMENT = `${CONF_MENU}.alignment` as const;
export const CONF_MENU_POSITION = `${CONF_MENU}.position` as const;
export const CONF_MENU_STYLE = `${CONF_MENU}.style` as const;
export const CONF_MENU_BUTTON_SIZE = `${CONF_MENU}.button_size` as const;
export const CONF_MENU_BUTTONS = `${CONF_MENU}.buttons` as const;

export const CONF_MENU_BUTTONS_FULLSCREEN = `${CONF_MENU_BUTTONS}.fullscreen` as const;
export const CONF_MENU_BUTTONS_IRIS = `${CONF_MENU_BUTTONS}.iris` as const;
export const CONF_MENU_BUTTONS_PLAY = `${CONF_MENU_BUTTONS}.play` as const;
export const CONF_MENU_BUTTONS_MUTE = `${CONF_MENU_BUTTONS}.mute` as const;
export const CONF_MENU_BUTTONS_MEDIA_PLAYER =
  `${CONF_MENU_BUTTONS}.media_player` as const;
export const CONF_MENU_BUTTONS_TIMELINE = `${CONF_MENU_BUTTONS}.timeline` as const;

export const CONF_STATUS_BAR = 'status_bar' as const;
export const CONF_STATUS_BAR_POSITION = `${CONF_STATUS_BAR}.position` as const;
export const CONF_STATUS_BAR_STYLE = `${CONF_STATUS_BAR}.style` as const;
export const CONF_STATUS_BAR_POPUP_SECONDS = `${CONF_STATUS_BAR}.popup_seconds` as const;
export const CONF_STATUS_BAR_HEIGHT = `${CONF_STATUS_BAR}.height` as const;

export const CONF_STATUS_BAR_ITEMS = `${CONF_STATUS_BAR}.items` as const;

const CONF_DIMENSIONS = 'dimensions' as const;
export const CONF_DIMENSIONS_ASPECT_RATIO = `${CONF_DIMENSIONS}.aspect_ratio` as const;
export const CONF_DIMENSIONS_ASPECT_RATIO_MODE =
  `${CONF_DIMENSIONS}.aspect_ratio_mode` as const;
export const CONF_DIMENSIONS_HEIGHT = `${CONF_DIMENSIONS}.height` as const;

export const CONF_OVERRIDES = 'overrides' as const;

const CONF_PERFORMANCE = 'performance' as const;
export const CONF_PERFORMANCE_FEATURES_ANIMATED_PROGRESS_INDICATOR = `${CONF_PERFORMANCE}.features.animated_progress_indicator`;
export const CONF_PERFORMANCE_FEATURES_CARD_LOADING_INDICATOR = `${CONF_PERFORMANCE}.features.card_loading_indicator`;
export const CONF_PERFORMANCE_FEATURES_MEDIA_CHUNK_SIZE = `${CONF_PERFORMANCE}.features.media_chunk_size`;
export const CONF_PERFORMANCE_FEATURES_MAX_SIMULTANEOUS_ENGINE_REQUESTS = `${CONF_PERFORMANCE}.features.max_simultaneous_engine_requests`;
export const CONF_PERFORMANCE_PROFILE = `${CONF_PERFORMANCE}.profile`;
export const CONF_PERFORMANCE_STYLE_BOX_SHADOW = `${CONF_PERFORMANCE}.style.box_shadow`;
export const CONF_PERFORMANCE_STYLE_BORDER_RADIUS = `${CONF_PERFORMANCE}.style.border_radius`;

export const CONF_PROFILES = 'profiles' as const;

const CONF_REMOTE_CONTROL = 'remote_control' as const;
export const CONF_REMOTE_CONTROL_ENTITIES_CAMERA =
  `${CONF_REMOTE_CONTROL}.entities.camera` as const;

// Taken from https://github.com/home-assistant/frontend/blob/a759767d794f02527d127802831e68d3caf0cb7a/src/data/media-player.ts#L82
export const MEDIA_PLAYER_SUPPORT_TURN_OFF = 256;
export const MEDIA_PLAYER_SUPPORT_STOP = 4096;
export const MEDIA_PLAYER_SUPPORT_BROWSE_MEDIA = 131072;

// The number of media items to fetch at a time (for clips/snapshot views, and
// gallery chunks). Smaller values will cause more frequent smaller fetches, but
// improved rendering performance.
export const MEDIA_CHUNK_SIZE_DEFAULT = 50;
export const MEDIA_CHUNK_SIZE_MAX = 1000;

export const IMAGE_VIEW_ZOOM_TARGET_SENTINEL = '__IMAGE_VIEW_ZOOM__';



================================================
FILE: src/declarations.d.ts
================================================
declare module '*.scss';
declare module '*.svg';
declare module '*.jpg';
declare module 'view' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface ViewContext {}
}
declare module 'action' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface ActionContext {}
}



================================================
FILE: src/editor.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import './components/icon.js';
import './components/key-assigner.js';
import { renderMessage } from './components/message.js';
import {
  copyConfig,
  deleteConfigValue,
  getArrayConfigPath,
  getConfigValue,
  isConfigUpgradeable,
  setConfigValue,
  upgradeConfig,
} from './config/management.js';
import { setProfiles } from './config/profiles/set-profiles.js';
import {
  BUTTON_SIZE_MIN,
  MENU_PRIORITY_MAX,
  STATUS_BAR_PRIORITY_MAX,
} from './config/schema/common/const.js';
import {
  THUMBNAIL_WIDTH_MAX,
  THUMBNAIL_WIDTH_MIN,
} from './config/schema/common/controls/thumbnails.js';
import { ZOOM_MAX, ZOOM_MIN } from './config/schema/common/zoom.js';
import { profilesSchema } from './config/schema/profiles.js';
import { STATUS_BAR_HEIGHT_MIN } from './config/schema/status-bar.js';
import { AdvancedCameraCardConfig, configDefaults } from './config/schema/types.js';
import { KeyboardShortcut } from './config/schema/view.js';
import {
  RawAdvancedCameraCardConfig,
  RawAdvancedCameraCardConfigArray,
} from './config/types.js';
import {
  CONF_CAMERAS,
  CONF_CAMERAS_ARRAY_ALWAYS_ERROR_IF_ENTITY_UNAVAILABLE,
  CONF_CAMERAS_ARRAY_CAMERA_ENTITY,
  CONF_CAMERAS_ARRAY_CAPABILITIES_DISABLE,
  CONF_CAMERAS_ARRAY_CAPABILITIES_DISABLE_EXCEPT,
  CONF_CAMERAS_ARRAY_CAST_DASHBOARD_DASHBOARD_PATH,
  CONF_CAMERAS_ARRAY_CAST_DASHBOARD_VIEW_PATH,
  CONF_CAMERAS_ARRAY_CAST_METHOD,
  CONF_CAMERAS_ARRAY_DEPENDENCIES_ALL_CAMERAS,
  CONF_CAMERAS_ARRAY_DEPENDENCIES_CAMERAS,
  CONF_CAMERAS_ARRAY_DIMENSIONS_ASPECT_RATIO,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_FIT,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_PAN_X,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_PAN_Y,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_POSITION_X,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_POSITION_Y,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_BOTTOM,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_LEFT,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_RIGHT,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_TOP,
  CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_ZOOM_FACTOR,
  CONF_CAMERAS_ARRAY_FRIGATE_CAMERA_NAME,
  CONF_CAMERAS_ARRAY_FRIGATE_CLIENT_ID,
  CONF_CAMERAS_ARRAY_FRIGATE_LABELS,
  CONF_CAMERAS_ARRAY_FRIGATE_URL,
  CONF_CAMERAS_ARRAY_FRIGATE_ZONES,
  CONF_CAMERAS_ARRAY_GO2RTC_MODES,
  CONF_CAMERAS_ARRAY_GO2RTC_STREAM,
  CONF_CAMERAS_ARRAY_GO2RTC_URL,
  CONF_CAMERAS_ARRAY_ICON,
  CONF_CAMERAS_ARRAY_ID,
  CONF_CAMERAS_ARRAY_IMAGE_ENTITY,
  CONF_CAMERAS_ARRAY_IMAGE_ENTITY_PARAMETERS,
  CONF_CAMERAS_ARRAY_IMAGE_MODE,
  CONF_CAMERAS_ARRAY_IMAGE_REFRESH_SECONDS,
  CONF_CAMERAS_ARRAY_IMAGE_URL,
  CONF_CAMERAS_ARRAY_LIVE_PROVIDER,
  CONF_CAMERAS_ARRAY_MOTIONEYE_IMAGES_DIRECTORY_PATTERN,
  CONF_CAMERAS_ARRAY_MOTIONEYE_IMAGES_FILE_PATTERN,
  CONF_CAMERAS_ARRAY_MOTIONEYE_MOVIES_DIRECTORY_PATTERN,
  CONF_CAMERAS_ARRAY_MOTIONEYE_MOVIES_FILE_PATTERN,
  CONF_CAMERAS_ARRAY_MOTIONEYE_URL,
  CONF_CAMERAS_ARRAY_PROXY_DYNAMIC,
  CONF_CAMERAS_ARRAY_PROXY_MEDIA,
  CONF_CAMERAS_ARRAY_PROXY_SSL_CIPHERS,
  CONF_CAMERAS_ARRAY_PROXY_SSL_VERIFICATION,
  CONF_CAMERAS_ARRAY_REOLINK_MEDIA_RESOLUTION,
  CONF_CAMERAS_ARRAY_REOLINK_URL,
  CONF_CAMERAS_ARRAY_TITLE,
  CONF_CAMERAS_ARRAY_TRIGGERS_ENTITIES,
  CONF_CAMERAS_ARRAY_TRIGGERS_EVENTS,
  CONF_CAMERAS_ARRAY_TRIGGERS_MOTION,
  CONF_CAMERAS_ARRAY_TRIGGERS_OCCUPANCY,
  CONF_CAMERAS_ARRAY_WEBRTC_CARD_ENTITY,
  CONF_CAMERAS_ARRAY_WEBRTC_CARD_URL,
  CONF_DIMENSIONS_ASPECT_RATIO,
  CONF_DIMENSIONS_ASPECT_RATIO_MODE,
  CONF_DIMENSIONS_HEIGHT,
  CONF_FOLDERS,
  CONF_FOLDERS_ARRAY_HA_URL,
  CONF_FOLDERS_ARRAY_ICON,
  CONF_FOLDERS_ARRAY_ID,
  CONF_FOLDERS_ARRAY_TITLE,
  CONF_FOLDERS_ARRAY_TYPE,
  CONF_IMAGE_ENTITY,
  CONF_IMAGE_ENTITY_PARAMETERS,
  CONF_IMAGE_MODE,
  CONF_IMAGE_REFRESH_SECONDS,
  CONF_IMAGE_URL,
  CONF_LIVE_AUTO_MUTE,
  CONF_LIVE_AUTO_PAUSE,
  CONF_LIVE_AUTO_PLAY,
  CONF_LIVE_AUTO_UNMUTE,
  CONF_LIVE_CONTROLS_BUILTIN,
  CONF_LIVE_CONTROLS_NEXT_PREVIOUS_SIZE,
  CONF_LIVE_CONTROLS_NEXT_PREVIOUS_STYLE,
  CONF_LIVE_CONTROLS_PTZ_HIDE_HOME,
  CONF_LIVE_CONTROLS_PTZ_HIDE_PAN_TILT,
  CONF_LIVE_CONTROLS_PTZ_HIDE_ZOOM,
  CONF_LIVE_CONTROLS_PTZ_MODE,
  CONF_LIVE_CONTROLS_PTZ_ORIENTATION,
  CONF_LIVE_CONTROLS_PTZ_POSITION,
  CONF_LIVE_CONTROLS_THUMBNAILS_EVENTS_MEDIA_TYPE,
  CONF_LIVE_CONTROLS_THUMBNAILS_MEDIA_TYPE,
  CONF_LIVE_CONTROLS_THUMBNAILS_MODE,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_LIVE_CONTROLS_THUMBNAILS_SIZE,
  CONF_LIVE_CONTROLS_TIMELINE_CLUSTERING_THRESHOLD,
  CONF_LIVE_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
  CONF_LIVE_CONTROLS_TIMELINE_FORMAT_24H,
  CONF_LIVE_CONTROLS_TIMELINE_MODE,
  CONF_LIVE_CONTROLS_TIMELINE_PAN_MODE,
  CONF_LIVE_CONTROLS_TIMELINE_SHOW_RECORDINGS,
  CONF_LIVE_CONTROLS_TIMELINE_STYLE,
  CONF_LIVE_CONTROLS_TIMELINE_WINDOW_SECONDS,
  CONF_LIVE_DISPLAY_GRID_COLUMNS,
  CONF_LIVE_DISPLAY_GRID_MAX_COLUMNS,
  CONF_LIVE_DISPLAY_GRID_SELECTED_POSITION,
  CONF_LIVE_DISPLAY_GRID_SELECTED_WIDTH_FACTOR,
  CONF_LIVE_DISPLAY_MODE,
  CONF_LIVE_DRAGGABLE,
  CONF_LIVE_LAZY_LOAD,
  CONF_LIVE_LAZY_UNLOAD,
  CONF_LIVE_MICROPHONE_ALWAYS_CONNECTED,
  CONF_LIVE_MICROPHONE_DISCONNECT_SECONDS,
  CONF_LIVE_MICROPHONE_MUTE_AFTER_MICROPHONE_MUTE_SECONDS,
  CONF_LIVE_PRELOAD,
  CONF_LIVE_SHOW_IMAGE_DURING_LOAD,
  CONF_LIVE_TRANSITION_EFFECT,
  CONF_LIVE_ZOOMABLE,
  CONF_MEDIA_GALLERY_CONTROLS_FILTER_MODE,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SIZE,
  CONF_MEDIA_VIEWER_AUTO_MUTE,
  CONF_MEDIA_VIEWER_AUTO_PAUSE,
  CONF_MEDIA_VIEWER_AUTO_PLAY,
  CONF_MEDIA_VIEWER_AUTO_UNMUTE,
  CONF_MEDIA_VIEWER_CONTROLS_BUILTIN,
  CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_SIZE,
  CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_STYLE,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_MODE,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SIZE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_CLUSTERING_THRESHOLD,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_FORMAT_24H,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_MODE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_PAN_MODE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_SHOW_RECORDINGS,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_STYLE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_WINDOW_SECONDS,
  CONF_MEDIA_VIEWER_DISPLAY_GRID_COLUMNS,
  CONF_MEDIA_VIEWER_DISPLAY_GRID_MAX_COLUMNS,
  CONF_MEDIA_VIEWER_DISPLAY_GRID_SELECTED_POSITION,
  CONF_MEDIA_VIEWER_DISPLAY_GRID_SELECTED_WIDTH_FACTOR,
  CONF_MEDIA_VIEWER_DISPLAY_MODE,
  CONF_MEDIA_VIEWER_DRAGGABLE,
  CONF_MEDIA_VIEWER_LAZY_LOAD,
  CONF_MEDIA_VIEWER_SNAPSHOT_CLICK_PLAYS_CLIP,
  CONF_MEDIA_VIEWER_TRANSITION_EFFECT,
  CONF_MEDIA_VIEWER_ZOOMABLE,
  CONF_MENU_ALIGNMENT,
  CONF_MENU_BUTTON_SIZE,
  CONF_MENU_BUTTONS,
  CONF_MENU_POSITION,
  CONF_MENU_STYLE,
  CONF_PERFORMANCE_FEATURES_ANIMATED_PROGRESS_INDICATOR,
  CONF_PERFORMANCE_FEATURES_CARD_LOADING_INDICATOR,
  CONF_PERFORMANCE_FEATURES_MAX_SIMULTANEOUS_ENGINE_REQUESTS,
  CONF_PERFORMANCE_FEATURES_MEDIA_CHUNK_SIZE,
  CONF_PERFORMANCE_PROFILE,
  CONF_PERFORMANCE_STYLE_BORDER_RADIUS,
  CONF_PERFORMANCE_STYLE_BOX_SHADOW,
  CONF_PROFILES,
  CONF_REMOTE_CONTROL_ENTITIES_CAMERA,
  CONF_STATUS_BAR_HEIGHT,
  CONF_STATUS_BAR_ITEMS,
  CONF_STATUS_BAR_POPUP_SECONDS,
  CONF_STATUS_BAR_POSITION,
  CONF_STATUS_BAR_STYLE,
  CONF_TIMELINE_CLUSTERING_THRESHOLD,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_MODE,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SIZE,
  CONF_TIMELINE_EVENTS_MEDIA_TYPE,
  CONF_TIMELINE_FORMAT_24H,
  CONF_TIMELINE_SHOW_RECORDINGS,
  CONF_TIMELINE_STYLE,
  CONF_TIMELINE_WINDOW_SECONDS,
  CONF_VIEW_CAMERA_SELECT,
  CONF_VIEW_DEFAULT,
  CONF_VIEW_DEFAULT_CYCLE_CAMERA,
  CONF_VIEW_DEFAULT_RESET,
  CONF_VIEW_DEFAULT_RESET_AFTER_INTERACTION,
  CONF_VIEW_DEFAULT_RESET_ENTITIES,
  CONF_VIEW_DEFAULT_RESET_EVERY_SECONDS,
  CONF_VIEW_DEFAULT_RESET_INTERACTION_MODE,
  CONF_VIEW_DIM,
  CONF_VIEW_INTERACTION_SECONDS,
  CONF_VIEW_KEYBOARD_SHORTCUTS,
  CONF_VIEW_KEYBOARD_SHORTCUTS_ENABLED,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_DOWN,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_HOME,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_LEFT,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_RIGHT,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_UP,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_ZOOM_IN,
  CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_ZOOM_OUT,
  CONF_VIEW_THEME_THEMES,
  CONF_VIEW_TRIGGERS,
  CONF_VIEW_TRIGGERS_ACTIONS,
  CONF_VIEW_TRIGGERS_ACTIONS_INTERACTION_MODE,
  CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER,
  CONF_VIEW_TRIGGERS_ACTIONS_UNTRIGGER,
  CONF_VIEW_TRIGGERS_FILTER_SELECTED_CAMERA,
  CONF_VIEW_TRIGGERS_SHOW_TRIGGER_STATUS,
  CONF_VIEW_TRIGGERS_UNTRIGGER_SECONDS,
  FOLDERS_CONFIGURATION_URL,
  MEDIA_CHUNK_SIZE_MAX,
} from './const.js';
import { fireHASSEvent } from './ha/fire-hass-event.js';
import { getEntitiesFromHASS } from './ha/get-entities.js';
import { getEntityTitle } from './ha/get-entity-title.js';
import { sideLoadHomeAssistantElements } from './ha/side-load-ha-elements.js';
import { HomeAssistant, LovelaceCardEditor } from './ha/types.js';
import { localize } from './localize/localize.js';
import editorStyle from './scss/editor.scss';
import { arrayMove, prettifyTitle } from './utils/basic.js';
import { getCameraID } from './utils/camera.js';

const MENU_CAMERAS = 'cameras';
const MENU_CAMERAS_CAPABILITIES = 'cameras.capabilities';
const MENU_CAMERAS_CAST = 'cameras.cast';
const MENU_CAMERAS_DEPENDENCIES = 'cameras.dependencies';
const MENU_CAMERAS_DIMENSIONS = 'cameras.dimensions';
const MENU_CAMERAS_DIMENSIONS_LAYOUT = 'cameras.dimensions.layout';
const MENU_CAMERAS_ENGINE = 'cameras.engine';
const MENU_CAMERAS_FRIGATE = 'cameras.frigate';
const MENU_CAMERAS_GO2RTC = 'cameras.go2rtc';
const MENU_CAMERAS_IMAGE = 'cameras.image';
const MENU_CAMERAS_LIVE_PROVIDER = 'cameras.live_provider';
const MENU_CAMERAS_MOTIONEYE = 'cameras.motioneye';
const MENU_CAMERAS_PROXY = 'cameras.proxy';
const MENU_CAMERAS_REOLINK = 'cameras.reolink';
const MENU_CAMERAS_TRIGGERS = 'cameras.triggers';
const MENU_CAMERAS_WEBRTC_CARD = 'cameras.webrtc_card';
const MENU_FOLDERS = 'folders';
const MENU_FOLDERS_HA = 'folders.ha';
const MENU_LIVE_CONTROLS = 'live.controls';
const MENU_LIVE_CONTROLS_NEXT_PREVIOUS = 'live.controls.next_previous';
const MENU_LIVE_CONTROLS_PTZ = 'live.controls.ptz';
const MENU_LIVE_CONTROLS_THUMBNAILS = 'live.controls.thumbnails';
const MENU_LIVE_CONTROLS_TIMELINE = 'live.controls.timeline';
const MENU_LIVE_DISPLAY = 'live.display';
const MENU_LIVE_MICROPHONE = 'live.microphone';
const MENU_MEDIA_GALLERY_CONTROLS_FILTER = 'media_gallery.controls.filter';
const MENU_MEDIA_GALLERY_CONTROLS_THUMBNAILS = 'media_gallery.controls.thumbnails';
const MENU_MEDIA_VIEWER_CONTROLS = 'media_viewer.controls';
const MENU_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS = 'media_viewer.controls.next_previous';
const MENU_MEDIA_VIEWER_CONTROLS_THUMBNAILS = 'media_viewer.controls.thumbnails';
const MENU_MEDIA_VIEWER_CONTROLS_TIMELINE = 'media_viewer.controls.timeline';
const MENU_MEDIA_VIEWER_DISPLAY = 'media_viewer.display';
const MENU_MENU_BUTTONS = 'menu.buttons';
const MENU_OPTIONS = 'options';
const MENU_PERFORMANCE_FEATURES = 'performance.features';
const MENU_PERFORMANCE_STYLE = 'performance.style';
const MENU_REMOTE_CONTROL_ENTITIES = 'remote_control.entities';
const MENU_STATUS_BAR_ITEMS = 'status_bar.items';
const MENU_TIMELINE_FORMAT = 'timeline.format';
const MENU_TIMELINE_CONTROLS_THUMBNAILS = 'timeline.controls.thumbnails';
const MENU_VIEW_DEFAULT_RESET = 'view.default_reset';
const MENU_VIEW_KEYBOARD_SHORTCUTS = 'view.keyboard_shortcuts';
const MENU_VIEW_TRIGGERS = 'view.triggers';
const MENU_VIEW_TRIGGERS_ACTIONS = 'view.triggers.actions';

interface EditorOptionsSet {
  icon: string;
  name: string;
  secondary: string;
}
interface EditorOptions {
  [setName: string]: EditorOptionsSet;
}

interface EditorSelectOption {
  value: unknown;
  label: string;
}

interface EditorMenuTarget {
  domain: string;
  key: string | number;
}

const options: EditorOptions = {
  cameras: {
    icon: 'video',
    name: localize('editor.cameras'),
    secondary: localize('editor.cameras_secondary'),
  },
  view: {
    icon: 'eye',
    name: localize('editor.view'),
    secondary: localize('editor.view_secondary'),
  },
  menu: {
    icon: 'menu',
    name: localize('editor.menu'),
    secondary: localize('editor.menu_secondary'),
  },
  status_bar: {
    icon: 'sign-text',
    name: localize('editor.status_bar'),
    secondary: localize('editor.status_bar_secondary'),
  },
  live: {
    icon: 'cctv',
    name: localize('editor.live'),
    secondary: localize('editor.live_secondary'),
  },
  folders: {
    icon: 'folder-multiple',
    name: localize('editor.folders'),
    secondary: localize('editor.folders'),
  },
  media_gallery: {
    icon: 'grid',
    name: localize('editor.media_gallery'),
    secondary: localize('editor.media_gallery_secondary'),
  },
  media_viewer: {
    icon: 'filmstrip',
    name: localize('editor.media_viewer'),
    secondary: localize('editor.media_viewer_secondary'),
  },
  image: {
    icon: 'image',
    name: localize('editor.image'),
    secondary: localize('editor.image_secondary'),
  },
  timeline: {
    icon: 'chart-gantt',
    name: localize('editor.timeline'),
    secondary: localize('editor.timeline_secondary'),
  },
  dimensions: {
    icon: 'aspect-ratio',
    name: localize('editor.dimensions'),
    secondary: localize('editor.dimensions_secondary'),
  },
  performance: {
    icon: 'speedometer',
    name: localize('editor.performance'),
    secondary: localize('editor.performance_secondary'),
  },
  profiles: {
    icon: 'folder-wrench-outline',
    name: localize('editor.profiles'),
    secondary: localize('editor.profiles_secondary'),
  },
  remote_control: {
    icon: 'remote',
    name: localize('editor.remote_control'),
    secondary: localize('editor.remote_control_secondary'),
  },
  overrides: {
    icon: 'file-replace',
    name: localize('editor.overrides'),
    secondary: localize('editor.overrides_secondary'),
  },
};

@customElement('advanced-camera-card-editor')
export class AdvancedCameraCardEditor extends LitElement implements LovelaceCardEditor {
  @property({ attribute: false }) public hass?: HomeAssistant;
  @state() protected _config?: RawAdvancedCameraCardConfig;
  @state() protected _defaults = copyConfig(configDefaults);

  protected _initialized = false;
  protected _configUpgradeable = false;

  @state()
  protected _expandedMenus: Record<string, string | number> = {};

  protected _viewModes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'clip', label: localize('config.view.views.clip') },
    { value: 'clips', label: localize('config.view.views.clips') },
    { value: 'folder', label: localize('config.view.views.folder') },
    { value: 'folders', label: localize('config.view.views.folders') },
    { value: 'image', label: localize('config.view.views.image') },
    { value: 'live', label: localize('config.view.views.live') },
    { value: 'recording', label: localize('config.view.views.recording') },
    { value: 'recordings', label: localize('config.view.views.recordings') },
    { value: 'snapshot', label: localize('config.view.views.snapshot') },
    { value: 'snapshots', label: localize('config.view.views.snapshots') },
    { value: 'timeline', label: localize('config.view.views.timeline') },
  ];

  protected _cameraSelectViewModes: EditorSelectOption[] = [
    ...this._viewModes,
    { value: 'current', label: localize('config.view.views.current') },
  ];

  protected _filterModes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'none',
      label: localize('config.common.controls.filter.modes.none'),
    },
    {
      value: 'left',
      label: localize('config.common.controls.filter.modes.left'),
    },
    {
      value: 'right',
      label: localize('config.common.controls.filter.modes.right'),
    },
  ];

  protected _menuStyles: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'none', label: localize('config.menu.styles.none') },
    { value: 'hidden', label: localize('config.menu.styles.hidden') },
    { value: 'overlay', label: localize('config.menu.styles.overlay') },
    { value: 'hover', label: localize('config.menu.styles.hover') },
    { value: 'hover-card', label: localize('config.menu.styles.hover-card') },
    { value: 'outside', label: localize('config.menu.styles.outside') },
  ];

  protected _menuPositions: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'left', label: localize('config.menu.positions.left') },
    { value: 'right', label: localize('config.menu.positions.right') },
    { value: 'top', label: localize('config.menu.positions.top') },
    { value: 'bottom', label: localize('config.menu.positions.bottom') },
  ];

  protected _menuAlignments: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'left', label: localize('config.menu.alignments.left') },
    { value: 'right', label: localize('config.menu.alignments.right') },
    { value: 'top', label: localize('config.menu.alignments.top') },
    { value: 'bottom', label: localize('config.menu.alignments.bottom') },
  ];

  protected _nextPreviousControlStyles: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'chevrons',
      label: localize('config.common.controls.next_previous.styles.chevrons'),
    },
    {
      value: 'icons',
      label: localize('config.common.controls.next_previous.styles.icons'),
    },
    {
      value: 'none',
      label: localize('config.common.controls.next_previous.styles.none'),
    },
    {
      value: 'thumbnails',
      label: localize('config.common.controls.next_previous.styles.thumbnails'),
    },
  ];

  protected _aspectRatioModes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'dynamic',
      label: localize('config.dimensions.aspect_ratio_modes.dynamic'),
    },
    { value: 'static', label: localize('config.dimensions.aspect_ratio_modes.static') },
    {
      value: 'unconstrained',
      label: localize('config.dimensions.aspect_ratio_modes.unconstrained'),
    },
  ];

  protected _thumbnailModes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'none',
      label: localize('config.common.controls.thumbnails.modes.none'),
    },
    {
      value: 'above',
      label: localize('config.common.controls.thumbnails.modes.above'),
    },
    {
      value: 'below',
      label: localize('config.common.controls.thumbnails.modes.below'),
    },
    {
      value: 'left',
      label: localize('config.common.controls.thumbnails.modes.left'),
    },
    {
      value: 'right',
      label: localize('config.common.controls.thumbnails.modes.right'),
    },
  ];

  protected _thumbnailMediaTypes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'events',
      label: localize('config.common.controls.thumbnails.media_types.events'),
    },
    {
      value: 'recordings',
      label: localize('config.common.controls.thumbnails.media_types.recordings'),
    },
  ];

  protected _thumbnailEventsMediaTypes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'clips',
      label: localize('config.common.controls.thumbnails.events_media_types.clips'),
    },
    {
      value: 'snapshots',
      label: localize('config.common.controls.thumbnails.events_media_types.snapshots'),
    },
  ];

  protected _transitionEffects: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'none', label: localize('config.media_viewer.transition_effects.none') },
    { value: 'slide', label: localize('config.media_viewer.transition_effects.slide') },
  ];

  protected _imageModes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'camera', label: localize('config.common.image.modes.camera') },
    { value: 'entity', label: localize('config.common.image.modes.entity') },
    { value: 'screensaver', label: localize('config.common.image.modes.screensaver') },
    { value: 'url', label: localize('config.common.image.modes.url') },
  ];

  protected _timelineEventsMediaTypes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'all', label: localize('config.common.timeline.events_media_types.all') },
    {
      value: 'clips',
      label: localize('config.common.timeline.events_media_types.clips'),
    },
    {
      value: 'snapshots',
      label: localize('config.common.timeline.events_media_types.snapshots'),
    },
  ];

  protected _timelineStyleTypes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'ribbon', label: localize('config.common.timeline.styles.ribbon') },
    { value: 'stack', label: localize('config.common.timeline.styles.stack') },
  ];

  protected _mediaActionNegativeConditions: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'unselected',
      label: localize('config.common.media_action_conditions.unselected'),
    },
    { value: 'hidden', label: localize('config.common.media_action_conditions.hidden') },
  ];

  protected _mediaActionPositiveConditions: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'selected',
      label: localize('config.common.media_action_conditions.selected'),
    },
    {
      value: 'visible',
      label: localize('config.common.media_action_conditions.visible'),
    },
  ];

  protected _mediaLiveUnmuteConditions: EditorSelectOption[] = [
    ...this._mediaActionPositiveConditions,
    {
      value: 'microphone',
      label: localize('config.common.media_action_conditions.microphone_unmute'),
    },
  ];

  protected _mediaLiveMuteConditions: EditorSelectOption[] = [
    ...this._mediaActionNegativeConditions,
    {
      value: 'microphone',
      label: localize('config.common.media_action_conditions.microphone_mute'),
    },
  ];

  protected _layoutFits: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'contain',
      label: localize('config.cameras.dimensions.layout.fits.contain'),
    },
    { value: 'cover', label: localize('config.cameras.dimensions.layout.fits.cover') },
    { value: 'fill', label: localize('config.cameras.dimensions.layout.fits.fill') },
  ];

  protected _miniTimelineModes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'none', label: localize('config.common.controls.timeline.modes.none') },
    { value: 'above', label: localize('config.common.controls.timeline.modes.above') },
    { value: 'below', label: localize('config.common.controls.timeline.modes.below') },
  ];

  protected _profiles: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'casting', label: localize('config.profiles.casting') },
    { value: 'low-performance', label: localize('config.profiles.low-performance') },
    { value: 'scrubbing', label: localize('config.profiles.scrubbing') },
  ];

  protected _go2rtcModes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'mse', label: localize('config.cameras.go2rtc.modes.mse') },
    { value: 'webrtc', label: localize('config.cameras.go2rtc.modes.webrtc') },
    { value: 'mp4', label: localize('config.cameras.go2rtc.modes.mp4') },
    { value: 'mjpeg', label: localize('config.cameras.go2rtc.modes.mjpeg') },
  ];

  protected _microphoneButtonTypes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'momentary', label: localize('config.menu.buttons.types.momentary') },
    { value: 'toggle', label: localize('config.menu.buttons.types.toggle') },
  ];

  protected _displayModes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'single', label: localize('display_modes.single') },
    { value: 'grid', label: localize('display_modes.grid') },
  ];

  protected _gridSelectPositions: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'default',
      label: localize('config.common.display.grid_selected_positions.default'),
    },
    {
      value: 'first',
      label: localize('config.common.display.grid_selected_positions.first'),
    },
    {
      value: 'last',
      label: localize('config.common.display.grid_selected_positions.last'),
    },
  ];

  protected _castMethods: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'standard', label: localize('config.cameras.cast.methods.standard') },
    { value: 'dashboard', label: localize('config.cameras.cast.methods.dashboard') },
  ];

  protected _ptzModes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'on', label: localize('config.live.controls.ptz.modes.on') },
    { value: 'off', label: localize('config.live.controls.ptz.modes.off') },
  ];

  protected _ptzOrientations: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'vertical',
      label: localize('config.live.controls.ptz.orientations.vertical'),
    },
    {
      value: 'horizontal',
      label: localize('config.live.controls.ptz.orientations.horizontal'),
    },
  ];

  protected _ptzPositions: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'top-left',
      label: localize('config.live.controls.ptz.positions.top-left'),
    },
    {
      value: 'top-right',
      label: localize('config.live.controls.ptz.positions.top-right'),
    },
    {
      value: 'bottom-left',
      label: localize('config.live.controls.ptz.positions.bottom-left'),
    },
    {
      value: 'bottom-right',
      label: localize('config.live.controls.ptz.positions.bottom-right'),
    },
  ];

  protected _triggersActionsInteractionModes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'all',
      label: localize('config.view.triggers.actions.interaction_modes.all'),
    },
    {
      value: 'inactive',
      label: localize('config.view.triggers.actions.interaction_modes.inactive'),
    },
    {
      value: 'active',
      label: localize('config.view.triggers.actions.interaction_modes.active'),
    },
  ];

  protected _triggersActionsTrigger: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'default',
      label: localize('config.view.triggers.actions.triggers.default'),
    },
    {
      value: 'live',
      label: localize('config.view.triggers.actions.triggers.live'),
    },
    {
      value: 'media',
      label: localize('config.view.triggers.actions.triggers.media'),
    },
    {
      value: 'none',
      label: localize('config.view.triggers.actions.triggers.none'),
    },
  ];

  protected _triggersActionsUntrigger: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'default',
      label: localize('config.view.triggers.actions.untriggers.default'),
    },
    {
      value: 'none',
      label: localize('config.view.triggers.actions.untriggers.none'),
    },
  ];

  protected _triggersEvents: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'events',
      label: localize('config.cameras.triggers.events.events'),
    },
    {
      value: 'clips',
      label: localize('config.cameras.triggers.events.clips'),
    },
    {
      value: 'snapshots',
      label: localize('config.cameras.triggers.events.snapshots'),
    },
  ];

  protected _timelinePanModes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'pan',
      label: localize('config.common.controls.timeline.pan_modes.pan'),
    },
    {
      value: 'seek',
      label: localize('config.common.controls.timeline.pan_modes.seek'),
    },
    {
      value: 'seek-in-media',
      label: localize('config.common.controls.timeline.pan_modes.seek-in-media'),
    },
    {
      value: 'seek-in-camera',
      label: localize('config.common.controls.timeline.pan_modes.seek-in-camera'),
    },
  ];

  protected _capabilities: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'live',
      label: localize('config.cameras.capabilities.capabilities.live'),
    },
    {
      value: 'substream',
      label: localize('config.cameras.capabilities.capabilities.substream'),
    },
    {
      value: 'clips',
      label: localize('config.cameras.capabilities.capabilities.clips'),
    },
    {
      value: 'recordings',
      label: localize('config.cameras.capabilities.capabilities.recordings'),
    },
    {
      value: 'snapshots',
      label: localize('config.cameras.capabilities.capabilities.snapshots'),
    },
    {
      value: 'favorite-events',
      label: localize('config.cameras.capabilities.capabilities.favorite-events'),
    },
    {
      value: 'favorite-recordings',
      label: localize('config.cameras.capabilities.capabilities.favorite-recordings'),
    },
    {
      value: 'seek',
      label: localize('config.cameras.capabilities.capabilities.seek'),
    },
    {
      value: 'ptz',
      label: localize('config.cameras.capabilities.capabilities.ptz'),
    },
    {
      value: 'menu',
      label: localize('config.cameras.capabilities.capabilities.menu'),
    },
  ];

  protected _defaultResetInteractionModes: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'all',
      label: localize('config.view.default_reset.interaction_modes.all'),
    },
    {
      value: 'inactive',
      label: localize('config.view.default_reset.interaction_modes.inactive'),
    },
    {
      value: 'active',
      label: localize('config.view.default_reset.interaction_modes.active'),
    },
  ];

  protected _proxyMedia: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'auto',
      label: localize('config.cameras.proxy.media.auto'),
    },
    {
      value: true,
      label: localize('config.cameras.proxy.media.true'),
    },
    {
      value: false,
      label: localize('config.cameras.proxy.media.false'),
    },
  ];

  protected _proxySSLCiphers: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'auto',
      label: localize('config.cameras.proxy.ssl_ciphers.auto'),
    },
    {
      value: 'default',
      label: localize('config.cameras.proxy.ssl_ciphers.default'),
    },
    {
      value: 'insecure',
      label: localize('config.cameras.proxy.ssl_ciphers.insecure'),
    },
    {
      value: 'intermediate',
      label: localize('config.cameras.proxy.ssl_ciphers.intermediate'),
    },
    {
      value: 'modern',
      label: localize('config.cameras.proxy.ssl_ciphers.modern'),
    },
  ];

  protected _proxySSLVerification: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'auto',
      label: localize('config.cameras.proxy.ssl_verification.auto'),
    },
    {
      value: true,
      label: localize('config.cameras.proxy.ssl_verification.true'),
    },
    {
      value: false,
      label: localize('config.cameras.proxy.ssl_verification.false'),
    },
  ];

  protected _reolinkMediaResolution: EditorSelectOption[] = [
    { value: '', label: '' },
    {
      value: 'high',
      label: localize('config.cameras.reolink.media_resolution.high'),
    },
    {
      value: 'low',
      label: localize('config.cameras.reolink.media_resolution.low'),
    },
  ];

  protected _statusBarStyles: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'hover', label: localize('config.status_bar.styles.hover') },
    { value: 'hover-card', label: localize('config.status_bar.styles.hover-card') },
    { value: 'none', label: localize('config.status_bar.styles.none') },
    { value: 'outside', label: localize('config.status_bar.styles.outside') },
    { value: 'overlay', label: localize('config.status_bar.styles.overlay') },
    { value: 'popup', label: localize('config.status_bar.styles.popup') },
  ];

  protected _statusBarPositions: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'top', label: localize('config.status_bar.positions.top') },
    { value: 'bottom', label: localize('config.status_bar.positions.bottom') },
  ];

  protected _themes: EditorSelectOption[] = [
    { value: '', label: '' },
    { value: 'ha', label: localize('config.view.theme.themes.ha') },
    { value: 'dark', label: localize('config.view.theme.themes.dark') },
    { value: 'light', label: localize('config.view.theme.themes.light') },
    { value: 'traditional', label: localize('config.view.theme.themes.traditional') },
  ];

  public setConfig(config: RawAdvancedCameraCardConfig): void {
    // Note: This does not use Zod to parse the full configuration, so it may be
    // partially or completely invalid. It's more useful to have a partially
    // valid configuration here, to allow the user to fix the broken parts. As
    // such, RawAdvancedCameraCardConfig is used as the type.
    this._config = config;
    this._configUpgradeable = isConfigUpgradeable(config);

    const profiles = profilesSchema.safeParse(
      (this._config as AdvancedCameraCardConfig).profiles,
    );

    if (profiles.success) {
      const defaults = copyConfig(configDefaults);
      setProfiles(this._config, defaults, profiles.data);
      this._defaults = defaults;
    }
  }

  protected willUpdate(): void {
    if (!this._initialized) {
      sideLoadHomeAssistantElements().then((success) => {
        if (success) {
          this._initialized = true;
        }
      });
    }
  }

  /**
   * Render an option set header
   * @param optionSetName The name of the EditorOptionsSet.
   * @returns A rendered template.
   */
  protected _renderOptionSetHeader(
    optionSetName: string,
    titleClass?: string,
  ): TemplateResult {
    const optionSet = options[optionSetName];

    return html`
      <div
        class="option option-${optionSetName}"
        @click=${this._toggleMenu}
        .domain=${'options'}
        .key=${optionSetName}
      >
        <div class="row">
          <advanced-camera-card-icon
            .icon=${{ icon: `mdi:${optionSet.icon}` }}
          ></advanced-camera-card-icon>
          <div class="title ${titleClass ?? ''}">${optionSet.name}</div>
        </div>
        <div class="secondary">${optionSet.secondary}</div>
      </div>
    `;
  }

  /**
   * Get a localized help label for a given config path.
   * @param configPath The config path.
   * @returns A localized label.
   */
  protected _getLabel(configPath: string): string {
    // Strip out array indices from the path.
    const path = configPath
      .split('.')
      .filter((e) => !e.match(/^\[[0-9]+\]$/))
      .join('.');
    return localize(`config.${path}`);
  }

  /**
   * Render an entity selector.
   * @param configPath The configuration path to set/read.
   * @param domain Only entities from this domain will be shown.
   * @returns A rendered template.
   */
  protected _renderEntitySelector(
    configPath: string,
    domain: string,
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }

    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{ entity: { domain: domain } }}
        .label=${this._getLabel(configPath)}
        .value=${getConfigValue(this._config, configPath, '')}
        .required=${false}
        @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
      >
      </ha-selector>
    `;
  }

  /**
   * Render an option/"select" selector.
   * @param configPath The configuration path to set/read.
   * @param options The options to show in the selector.
   * @param params Option parameters to control the selector.
   * @returns A rendered template.
   */
  protected _renderOptionSelector(
    configPath: string,
    options: string[] | { value: unknown; label: string }[] = [],
    params?: {
      multiple?: boolean;
      label?: string;
    },
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }

    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{
          select: {
            mode: 'dropdown',
            multiple: !!params?.multiple,
            custom_value: !options.length,
            options: options,
          },
        }}
        .label=${params?.label || this._getLabel(configPath)}
        .value=${getConfigValue(this._config, configPath, '')}
        .required=${false}
        @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
      >
      </ha-selector>
    `;
  }

  /**
   * Render an icon selector.
   * @param configPath The configuration path to set/read.
   * @param params Optional parameters to control the selector.
   * @returns A rendered template.
   */
  protected _renderIconSelector(
    configPath: string,
    params?: {
      label?: string;
    },
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }

    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{
          icon: {},
        }}
        .label=${params?.label || this._getLabel(configPath)}
        .value=${getConfigValue(this._config, configPath, '')}
        .required=${false}
        @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
      >
      </ha-selector>
    `;
  }

  /**
   * Render a number slider.
   * @param configPath Configuration path of the variable.
   * @param params Optional parameters to control the selector.
   * @returns A rendered template.
   */
  protected _renderNumberInput(
    configPath: string,
    params?: {
      min?: number;
      max?: number;
      label?: string;
      default?: number;
      step?: number;
    },
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }
    const value = getConfigValue(this._config, configPath);
    const mode = params?.max === undefined ? 'box' : 'slider';

    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{
          number: {
            min: params?.min || 0,
            max: params?.max,
            mode: mode,
            step: params?.step,
          },
        }}
        .label=${params?.label || this._getLabel(configPath)}
        .value=${value ?? params?.default}
        .required=${false}
        @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
      >
      </ha-selector>
    `;
  }

  /**
   * Render a simple text info box.
   * @param info The string to display.
   * @returns A rendered template.
   */
  protected _renderInfo(info: string): TemplateResult {
    return html` <span class="info">${info}</span>`;
  }

  /**
   * Get an editor title for the camera.
   * @param cameraIndex The index of the camera in the cameras array.
   * @param cameraConfig The raw camera configuration object.
   * @returns A string title.
   */
  protected _getEditorCameraTitle(
    cameraIndex: number,
    cameraConfig: RawAdvancedCameraCardConfig,
  ): string {
    // Attempt to render a recognizable name for the camera, starting with the
    // most likely to be useful and working our ways towards the least useful.
    // This is only used for the editor since the card itself can use the
    // cameraManager.
    return (
      (typeof cameraConfig?.title === 'string' && cameraConfig.title) ||
      (typeof cameraConfig?.camera_entity === 'string'
        ? getEntityTitle(this.hass, cameraConfig.camera_entity)
        : '') ||
      (typeof cameraConfig?.webrtc_card === 'object' &&
        cameraConfig.webrtc_card &&
        typeof cameraConfig.webrtc_card['entity'] === 'string' &&
        cameraConfig.webrtc_card['entity']) ||
      // Usage of engine specific logic here is allowed as an exception, since
      // the camera manager cannot be started with an unparsed and unloaded
      // config.
      (typeof cameraConfig?.frigate === 'object' &&
      cameraConfig.frigate &&
      typeof cameraConfig?.frigate['camera_name'] === 'string' &&
      cameraConfig.frigate['camera_name']
        ? prettifyTitle(cameraConfig.frigate['camera_name'])
        : '') ||
      (typeof cameraConfig?.id === 'string' && cameraConfig.id) ||
      localize('editor.camera') + ' #' + cameraIndex
    );
  }

  /**
   * Get an editor title for the camera.
   * @param cameraIndex The index of the camera in the cameras array.
   * @param cameraConfig The raw camera configuration object.
   * @returns A string title.
   */
  protected _getEditorFolderTitle(
    folderIndex: number,
    folderConfig: RawAdvancedCameraCardConfig,
  ): string {
    // Attempt to render a recognizable name for the camera, starting with the
    // most likely to be useful and working our ways towards the least useful.
    // This is only used for the editor since the card itself can use the
    // cameraManager.
    return (
      (typeof folderConfig?.title === 'string' && folderConfig.title) ||
      (typeof folderConfig?.id === 'string' && folderConfig.id) ||
      localize('common.folder') + ' #' + folderIndex
    );
  }

  protected _renderViewDefaultResetMenu(): TemplateResult {
    return this._putInSubmenu(
      MENU_VIEW_DEFAULT_RESET,
      true,
      `config.${CONF_VIEW_DEFAULT_RESET}.editor_label`,
      'mdi:restart',
      html`
        ${this._renderSwitch(
          CONF_VIEW_DEFAULT_RESET_AFTER_INTERACTION,
          this._defaults.view.default_reset.after_interaction,
        )}
        ${this._renderNumberInput(CONF_VIEW_DEFAULT_RESET_EVERY_SECONDS)}
        ${this._renderOptionSelector(
          CONF_VIEW_DEFAULT_RESET_INTERACTION_MODE,
          this._defaultResetInteractionModes,
          {
            label: localize('config.view.default_reset.interaction_mode'),
          },
        )},
        ${this._renderOptionSelector(
          CONF_VIEW_DEFAULT_RESET_ENTITIES,
          this.hass ? getEntitiesFromHASS(this.hass) : [],
          {
            multiple: true,
          },
        )}
      `,
    );
  }

  protected _renderViewTriggersMenu(): TemplateResult {
    return this._putInSubmenu(
      MENU_VIEW_TRIGGERS,
      true,
      `config.${CONF_VIEW_TRIGGERS}.editor_label`,
      'mdi:target-account',
      html`
        ${this._renderSwitch(
          CONF_VIEW_TRIGGERS_FILTER_SELECTED_CAMERA,
          this._defaults.view.triggers.filter_selected_camera,
          {
            label: localize(`config.${CONF_VIEW_TRIGGERS_FILTER_SELECTED_CAMERA}`),
          },
        )}
        ${this._renderSwitch(
          CONF_VIEW_TRIGGERS_SHOW_TRIGGER_STATUS,
          this._defaults.view.triggers.show_trigger_status,
          {
            label: localize(`config.${CONF_VIEW_TRIGGERS_SHOW_TRIGGER_STATUS}`),
          },
        )}
        ${this._renderNumberInput(CONF_VIEW_TRIGGERS_UNTRIGGER_SECONDS, {
          default: this._defaults.view.triggers.untrigger_seconds,
        })}
        ${this._putInSubmenu(
          MENU_VIEW_TRIGGERS_ACTIONS,
          true,
          `config.${CONF_VIEW_TRIGGERS_ACTIONS}.editor_label`,
          'mdi:cogs',
          html` ${this._renderOptionSelector(
            CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER,
            this._triggersActionsTrigger,
            {
              label: localize('config.view.triggers.actions.trigger'),
            },
          )}
          ${this._renderOptionSelector(
            CONF_VIEW_TRIGGERS_ACTIONS_UNTRIGGER,
            this._triggersActionsUntrigger,
            {
              label: localize('config.view.triggers.actions.untrigger'),
            },
          )}
          ${this._renderOptionSelector(
            CONF_VIEW_TRIGGERS_ACTIONS_INTERACTION_MODE,
            this._triggersActionsInteractionModes,
            {
              label: localize('config.view.triggers.actions.interaction_mode'),
            },
          )}`,
        )}
      `,
    );
  }

  protected _renderKeyAssigner(
    configPath: string,
    defaultValue: KeyboardShortcut,
  ): TemplateResult {
    return html` <advanced-camera-card-key-assigner
      .label=${localize(`config.${configPath}`)}
      .value=${this._config
        ? getConfigValue(this._config, configPath, defaultValue)
        : null}
      @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
    ></advanced-camera-card-key-assigner>`;
  }

  protected _renderViewKeyboardShortcutMenu(): TemplateResult {
    return this._putInSubmenu(
      MENU_VIEW_KEYBOARD_SHORTCUTS,
      true,
      `config.${CONF_VIEW_KEYBOARD_SHORTCUTS}.editor_label`,
      'mdi:keyboard',
      html`
        ${this._renderSwitch(
          CONF_VIEW_KEYBOARD_SHORTCUTS_ENABLED,
          this._defaults.view.keyboard_shortcuts.enabled,
          {
            label: localize(`config.${CONF_VIEW_KEYBOARD_SHORTCUTS_ENABLED}`),
          },
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_LEFT,
          this._defaults.view.keyboard_shortcuts.ptz_left,
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_RIGHT,
          this._defaults.view.keyboard_shortcuts.ptz_right,
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_UP,
          this._defaults.view.keyboard_shortcuts.ptz_up,
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_DOWN,
          this._defaults.view.keyboard_shortcuts.ptz_down,
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_ZOOM_IN,
          this._defaults.view.keyboard_shortcuts.ptz_zoom_in,
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_ZOOM_OUT,
          this._defaults.view.keyboard_shortcuts.ptz_zoom_out,
        )}
        ${this._renderKeyAssigner(
          CONF_VIEW_KEYBOARD_SHORTCUTS_PTZ_HOME,
          this._defaults.view.keyboard_shortcuts.ptz_home,
        )}
      `,
    );
  }

  protected _renderStatusBarItem(item: string): TemplateResult {
    return html` ${this._putInSubmenu(
      MENU_STATUS_BAR_ITEMS,
      item,
      `config.status_bar.items.${item}`,
      'mdi:feature-search',
      html`
        ${this._renderSwitch(
          `${CONF_STATUS_BAR_ITEMS}.${item}.enabled`,
          this._defaults.status_bar.items[item]?.enabled ?? true,
          {
            label: localize('config.status_bar.items.enabled'),
          },
        )}
        ${this._renderNumberInput(`${CONF_STATUS_BAR_ITEMS}.${item}.priority`, {
          max: STATUS_BAR_PRIORITY_MAX,
          default: this._defaults.status_bar.items[item]?.priority,
          label: localize('config.status_bar.items.priority'),
        })}
      `,
    )}`;
  }

  protected _renderMenuButton(
    button: string,
    additionalOptions?: TemplateResult,
  ): TemplateResult {
    const menuButtonAlignments: EditorSelectOption[] = [
      { value: '', label: '' },
      { value: 'matching', label: localize('config.menu.buttons.alignments.matching') },
      { value: 'opposing', label: localize('config.menu.buttons.alignments.opposing') },
    ];

    return html` ${this._putInSubmenu(
      MENU_MENU_BUTTONS,
      button,
      `config.menu.buttons.${button}`,
      'mdi:gesture-tap-button',
      html`
        ${this._renderSwitch(
          `${CONF_MENU_BUTTONS}.${button}.enabled`,
          this._defaults.menu.buttons[button]?.enabled ?? true,
          {
            label: localize('config.menu.buttons.enabled'),
          },
        )}
        ${this._renderOptionSelector(
          `${CONF_MENU_BUTTONS}.${button}.alignment`,
          menuButtonAlignments,
          {
            label: localize('config.menu.buttons.alignment'),
          },
        )}
        ${this._renderSwitch(
          `${CONF_MENU_BUTTONS}.${button}.permanent`,
          this._defaults.menu.buttons[button]?.permanent ?? false,
          {
            label: localize('config.menu.buttons.permanent'),
          },
        )}
        ${this._renderNumberInput(`${CONF_MENU_BUTTONS}.${button}.priority`, {
          max: MENU_PRIORITY_MAX,
          default: this._defaults.menu.buttons[button]?.priority,
          label: localize('config.menu.buttons.priority'),
        })}
        ${this._renderIconSelector(`${CONF_MENU_BUTTONS}.${button}.icon`, {
          label: localize('config.menu.buttons.icon'),
        })}
        ${additionalOptions}
      `,
    )}`;
  }

  /**
   * Put a given rendered template into a submenu.
   * @param domain The submenu domain.
   * @param key The submenu key.
   * @param icon The icon for the submenu.
   * @param labelPath The path to the label to localize.
   * @param template The template to put in the submenu.
   * @returns
   */
  protected _putInSubmenu(
    domain: string,
    key: unknown,
    labelPath: string,
    icon: string,
    template: TemplateResult,
  ): TemplateResult {
    const selected = this._expandedMenus[domain] === key;
    const submenuClasses = {
      submenu: true,
      selected: selected,
    };

    return html` <div class="${classMap(submenuClasses)}">
      <div
        class="submenu-header"
        @click=${this._toggleMenu}
        .domain=${domain}
        .key=${key}
      >
        <advanced-camera-card-icon .icon=${{ icon: icon }}></advanced-camera-card-icon>
        <span>${localize(labelPath)}</span>
      </div>
      ${selected ? html`<div class="values">${template}</div>` : ''}
    </div>`;
  }

  /**
   * Render a media layout section.
   * @param domain The submenu domain.
   * @param labelPath The path to the label.
   * @param configPathFit The path to the fit config.
   * @param configPathPositionX The path to the position.x config.
   * @param configPathPositionY The path to the position.y config.
   * @returns A rendered template.
   */
  protected _renderMediaLayout(
    domain: string,
    labelPath: string,
    configPathFit: string,
    configPathPositionX: string,
    configPathPositionY: string,
    configPathViewBoxTop: string,
    configPathViewBoxBottom: string,
    configPathViewBoxLeft: string,
    configPathViewBoxRight: string,
    configPathZoom: string,
    configPathPanX: string,
    configPathPanY: string,
  ): TemplateResult | void {
    return this._putInSubmenu(
      domain,
      true,
      labelPath,
      'mdi:page-layout-body',
      html`
        ${this._renderNumberInput(configPathZoom, {
          min: ZOOM_MIN,
          max: ZOOM_MAX,
          label: localize('config.cameras.dimensions.layout.zoom'),
          step: 0.1,
        })}
        ${this._renderNumberInput(configPathPanX, {
          min: 0,
          max: 100,
          label: localize('config.cameras.dimensions.layout.pan.x'),
        })}
        ${this._renderNumberInput(configPathPanY, {
          min: 0,
          max: 100,
          label: localize('config.cameras.dimensions.layout.pan.y'),
        })}
        ${this._renderOptionSelector(configPathFit, this._layoutFits, {
          label: localize('config.cameras.dimensions.layout.fit'),
        })}
        ${this._putInSubmenu(
          `${domain}.position`,
          true,
          'config.cameras.dimensions.layout.position.editor_label',
          'mdi:aspect-ratio',
          html` ${this._renderNumberInput(configPathPositionX, {
            min: 0,
            max: 100,
            label: localize('config.cameras.dimensions.layout.position.x'),
          })}
          ${this._renderNumberInput(configPathPositionY, {
            min: 0,
            max: 100,
            label: localize('config.cameras.dimensions.layout.position.y'),
          })}`,
        )}
        ${this._putInSubmenu(
          `${domain}.view_box`,
          true,
          'config.cameras.dimensions.layout.view_box.editor_label',
          'mdi:crop',
          html`
            ${this._renderNumberInput(configPathViewBoxTop, {
              min: 0,
              max: 100,
              label: localize('config.cameras.dimensions.layout.view_box.top'),
            })}
            ${this._renderNumberInput(configPathViewBoxBottom, {
              min: 0,
              max: 100,
              label: localize('config.cameras.dimensions.layout.view_box.bottom'),
            })}
            ${this._renderNumberInput(configPathViewBoxLeft, {
              min: 0,
              max: 100,
              label: localize('config.cameras.dimensions.layout.view_box.left'),
            })}
            ${this._renderNumberInput(configPathViewBoxRight, {
              min: 0,
              max: 100,
              label: localize('config.cameras.dimensions.layout.view_box.right'),
            })}
          `,
        )}
      `,
    );
  }

  /**
   * Render the core timeline controls (mini or full timeline),
   * @param configPathStyle Timeline style config path.
   * @param configPathWindowSeconds Timeline window config path.
   * @param configPathClusteringThreshold Clustering threshold config path.
   * @param configPathTimelineEventsMediaType Timeline media config path.
   * @param configPathShowRecordings Show recordings config path.
   * @param defaultShowRecordings Default value of show_recordings.
   * @returns A rendered template.
   */
  protected _renderTimelineCoreControls(
    domain: string,
    configPathStyle: string,
    configPathWindowSeconds: string,
    configPathClusteringThreshold: string,
    configPathTimelineEventsMediaType: string,
    configPathShowRecordings: string,
    configPathFormat24h: string,
    defaultShowRecordings: boolean,
    defaultFormat24h: boolean,
    configPathPanMode?: string,
  ): TemplateResult {
    return html`
      ${this._renderOptionSelector(configPathStyle, this._timelineStyleTypes, {
        label: localize(`config.common.${CONF_TIMELINE_STYLE}`),
      })}
      ${configPathPanMode
        ? this._renderOptionSelector(configPathPanMode, this._timelinePanModes, {
            label: localize(`config.common.controls.timeline.pan_mode`),
          })
        : ``}
      ${this._renderNumberInput(configPathWindowSeconds, {
        label: localize(`config.common.${CONF_TIMELINE_WINDOW_SECONDS}`),
      })}
      ${this._renderNumberInput(configPathClusteringThreshold, {
        label: localize(`config.common.${CONF_TIMELINE_CLUSTERING_THRESHOLD}`),
      })}
      ${this._renderOptionSelector(
        configPathTimelineEventsMediaType,
        this._timelineEventsMediaTypes,
        {
          label: localize(`config.common.${CONF_TIMELINE_EVENTS_MEDIA_TYPE}`),
        },
      )}
      ${this._renderSwitch(configPathShowRecordings, defaultShowRecordings, {
        label: localize(`config.common.${CONF_TIMELINE_SHOW_RECORDINGS}`),
      })}
      ${this._putInSubmenu(
        `${domain}.format`,
        true,
        'config.common.controls.timeline.format.editor_label',
        'mdi:clock-edit',
        html`
          ${this._renderSwitch(configPathFormat24h, defaultFormat24h, {
            label: localize('config.common.controls.timeline.format.24h'),
          })}
        `,
      )}
    `;
  }

  /**
   * Render the mini timeline controls.
   * @param domain The submenu domain.
   * @param configPathWindowSeconds Timeline window config path.
   * @param configPathClusteringThreshold Clustering threshold config path.
   * @param configPathTimelineEventsMediaType Timeline media config path.
   * @param configPathShowRecordings Show recordings config path.
   * @returns A rendered template.
   */
  protected _renderMiniTimeline(
    domain: string,
    configPathMode: string,
    configPathStyle: string,
    configPathWindowSeconds: string,
    configPathClusteringThreshold: string,
    configPathTimelineEventsMediaType: string,
    configPathShowRecordings: string,
    configPathFormat24h: string,
    defaultShowRecordings: boolean,
    defaultFormat24h: boolean,
    configPathPanMode: string,
  ): TemplateResult | void {
    return this._putInSubmenu(
      domain,
      true,
      'config.common.controls.timeline.editor_label',
      'mdi:chart-gantt',
      html` ${this._renderOptionSelector(configPathMode, this._miniTimelineModes, {
        label: localize('config.common.controls.timeline.mode'),
      })}
      ${this._renderTimelineCoreControls(
        domain,
        configPathStyle,
        configPathWindowSeconds,
        configPathClusteringThreshold,
        configPathTimelineEventsMediaType,
        configPathShowRecordings,
        configPathFormat24h,
        defaultShowRecordings,
        defaultFormat24h,
        configPathPanMode,
      )}`,
    );
  }

  /**
   * Render the next & previous controls.
   * @param domain The submenu domain.
   * @param configPathStyle Next previous style config path.
   * @param configPathSize Next previous size config path.
   * @returns A rendered template.
   */
  protected _renderViewDisplay(
    domain: string,
    configPathMode: string,
    configPathSelectedPosition: string,
    configPathSelectedWidthFactor: string,
    configPathColumns: string,
    configPathMaxColumns: string,
  ): TemplateResult | void {
    return this._putInSubmenu(
      domain,
      true,
      'config.common.display.editor_label',
      'mdi:palette-swatch',
      html`
        ${this._renderOptionSelector(configPathMode, this._displayModes, {
          label: localize('config.common.display.mode'),
        })}
        ${this._renderOptionSelector(
          configPathSelectedPosition,
          this._gridSelectPositions,
          {
            label: localize('config.common.display.grid_selected_position'),
          },
        )}
        ${this._renderNumberInput(configPathSelectedWidthFactor, {
          min: 0,
          label: localize('config.common.display.grid_selected_width_factor'),
        })}
        ${this._renderNumberInput(configPathColumns, {
          min: 0,
          label: localize('config.common.display.grid_columns'),
        })}
        ${this._renderNumberInput(configPathMaxColumns, {
          min: 0,
          label: localize('config.common.display.grid_max_columns'),
        })}
      `,
    );
  }

  /**
   * Render the next & previous controls.
   * @param domain The submenu domain.
   * @param configPathStyle Next previous style config path.
   * @param configPathSize Next previous size config path.
   * @returns A rendered template.
   */
  protected _renderNextPreviousControls(
    domain: string,
    configPathStyle: string,
    configPathSize: string,
    options?: {
      allowIcons?: boolean;
      allowThumbnails?: boolean;
    },
  ): TemplateResult | void {
    return this._putInSubmenu(
      domain,
      true,
      'config.common.controls.next_previous.editor_label',
      'mdi:arrow-right-bold-circle',
      html`
        ${this._renderOptionSelector(
          configPathStyle,
          this._nextPreviousControlStyles.filter(
            (item) =>
              (!!options?.allowThumbnails || item.value !== 'thumbnails') &&
              (!!options?.allowIcons || item.value !== 'icons'),
          ),
          {
            label: localize('config.common.controls.next_previous.style'),
          },
        )}
        ${this._renderNumberInput(configPathSize, {
          min: BUTTON_SIZE_MIN,
          label: localize('config.common.controls.next_previous.size'),
        })}
      `,
    );
  }

  /**
   * Render the thumbnails controls.
   * @param domain The submenu domain.
   * @param configPathMode Thumbnails mode config path.
   * @param configPathSize Thumbnails size config path.
   * @param configPathShowDetails Thumbnails show details config path.
   * @param configPathShowFavoriteControl Thumbnails show favorite control config path.
   * @param configPathShowTimelineControl Thumbnails show timeline control config path,
   * @param options An optional config path to media selection and mini-timeline mode.
   * @returns A rendered template.
   */
  protected _renderThumbnailsControls(
    domain: string,
    configPathSize: string,
    configPathShowDetails: string,
    configPathShowFavoriteControl: string,
    configPathShowTimelineControl: string,
    configPathShowDownloadControl: string,
    defaults: {
      show_details: boolean;
      show_favorite_control: boolean;
      show_timeline_control: boolean;
      show_download_control: boolean;
    },
    options?: {
      configPathMediaType?: string;
      configPathEventsMediaType?: string;
      configPathMode?: string;
    },
  ): TemplateResult | void {
    return this._putInSubmenu(
      domain,
      true,
      'config.common.controls.thumbnails.editor_label',
      'mdi:image-text',
      html`
        ${options?.configPathMode
          ? html`${this._renderOptionSelector(
              options.configPathMode,
              this._thumbnailModes,
              {
                label: localize('config.common.controls.thumbnails.mode'),
              },
            )}`
          : html``}
        ${options?.configPathMediaType
          ? html`${this._renderOptionSelector(
              options.configPathMediaType,
              this._thumbnailMediaTypes,
              {
                label: localize('config.common.controls.thumbnails.media_type'),
              },
            )}`
          : html``}
        ${options?.configPathEventsMediaType
          ? html`${this._renderOptionSelector(
              options.configPathEventsMediaType,
              this._thumbnailEventsMediaTypes,
              {
                label: localize('config.common.controls.thumbnails.events_media_type'),
              },
            )}`
          : html``}
        ${this._renderNumberInput(configPathSize, {
          min: THUMBNAIL_WIDTH_MIN,
          max: THUMBNAIL_WIDTH_MAX,
          label: localize('config.common.controls.thumbnails.size'),
        })}
        ${this._renderSwitch(configPathShowDetails, defaults.show_details, {
          label: localize('config.common.controls.thumbnails.show_details'),
        })}
        ${this._renderSwitch(
          configPathShowFavoriteControl,
          defaults.show_favorite_control,
          {
            label: localize('config.common.controls.thumbnails.show_favorite_control'),
          },
        )}
        ${this._renderSwitch(
          configPathShowTimelineControl,
          defaults.show_timeline_control,
          {
            label: localize('config.common.controls.thumbnails.show_timeline_control'),
          },
        )}
        ${this._renderSwitch(
          configPathShowDownloadControl,
          defaults.show_download_control,
          {
            label: localize('config.common.controls.thumbnails.show_download_control'),
          },
        )}
      `,
    );
  }

  /**
   * Render the thumbnails controls.
   * @param domain The submenu domain.
   * @param configPathMode Filter mode config path.
   * @returns A rendered template.
   */
  protected _renderFilterControls(
    domain: string,
    configPathMode: string,
  ): TemplateResult | void {
    return this._putInSubmenu(
      domain,
      true,
      'config.common.controls.filter.editor_label',
      'mdi:filter-cog',
      html`
        ${configPathMode
          ? html`${this._renderOptionSelector(configPathMode, this._filterModes, {
              label: localize('config.common.controls.filter.mode'),
            })}`
          : html``}
      `,
    );
  }

  protected _renderImageOptions(
    configPathMode: string,
    configPathUrl: string,
    configPathEntity: string,
    configPathEntityParameters: string,
    configPathRefreshSeconds: string,
  ): TemplateResult {
    return html`
      ${this._renderOptionSelector(configPathMode, this._imageModes, {
        label: localize('config.common.image.mode'),
      })}
      ${this._renderStringInput(configPathUrl, {
        label: localize('config.common.image.url'),
      })}
      ${this._renderOptionSelector(
        configPathEntity,
        this.hass ? getEntitiesFromHASS(this.hass) : [],
        {
          label: localize('config.common.image.entity'),
        },
      )}
      ${this._renderStringInput(configPathEntityParameters, {
        label: localize('config.common.image.entity_parameters'),
      })}
      ${this._renderNumberInput(configPathRefreshSeconds, {
        label: localize('config.common.image.refresh_seconds'),
      })}
    `;
  }

  protected _modifyConfig(func: (config: RawAdvancedCameraCardConfig) => boolean): void {
    if (this._config) {
      const newConfig = copyConfig(this._config);
      if (func(newConfig)) {
        this._updateConfig(newConfig);
      }
    }
  }

  protected _renderArrayManagementControls(
    configPathArray: string,
    index: number,
    menu: string,
    add?: boolean,
  ): TemplateResult | void {
    const array = this._config ? getConfigValue(this._config, configPathArray) : null;

    return html`
      <div class="controls">
        <ha-icon-button
          .label=${localize('editor.move_up')}
          .disabled=${add || !this._config || !Array.isArray(array) || index <= 0}
          @click=${() =>
            !add &&
            this._modifyConfig((config: RawAdvancedCameraCardConfig): boolean => {
              const array = getConfigValue(config, configPathArray);
              if (Array.isArray(array) && index > 0) {
                arrayMove(array, index, index - 1);
                this._openMenu(menu, index - 1);
                return true;
              }
              return false;
            })}
        >
          <advanced-camera-card-icon
            .icon=${{ icon: 'mdi:arrow-up' }}
          ></advanced-camera-card-icon>
        </ha-icon-button>
        <ha-icon-button
          .label=${localize('editor.move_down')}
          .disabled=${add ||
          !this._config ||
          !Array.isArray(this._config.cameras) ||
          index >= this._config.cameras.length - 1}
          @click=${() =>
            !add &&
            this._modifyConfig((config: RawAdvancedCameraCardConfig): boolean => {
              const array = getConfigValue(config, configPathArray);
              if (Array.isArray(array) && index < array.length - 1) {
                arrayMove(array, index, index + 1);
                this._openMenu(menu, index + 1);
                return true;
              }
              return false;
            })}
        >
          <advanced-camera-card-icon
            .icon=${{ icon: 'mdi:arrow-down' }}
          ></advanced-camera-card-icon>
        </ha-icon-button>
        <ha-icon-button
          .label=${localize('editor.delete')}
          .disabled=${add}
          @click=${() => {
            this._modifyConfig((config: RawAdvancedCameraCardConfig): boolean => {
              const array = getConfigValue(config, configPathArray);
              if (Array.isArray(array)) {
                array.splice(index, 1);
                this._closeMenu(menu);
                return true;
              }
              return false;
            });
          }}
        >
          <advanced-camera-card-icon
            .icon=${{ icon: 'mdi:delete' }}
          ></advanced-camera-card-icon>
        </ha-icon-button>
      </div>
    `;
  }

  protected _renderFolder(
    folders: RawAdvancedCameraCardConfigArray,
    folderIndex: number,
    addNewFolder?: boolean,
  ): TemplateResult | void {
    const submenuClasses = {
      submenu: true,
      selected: this._expandedMenus[MENU_FOLDERS] === folderIndex,
    };

    const folderTypes: EditorSelectOption[] = [
      { value: '', label: '' },
      { value: 'ha', label: localize('config.folders.types.ha') },
    ];

    return html` <div class="${classMap(submenuClasses)}">
      <div
        class="submenu-header"
        @click=${this._toggleMenu}
        .domain=${MENU_FOLDERS}
        .key=${folderIndex}
      >
        <advanced-camera-card-icon
          .icon=${{ icon: addNewFolder ? 'mdi:folder-plus' : 'mdi:folder' }}
        ></advanced-camera-card-icon>
        <span>
          ${addNewFolder
            ? html` <span class="new"> [${localize('editor.add_new_folder')}...] </span>`
            : html`<span
                >${this._getEditorFolderTitle(
                  folderIndex,
                  folders[folderIndex] || {},
                )}</span
              >`}
        </span>
      </div>
      ${this._expandedMenus[MENU_FOLDERS] === folderIndex
        ? html` <div class="values">
            ${this._renderArrayManagementControls(
              CONF_FOLDERS,
              folderIndex,
              MENU_FOLDERS,
              addNewFolder,
            )}
            ${this._renderOptionSelector(
              getArrayConfigPath(CONF_FOLDERS_ARRAY_TYPE, folderIndex),
              folderTypes,
            )}
            ${this._renderStringInput(
              getArrayConfigPath(CONF_FOLDERS_ARRAY_TITLE, folderIndex),
            )}
            ${this._renderIconSelector(
              getArrayConfigPath(CONF_FOLDERS_ARRAY_ICON, folderIndex),
              {
                label: localize('config.folders.icon'),
              },
            )}
            ${this._renderStringInput(
              getArrayConfigPath(CONF_FOLDERS_ARRAY_ID, folderIndex),
            )}
            ${this._putInSubmenu(
              MENU_FOLDERS_HA,
              folderIndex,
              'config.folders.ha.editor_label',
              'mdi:home-assistant',
              html`
                ${this._renderStringInput(
                  getArrayConfigPath(CONF_FOLDERS_ARRAY_HA_URL, folderIndex),
                )}
                ${renderMessage({
                  message: localize('config.folders.ha.path_info'),
                  icon: 'mdi:information-outline',
                  url: {
                    link: FOLDERS_CONFIGURATION_URL,
                    title: localize('error.configuration'),
                  },
                })}
              `,
            )}
          </div>`
        : ''}
    </div>`;
  }

  /**
   * Render a camera section.
   * @param cameras The full array of cameras.
   * @param cameraIndex The index (in the array) to render.
   * @param addNewCamera Whether or not this is a section to add a new non-existent camera.
   * @returns A rendered template.
   */
  protected _renderCamera(
    cameras: RawAdvancedCameraCardConfigArray,
    cameraIndex: number,
    entities: string[],
    addNewCamera?: boolean,
  ): TemplateResult | void {
    const liveProviders: EditorSelectOption[] = [
      { value: '', label: '' },
      { value: 'auto', label: localize('config.cameras.live_providers.auto') },
      { value: 'ha', label: localize('config.cameras.live_providers.ha') },
      {
        value: 'image',
        label: localize('config.cameras.live_providers.image'),
      },
      {
        value: 'jsmpeg',
        label: localize('config.cameras.live_providers.jsmpeg'),
      },
      {
        value: 'go2rtc',
        label: localize('config.cameras.live_providers.go2rtc'),
      },
      {
        value: 'webrtc-card',
        label: localize('config.cameras.live_providers.webrtc-card'),
      },
    ];

    const dependentCameras: EditorSelectOption[] = [];
    cameras.forEach((camera, index) => {
      if (index !== cameraIndex) {
        dependentCameras.push({
          value: getCameraID(camera),
          label: this._getEditorCameraTitle(index, camera),
        });
      }
    });

    const submenuClasses = {
      submenu: true,
      selected: this._expandedMenus[MENU_CAMERAS] === cameraIndex,
    };

    return html`
      <div class="${classMap(submenuClasses)}">
        <div
          class="submenu-header"
          @click=${this._toggleMenu}
          .domain=${MENU_CAMERAS}
          .key=${cameraIndex}
        >
          <advanced-camera-card-icon
            .icon=${{ icon: addNewCamera ? 'mdi:video-plus' : 'mdi:video' }}
          ></advanced-camera-card-icon>
          <span>
            ${addNewCamera
              ? html` <span class="new">
                  [${localize('editor.add_new_camera')}...]
                </span>`
              : html`<span
                  >${this._getEditorCameraTitle(
                    cameraIndex,
                    cameras[cameraIndex] || {},
                  )}</span
                >`}
          </span>
        </div>
        ${this._expandedMenus[MENU_CAMERAS] === cameraIndex
          ? html` <div class="values">
              ${this._renderArrayManagementControls(
                CONF_CAMERAS,
                cameraIndex,
                MENU_CAMERAS,
                addNewCamera,
              )}
              ${this._renderEntitySelector(
                getArrayConfigPath(CONF_CAMERAS_ARRAY_CAMERA_ENTITY, cameraIndex),
                'camera',
              )}
              ${this._renderOptionSelector(
                getArrayConfigPath(CONF_CAMERAS_ARRAY_LIVE_PROVIDER, cameraIndex),
                liveProviders,
              )}
              ${this._renderStringInput(
                getArrayConfigPath(CONF_CAMERAS_ARRAY_TITLE, cameraIndex),
              )}
              ${this._renderIconSelector(
                getArrayConfigPath(CONF_CAMERAS_ARRAY_ICON, cameraIndex),
                {
                  label: localize('config.cameras.icon'),
                },
              )}
              ${this._renderStringInput(
                getArrayConfigPath(CONF_CAMERAS_ARRAY_ID, cameraIndex),
              )}
              ${this._renderSwitch(
                getArrayConfigPath(
                  CONF_CAMERAS_ARRAY_ALWAYS_ERROR_IF_ENTITY_UNAVAILABLE,
                  cameraIndex,
                ),
                this._defaults.cameras.always_error_if_entity_unavailable,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_ENGINE,
                true,
                'config.cameras.engines.editor_label',
                'mdi:engine',
                html`${this._putInSubmenu(
                  MENU_CAMERAS_FRIGATE,
                  cameraIndex,
                  'config.cameras.frigate.editor_label',
                  'frigate',
                  html`
                    ${this._renderStringInput(
                      getArrayConfigPath(
                        CONF_CAMERAS_ARRAY_FRIGATE_CAMERA_NAME,
                        cameraIndex,
                      ),
                    )}
                    ${this._renderStringInput(
                      getArrayConfigPath(CONF_CAMERAS_ARRAY_FRIGATE_URL, cameraIndex),
                    )}
                    ${this._renderOptionSelector(
                      getArrayConfigPath(CONF_CAMERAS_ARRAY_FRIGATE_LABELS, cameraIndex),
                      [],
                      {
                        multiple: true,
                        label: localize('config.cameras.frigate.labels'),
                      },
                    )}
                    ${this._renderOptionSelector(
                      getArrayConfigPath(CONF_CAMERAS_ARRAY_FRIGATE_ZONES, cameraIndex),
                      [],
                      {
                        multiple: true,
                        label: localize('config.cameras.frigate.zones'),
                      },
                    )}
                    ${this._renderStringInput(
                      getArrayConfigPath(
                        CONF_CAMERAS_ARRAY_FRIGATE_CLIENT_ID,
                        cameraIndex,
                      ),
                    )}
                  `,
                )}
                ${this._putInSubmenu(
                  MENU_CAMERAS_MOTIONEYE,
                  cameraIndex,
                  'config.cameras.motioneye.editor_label',
                  'motioneye',
                  html` ${this._renderStringInput(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_MOTIONEYE_URL, cameraIndex),
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_MOTIONEYE_IMAGES_DIRECTORY_PATTERN,
                      cameraIndex,
                    ),
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_MOTIONEYE_IMAGES_FILE_PATTERN,
                      cameraIndex,
                    ),
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_MOTIONEYE_MOVIES_DIRECTORY_PATTERN,
                      cameraIndex,
                    ),
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_MOTIONEYE_MOVIES_FILE_PATTERN,
                      cameraIndex,
                    ),
                  )}`,
                )}
                ${this._putInSubmenu(
                  MENU_CAMERAS_REOLINK,
                  cameraIndex,
                  'config.cameras.reolink.editor_label',
                  'reolink',
                  html` ${this._renderStringInput(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_REOLINK_URL, cameraIndex),
                  )}
                  ${this._renderOptionSelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_REOLINK_MEDIA_RESOLUTION,
                      cameraIndex,
                    ),
                    this._reolinkMediaResolution,
                    {
                      label: localize(
                        'config.cameras.reolink.media_resolution.editor_label',
                      ),
                    },
                  )}`,
                )}`,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_LIVE_PROVIDER,
                true,
                'config.cameras.live_provider_options.editor_label',
                'mdi:cctv',
                html` ${this._putInSubmenu(
                  MENU_CAMERAS_GO2RTC,
                  cameraIndex,
                  'config.cameras.go2rtc.editor_label',
                  'mdi:alpha-g-circle',
                  html`${this._renderOptionSelector(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_GO2RTC_MODES, cameraIndex),
                    this._go2rtcModes,
                    {
                      multiple: true,
                      label: localize('config.cameras.go2rtc.modes.editor_label'),
                    },
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_GO2RTC_STREAM, cameraIndex),
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_GO2RTC_URL, cameraIndex),
                  )} `,
                )}
                ${this._putInSubmenu(
                  MENU_CAMERAS_IMAGE,
                  true,
                  'config.cameras.image.editor_label',
                  'mdi:image',
                  this._renderImageOptions(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_IMAGE_MODE, cameraIndex),
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_IMAGE_URL, cameraIndex),
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_IMAGE_ENTITY, cameraIndex),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_IMAGE_ENTITY_PARAMETERS,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_IMAGE_REFRESH_SECONDS,
                      cameraIndex,
                    ),
                  ),
                )}
                ${this._putInSubmenu(
                  MENU_CAMERAS_WEBRTC_CARD,
                  cameraIndex,
                  'config.cameras.webrtc_card.editor_label',
                  'mdi:webrtc',
                  html`${this._renderEntitySelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_WEBRTC_CARD_ENTITY,
                      cameraIndex,
                    ),
                    'camera',
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_WEBRTC_CARD_URL, cameraIndex),
                  )}`,
                )}`,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_DEPENDENCIES,
                cameraIndex,
                'config.cameras.dependencies.editor_label',
                'mdi:graph',
                html` ${this._renderSwitch(
                  getArrayConfigPath(
                    CONF_CAMERAS_ARRAY_DEPENDENCIES_ALL_CAMERAS,
                    cameraIndex,
                  ),
                  this._defaults.cameras.dependencies.all_cameras,
                )}
                ${this._renderOptionSelector(
                  getArrayConfigPath(
                    CONF_CAMERAS_ARRAY_DEPENDENCIES_CAMERAS,
                    cameraIndex,
                  ),
                  dependentCameras,
                  {
                    multiple: true,
                  },
                )}`,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_TRIGGERS,
                cameraIndex,
                'config.cameras.triggers.editor_label',
                'mdi:magnify-scan',
                html`
                  ${this._renderSwitch(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_TRIGGERS_OCCUPANCY,
                      cameraIndex,
                    ),
                    this._defaults.cameras.triggers.occupancy,
                  )}
                  ${this._renderSwitch(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_TRIGGERS_MOTION, cameraIndex),
                    this._defaults.cameras.triggers.motion,
                  )}
                  ${this._renderOptionSelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_TRIGGERS_ENTITIES,
                      cameraIndex,
                    ),
                    entities,
                    {
                      multiple: true,
                    },
                  )}
                  ${this._renderOptionSelector(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_TRIGGERS_EVENTS, cameraIndex),
                    this._triggersEvents,
                    {
                      multiple: true,
                      label: localize('config.cameras.triggers.events.editor_label'),
                    },
                  )}
                `,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_CAST,
                cameraIndex,
                'config.cameras.cast.editor_label',
                'mdi:cast',
                html`
                  ${this._renderOptionSelector(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_CAST_METHOD, cameraIndex),
                    this._castMethods,
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_CAST_DASHBOARD_DASHBOARD_PATH,
                      cameraIndex,
                    ),
                  )}
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_CAST_DASHBOARD_VIEW_PATH,
                      cameraIndex,
                    ),
                  )}
                `,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_DIMENSIONS,
                cameraIndex,
                'config.cameras.dimensions.editor_label',
                'mdi:aspect-ratio',
                html`
                  ${this._renderStringInput(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_ASPECT_RATIO,
                      cameraIndex,
                    ),
                  )}
                  ${this._renderMediaLayout(
                    MENU_CAMERAS_DIMENSIONS_LAYOUT,
                    'config.cameras.dimensions.layout.editor_label',
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_FIT,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_POSITION_X,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_POSITION_Y,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_TOP,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_BOTTOM,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_LEFT,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_VIEW_BOX_RIGHT,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_ZOOM_FACTOR,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_PAN_X,
                      cameraIndex,
                    ),
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_DIMENSIONS_LAYOUT_PAN_Y,
                      cameraIndex,
                    ),
                  )}
                `,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_CAPABILITIES,
                cameraIndex,
                'config.cameras.capabilities.editor_label',
                'mdi:cog-stop',
                html`
                  ${this._renderOptionSelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_CAPABILITIES_DISABLE,
                      cameraIndex,
                    ),
                    this._capabilities,
                    {
                      multiple: true,
                    },
                  )}
                  ${this._renderOptionSelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_CAPABILITIES_DISABLE_EXCEPT,
                      cameraIndex,
                    ),
                    this._capabilities,
                    {
                      multiple: true,
                    },
                  )}
                `,
              )}
              ${this._putInSubmenu(
                MENU_CAMERAS_PROXY,
                cameraIndex,
                'config.cameras.proxy.editor_label',
                'mdi:arrow-decision',
                html`
                  ${this._renderOptionSelector(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_PROXY_MEDIA, cameraIndex),
                    this._proxyMedia,
                    {
                      label: localize('config.cameras.proxy.media.editor_label'),
                    },
                  )}
                  ${this._renderSwitch(
                    getArrayConfigPath(CONF_CAMERAS_ARRAY_PROXY_DYNAMIC, cameraIndex),
                    this._defaults.cameras.proxy.dynamic,
                  )}
                  ${this._renderOptionSelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_PROXY_SSL_VERIFICATION,
                      cameraIndex,
                    ),
                    this._proxySSLVerification,
                    {
                      label: localize(
                        'config.cameras.proxy.ssl_verification.editor_label',
                      ),
                    },
                  )}
                  ${this._renderOptionSelector(
                    getArrayConfigPath(
                      CONF_CAMERAS_ARRAY_PROXY_SSL_CIPHERS,
                      cameraIndex,
                    ),
                    this._proxySSLCiphers,
                    {
                      label: localize('config.cameras.proxy.ssl_ciphers.editor_label'),
                    },
                  )}
                `,
              )}
            </div>`
          : ``}
      </div>
    `;
  }

  /**
   * Render a string input field.
   * @param configPath The configuration path to set/read.
   * @param type The allowable input
   * @returns A rendered template.
   */
  protected _renderStringInput(
    configPath: string,
    params?: {
      label?: string;
      type?:
        | 'number'
        | 'text'
        | 'search'
        | 'tel'
        | 'url'
        | 'email'
        | 'password'
        | 'date'
        | 'month'
        | 'week'
        | 'time'
        | 'datetime-local'
        | 'color';
    },
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }

    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{ text: { type: params?.type || 'text' } }}
        .label=${params?.label ?? this._getLabel(configPath)}
        .value=${getConfigValue(this._config, configPath, '')}
        .required=${false}
        @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
      >
      </ha-selector>
    `;
  }

  /**
   * Render a boolean selector.
   * @param configPath The configuration path to set/read.
   * @param valueDefault The default switch value if unset.
   * @param params Optional parameters to control the selector.
   * @returns A rendered template.
   */
  protected _renderSwitch(
    configPath: string,
    valueDefault: boolean,
    params?: {
      label?: string;
    },
  ): TemplateResult | void {
    if (!this._config) {
      return;
    }

    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{ boolean: {} }}
        .label=${params?.label || this._getLabel(configPath)}
        .value=${getConfigValue(this._config, configPath, valueDefault)}
        .required=${false}
        @value-changed=${(ev) => this._valueChangedHandler(configPath, ev)}
      >
      </ha-selector>
    `;
  }

  protected _updateConfig(config: RawAdvancedCameraCardConfig): void {
    this._config = config;
    fireHASSEvent(this, 'config-changed', { config: this._config });
  }

  protected render(): TemplateResult | void {
    if (!this.hass || !this._config) {
      return html``;
    }

    const entities = getEntitiesFromHASS(this.hass);
    const cameras = (getConfigValue(this._config, CONF_CAMERAS) ||
      []) as RawAdvancedCameraCardConfigArray;
    const folders = (getConfigValue(this._config, CONF_FOLDERS) ||
      []) as RawAdvancedCameraCardConfigArray;

    return html`
      ${this._configUpgradeable
        ? html` <div class="upgrade">
              <span>${localize('editor.upgrade_available')}</span>
              <span>
                <mwc-button
                  raised
                  label="${localize('editor.upgrade')}"
                  @click=${() => {
                    if (this._config) {
                      const upgradedConfig = copyConfig(this._config);
                      upgradeConfig(upgradedConfig);
                      this._updateConfig(upgradedConfig);
                    }
                  }}
                >
                </mwc-button>
              </span>
            </div>
            <br />`
        : html``}
      <div class="card-config">
        ${this._renderOptionSetHeader('cameras')}
        ${this._expandedMenus[MENU_OPTIONS] === 'cameras'
          ? html`
              <div class="values">
                ${cameras.map((_, index) =>
                  this._renderCamera(cameras, index, entities),
                )}
                ${this._renderCamera(cameras, cameras.length, entities, true)}
              </div>
            `
          : ''}
        ${this._renderOptionSetHeader('profiles')}
        ${this._expandedMenus[MENU_OPTIONS] === 'profiles'
          ? html` <div class="values">
              ${this._renderOptionSelector(CONF_PROFILES, this._profiles, {
                multiple: true,
                label: localize('config.profiles.editor_label'),
              })}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('view')}
        ${this._expandedMenus[MENU_OPTIONS] === 'view'
          ? html`
              <div class="values">
                ${this._renderOptionSelector(CONF_VIEW_DEFAULT, this._viewModes)}
                ${this._renderOptionSelector(
                  CONF_VIEW_CAMERA_SELECT,
                  this._cameraSelectViewModes,
                )}
                ${this._renderSwitch(CONF_VIEW_DIM, this._defaults.view.dim)}
                ${this._renderNumberInput(CONF_VIEW_INTERACTION_SECONDS)}
                ${this._renderSwitch(
                  CONF_VIEW_DEFAULT_CYCLE_CAMERA,
                  this._defaults.view.default_cycle_camera,
                )}
                ${this._renderViewDefaultResetMenu()} ${this._renderViewTriggersMenu()}
                ${this._renderViewKeyboardShortcutMenu()}
                ${this._renderOptionSelector(CONF_VIEW_THEME_THEMES, this._themes, {
                  label: localize('config.view.theme.themes.editor_label'),
                  multiple: true,
                })}
              </div>
            `
          : ''}
        ${this._renderOptionSetHeader('menu')}
        ${this._expandedMenus[MENU_OPTIONS] === 'menu'
          ? html`
              <div class="values">
                ${this._renderOptionSelector(CONF_MENU_STYLE, this._menuStyles)}
                ${this._renderOptionSelector(CONF_MENU_POSITION, this._menuPositions)}
                ${this._renderOptionSelector(CONF_MENU_ALIGNMENT, this._menuAlignments)}
                ${this._renderNumberInput(CONF_MENU_BUTTON_SIZE, {
                  min: BUTTON_SIZE_MIN,
                })}
                ${this._renderMenuButton('iris') /* */}
                ${this._renderMenuButton('cameras') /* */}
                ${this._renderMenuButton('substreams') /* */}
                ${this._renderMenuButton('live') /* */}
                ${this._renderMenuButton('clips') /* */}
                ${this._renderMenuButton('snapshots')}
                ${this._renderMenuButton('recordings')}
                ${this._renderMenuButton('folders')}
                ${this._renderMenuButton('image') /* */}
                ${this._renderMenuButton('download')}
                ${this._renderMenuButton('camera_ui')}
                ${this._renderMenuButton('fullscreen')}
                ${this._renderMenuButton('expand') /* */}
                ${this._renderMenuButton('timeline')}
                ${this._renderMenuButton('media_player')}
                ${this._renderMenuButton(
                  'microphone',
                  html`${this._renderOptionSelector(
                    `${CONF_MENU_BUTTONS}.microphone.type`,
                    this._microphoneButtonTypes,
                    { label: localize('config.menu.buttons.type') },
                  )}`,
                )}
                ${this._renderMenuButton('play') /*  */}
                ${this._renderMenuButton('mute') /*  */}
                ${this._renderMenuButton('screenshot')}
                ${this._renderMenuButton('display_mode')}
                ${this._renderMenuButton('ptz_controls')}
                ${this._renderMenuButton('ptz_home')}
              </div>
            `
          : ''}
        ${this._renderOptionSetHeader('status_bar')}
        ${this._expandedMenus[MENU_OPTIONS] === 'status_bar'
          ? html`
              <div class="values">
                ${this._renderOptionSelector(
                  CONF_STATUS_BAR_STYLE,
                  this._statusBarStyles,
                )}
                ${this._renderOptionSelector(
                  CONF_STATUS_BAR_POSITION,
                  this._statusBarPositions,
                )}
                ${this._renderNumberInput(CONF_STATUS_BAR_HEIGHT, {
                  min: STATUS_BAR_HEIGHT_MIN,
                  label: localize('config.status_bar.height'),
                })}
                ${this._renderNumberInput(CONF_STATUS_BAR_POPUP_SECONDS, {
                  min: 0,
                  max: 60,
                  default: this._defaults.status_bar.popup_seconds,
                  label: localize('config.status_bar.popup_seconds'),
                })}
                ${this._renderStatusBarItem('title') /* */}
                ${this._renderStatusBarItem('resolution') /* */}
                ${this._renderStatusBarItem('technology') /* */}
                ${this._renderStatusBarItem('engine') /* */}
              </div>
            `
          : ''}
        ${this._renderOptionSetHeader('live')}
        ${this._expandedMenus[MENU_OPTIONS] === 'live'
          ? html`
              <div class="values">
                ${this._renderSwitch(CONF_LIVE_PRELOAD, this._defaults.live.preload)}
                ${this._renderSwitch(CONF_LIVE_DRAGGABLE, this._defaults.live.draggable)}
                ${this._renderSwitch(CONF_LIVE_ZOOMABLE, this._defaults.live.zoomable)}
                ${this._renderSwitch(CONF_LIVE_LAZY_LOAD, this._defaults.live.lazy_load)}
                ${this._renderOptionSelector(
                  CONF_LIVE_LAZY_UNLOAD,
                  this._mediaActionNegativeConditions,
                  {
                    multiple: true,
                  },
                )}
                ${this._renderOptionSelector(
                  CONF_LIVE_AUTO_PLAY,
                  this._mediaActionPositiveConditions,
                  {
                    multiple: true,
                  },
                )}
                ${this._renderOptionSelector(
                  CONF_LIVE_AUTO_PAUSE,
                  this._mediaActionNegativeConditions,
                  {
                    multiple: true,
                  },
                )}
                ${this._renderOptionSelector(
                  CONF_LIVE_AUTO_MUTE,
                  this._mediaLiveMuteConditions,
                  {
                    multiple: true,
                  },
                )}
                ${this._renderOptionSelector(
                  CONF_LIVE_AUTO_UNMUTE,
                  this._mediaLiveUnmuteConditions,
                  {
                    multiple: true,
                  },
                )}
                ${this._renderOptionSelector(
                  CONF_LIVE_TRANSITION_EFFECT,
                  this._transitionEffects,
                )}
                ${this._renderSwitch(
                  CONF_LIVE_SHOW_IMAGE_DURING_LOAD,
                  this._defaults.live.show_image_during_load,
                )}
                ${this._renderViewDisplay(
                  MENU_LIVE_DISPLAY,
                  CONF_LIVE_DISPLAY_MODE,
                  CONF_LIVE_DISPLAY_GRID_SELECTED_POSITION,
                  CONF_LIVE_DISPLAY_GRID_SELECTED_WIDTH_FACTOR,
                  CONF_LIVE_DISPLAY_GRID_COLUMNS,
                  CONF_LIVE_DISPLAY_GRID_MAX_COLUMNS,
                )}
                ${this._putInSubmenu(
                  MENU_LIVE_CONTROLS,
                  true,
                  'config.live.controls.editor_label',
                  'mdi:gamepad',
                  html`
                    ${this._renderSwitch(
                      CONF_LIVE_CONTROLS_BUILTIN,
                      this._defaults.live.controls.builtin,
                      {
                        label: localize('config.common.controls.builtin'),
                      },
                    )}
                    ${this._renderNextPreviousControls(
                      MENU_LIVE_CONTROLS_NEXT_PREVIOUS,
                      CONF_LIVE_CONTROLS_NEXT_PREVIOUS_STYLE,
                      CONF_LIVE_CONTROLS_NEXT_PREVIOUS_SIZE,
                      {
                        allowIcons: true,
                      },
                    )}
                    ${this._renderThumbnailsControls(
                      MENU_LIVE_CONTROLS_THUMBNAILS,
                      CONF_LIVE_CONTROLS_THUMBNAILS_SIZE,
                      CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DETAILS,
                      CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
                      CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
                      CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
                      this._defaults.live.controls.thumbnails,
                      {
                        configPathMediaType: CONF_LIVE_CONTROLS_THUMBNAILS_MEDIA_TYPE,
                        configPathEventsMediaType:
                          CONF_LIVE_CONTROLS_THUMBNAILS_EVENTS_MEDIA_TYPE,
                        configPathMode: CONF_LIVE_CONTROLS_THUMBNAILS_MODE,
                      },
                    )}
                    ${this._renderMiniTimeline(
                      MENU_LIVE_CONTROLS_TIMELINE,
                      CONF_LIVE_CONTROLS_TIMELINE_MODE,
                      CONF_LIVE_CONTROLS_TIMELINE_STYLE,
                      CONF_LIVE_CONTROLS_TIMELINE_WINDOW_SECONDS,
                      CONF_LIVE_CONTROLS_TIMELINE_CLUSTERING_THRESHOLD,
                      CONF_LIVE_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
                      CONF_LIVE_CONTROLS_TIMELINE_SHOW_RECORDINGS,
                      CONF_LIVE_CONTROLS_TIMELINE_FORMAT_24H,
                      this._defaults.live.controls.timeline.show_recordings,
                      this._defaults.live.controls.timeline.format['24h'],
                      CONF_LIVE_CONTROLS_TIMELINE_PAN_MODE,
                    )}
                    ${this._putInSubmenu(
                      MENU_LIVE_CONTROLS_PTZ,
                      true,
                      'config.live.controls.ptz.editor_label',
                      'mdi:pan',
                      html`
                        ${this._renderOptionSelector(
                          CONF_LIVE_CONTROLS_PTZ_MODE,
                          this._ptzModes,
                        )}
                        ${this._renderOptionSelector(
                          CONF_LIVE_CONTROLS_PTZ_POSITION,
                          this._ptzPositions,
                        )}
                        ${this._renderOptionSelector(
                          CONF_LIVE_CONTROLS_PTZ_ORIENTATION,
                          this._ptzOrientations,
                        )}
                        ${this._renderSwitch(
                          CONF_LIVE_CONTROLS_PTZ_HIDE_PAN_TILT,
                          this._defaults.live.controls.ptz.hide_pan_tilt,
                          {
                            label: localize('config.live.controls.ptz.hide_pan_tilt'),
                          },
                        )}
                        ${this._renderSwitch(
                          CONF_LIVE_CONTROLS_PTZ_HIDE_ZOOM,
                          this._defaults.live.controls.ptz.hide_pan_tilt,
                          {
                            label: localize('config.live.controls.ptz.hide_zoom'),
                          },
                        )}
                        ${this._renderSwitch(
                          CONF_LIVE_CONTROLS_PTZ_HIDE_HOME,
                          this._defaults.live.controls.ptz.hide_home,
                          {
                            label: localize('config.live.controls.ptz.hide_home'),
                          },
                        )}
                      `,
                    )}
                  `,
                )}
                ${this._putInSubmenu(
                  MENU_LIVE_MICROPHONE,
                  true,
                  'config.live.microphone.editor_label',
                  'mdi:microphone',
                  html`
                    ${this._renderNumberInput(CONF_LIVE_MICROPHONE_DISCONNECT_SECONDS)}
                    ${this._renderSwitch(
                      CONF_LIVE_MICROPHONE_ALWAYS_CONNECTED,
                      this._defaults.live.microphone.always_connected,
                    )}
                    ${this._renderNumberInput(
                      CONF_LIVE_MICROPHONE_MUTE_AFTER_MICROPHONE_MUTE_SECONDS,
                    )}
                  `,
                )}
              </div>
            `
          : ''}
        ${this._renderOptionSetHeader('folders')}
        ${this._expandedMenus[MENU_OPTIONS] === 'folders'
          ? html` <div class="values">
              ${folders.map((_, index) => this._renderFolder(folders, index))}
              ${this._renderFolder(folders, folders.length, true)}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('media_gallery')}
        ${this._expandedMenus[MENU_OPTIONS] === 'media_gallery'
          ? html` <div class="values">
              ${this._renderThumbnailsControls(
                MENU_MEDIA_GALLERY_CONTROLS_THUMBNAILS,
                CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SIZE,
                CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DETAILS,
                CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
                CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
                CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
                this._defaults.media_gallery.controls.thumbnails,
              )}
              ${this._renderFilterControls(
                MENU_MEDIA_GALLERY_CONTROLS_FILTER,
                CONF_MEDIA_GALLERY_CONTROLS_FILTER_MODE,
              )}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('media_viewer')}
        ${this._expandedMenus[MENU_OPTIONS] === 'media_viewer'
          ? html` <div class="values">
              ${this._renderOptionSelector(
                CONF_MEDIA_VIEWER_AUTO_PLAY,
                this._mediaActionPositiveConditions,
                {
                  multiple: true,
                },
              )}
              ${this._renderOptionSelector(
                CONF_MEDIA_VIEWER_AUTO_PAUSE,
                this._mediaActionNegativeConditions,
                {
                  multiple: true,
                },
              )}
              ${this._renderOptionSelector(
                CONF_MEDIA_VIEWER_AUTO_MUTE,
                this._mediaActionNegativeConditions,
                {
                  multiple: true,
                },
              )}
              ${this._renderOptionSelector(
                CONF_MEDIA_VIEWER_AUTO_UNMUTE,
                this._mediaActionPositiveConditions,
                {
                  multiple: true,
                },
              )}
              ${this._renderSwitch(
                CONF_MEDIA_VIEWER_DRAGGABLE,
                this._defaults.media_viewer.draggable,
              )}
              ${this._renderSwitch(
                CONF_MEDIA_VIEWER_ZOOMABLE,
                this._defaults.media_viewer.zoomable,
              )}
              ${this._renderSwitch(
                CONF_MEDIA_VIEWER_LAZY_LOAD,
                this._defaults.media_viewer.lazy_load,
              )}
              ${this._renderOptionSelector(
                CONF_MEDIA_VIEWER_TRANSITION_EFFECT,
                this._transitionEffects,
              )}
              ${this._renderSwitch(
                CONF_MEDIA_VIEWER_SNAPSHOT_CLICK_PLAYS_CLIP,
                this._defaults.media_viewer.snapshot_click_plays_clip,
              )}
              ${this._renderViewDisplay(
                MENU_MEDIA_VIEWER_DISPLAY,
                CONF_MEDIA_VIEWER_DISPLAY_MODE,
                CONF_MEDIA_VIEWER_DISPLAY_GRID_SELECTED_POSITION,
                CONF_MEDIA_VIEWER_DISPLAY_GRID_SELECTED_WIDTH_FACTOR,
                CONF_MEDIA_VIEWER_DISPLAY_GRID_COLUMNS,
                CONF_MEDIA_VIEWER_DISPLAY_GRID_MAX_COLUMNS,
              )}
              ${this._putInSubmenu(
                MENU_MEDIA_VIEWER_CONTROLS,
                true,
                'config.media_viewer.controls.editor_label',
                'mdi:gamepad',
                html`
                  ${this._renderSwitch(
                    CONF_MEDIA_VIEWER_CONTROLS_BUILTIN,
                    this._defaults.media_viewer.controls.builtin,
                    {
                      label: localize('config.common.controls.builtin'),
                    },
                  )}
                  ${this._renderNextPreviousControls(
                    MENU_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS,
                    CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_STYLE,
                    CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_SIZE,
                    {
                      allowThumbnails: true,
                    },
                  )}
                  ${this._renderThumbnailsControls(
                    MENU_MEDIA_VIEWER_CONTROLS_THUMBNAILS,
                    CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SIZE,
                    CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DETAILS,
                    CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
                    CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
                    CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
                    this._defaults.media_viewer.controls.thumbnails,
                    {
                      configPathMode: CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_MODE,
                    },
                  )}
                  ${this._renderMiniTimeline(
                    MENU_MEDIA_VIEWER_CONTROLS_TIMELINE,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_MODE,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_STYLE,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_WINDOW_SECONDS,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_CLUSTERING_THRESHOLD,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_SHOW_RECORDINGS,
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_FORMAT_24H,
                    this._defaults.media_viewer.controls.timeline.show_recordings,
                    this._defaults.media_viewer.controls.timeline.format['24h'],
                    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_PAN_MODE,
                  )}
                `,
              )}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('image')}
        ${this._expandedMenus[MENU_OPTIONS] === 'image'
          ? html` <div class="values">
              ${this._renderImageOptions(
                CONF_IMAGE_MODE,
                CONF_IMAGE_URL,
                CONF_IMAGE_ENTITY,
                CONF_IMAGE_ENTITY_PARAMETERS,
                CONF_IMAGE_REFRESH_SECONDS,
              )}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('timeline')}
        ${this._expandedMenus[MENU_OPTIONS] === 'timeline'
          ? html` <div class="values">
              ${this._renderTimelineCoreControls(
                MENU_TIMELINE_FORMAT,
                CONF_TIMELINE_STYLE,
                CONF_TIMELINE_WINDOW_SECONDS,
                CONF_TIMELINE_CLUSTERING_THRESHOLD,
                CONF_TIMELINE_EVENTS_MEDIA_TYPE,
                CONF_TIMELINE_SHOW_RECORDINGS,
                CONF_TIMELINE_FORMAT_24H,
                this._defaults.timeline.show_recordings,
                this._defaults.timeline.format['24h'],
              )}
              ${this._renderThumbnailsControls(
                MENU_TIMELINE_CONTROLS_THUMBNAILS,
                CONF_TIMELINE_CONTROLS_THUMBNAILS_SIZE,
                CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DETAILS,
                CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
                CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
                CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
                this._defaults.timeline.controls.thumbnails,
                {
                  configPathMode: CONF_TIMELINE_CONTROLS_THUMBNAILS_MODE,
                },
              )}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('dimensions')}
        ${this._expandedMenus[MENU_OPTIONS] === 'dimensions'
          ? html` <div class="values">
              ${this._renderOptionSelector(
                CONF_DIMENSIONS_ASPECT_RATIO_MODE,
                this._aspectRatioModes,
              )}
              ${this._renderStringInput(CONF_DIMENSIONS_ASPECT_RATIO)}
              ${this._renderStringInput(CONF_DIMENSIONS_HEIGHT)}
            </div>`
          : ''}
        ${this._renderOptionSetHeader(
          'performance',
          getConfigValue(this._config, CONF_PERFORMANCE_PROFILE) === 'low'
            ? 'warning'
            : undefined,
        )}
        ${this._expandedMenus[MENU_OPTIONS] === 'performance'
          ? html` <div class="values">
              ${getConfigValue(this._config, CONF_PERFORMANCE_PROFILE) === 'low'
                ? this._renderInfo(localize('config.performance.warning'))
                : html``}
              ${this._putInSubmenu(
                MENU_PERFORMANCE_FEATURES,
                true,
                'config.performance.features.editor_label',
                'mdi:feature-search',
                html`
                  ${this._renderSwitch(
                    CONF_PERFORMANCE_FEATURES_CARD_LOADING_INDICATOR,
                    this._defaults.performance.features.card_loading_indicator,
                  )}
                  ${this._renderSwitch(
                    CONF_PERFORMANCE_FEATURES_ANIMATED_PROGRESS_INDICATOR,
                    this._defaults.performance.features.animated_progress_indicator,
                  )}
                  ${this._renderNumberInput(CONF_PERFORMANCE_FEATURES_MEDIA_CHUNK_SIZE, {
                    max: MEDIA_CHUNK_SIZE_MAX,
                  })}
                  ${this._renderNumberInput(
                    CONF_PERFORMANCE_FEATURES_MAX_SIMULTANEOUS_ENGINE_REQUESTS,
                    {
                      min: 1,
                    },
                  )}
                `,
              )}
              ${this._putInSubmenu(
                MENU_PERFORMANCE_STYLE,
                true,
                'config.performance.style.editor_label',
                'mdi:palette-swatch-variant',
                html`
                  ${this._renderSwitch(
                    CONF_PERFORMANCE_STYLE_BORDER_RADIUS,
                    this._defaults.performance.style.border_radius,
                  )}
                  ${this._renderSwitch(
                    CONF_PERFORMANCE_STYLE_BOX_SHADOW,
                    this._defaults.performance.style.box_shadow,
                  )}
                `,
              )}
            </div>`
          : ''}
        ${this._renderOptionSetHeader('remote_control')}
        ${this._expandedMenus[MENU_OPTIONS] === 'remote_control'
          ? html` <div class="values">
              ${this._putInSubmenu(
                MENU_REMOTE_CONTROL_ENTITIES,
                true,
                'config.remote_control.entities.editor_label',
                'mdi:devices',
                html`
                  ${this._renderEntitySelector(
                    CONF_REMOTE_CONTROL_ENTITIES_CAMERA,
                    'input_select',
                  )}
                `,
              )}
            </div>`
          : ''}
        ${this._config['overrides'] !== undefined
          ? html` ${this._renderOptionSetHeader('overrides')}
            ${this._expandedMenus[MENU_OPTIONS] === 'overrides'
              ? html` <div class="values">
                  ${this._renderInfo(localize('config.overrides.info'))}
                </div>`
              : ''}`
          : html``}
      </div>
    `;
  }

  /**
   * Close the editor menu with the given domain.
   * @param targetDomain The menu domain to close.
   */
  protected _closeMenu(targetDomain: string) {
    delete this._expandedMenus[targetDomain];
    this.requestUpdate();
  }

  /**
   * Open an editor menu.
   * @param targetDomain The menu domain to open.
   * @param key The menu object key to open.
   */
  protected _openMenu(targetDomain: string, key: number | string) {
    this._expandedMenus[targetDomain] = key;
    this.requestUpdate();
  }

  /**
   * Toggle an editor menu.
   * @param ev An event.
   */
  protected _toggleMenu(ev: { target: EditorMenuTarget | null }): void {
    if (ev && ev.target) {
      const domain = ev.target.domain;
      const key = ev.target.key;

      if (this._expandedMenus[domain] === key) {
        this._closeMenu(domain);
      } else {
        this._openMenu(domain, key);
      }
    }
  }

  /**
   * Handle a changed option value.
   * @param ev Event triggering the change.
   */
  protected _valueChangedHandler(
    key: string,
    ev: CustomEvent<{ value: unknown }>,
  ): void {
    if (!this._config || !this.hass) {
      return;
    }

    let value;
    if (ev.detail && ev.detail.value !== undefined) {
      value = ev.detail.value;
      if (typeof value === 'string') {
        value = value.trim();
      }
    }
    if (getConfigValue(this._config, key) === value) {
      return;
    }

    const newConfig = copyConfig(this._config);
    if (value === '' || value === undefined) {
      deleteConfigValue(newConfig, key);
    } else {
      setConfigValue(newConfig, key, value);
    }
    this._updateConfig(newConfig);
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(editorStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-editor': AdvancedCameraCardEditor;
  }
}



================================================
FILE: src/types.ts
================================================
import { z } from 'zod';
import { LovelaceCard, LovelaceCardConfig, LovelaceCardEditor } from './ha/types';

export type ClipsOrSnapshots = 'clips' | 'snapshots';
export type ClipsOrSnapshotsOrAll = 'clips' | 'snapshots' | 'all';

export class AdvancedCameraCardError extends Error {
  context?: unknown;

  constructor(message: string, context?: unknown) {
    super(message);
    this.context = context;
  }
}

export interface MediaLoadedCapabilities {
  supports2WayAudio?: boolean;
  supportsPause?: boolean;
  hasAudio?: boolean;
}

export type MediaTechnology =
  | 'hls'
  | 'jpg'
  | 'jsmpeg'
  | 'mjpeg'
  | 'mp4'
  | 'mse'
  | 'webrtc';

export interface MediaLoadedInfo {
  width: number;
  height: number;
  technology?: MediaTechnology[];

  mediaPlayerController?: MediaPlayerController;
  capabilities?: MediaLoadedCapabilities;
}

export type MessageType = 'info' | 'error' | 'connection' | 'diagnostics';
export interface MessageURL {
  link: string;
  title: string;
}

export interface Message {
  message: string;
  type?: MessageType;
  icon?: string;
  context?: unknown;
  dotdotdot?: boolean;
  url?: MessageURL;
}

export type WebkitHTMLVideoElement = HTMLVideoElement & {
  webkitDisplayingFullscreen: boolean;
  webkitSupportsFullscreen: boolean;
  webkitEnterFullscreen: () => void;
  webkitExitFullscreen: () => void;
};

export type FullscreenElement = HTMLElement;

export interface MediaPlayerController {
  play(): Promise<void>;
  pause(): Promise<void>;
  mute(): Promise<void>;
  unmute(): Promise<void>;
  isMuted(): boolean;
  seek(seconds: number): Promise<void>;
  getScreenshotURL(): Promise<string | null>;
  // If no value for controls if specified, the player should use the default.
  setControls(controls?: boolean): Promise<void>;
  isPaused(): boolean;
  getFullscreenElement(): FullscreenElement | null;
}

export interface MediaPlayer {
  getMediaPlayerController(): Promise<MediaPlayerController | null>;
}

export type MediaPlayerElement<T extends HTMLElement = HTMLElement> = T & MediaPlayer;

export type LovelaceCardWithEditor = LovelaceCard & {
  constructor: {
    getConfigElement(): Promise<LovelaceCardEditor>;
  };
};

export interface CardHelpers {
  createCardElement(config: LovelaceCardConfig): Promise<LovelaceCardWithEditor>;
}

export enum PTZMovementType {
  Relative = 'relative',
  Continuous = 'continuous',
}

export interface PTZCapabilities {
  left?: PTZMovementType[];
  right?: PTZMovementType[];
  up?: PTZMovementType[];
  down?: PTZMovementType[];
  zoomIn?: PTZMovementType[];
  zoomOut?: PTZMovementType[];

  presets?: string[];
}

export interface CapabilitiesRaw {
  live?: boolean;
  substream?: boolean;

  clips?: boolean;
  recordings?: boolean;
  snapshots?: boolean;

  'favorite-events'?: boolean;
  'favorite-recordings'?: boolean;

  'remote-control-entity'?: boolean;

  seek?: boolean;

  ptz?: PTZCapabilities;

  menu?: boolean;

  trigger?: boolean;
}

export type CapabilityKey = keyof CapabilitiesRaw;
export const capabilityKeys: readonly [CapabilityKey, ...CapabilityKey[]] = [
  'clips',
  'remote-control-entity',
  'favorite-events',
  'favorite-recordings',
  'live',
  'menu',
  'ptz',
  'recordings',
  'seek',
  'snapshots',
  'substream',
  'trigger',
] as const;

export interface Icon {
  // If set, this icon will be used.
  icon?: string;

  // If icon is not set, this entity's icon will be used (and HA will be asked
  // to render it).
  entity?: string;

  // Whether or not to change the icon color depending on entity state.
  stateColor?: boolean;

  // If an icon is not otherwise resolved / available, this will be used instead.
  fallback?: string;
}

export interface Interaction {
  action: string;
}

export interface Endpoint {
  endpoint: string;
  sign?: boolean;
}

export const signedPathSchema = z.object({
  path: z.string(),
});
export type SignedPath = z.infer<typeof signedPathSchema>;



================================================
FILE: src/cache/base.ts
================================================
import { CacheInterface } from './types.js';

export class CacheBase<Key, Value> implements CacheInterface<Key, Value> {
  private _cache: Map<Key, Value>;

  constructor(cache: Map<Key, Value>) {
    this._cache = cache;
  }

  /**
   * Determine if the cache has a given id.
   * @param key
   * @returns `true` if the id is in the cache, `false` otherwise.
   */
  public has(key: Key): boolean {
    return this._cache.has(key);
  }

  public entries(): MapIterator<[Key, Value]> {
    return this._cache.entries();
  }

  public delete(key: Key): boolean {
    return this._cache.delete(key);
  }

  public clear(): void {
    this._cache.clear();
  }

  /**
   * Get resolved media information given an id.
   * @param key The id.
   * @returns The `ResolvedMedia` for this id.
   */
  public get(key: Key): Value | null {
    return this._cache.get(key) ?? null;
  }

  public getMatches(predicate: (arg: Value) => boolean): Value[] {
    return [...this._cache.values()].filter(predicate);
  }

  /**
   * Add a given ResolvedMedia to the cache.
   * @param key The id for the object.
   * @param resolvedMedia The `ResolvedMedia` object.
   */
  public set(key: Key, val: Value): void {
    this._cache.set(key, val);
  }
}



================================================
FILE: src/cache/cache.ts
================================================
import { CacheBase } from './base';

export class Cache<Key, Value> extends CacheBase<Key, Value> {
  constructor() {
    super(new Map());
  }
}



================================================
FILE: src/cache/equality-cache.ts
================================================
import { CacheBase } from './base';
import { EqualityMap } from './equality-map';

export class EqualityCache<Key, Value> extends CacheBase<Key, Value> {
  constructor() {
    super(new EqualityMap());
  }
}



================================================
FILE: src/cache/equality-map.ts
================================================
import { isEqual } from 'lodash-es';

interface EqualityMapItem<Key, Value> {
  key: Key;
  value: Value;
}

/** A simple equality based map. This is not performant and should be used for
 * small datasets only.
 */
export class EqualityMap<Key, Value> implements Map<Key, Value> {
  private _data: EqualityMapItem<Key, Value>[] = [];

  get [Symbol.toStringTag](): string {
    return 'EqualityMap';
  }

  public has(key: Key): boolean {
    return !!this.get(key);
  }

  public get(searchKey: Key): Value | undefined {
    for (const pair of this._data) {
      if (isEqual(pair.key, searchKey)) {
        return pair.value;
      }
    }
    return undefined;
  }

  public set(key: Key, value: Value): this {
    this.delete(key);
    this._data.push({ key, value });
    return this;
  }

  public delete(searchKey: Key): boolean {
    for (let i = 0; i < this._data.length; i++) {
      if (isEqual(this._data[i].key, searchKey)) {
        this._data.splice(i, 1);
        return true;
      }
    }
    return false;
  }

  public clear(): void {
    this._data = [];
  }

  public *entries(): MapIterator<[Key, Value]> {
    for (const pair of this._data) {
      yield [pair.key, pair.value];
    }
  }

  public forEach(
    callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    thisArg?: any,
  ): void {
    for (const pair of this._data) {
      callbackfn.call(thisArg, pair.value, pair.key, this);
    }
  }

  public get size(): number {
    return this._data.length;
  }

  public [Symbol.iterator](): IterableIterator<[Key, Value]> {
    return this.entries();
  }
  public keys(): IterableIterator<Key> {
    return this._data.map((pair) => pair.key).values();
  }
  public values(): IterableIterator<Value> {
    return this._data.map((pair) => pair.value).values();
  }
}



================================================
FILE: src/cache/expiring-cache.ts
================================================
import { CacheInterface } from './types';
import { EqualityCache } from './equality-cache';

interface ExpiringValue<Value> {
  value: Value;
  expires?: Date;
}

export class ExpiringEqualityCache<Key, Value> implements CacheInterface<Key, Value> {
  protected _data: EqualityCache<Key, ExpiringValue<Value>> = new EqualityCache();

  public get(key: Key): Value | null {
    const value = this._data.get(key);
    const now = new Date();
    return value && (!value.expires || now <= value.expires) ? value.value : null;
  }

  public has(key: Key): boolean {
    return !!this.get(key);
  }

  public set(key: Key, value: Value, expiry?: Date): void {
    this._data.set(key, {
      value: value,
      expires: expiry,
    });

    // Clean up old requests on set.
    this._expireOldValues();
  }

  public delete(key: Key): boolean {
    return this._data.delete(key);
  }

  public clear(): void {
    this._data.clear();
  }

  public *entries(): MapIterator<[Key, Value]> {
    const now = new Date();
    for (const [key, value] of this._data.entries()) {
      if (!value.expires || now <= value.expires) {
        yield [key, value.value];
      }
    }
  }

  public getMatches(predicate: (value: Value) => boolean): Value[] {
    const out: Value[] = [];

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [_key, value] of this.entries()) {
      if (predicate(value)) {
        out.push(value);
      }
    }
    return out;
  }

  protected _expireOldValues(): void {
    const now = new Date();

    for (const [key, value] of this._data.entries()) {
      if (value.expires && now > value.expires) {
        this._data.delete(key);
      }
    }
  }
}



================================================
FILE: src/cache/lru.ts
================================================
import QuickLRU from 'quick-lru';
import { CacheBase } from './base';

export class LRUCache<Key, Value> extends CacheBase<Key, Value> {
  constructor(maxSize: number) {
    super(new QuickLRU({ maxSize }));
  }
}



================================================
FILE: src/cache/types.ts
================================================
export interface CacheInterface<K, V> {
  has(k: K): boolean;
  get(k: K): V | null;
  set(k: K, v: V): void;
  delete(k: K): boolean;
  clear(): void;
  entries(): MapIterator<[K, V]>;
  getMatches(predicate: (arg: V) => boolean): V[];
}



================================================
FILE: src/camera-manager/cache.ts
================================================
import { orderBy, sortedUniqBy } from 'lodash-es';
import { DateRange, MemoryRangeSet } from './range';
import { RecordingSegment } from './types';

class MemoryRangedCache<Data> {
  protected _ranges: MemoryRangeSet = new MemoryRangeSet();
  protected _data: Data[] = [];
  protected _timeFunc: (data: Data) => number;
  protected _idFunc: (data: Data) => string;

  constructor(timeFunc: (data: Data) => number, idFunc: (data: Data) => string) {
    this._timeFunc = timeFunc;
    this._idFunc = idFunc;
  }

  public add(range: DateRange, data: Data[]) {
    this._ranges.add(range);
    this._data = sortedUniqBy(
      orderBy(this._data.concat(data), this._timeFunc, 'asc'),
      this._idFunc,
    );
  }

  public hasCoverage(range: DateRange): boolean {
    return this._ranges.hasCoverage(range);
  }

  public get(range: DateRange): Data[] | null {
    if (!this.hasCoverage(range)) {
      return null;
    }

    const output: Data[] = [];
    for (const data of this._data) {
      const start = this._timeFunc(data);
      if (start >= range.start.getTime()) {
        if (start > range.end.getTime()) {
          // Data is kept in order.
          break;
        }
        output.push(data);
      }
    }
    return output;
  }

  public getSize(): number {
    return this._data.length;
  }

  /**
   * Remove old data that matches a given predicate. No change to the covered
   * ranges is made, i.e. this is asserting authoritiatively that this data does
   * not exist in the current ranges.
   * @param predicate A predicate to run on each data element.
   */
  public expireMatches(predicate: (data: Data) => boolean): void {
    this._data = this._data.filter((data) => !predicate(data));
  }
}

export class RecordingSegmentsCache {
  protected _segments: Map<string, MemoryRangedCache<RecordingSegment>> = new Map();

  public add(cameraID: string, range: DateRange, segments: RecordingSegment[]) {
    let cameraSegmentCache: MemoryRangedCache<RecordingSegment> | undefined =
      this._segments.get(cameraID);
    if (!cameraSegmentCache) {
      cameraSegmentCache = new MemoryRangedCache(
        (segment: RecordingSegment) => segment.start_time * 1000,
        (segment: RecordingSegment) => segment.id,
      );
      this._segments.set(cameraID, cameraSegmentCache);
    }
    cameraSegmentCache.add(range, segments);
  }

  public clear(): void {
    this._segments.clear();
  }

  public hasCoverage(cameraID: string, range: DateRange): boolean {
    return !!this._segments.get(cameraID)?.hasCoverage(range);
  }

  public get(cameraID: string, range: DateRange): RecordingSegment[] | null {
    return this._segments.get(cameraID)?.get(range) ?? null;
  }

  public getSize(cameraID: string): number | null {
    return this._segments.get(cameraID)?.getSize() ?? null;
  }

  public getCameraIDs(): string[] {
    return [...this._segments.keys()];
  }

  public expireMatches(
    cameraID: string,
    func: (segment: RecordingSegment) => boolean,
  ): void {
    this._segments.get(cameraID)?.expireMatches(func);
  }
}



================================================
FILE: src/camera-manager/camera.ts
================================================
import { ActionsExecutor } from '../card-controller/actions/types';
import { StateWatcherSubscriptionInterface } from '../card-controller/hass/state-watcher';
import { PTZAction, PTZActionPhase } from '../config/schema/actions/custom/ptz';
import { CameraConfig } from '../config/schema/cameras';
import { isTriggeredState } from '../ha/is-triggered-state';
import { HassStateDifference } from '../ha/types';
import { localize } from '../localize/localize';
import { Capabilities } from './capabilities';
import { CameraManagerEngine } from './engine';
import { CameraNoIDError } from './error';
import { CameraEventCallback, CameraProxyConfig } from './types';
import { getConfiguredPTZAction } from './utils/ptz';

export interface CameraInitializationOptions {
  stateWatcher: StateWatcherSubscriptionInterface;
}
type DestroyCallback = () => void | Promise<void>;

export class Camera {
  protected _config: CameraConfig;
  protected _engine: CameraManagerEngine;
  protected _capabilities?: Capabilities;
  protected _eventCallback?: CameraEventCallback;
  protected _destroyCallbacks: DestroyCallback[] = [];

  constructor(
    config: CameraConfig,
    engine: CameraManagerEngine,
    options?: {
      capabilities?: Capabilities;
      eventCallback?: CameraEventCallback;
    },
  ) {
    this._config = config;
    this._engine = engine;
    this._capabilities = options?.capabilities;
    this._eventCallback = options?.eventCallback;
  }

  async initialize(options: CameraInitializationOptions): Promise<Camera> {
    if (this._capabilities?.has('trigger')) {
      options.stateWatcher.subscribe(
        this._stateChangeHandler,
        this._config.triggers.entities,
      );
    }
    this._onDestroy(() => options.stateWatcher.unsubscribe(this._stateChangeHandler));
    return this;
  }

  public async destroy(): Promise<void> {
    this._destroyCallbacks.forEach((callback) => callback());
  }

  public getConfig(): CameraConfig {
    return this._config;
  }

  public setID(cameraID: string): void {
    this._config.id = cameraID;
  }

  public getID(): string {
    if (this._config.id) {
      return this._config.id;
    }
    throw new CameraNoIDError(localize('error.no_camera_id'));
  }

  public getEngine(): CameraManagerEngine {
    return this._engine;
  }

  public getCapabilities(): Capabilities | null {
    return this._capabilities ?? null;
  }

  public getProxyConfig(): CameraProxyConfig {
    return {
      dynamic: this._config.proxy.dynamic,
      media: this._config.proxy.media === 'auto' ? false : this._config.proxy.media,
      ssl_verification: this._config.proxy.ssl_verification !== false,
      ssl_ciphers:
        this._config.proxy.ssl_ciphers === 'auto'
          ? 'default'
          : this._config.proxy.ssl_ciphers,
    };
  }

  public async executePTZAction(
    executor: ActionsExecutor,
    action: PTZAction,
    options?: {
      phase?: PTZActionPhase;
      preset?: string;
    },
  ): Promise<boolean> {
    const configuredAction = getConfiguredPTZAction(this.getConfig(), action, options);
    if (configuredAction) {
      await executor.executeActions({ actions: configuredAction });
      return true;
    }
    return false;
  }

  protected _stateChangeHandler = (difference: HassStateDifference): void => {
    this._eventCallback?.({
      cameraID: this.getID(),
      type: isTriggeredState(difference.newState.state) ? 'new' : 'end',
    });
  };

  protected _onDestroy(callback: DestroyCallback): void {
    this._destroyCallbacks.push(callback);
  }
}



================================================
FILE: src/camera-manager/capabilities.ts
================================================
import {
  CapabilitiesRaw,
  CapabilityKey,
  capabilityKeys,
  PTZCapabilities,
} from '../types';
import { CapabilitySearchOptions } from './types';

export class Capabilities {
  private _capabilities: CapabilitiesRaw;

  constructor(
    capabilities: CapabilitiesRaw,
    options?: {
      disable?: CapabilityKey[];
      disableExcept?: CapabilityKey[];
    },
  ) {
    this._capabilities = capabilities;

    for (const key of options?.disable ?? []) {
      this._disable(key);
    }
    for (const key of capabilityKeys) {
      if (options?.disableExcept?.length && !options.disableExcept.includes(key)) {
        this._disable(key);
      }
    }
  }

  protected _disable(capability: CapabilityKey): void {
    delete this._capabilities[capability];
  }

  public matches(capability: CapabilitySearchOptions): boolean {
    let result = true;
    if (typeof capability === 'string') {
      result &&= this.has(capability);
    }
    if (typeof capability === 'object' && capability.allCapabilities) {
      result &&= capability.allCapabilities.every((capability) => this.has(capability));
    }
    if (typeof capability === 'object' && capability.anyCapabilities) {
      result &&= capability.anyCapabilities.some((capability) => this.has(capability));
    }
    return result;
  }

  public has(capability: CapabilityKey): boolean {
    return !!this._capabilities[capability];
  }

  public getPTZCapabilities(): PTZCapabilities | null {
    return this._capabilities.ptz ?? null;
  }

  public hasPTZCapability(): boolean {
    return !!(
      this._capabilities.ptz?.down?.length ||
      this._capabilities.ptz?.up?.length ||
      this._capabilities.ptz?.left?.length ||
      this._capabilities.ptz?.right?.length ||
      this._capabilities.ptz?.zoomIn?.length ||
      this._capabilities.ptz?.zoomOut?.length ||
      this._capabilities.ptz?.presets?.length
    );
  }

  public getRawCapabilities(): CapabilitiesRaw {
    return this._capabilities;
  }
}



================================================
FILE: src/camera-manager/engine-factory.ts
================================================
import { StateWatcherSubscriptionInterface } from '../card-controller/hass/state-watcher';
import { CameraConfig } from '../config/schema/cameras';
import { BrowseMediaWalker } from '../ha/browse-media/walker';
import { EntityRegistryManager } from '../ha/registry/entity/types';
import { ResolvedMediaCache } from '../ha/resolved-media';
import { HomeAssistant } from '../ha/types';
import { localize } from '../localize/localize';
import { RecordingSegmentsCache } from './cache';
import { CameraManagerEngine } from './engine';
import { CameraInitializationError } from './error';
import { CameraEventCallback, CameraManagerRequestCache, Engine } from './types';
import { getCameraEntityFromConfig } from './utils/camera-entity-from-config';

interface CameraManagerEngineFactoryOptions {
  stateWatcher: StateWatcherSubscriptionInterface;
  resolvedMediaCache: ResolvedMediaCache;
  eventCallback?: CameraEventCallback;
}

export class CameraManagerEngineFactory {
  // Entity registry manager is required for the actual function of the factory.
  protected _entityRegistryManager: EntityRegistryManager;

  constructor(entityRegistryManager: EntityRegistryManager) {
    this._entityRegistryManager = entityRegistryManager;
  }

  public async createEngine(
    engine: Engine,
    options: CameraManagerEngineFactoryOptions,
  ): Promise<CameraManagerEngine> {
    let cameraManagerEngine: CameraManagerEngine;
    switch (engine) {
      case Engine.Generic:
        const { GenericCameraManagerEngine } = await import('./generic/engine-generic');
        cameraManagerEngine = new GenericCameraManagerEngine(
          options.stateWatcher,
          options.eventCallback,
        );
        break;
      case Engine.Frigate:
        const { FrigateCameraManagerEngine } = await import('./frigate/engine-frigate');
        cameraManagerEngine = new FrigateCameraManagerEngine(
          this._entityRegistryManager,
          options.stateWatcher,
          new RecordingSegmentsCache(),
          new CameraManagerRequestCache(),
          options.eventCallback,
        );
        break;
      case Engine.MotionEye:
        const { MotionEyeCameraManagerEngine } = await import(
          './motioneye/engine-motioneye'
        );
        cameraManagerEngine = new MotionEyeCameraManagerEngine(
          this._entityRegistryManager,
          options.stateWatcher,
          new BrowseMediaWalker(),
          options.resolvedMediaCache,
          new CameraManagerRequestCache(),
          options.eventCallback,
        );
        break;
      case Engine.Reolink:
        const { ReolinkCameraManagerEngine } = await import('./reolink/engine-reolink');
        cameraManagerEngine = new ReolinkCameraManagerEngine(
          this._entityRegistryManager,
          options.stateWatcher,
          new BrowseMediaWalker(),
          options.resolvedMediaCache,
          new CameraManagerRequestCache(),
          options.eventCallback,
        );
    }
    return cameraManagerEngine;
  }

  public async getEngineForCamera(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): Promise<Engine | null> {
    let engine: Engine | null = null;
    if (cameraConfig.engine === 'frigate') {
      engine = Engine.Frigate;
    } else if (cameraConfig.engine === 'motioneye') {
      engine = Engine.MotionEye;
    } else if (cameraConfig.engine === 'generic') {
      engine = Engine.Generic;
    } else if (cameraConfig.engine === 'reolink') {
      engine = Engine.Reolink;
    } else {
      const cameraEntity = getCameraEntityFromConfig(cameraConfig);

      if (cameraEntity) {
        const entity = await this._entityRegistryManager.getEntity(hass, cameraEntity);
        if (!entity) {
          // If the camera is not in the registry, but is in the HA states it is
          // assumed to be a generic camera.
          if (hass.states[cameraEntity]) {
            return Engine.Generic;
          }
          // Otherwise, it's probably a typo so throw an exception.
          throw new CameraInitializationError(
            localize('error.no_camera_entity'),
            cameraConfig,
          );
        }

        switch (entity?.platform) {
          case 'frigate':
            engine = Engine.Frigate;
            break;
          case 'motioneye':
            engine = Engine.MotionEye;
            break;
          case 'reolink':
            engine = Engine.Reolink;
            break;
          default:
            engine = Engine.Generic;
        }
      } else if (cameraConfig.frigate.camera_name) {
        // Frigate technically does not need an entity, if the camera name is
        // manually set the camera is assumed to be Frigate.
        engine = Engine.Frigate;
      } else if (
        cameraConfig.webrtc_card?.url ||
        (cameraConfig.go2rtc?.url && cameraConfig.go2rtc?.stream)
      ) {
        engine = Engine.Generic;
      }
    }

    return engine;
  }
}



================================================
FILE: src/camera-manager/engine.ts
================================================
import { CameraConfig } from '../config/schema/cameras';
import { HomeAssistant } from '../ha/types';
import { Endpoint } from '../types';
import { ViewMedia } from '../view/item';
import { ViewItemCapabilities } from '../view/types';
import { Camera } from './camera';
import { CameraManagerReadOnlyConfigStore } from './store';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraManagerCameraMetadata,
  CameraQuery,
  Engine,
  EngineOptions,
  EventQuery,
  EventQueryResultsMap,
  MediaMetadataQuery,
  MediaMetadataQueryResultsMap,
  PartialEventQuery,
  PartialRecordingQuery,
  PartialRecordingSegmentsQuery,
  QueryReturnType,
  RecordingQuery,
  RecordingQueryResultsMap,
  RecordingSegmentsQuery,
  RecordingSegmentsQueryResultsMap,
} from './types';

export const CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT = 10000;

export interface CameraManagerEngine {
  getEngineType(): Engine;

  createCamera(hass: HomeAssistant, cameraConfig: CameraConfig): Promise<Camera>;

  generateDefaultEventQuery(
    store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query: PartialEventQuery,
  ): EventQuery[] | null;

  generateDefaultRecordingQuery(
    store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query: PartialRecordingQuery,
  ): RecordingQuery[] | null;

  generateDefaultRecordingSegmentsQuery(
    store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query: PartialRecordingSegmentsQuery,
  ): RecordingSegmentsQuery[] | null;

  getEvents(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: EventQuery,
    engineOptions?: EngineOptions,
  ): Promise<EventQueryResultsMap | null>;

  getRecordings(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: RecordingQuery,
    engineOptions?: EngineOptions,
  ): Promise<RecordingQueryResultsMap | null>;

  getRecordingSegments(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: RecordingSegmentsQuery,
    engineOptions?: EngineOptions,
  ): Promise<RecordingSegmentsQueryResultsMap | null>;

  generateMediaFromEvents(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: EventQuery,
    results: QueryReturnType<EventQuery>,
  ): ViewMedia[] | null;

  generateMediaFromRecordings(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: RecordingQuery,
    results: QueryReturnType<RecordingQuery>,
  ): ViewMedia[] | null;

  getMediaDownloadPath(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
    media: ViewMedia,
  ): Promise<Endpoint | null>;

  favoriteMedia(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
    media: ViewMedia,
    favorite: boolean,
  ): Promise<void>;

  getQueryResultMaxAge(query: CameraQuery): number | null;

  getMediaSeekTime(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    media: ViewMedia,
    target: Date,
    engineOptions?: EngineOptions,
  ): Promise<number | null>;

  getMediaMetadata(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: MediaMetadataQuery,
    engineOptions?: EngineOptions,
  ): Promise<MediaMetadataQueryResultsMap | null>;

  getCameraMetadata(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): CameraManagerCameraMetadata;

  getMediaCapabilities(media: ViewMedia): ViewItemCapabilities | null;

  getCameraEndpoints(
    cameraConfig: CameraConfig,
    context?: CameraEndpointsContext,
  ): CameraEndpoints | null;
}



================================================
FILE: src/camera-manager/error.ts
================================================
import { AdvancedCameraCardError } from '../types.js';

export class CameraInitializationError extends AdvancedCameraCardError {}
export class CameraNoIDError extends AdvancedCameraCardError {}



================================================
FILE: src/camera-manager/manager.ts
================================================
import { add } from 'date-fns';
import { cloneDeep, sum } from 'lodash-es';
import PQueue from 'p-queue';
import { CardCameraAPI } from '../card-controller/types.js';
import { sortItems } from '../card-controller/view/sort.js';
import { PTZAction, PTZActionPhase } from '../config/schema/actions/custom/ptz.js';
import { CameraConfig, CamerasConfig } from '../config/schema/cameras.js';
import { MEDIA_CHUNK_SIZE_DEFAULT } from '../const.js';
import { localize } from '../localize/localize.js';
import { Endpoint } from '../types.js';
import {
  allPromises,
  arrayify,
  isTruthy,
  recursivelyMergeObjectsNotArrays,
  setify,
} from '../utils/basic.js';
import { getCameraID } from '../utils/camera.js';
import { log } from '../utils/debug.js';
import { ViewItemClassifier } from '../view/item-classifier.js';
import { ViewItem, ViewMedia } from '../view/item.js';
import { ViewItemCapabilities } from '../view/types.js';
import { Capabilities } from './capabilities.js';
import { CameraManagerEngineFactory } from './engine-factory.js';
import { CameraManagerEngine } from './engine.js';
import { CameraInitializationError } from './error.js';
import { CameraManagerReadOnlyConfigStore, CameraManagerStore } from './store.js';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraManagerCameraMetadata,
  CameraQuery,
  Engine,
  EngineOptions,
  EventQuery,
  EventQueryResults,
  EventQueryResultsMap,
  MediaMetadata,
  MediaMetadataQuery,
  MediaMetadataQueryResults,
  MediaQuery,
  PartialCameraQuery,
  PartialEventQuery,
  PartialQueryConcreteType,
  PartialRecordingQuery,
  PartialRecordingSegmentsQuery,
  QueryResults,
  QueryResultsType,
  QueryReturnType,
  QueryType,
  RecordingQuery,
  RecordingQueryResults,
  RecordingQueryResultsMap,
  RecordingSegmentsQuery,
  RecordingSegmentsQueryResults,
  RecordingSegmentsQueryResultsMap,
  ResultsMap,
} from './types.js';

export class CameraQueryClassifier {
  public static isEventQuery(
    query: CameraQuery | PartialCameraQuery,
  ): query is EventQuery {
    return query.type === QueryType.Event;
  }
  public static isRecordingQuery(
    query: CameraQuery | PartialCameraQuery,
  ): query is RecordingQuery {
    return query.type === QueryType.Recording;
  }
  public static isRecordingSegmentsQuery(
    query: CameraQuery | PartialCameraQuery,
  ): query is RecordingSegmentsQuery {
    return query.type === QueryType.RecordingSegments;
  }
  public static isMediaMetadataQuery(
    query: CameraQuery | PartialCameraQuery,
  ): query is MediaMetadataQuery {
    return query.type === QueryType.MediaMetadata;
  }
}

export class QueryResultClassifier {
  public static isEventQueryResult(
    queryResults: QueryResults,
  ): queryResults is EventQueryResults {
    return queryResults.type === QueryResultsType.Event;
  }
  public static isRecordingQueryResult(
    queryResults: QueryResults,
  ): queryResults is RecordingQueryResults {
    return queryResults.type === QueryResultsType.Recording;
  }
  public static isRecordingSegmentsQueryResult(
    queryResults: QueryResults,
  ): queryResults is RecordingSegmentsQueryResults {
    return queryResults.type === QueryResultsType.RecordingSegments;
  }
  public static isMediaMetadataQueryResult(
    queryResults: QueryResults,
  ): queryResults is MediaMetadataQueryResults {
    return queryResults.type === QueryResultsType.MediaMetadata;
  }
}

export interface ExtendedMediaQueryResult<T extends MediaQuery> {
  queries: T[];
  results: ViewItem[];
}

export class CameraManager {
  protected _api: CardCameraAPI;
  protected _engineFactory: CameraManagerEngineFactory;
  protected _store: CameraManagerStore;
  protected _requestLimit = new PQueue();

  constructor(
    api: CardCameraAPI,
    options?: {
      store?: CameraManagerStore;
      factory?: CameraManagerEngineFactory;
    },
  ) {
    this._api = api;
    this._engineFactory =
      options?.factory ??
      new CameraManagerEngineFactory(this._api.getEntityRegistryManager());
    this._store = options?.store ?? new CameraManagerStore();
  }

  public async initializeCamerasFromConfig(): Promise<boolean> {
    const config = this._api.getConfigManager().getConfig();
    const hass = this._api.getHASSManager().getHASS();

    if (!config || !hass) {
      return false;
    }

    this._requestLimit.concurrency =
      config.performance.features.max_simultaneous_engine_requests ?? Infinity;

    // For each camera merge the config (which has no defaults) into the camera
    // global config (which does have defaults). The merging must happen in this
    // order, to ensure that the defaults in the cameras global config do not
    // override the values specified in the per-camera config.
    const cameras = config.cameras.map((camera) =>
      recursivelyMergeObjectsNotArrays({}, cloneDeep(config?.cameras_global), camera),
    );

    try {
      await this._initializeCameras(cameras);
    } catch (e: unknown) {
      this._api
        .getMessageManager()
        .setErrorIfHigherPriority(e, localize('error.camera_initialization'));
      return false;
    }
    return true;
  }

  public async destroy(): Promise<void> {
    await this._store.reset();
  }

  protected async _getEnginesForCameras(
    camerasConfig: CamerasConfig,
  ): Promise<Map<CameraConfig, CameraManagerEngine>> {
    const output: Map<CameraConfig, CameraManagerEngine> = new Map();
    const engines: Map<Engine, CameraManagerEngine> = new Map();
    const hass = this._api.getHASSManager().getHASS();

    /* istanbul ignore if: the if path cannot be reached -- @preserve */
    if (!hass) {
      return output;
    }

    const getEngineTypes = async (configs: CameraConfig[]) => {
      return await allPromises(configs, (config) =>
        this._engineFactory.getEngineForCamera(hass, config),
      );
    };

    const engineTypes = await getEngineTypes(camerasConfig);
    for (const [index, cameraConfig] of camerasConfig.entries()) {
      const engineType = engineTypes[index];
      const engine = engineType
        ? engines.get(engineType) ??
          (await this._engineFactory.createEngine(engineType, {
            eventCallback: (ev) => this._api.getTriggersManager().handleCameraEvent(ev),
            stateWatcher: this._api.getHASSManager().getStateWatcher(),
            resolvedMediaCache: this._api.getResolvedMediaCache(),
          }))
        : null;
      if (!engine || !engineType) {
        throw new CameraInitializationError(
          localize('error.no_camera_engine'),
          // Camera initialization may modify the configuration. Keep the
          // original config unchanged.
          cloneDeep(cameraConfig),
        );
      }
      engines.set(engineType, engine);
      output.set(cameraConfig, engine);
    }
    return output;
  }

  protected async _initializeCameras(camerasConfig: CamerasConfig): Promise<void> {
    const initializationStartTime = new Date();
    const hass = this._api.getHASSManager().getHASS();

    /* istanbul ignore if: the if path cannot be reached -- @preserve */
    if (!hass) {
      return;
    }

    const hasAutoTriggers = (config: CameraConfig): boolean => {
      return config.triggers.motion || config.triggers.occupancy;
    };

    if (
      // If any camera requires automatic trigger detection ...
      camerasConfig.some((config) => hasAutoTriggers(config))
    ) {
      // ... then we need to populate the entity cache by fetching all entities
      // from Home Assistant. Attempt to do this once upfront, to avoid each
      // camera doing needing to fetch entity state.
      await this._api.getEntityRegistryManager().fetchEntityList(hass);
    }

    // Engines are created sequentially, to avoid duplicate creation of the same
    // engine. See: https://github.com/dermotduffy/advanced-camera-card/issues/941
    const engineByConfig = await this._getEnginesForCameras(camerasConfig);

    // Configuration is initialized in parallel.
    const cameras = await allPromises(
      engineByConfig.entries(),
      async ([cameraConfig, engine]) => await engine.createCamera(hass, cameraConfig),
    );

    const destroyCameras = async () => {
      cameras.forEach((camera) => camera.destroy());
    };
    const cameraIDs: Set<string> = new Set();

    // Do the additions based off the result-order, to ensure the map order is
    // preserved.
    for (const camera of cameras) {
      const cameraID = getCameraID(camera.getConfig());

      if (!cameraID) {
        await destroyCameras();
        throw new CameraInitializationError(
          localize('error.no_camera_id'),
          camera.getConfig(),
        );
      }

      if (cameraIDs.has(cameraID)) {
        await destroyCameras();
        throw new CameraInitializationError(
          localize('error.duplicate_camera_id'),
          camera.getConfig(),
        );
      }

      // Always ensure the actual ID used in the card is in the configuration itself.
      camera.setID(cameraID);
      cameraIDs.add(cameraID);
    }

    await this._store.setCameras(cameras);

    log(
      this._api.getConfigManager().getCardWideConfig(),
      'Advanced Camera Card CameraManager initialized (Cameras: ',
      this._store.getCameras(),
      `, Duration: ${
        (new Date().getTime() - initializationStartTime.getTime()) / 1000
      }s,`,
      ')',
    );
  }

  public isInitialized(): boolean {
    return this._store.getCameraCount() > 0;
  }

  public getStore(): CameraManagerReadOnlyConfigStore {
    return this._store;
  }

  public generateDefaultEventQueries(
    cameraIDs: string | Set<string>,
    partialQuery?: PartialEventQuery,
  ): EventQuery[] | null {
    return this._generateDefaultQueries(cameraIDs, {
      type: QueryType.Event,
      ...partialQuery,
    });
  }

  public generateDefaultRecordingQueries(
    cameraIDs: string | Set<string>,
    partialQuery?: PartialRecordingQuery,
  ): RecordingQuery[] | null {
    return this._generateDefaultQueries(cameraIDs, {
      type: QueryType.Recording,
      ...partialQuery,
    });
  }

  public generateDefaultRecordingSegmentsQueries(
    cameraIDs: string | Set<string>,
    partialQuery?: PartialRecordingSegmentsQuery,
  ): RecordingSegmentsQuery[] | null {
    return this._generateDefaultQueries(cameraIDs, {
      type: QueryType.RecordingSegments,
      ...partialQuery,
    });
  }

  protected _generateDefaultQueries<PQT extends PartialCameraQuery>(
    cameraIDs: string | Set<string>,
    partialQuery: PQT,
  ): PartialQueryConcreteType<PQT>[] | null {
    const concreteQueries: PartialQueryConcreteType<PQT>[] = [];
    const _cameraIDs = setify(cameraIDs);
    const engines = this._store.getEnginesForCameraIDs(_cameraIDs);
    if (!engines) {
      return null;
    }

    for (const [engine, cameraIDs] of engines) {
      let queries: CameraQuery[] | null = null;
      /* istanbul ignore else: the else path cannot be reached -- @preserve */
      if (CameraQueryClassifier.isEventQuery(partialQuery)) {
        queries = engine.generateDefaultEventQuery(this._store, cameraIDs, partialQuery);
      } else if (CameraQueryClassifier.isRecordingQuery(partialQuery)) {
        queries = engine.generateDefaultRecordingQuery(
          this._store,
          cameraIDs,
          partialQuery,
        );
      } else if (CameraQueryClassifier.isRecordingSegmentsQuery(partialQuery)) {
        queries = engine.generateDefaultRecordingSegmentsQuery(
          this._store,
          cameraIDs,
          partialQuery,
        );
      }

      for (const query of queries ?? []) {
        concreteQueries.push(query as PartialQueryConcreteType<PQT>);
      }
    }
    return concreteQueries.length ? concreteQueries : null;
  }

  public async getMediaMetadata(): Promise<MediaMetadata | null> {
    const tags: Set<string> = new Set();
    const what: Set<string> = new Set();
    const where: Set<string> = new Set();
    const days: Set<string> = new Set();

    const query: MediaMetadataQuery = {
      type: QueryType.MediaMetadata,
      cameraIDs: this._store.getCameraIDs(),
    };

    const results = await this._handleQuery(query);

    for (const result of results.values()) {
      if (result.metadata.tags) {
        result.metadata.tags.forEach(tags.add, tags);
      }
      if (result.metadata.what) {
        result.metadata.what.forEach(what.add, what);
      }
      if (result.metadata.where) {
        result.metadata.where.forEach(where.add, where);
      }
      if (result.metadata.days) {
        result.metadata.days.forEach(days.add, days);
      }
    }

    if (!what.size && !where.size && !days.size && !tags.size) {
      return null;
    }
    return {
      ...(tags.size && { tags: tags }),
      ...(what.size && { what: what }),
      ...(where.size && { where: where }),
      ...(days.size && { days: days }),
    };
  }

  public async getEvents(
    query: EventQuery | EventQuery[],
    engineOptions?: EngineOptions,
  ): Promise<EventQueryResultsMap> {
    return await this._handleQuery(query, engineOptions);
  }

  public async getRecordings(
    query: RecordingQuery | RecordingQuery[],
    engineOptions?: EngineOptions,
  ): Promise<RecordingQueryResultsMap> {
    return await this._handleQuery(query, engineOptions);
  }

  public async getRecordingSegments(
    query: RecordingSegmentsQuery | RecordingSegmentsQuery[],
    engineOptions?: EngineOptions,
  ): Promise<RecordingSegmentsQueryResultsMap> {
    return await this._handleQuery(query, engineOptions);
  }

  public async executeMediaQueries<T extends MediaQuery>(
    queries: T[],
    engineOptions?: EngineOptions,
  ): Promise<ViewMedia[] | null> {
    return this._convertQueryResultsToMedia(
      await this._handleQuery(queries, engineOptions),
    );
  }

  public async extendMediaQueries<T extends MediaQuery>(
    queries: T[],
    results: ViewItem[],
    direction: 'earlier' | 'later',
    engineOptions?: EngineOptions,
  ): Promise<ExtendedMediaQueryResult<T> | null> {
    const hass = this._api.getHASSManager().getHASS();
    if (!hass) {
      return null;
    }

    const getTimeFromResults = (want: 'earliest' | 'latest'): Date | null => {
      let output: Date | null = null;
      for (const result of results) {
        if (!ViewItemClassifier.isMedia(result)) {
          continue;
        }
        const startTime = result.getStartTime();
        if (
          startTime &&
          (!output ||
            (want === 'earliest' && startTime < output) ||
            (want === 'latest' && startTime > output))
        ) {
          output = startTime;
        }
      }
      return output;
    };

    const chunkSize =
      this._api.getConfigManager().getCardWideConfig()?.performance?.features
        .media_chunk_size ?? MEDIA_CHUNK_SIZE_DEFAULT;

    // The queries associated with the chunk to fetch.
    const newChunkQueries: T[] = [];

    // The re-constituted combined query.
    const extendedQueries: T[] = [];

    for (const query of queries) {
      const newChunkQuery = { ...query };

      /* istanbul ignore else: the else path cannot be reached -- @preserve */
      if (direction === 'later') {
        const latestResult = getTimeFromResults('latest');
        if (latestResult) {
          newChunkQuery.start = latestResult;
          delete newChunkQuery.end;
        }
      } else if (direction === 'earlier') {
        const earliestResult = getTimeFromResults('earliest');
        if (earliestResult) {
          newChunkQuery.end = earliestResult;
          delete newChunkQuery.start;
        }
      }
      newChunkQuery.limit = chunkSize;

      extendedQueries.push({
        ...query,
        limit: (query.limit ?? 0) + chunkSize,
      });
      newChunkQueries.push(newChunkQuery);
    }

    const newChunkMedia = this._convertQueryResultsToMedia(
      await this._handleQuery(newChunkQueries, engineOptions),
    );

    if (!newChunkMedia.length) {
      return null;
    }

    const outputMedia = sortItems(results.concat(newChunkMedia));

    // If the media did not _ACTUALLY_ get longer, there is no new media despite
    // the increased limit, so just return null.
    if (outputMedia.length === results.length) {
      return null;
    }

    return {
      queries: extendedQueries,
      results: outputMedia,
    };
  }

  public async getMediaDownloadPath(media: ViewMedia): Promise<Endpoint | null> {
    const cameraConfig = this._store.getCameraConfigForMedia(media);
    const engine = this._store.getEngineForMedia(media);
    const hass = this._api.getHASSManager().getHASS();

    if (!cameraConfig || !engine || !hass) {
      return null;
    }
    return await engine.getMediaDownloadPath(hass, cameraConfig, media);
  }

  public getMediaCapabilities(media: ViewMedia): ViewItemCapabilities | null {
    const engine = this._store.getEngineForMedia(media);
    if (!engine) {
      return null;
    }
    return engine.getMediaCapabilities(media);
  }

  public async favoriteMedia(media: ViewMedia, favorite: boolean): Promise<void> {
    const cameraConfig = this._store.getCameraConfigForMedia(media);
    const engine = this._store.getEngineForMedia(media);
    const hass = this._api.getHASSManager().getHASS();

    if (!cameraConfig || !engine || !hass) {
      return;
    }

    const queryStartTime = new Date();

    await this._requestLimit.add(() =>
      engine.favoriteMedia(hass, cameraConfig, media, favorite),
    );

    log(
      this._api.getConfigManager().getCardWideConfig(),
      'Advanced Camera Card CameraManager favorite request (',
      `Duration: ${(new Date().getTime() - queryStartTime.getTime()) / 1000}s,`,
      'Media:',
      media.getID(),
      ', Favorite:',
      favorite,
      ')',
    );
  }

  public areMediaQueriesResultsFresh<T extends MediaQuery>(
    queries: T[],
    resultsTimestamp: Date,
  ): boolean {
    const now = new Date();

    for (const query of queries) {
      const engines = this._store.getEnginesForCameraIDs(query.cameraIDs);
      for (const [engine, cameraIDs] of engines ?? []) {
        const maxAgeSeconds = engine.getQueryResultMaxAge({
          ...query,
          cameraIDs: cameraIDs,
        });
        if (
          maxAgeSeconds !== null &&
          add(resultsTimestamp, { seconds: maxAgeSeconds }) < now
        ) {
          return false;
        }
      }
    }
    return true;
  }

  public async getMediaSeekTime(media: ViewMedia, target: Date): Promise<number | null> {
    const startTime = media.getStartTime();
    const endTime = media.getEndTime();
    const engine = this._store.getEngineForMedia(media);
    const hass = this._api.getHASSManager().getHASS();

    if (
      !hass ||
      !engine ||
      !startTime ||
      !endTime ||
      target < startTime ||
      target > endTime
    ) {
      return null;
    }

    return (
      (await this._requestLimit.add(() =>
        engine.getMediaSeekTime(hass, this._store, media, target),
      )) ?? null
    );
  }

  protected async _handleQuery<QT extends CameraQuery>(
    query: QT | QT[],
    engineOptions?: EngineOptions,
  ): Promise<Map<QT, QueryReturnType<QT>>> {
    const _queries = arrayify(query);
    const results = new Map<QT, QueryReturnType<QT>>();
    const queryStartTime = new Date();
    const hass = this._api.getHASSManager().getHASS();

    if (!hass) {
      return results;
    }

    const processEngineQuery = async (
      engine: CameraManagerEngine,
      query: QT,
    ): Promise<void> => {
      let engineResult: Map<QT, QueryReturnType<QT>> | null = null;

      /* istanbul ignore else: the else path cannot be reached -- @preserve */
      if (CameraQueryClassifier.isEventQuery(query)) {
        engineResult = (await engine.getEvents(
          hass,
          this._store,
          query,
          engineOptions,
        )) as Map<QT, QueryReturnType<QT>> | null;
      } else if (CameraQueryClassifier.isRecordingQuery(query)) {
        engineResult = (await engine.getRecordings(
          hass,
          this._store,
          query,
          engineOptions,
        )) as Map<QT, QueryReturnType<QT>> | null;
      } else if (CameraQueryClassifier.isRecordingSegmentsQuery(query)) {
        engineResult = (await engine.getRecordingSegments(
          hass,
          this._store,
          query,
          engineOptions,
        )) as Map<QT, QueryReturnType<QT>> | null;
      } else if (CameraQueryClassifier.isMediaMetadataQuery(query)) {
        engineResult = (await engine.getMediaMetadata(
          hass,
          this._store,
          query,
          engineOptions,
        )) as Map<QT, QueryReturnType<QT>> | null;
      }

      engineResult?.forEach((value, key) => results.set(key, value));
    };

    const processQuery = async (query: QT): Promise<void> => {
      const engines = this._store.getEnginesForCameraIDs(query.cameraIDs);
      if (!engines) {
        return;
      }
      await Promise.all(
        Array.from(engines.keys()).map((engine) =>
          this._requestLimit.add(() =>
            processEngineQuery(engine, { ...query, cameraIDs: engines.get(engine) }),
          ),
        ),
      );
    };

    await Promise.all(_queries.map((query) => processQuery(query)));

    const cachedOutputQueries = sum(
      Array.from(results.values()).map((result) => Number(result.cached ?? 0)),
    );

    log(
      this._api.getConfigManager().getCardWideConfig(),
      'Advanced Camera Card CameraManager request [Input queries:',
      _queries.length,
      ', Cached output queries:',
      cachedOutputQueries,
      ', Total output queries:',
      results.size,
      ', Duration:',
      `${(new Date().getTime() - queryStartTime.getTime()) / 1000}s,`,
      ', Queries:',
      _queries,
      ', Results:',
      results,
      ', Options:',
      engineOptions ?? {},
      ']',
    );
    return results;
  }

  protected _convertQueryResultsToMedia<QT extends CameraQuery>(
    results: ResultsMap<QT>,
  ): ViewMedia[] {
    const mediaArray: ViewMedia[] = [];
    const hass = this._api.getHASSManager().getHASS();

    if (!hass) {
      return mediaArray;
    }

    for (const [query, result] of results.entries()) {
      const engine = this._store.getEngineOfType(result.engine);

      if (engine) {
        let media: ViewMedia[] | null = null;
        /* istanbul ignore else: the else path cannot be reached -- @preserve */
        if (
          CameraQueryClassifier.isEventQuery(query) &&
          QueryResultClassifier.isEventQueryResult(result)
        ) {
          media = engine.generateMediaFromEvents(hass, this._store, query, result);
        } else if (
          CameraQueryClassifier.isRecordingQuery(query) &&
          QueryResultClassifier.isRecordingQueryResult(result)
        ) {
          media = engine.generateMediaFromRecordings(hass, this._store, query, result);
        }
        if (media) {
          mediaArray.push(...media);
        }
      }
    }
    return sortItems(mediaArray);
  }

  public getCameraEndpoints(
    cameraID: string,
    context?: CameraEndpointsContext,
  ): CameraEndpoints | null {
    const cameraConfig = this._store.getCameraConfig(cameraID);
    const engine = this._store.getEngineForCameraID(cameraID);
    if (!cameraConfig || !engine) {
      return null;
    }
    return engine.getCameraEndpoints(cameraConfig, context);
  }

  public getCameraMetadata(cameraID: string): CameraManagerCameraMetadata | null {
    const cameraConfig = this._store.getCameraConfig(cameraID);
    const engine = this._store.getEngineForCameraID(cameraID);
    const hass = this._api.getHASSManager().getHASS();

    if (!cameraConfig || !engine || !hass) {
      return null;
    }
    return engine.getCameraMetadata(hass, cameraConfig);
  }

  public getCameraCapabilities(cameraID: string): Capabilities | null {
    return this._store.getCamera(cameraID)?.getCapabilities() ?? null;
  }

  public getAggregateCameraCapabilities(cameraIDs?: Set<string>): Capabilities {
    const cameras = [...(cameraIDs ?? this._store.getCameraIDs())]
      .map((cameraID) => this._store.getCamera(cameraID))
      .filter(isTruthy);

    return new Capabilities({
      live: cameras.some((camera) => camera.getCapabilities()?.has('live')),
      clips: cameras.some((camera) => camera.getCapabilities()?.has('clips')),
      recordings: cameras.some((camera) => camera.getCapabilities()?.has('recordings')),
      snapshots: cameras.some((camera) => camera.getCapabilities()?.has('snapshots')),
      'favorite-events': cameras.some((camera) =>
        camera.getCapabilities()?.has('favorite-events'),
      ),
      'favorite-recordings': cameras.some((camera) =>
        camera.getCapabilities()?.has('favorite-recordings'),
      ),
      seek: cameras.some((camera) => camera.getCapabilities()?.has('seek')),
      menu: cameras.some((camera) => camera.getCapabilities()?.has('menu')),
    });
  }

  public async executePTZAction(
    cameraID: string,
    action: PTZAction,
    options?: {
      phase?: PTZActionPhase;
      preset?: string;
    },
  ): Promise<void> {
    const camera = this._store.getCamera(cameraID);
    if (!camera) {
      return;
    }
    await this._requestLimit.add(() =>
      camera.executePTZAction(this._api.getActionsManager(), action, options),
    );
  }
}



================================================
FILE: src/camera-manager/range.ts
================================================
import { orderBy } from 'lodash-es';

interface Range<T extends Date | number> {
  start: T;
  end: T;
}

export type DateRange = Range<Date>;
export type PartialDateRange = Partial<DateRange>;

interface MemoryRangeSetInterface<T> {
  hasCoverage(range: T): boolean;
  add(range: T): void;
  clear(): void;
}

export class MemoryRangeSet implements MemoryRangeSetInterface<DateRange> {
  protected _ranges: DateRange[];

  constructor(ranges?: DateRange[]) {
    this._ranges = ranges ?? [];
  }

  public hasCoverage(range: DateRange): boolean {
    return this._ranges.some((cachedRange) =>
      rangeIsEntirelyContained(cachedRange, range),
    );
  }

  public add(range: DateRange): void {
    this._ranges.push(range);
    this._ranges = compressRanges(this._ranges);
  }

  public clear(): void {
    this._ranges = [];
  }
}

export interface ExpiringRange<T extends Date | number> extends Range<T> {
  expires: Date;
}

export class ExpiringMemoryRangeSet
  implements MemoryRangeSetInterface<ExpiringRange<Date>>
{
  protected _ranges: ExpiringRange<Date>[];

  constructor(ranges?: ExpiringRange<Date>[]) {
    this._ranges = ranges ?? [];
  }

  public hasCoverage(range: DateRange): boolean {
    const now = new Date();
    return this._ranges.some(
      (cachedRange) =>
        now < cachedRange.expires && rangeIsEntirelyContained(cachedRange, range),
    );
  }

  public add(range: ExpiringRange<Date>): void {
    this._ranges.push(range);
    this._expireOldRanges();
  }

  protected _expireOldRanges(): void {
    const now = new Date();
    this._ranges = this._ranges.filter((range) => now < range.expires);
  }

  public clear(): void {
    this._ranges = [];
  }
}

const rangeIsEntirelyContained = (bigger: DateRange, smaller: DateRange): boolean => {
  return smaller.start >= bigger.start && smaller.end <= bigger.end;
};

export const rangesOverlap = (a: DateRange, b: DateRange): boolean => {
  return (
    // a starts within the range of b.
    (a.start >= b.start && a.start <= b.end) ||
    // a ends within the range of b.
    (a.end >= b.start && a.end <= b.end) ||
    // a encompasses the entire range of b.
    (a.start <= b.start && a.end >= b.end)
  );
};

export const compressRanges = <T extends Date | number>(
  ranges: Range<T>[],
  toleranceSeconds = 0,
): Range<T>[] => {
  const compressedRanges: Range<T>[] = [];
  ranges = orderBy(ranges, (range) => range.start, 'asc');

  let current: Range<T> | null = null;
  for (const range of ranges) {
    const rangeStartSeconds: number =
      range.start instanceof Date ? range.start.getTime() : range.start;

    if (!current) {
      current = { ...range };
      continue;
    }

    const currentEndSeconds =
      current.end instanceof Date ? current.end.getTime() : (current.end as number);

    if (currentEndSeconds + toleranceSeconds * 1000 >= rangeStartSeconds) {
      if (range.end > current.end) {
        current.end = range.end;
      }
    } else {
      compressedRanges.push(current);
      current = { ...range };
    }
  }
  if (current) {
    compressedRanges.push(current);
  }

  return compressedRanges;
};



================================================
FILE: src/camera-manager/store.ts
================================================
import { CameraConfig } from '../config/schema/cameras';
import { CapabilityKey } from '../types';
import { allPromises } from '../utils/basic';
import { ViewMedia } from '../view/item';
import { Camera } from './camera';
import { CameraManagerEngine } from './engine';
import { CapabilitySearchOptions, Engine } from './types';

type CameraManagerEngineCameraIDMap = Map<CameraManagerEngine, Set<string>>;

export interface CameraManagerReadOnlyConfigStore {
  getCameraConfig(cameraID: string): CameraConfig | null;
  getCameraConfigForMedia(media: ViewMedia): CameraConfig | null;

  hasCameraID(cameraID: string): boolean;

  getCamera(cameraID: string): Camera | null;
  getCameras(): Map<string, Camera>;
  getCameraCount(): number;

  getCameraConfigs(cameraIDs?: Iterable<string>): IterableIterator<CameraConfig>;
  getCameraConfigEntries(
    cameraIDs?: Iterable<string>,
  ): IterableIterator<[string, CameraConfig]>;

  getCameraIDs(): Set<string>;
  getDefaultCameraID(): string | null;

  getCameraIDsWithCapability(
    capability: CapabilityKey | CapabilitySearchOptions,
  ): Set<string>;
  getAllDependentCameras(
    cameraID: string,
    capability?: CapabilityKey | CapabilitySearchOptions,
  ): Set<string>;
}

export class CameraManagerStore implements CameraManagerReadOnlyConfigStore {
  protected _cameras: Map<string, Camera> = new Map();
  protected _enginesByType: Map<Engine, CameraManagerEngine> = new Map();

  public addCamera(camera: Camera): void {
    this._cameras.set(camera.getID(), camera);
    this._enginesByType.set(camera.getEngine().getEngineType(), camera.getEngine());
  }

  public async setCameras(cameras: Camera[]): Promise<void> {
    // In setting the store cameras, take great care to replace/add first before
    // remove. Otherwise, there may be race conditions where the card attempts
    // to render a view with (momentarily) no camera.
    // See: https://github.com/dermotduffy/advanced-camera-card/issues/1533

    // Replace/Add the new cameras.
    for (const camera of cameras) {
      const oldCamera = this._cameras.get(camera.getID());
      if (oldCamera !== camera) {
        this.addCamera(camera);
        await oldCamera?.destroy();
      }
    }

    // Remove the old cameras.
    for (const camera of this._cameras.values()) {
      if (!cameras.includes(camera)) {
        await camera.destroy();
        this._cameras.delete(camera.getID());
      }
    }
  }

  public async reset(): Promise<void> {
    await allPromises(this._cameras.values(), (camera) => camera.destroy());
    this._cameras.clear();
    this._enginesByType.clear();
  }

  public getCamera(cameraID: string): Camera | null {
    return this._cameras.get(cameraID) ?? null;
  }
  public getCameras(): Map<string, Camera> {
    return this._cameras;
  }
  public getCameraConfig(cameraID: string): CameraConfig | null {
    return this._cameras.get(cameraID)?.getConfig() ?? null;
  }

  public hasCameraID(cameraID: string): boolean {
    return this._cameras.has(cameraID);
  }

  public getCameraCount(): number {
    return this._cameras.size;
  }

  public getDefaultCameraID(): string | null {
    return this._cameras.keys().next().value ?? null;
  }

  public *getCameraConfigs(
    cameraIDs?: Iterable<string>,
  ): IterableIterator<CameraConfig> {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const [_cameraID, config] of this.getCameraConfigEntries(cameraIDs)) {
      yield config;
    }
  }
  public *getCameraConfigEntries(
    cameraIDs?: Iterable<string>,
  ): IterableIterator<[string, CameraConfig]> {
    for (const cameraID of cameraIDs ?? this._cameras.keys()) {
      const config = this.getCameraConfig(cameraID);

      if (config) {
        yield [cameraID, config];
      }
    }
  }

  public getCameraIDs(): Set<string> {
    return new Set(this._cameras.keys());
  }

  public getCameraIDsWithCapability(
    capability: CapabilityKey | CapabilitySearchOptions,
  ): Set<string> {
    const output: Set<string> = new Set();
    for (const camera of this._cameras.values()) {
      if (camera.getCapabilities()?.matches(capability)) {
        output.add(camera.getID());
      }
    }
    return output;
  }

  public getCameraConfigForMedia(media: ViewMedia): CameraConfig | null {
    const cameraID = media.getCameraID();
    return cameraID ? this.getCameraConfig(cameraID) : null;
  }

  public getEngineOfType(engine: Engine): CameraManagerEngine | null {
    return this._enginesByType.get(engine) ?? null;
  }

  public getEngineForCameraID(cameraID: string): CameraManagerEngine | null {
    return this._cameras.get(cameraID)?.getEngine() ?? null;
  }

  public getEnginesForCameraIDs(
    cameraIDs: Set<string>,
  ): CameraManagerEngineCameraIDMap | null {
    const output: CameraManagerEngineCameraIDMap = new Map();

    for (const cameraID of cameraIDs) {
      const engine = this.getEngineForCameraID(cameraID);
      if (!engine) {
        continue;
      }
      if (!output.has(engine)) {
        output.set(engine, new Set());
      }
      output.get(engine)?.add(cameraID);
    }
    return output.size ? output : null;
  }

  public getEngineForMedia(media: ViewMedia): CameraManagerEngine | null {
    const cameraID = media.getCameraID();
    return cameraID ? this.getEngineForCameraID(cameraID) : null;
  }

  /**
   * Get all cameras that depend on a given camera.
   * @param cameraManager The camera manager.
   * @param cameraID ID of the target camera.
   * @returns A set of dependent cameraIDs or null (since JS sets guarantee order,
   * the first item in the set is guaranteed to be the cameraID itself).
   */
  public getAllDependentCameras(
    cameraID: string,
    capability?: CapabilitySearchOptions,
  ): Set<string> {
    const visitedCameraIDs = new Set<string>();
    const matchingCameraIDs: Set<string> = new Set();
    const getDependentCameras = (cameraID: string): void => {
      visitedCameraIDs.add(cameraID);

      const camera = this.getCamera(cameraID);
      const cameraConfig = camera?.getConfig();

      if (camera && cameraConfig) {
        if (!capability || camera.getCapabilities()?.matches(capability)) {
          matchingCameraIDs.add(cameraID);
        }
        const dependentCameras: Set<string> = new Set();
        cameraConfig.dependencies.cameras.forEach((item) => dependentCameras.add(item));
        if (cameraConfig.dependencies.all_cameras) {
          this.getCameraIDs().forEach((cameraID) => dependentCameras.add(cameraID));
        }
        for (const dependentCameraID of dependentCameras) {
          if (!visitedCameraIDs.has(dependentCameraID)) {
            getDependentCameras(dependentCameraID);
          }
        }
      }
    };
    getDependentCameras(cameraID);
    return matchingCameraIDs;
  }
}



================================================
FILE: src/camera-manager/types.ts
================================================
import { ExpiringEqualityCache } from '../cache/expiring-cache';
import { SSLCiphers } from '../config/schema/cameras';
import { AdvancedCameraCardView } from '../config/schema/common/const';
import { CapabilityKey, Endpoint, Icon } from '../types';
import { ViewMedia } from '../view/item';

// ====
// Base
// ====

export enum QueryType {
  Event = 'event-query',
  Recording = 'recording-query',
  RecordingSegments = 'recording-segments-query',
  MediaMetadata = 'media-metadata',
}

export enum QueryResultsType {
  Event = 'event-results',
  Recording = 'recording-results',
  RecordingSegments = 'recording-segments-results',
  MediaMetadata = 'media-metadata-results',
}

export enum Engine {
  Frigate = 'frigate',
  Generic = 'generic',
  MotionEye = 'motioneye',
  Reolink = 'reolink',
}

export interface CameraQuery {
  type: QueryType;
  cameraIDs: Set<string>;
}
export type PartialCameraQuery = Partial<CameraQuery>;

interface TimeBasedDataQuery {
  start: Date;
  end: Date;
}

interface LimitedDataQuery {
  limit: number;
}

export interface MediaQuery
  extends CameraQuery,
    Partial<TimeBasedDataQuery>,
    Partial<LimitedDataQuery> {
  favorite?: boolean;
}

export interface QueryResults {
  type: QueryResultsType;
  engine: Engine;
  expiry?: Date;
  cached?: boolean;
}

// Generic recording segment type (inspired by Frigate recording segments).
export interface RecordingSegment {
  start_time: number;
  end_time: number;
  id: string;
}

export type QueryReturnType<QT> = QT extends EventQuery
  ? EventQueryResults
  : QT extends RecordingQuery
    ? RecordingQueryResults
    : QT extends RecordingSegmentsQuery
      ? RecordingSegmentsQueryResults
      : QT extends MediaMetadataQuery
        ? MediaMetadataQueryResults
        : never;
export type PartialQueryConcreteType<PQT> = PQT extends PartialEventQuery
  ? EventQuery
  : PQT extends PartialRecordingQuery
    ? RecordingQuery
    : PQT extends PartialRecordingSegmentsQuery
      ? RecordingSegmentsQuery
      : never;

export type ResultsMap<QT> = Map<QT, QueryReturnType<QT>>;
export type EventQueryResultsMap = ResultsMap<EventQuery>;
export type RecordingQueryResultsMap = ResultsMap<RecordingQuery>;
export type RecordingSegmentsQueryResultsMap = ResultsMap<RecordingSegmentsQuery>;
export type MediaMetadataQueryResultsMap = ResultsMap<MediaMetadataQuery>;

export interface MediaMetadata {
  days?: Set<string>;
  tags?: Set<string>;
  where?: Set<string>;
  what?: Set<string>;
}

interface CapabilitySearchAllAny {
  allCapabilities?: CapabilityKey[];
  anyCapabilities?: CapabilityKey[];
}
export type CapabilitySearchOptions = CapabilityKey | CapabilitySearchAllAny;

export interface CameraManagerCameraMetadata {
  title: string;
  icon: Icon;

  // Engine icon is just a string since it will never be entity-derived.
  engineIcon?: string;
}

export interface CameraEndpointsContext {
  media?: ViewMedia;
  view?: AdvancedCameraCardView;
}

export interface CameraEndpoints {
  ui?: Endpoint;
  go2rtc?: Endpoint;
  jsmpeg?: Endpoint;
  webrtcCard?: Endpoint;
}

export interface CameraProxyConfig {
  dynamic: boolean;
  media: boolean;
  ssl_verification: boolean;
  ssl_ciphers: SSLCiphers;
}

export interface EngineOptions {
  useCache?: boolean;
}

export interface CameraEvent {
  cameraID: string;

  type: 'new' | 'update' | 'end';

  // When fidelity is `high`, the engine is assumed to provide exact details of
  // what new media is available. Otherwise all media types are assumed to be
  // possibly newly available.
  fidelity?: 'high' | 'low';

  // Whether a new clip/snapshot/recording may be available.
  clip?: boolean;
  snapshot?: boolean;
}
export type CameraEventCallback = (ev: CameraEvent) => void;

export class CameraManagerRequestCache extends ExpiringEqualityCache<
  CameraQuery,
  QueryResults
> {}

// ===========
// Event Query
// ===========

export interface EventQuery extends MediaQuery {
  type: QueryType.Event;

  // Frigate equivalent: has_snapshot
  hasSnapshot?: boolean;

  // Frigate equivalent: has_clip
  hasClip?: boolean;

  // Frigate equivalent: label
  what?: Set<string>;

  // Frigate equivalent: sub_label
  tags?: Set<string>;

  // Frigate equivalent: zone
  where?: Set<string>;
}
export type PartialEventQuery = Partial<EventQuery>;

export interface EventQueryResults extends QueryResults {
  type: QueryResultsType.Event;
}

// ===============
// Recording Query
// ===============

export interface RecordingQuery extends MediaQuery {
  type: QueryType.Recording;
}
export type PartialRecordingQuery = Partial<RecordingQuery>;

export interface RecordingQueryResults extends QueryResults {
  type: QueryResultsType.Recording;
}

// ========================
// Recording Segments Query
// ========================

export interface RecordingSegmentsQuery extends CameraQuery, TimeBasedDataQuery {
  type: QueryType.RecordingSegments;
}
export type PartialRecordingSegmentsQuery = Partial<RecordingSegmentsQuery>;

export interface RecordingSegmentsQueryResults extends QueryResults {
  type: QueryResultsType.RecordingSegments;
  segments: RecordingSegment[];
}

// ====================
// Media metadata Query
// ====================

export interface MediaMetadataQuery extends CameraQuery {
  type: QueryType.MediaMetadata;
}

export interface MediaMetadataQueryResults extends QueryResults {
  type: QueryResultsType.MediaMetadata;
  metadata: MediaMetadata;
}



================================================
FILE: src/camera-manager/browse-media/camera.ts
================================================
import { Entity, EntityRegistryManager } from '../../ha/registry/entity/types';
import { HomeAssistant } from '../../ha/types';
import { localize } from '../../localize/localize';
import { Camera, CameraInitializationOptions } from '../camera';
import { CameraInitializationError } from '../error';

interface BrowseMediaCameraInitializationOptions extends CameraInitializationOptions {
  entityRegistryManager: EntityRegistryManager;
  hass: HomeAssistant;
}

export class BrowseMediaCamera extends Camera {
  protected _entity: Entity | null = null;

  public async initialize(
    options: BrowseMediaCameraInitializationOptions,
  ): Promise<Camera> {
    const config = this.getConfig();
    const entity = config.camera_entity
      ? await options.entityRegistryManager.getEntity(options.hass, config.camera_entity)
      : null;

    if (!entity || !config.camera_entity) {
      throw new CameraInitializationError(localize('error.no_camera_entity'), config);
    }
    this._entity = entity;
    return await super.initialize(options);
  }

  public getEntity(): Entity | null {
    return this._entity;
  }
}



================================================
FILE: src/camera-manager/browse-media/engine-browse-media.ts
================================================
import { StateWatcherSubscriptionInterface } from '../../card-controller/hass/state-watcher';
import { CameraConfig } from '../../config/schema/cameras';
import { BROWSE_MEDIA_CACHE_SECONDS } from '../../ha/browse-media/types';
import { BrowseMediaWalker } from '../../ha/browse-media/walker';
import { getMediaDownloadPath } from '../../ha/download';
import { EntityRegistryManager } from '../../ha/registry/entity/types';
import { ResolvedMediaCache } from '../../ha/resolved-media';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import { ViewMedia } from '../../view/item';
import { ViewItemCapabilities } from '../../view/types';
import { CameraManagerEngine } from '../engine';
import { GenericCameraManagerEngine } from '../generic/engine-generic';
import { CameraManagerReadOnlyConfigStore } from '../store';
import {
  CameraEventCallback,
  CameraManagerRequestCache,
  CameraQuery,
  EventQuery,
  PartialEventQuery,
  QueryType,
} from '../types';

/**
 * A base class for cameras that read events from HA BrowseMedia interface.
 */
export class BrowseMediaCameraManagerEngine
  extends GenericCameraManagerEngine
  implements CameraManagerEngine
{
  protected _browseMediaWalker: BrowseMediaWalker;
  protected _entityRegistryManager: EntityRegistryManager;
  protected _resolvedMediaCache: ResolvedMediaCache;
  protected _requestCache: CameraManagerRequestCache;

  public constructor(
    entityRegistryManager: EntityRegistryManager,
    stateWatcher: StateWatcherSubscriptionInterface,
    browseMediaManager: BrowseMediaWalker,
    resolvedMediaCache: ResolvedMediaCache,
    requestCache: CameraManagerRequestCache,
    eventCallback?: CameraEventCallback,
  ) {
    super(stateWatcher, eventCallback);
    this._entityRegistryManager = entityRegistryManager;
    this._browseMediaWalker = browseMediaManager;
    this._resolvedMediaCache = resolvedMediaCache;
    this._requestCache = requestCache;
  }

  public generateDefaultEventQuery(
    _store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query: PartialEventQuery,
  ): EventQuery[] | null {
    return [
      {
        type: QueryType.Event,
        cameraIDs: cameraIDs,
        ...query,
      },
    ];
  }

  public async getMediaDownloadPath(
    hass: HomeAssistant,
    _cameraConfig: CameraConfig,
    media: ViewMedia,
  ): Promise<Endpoint | null> {
    return getMediaDownloadPath(hass, media.getContentID(), this._resolvedMediaCache);
  }

  public getQueryResultMaxAge(query: CameraQuery): number | null {
    if (query.type === QueryType.Event) {
      return BROWSE_MEDIA_CACHE_SECONDS;
    }
    return null;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public getMediaCapabilities(_media: ViewMedia): ViewItemCapabilities {
    return {
      canFavorite: false,
      canDownload: true,
    };
  }
}



================================================
FILE: src/camera-manager/frigate/camera.ts
================================================
import { uniq } from 'lodash-es';
import { ActionsExecutor } from '../../card-controller/actions/types';
import { StateWatcherSubscriptionInterface } from '../../card-controller/hass/state-watcher';
import { PTZAction, PTZActionPhase } from '../../config/schema/actions/custom/ptz';
import { CameraConfig } from '../../config/schema/cameras';
import { Entity, EntityRegistryManager } from '../../ha/registry/entity/types';
import { HomeAssistant } from '../../ha/types';
import { localize } from '../../localize/localize';
import { PTZCapabilities, PTZMovementType } from '../../types';
import { errorToConsole } from '../../utils/basic';
import { Camera, CameraInitializationOptions } from '../camera';
import { Capabilities } from '../capabilities';
import { CameraManagerEngine } from '../engine';
import { CameraInitializationError } from '../error';
import { CameraEventCallback } from '../types';
import { getCameraEntityFromConfig } from '../utils/camera-entity-from-config';
import { getPTZCapabilitiesFromCameraConfig } from '../utils/ptz';
import {
  FrigateEventWatcherRequest,
  FrigateEventWatcherSubscriptionInterface,
} from './event-watcher';
import { getPTZInfo } from './requests';
import { FrigateEventChange, PTZInfo } from './types';

const CAMERA_BIRDSEYE = 'birdseye' as const;

interface FrigateCameraInitializationOptions extends CameraInitializationOptions {
  entityRegistryManager: EntityRegistryManager;
  frigateEventWatcher: FrigateEventWatcherSubscriptionInterface;
  hass: HomeAssistant;
  stateWatcher: StateWatcherSubscriptionInterface;
}

export const isBirdseye = (cameraConfig: CameraConfig): boolean => {
  return cameraConfig.frigate.camera_name === CAMERA_BIRDSEYE;
};

export class FrigateCamera extends Camera {
  constructor(
    config: CameraConfig,
    engine: CameraManagerEngine,
    options?: {
      capabilities?: Capabilities;
      eventCallback?: CameraEventCallback;
    },
  ) {
    super(config, engine, options);
  }

  public async initialize(options: FrigateCameraInitializationOptions): Promise<Camera> {
    await this._initializeConfig(options.hass, options.entityRegistryManager);
    await this._initializeCapabilities(options.hass);

    if (this._capabilities?.has('trigger')) {
      await this._subscribeToEvents(options.hass, options.frigateEventWatcher);
    }

    return await super.initialize(options);
  }

  public async executePTZAction(
    executor: ActionsExecutor,
    action: PTZAction,
    options?: {
      phase?: PTZActionPhase;
      preset?: string;
    },
  ): Promise<boolean> {
    if (await super.executePTZAction(executor, action, options)) {
      return true;
    }

    const cameraEntity = this.getConfig().camera_entity;
    if ((action === 'preset' && !options?.preset) || !cameraEntity) {
      return false;
    }

    // Awkward translation between card action and service parameters:
    // https://github.com/blakeblackshear/frigate-hass-integration/blob/dev/custom_components/frigate/services.yaml
    await executor.executeActions({
      actions: {
        action: 'perform-action',
        perform_action: 'frigate.ptz',
        data: {
          action:
            options?.phase === 'stop'
              ? 'stop'
              : action === 'zoom_in' || action === 'zoom_out'
                ? 'zoom'
                : action === 'preset'
                  ? 'preset'
                  : 'move',
          ...(options?.phase !== 'stop' && {
            argument:
              action === 'zoom_in'
                ? 'in'
                : action === 'zoom_out'
                  ? 'out'
                  : action === 'preset'
                    ? options?.preset
                    : action,
          }),
        },
        target: { entity_id: cameraEntity },
      },
    });
    return true;
  }

  protected async _initializeConfig(
    hass: HomeAssistant,
    entityRegistryManager: EntityRegistryManager,
  ): Promise<void> {
    const config = this.getConfig();
    const hasCameraName = !!config.frigate?.camera_name;
    const hasAutoTriggers = config.triggers.motion || config.triggers.occupancy;

    let entity: Entity | null = null;
    const cameraEntity = getCameraEntityFromConfig(config);

    // Entity information is required if the Frigate camera name is missing, or
    // if the entity requires automatic resolution of motion/occupancy sensors.
    if (cameraEntity && (!hasCameraName || hasAutoTriggers)) {
      entity = await entityRegistryManager.getEntity(hass, cameraEntity);
      if (!entity) {
        throw new CameraInitializationError(localize('error.no_camera_entity'), config);
      }
    }

    if (entity && !hasCameraName) {
      const resolvedName = this._getFrigateCameraNameFromEntity(entity);
      if (resolvedName) {
        this._config.frigate.camera_name = resolvedName;
      }
    }

    if (hasAutoTriggers) {
      // Try to find the correct entities for the motion & occupancy sensors.
      // We know they are binary_sensors, and that they'll have the same
      // config entry ID as the camera. Searching via unique_id ensures this
      // search still works if the user renames the entity_id.
      const binarySensorEntities = await entityRegistryManager.getMatchingEntities(
        hass,
        (ent) =>
          ent.config_entry_id === entity?.config_entry_id &&
          !ent.disabled_by &&
          ent.entity_id.startsWith('binary_sensor.'),
      );

      if (config.triggers.motion) {
        const motionEntity = this._getMotionSensor(config, [
          ...binarySensorEntities.values(),
        ]);
        if (motionEntity) {
          config.triggers.entities.push(motionEntity);
        }
      }

      if (config.triggers.occupancy) {
        const occupancyEntities = this._getOccupancySensor(config, [
          ...binarySensorEntities.values(),
        ]);
        if (occupancyEntities) {
          config.triggers.entities.push(...occupancyEntities);
        }
      }

      // De-duplicate triggering entities.
      config.triggers.entities = uniq(config.triggers.entities);
    }
  }

  protected async _initializeCapabilities(hass: HomeAssistant): Promise<void> {
    const config = this.getConfig();

    const configPTZCapabilities = getPTZCapabilitiesFromCameraConfig(this.getConfig());
    const frigatePTZCapabilities = await this._getPTZCapabilities(hass, config);

    const combinedPTZCapabilities: PTZCapabilities | null =
      configPTZCapabilities || frigatePTZCapabilities
        ? {
            ...frigatePTZCapabilities,
            ...configPTZCapabilities,
          }
        : null;

    const birdseye = isBirdseye(config);
    this._capabilities = new Capabilities(
      {
        'favorite-events': !birdseye,
        'favorite-recordings': false,
        'remote-control-entity': true,
        seek: !birdseye,
        clips: !birdseye,
        snapshots: !birdseye,
        recordings: !birdseye,
        live: true,
        menu: true,
        substream: true,
        trigger: true,
        ...(combinedPTZCapabilities && { ptz: combinedPTZCapabilities }),
      },
      {
        disable: config.capabilities?.disable,
        disableExcept: config.capabilities?.disable_except,
      },
    );
  }

  protected _getFrigateCameraNameFromEntity(entity: Entity): string | null {
    if (
      entity.platform === 'frigate' &&
      entity.unique_id &&
      typeof entity.unique_id === 'string'
    ) {
      const match = entity.unique_id.match(/:camera:(?<camera>[^:]+)$/);
      if (match && match.groups) {
        return match.groups['camera'];
      }
    }
    return null;
  }

  protected async _getPTZCapabilities(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): Promise<PTZCapabilities | null> {
    if (!cameraConfig.frigate.camera_name || isBirdseye(cameraConfig)) {
      return null;
    }

    let ptzInfo: PTZInfo | null = null;
    try {
      ptzInfo = await getPTZInfo(
        hass,
        cameraConfig.frigate.client_id,
        cameraConfig.frigate.camera_name,
      );
    } catch (e) {
      errorToConsole(e as Error);
      return null;
    }

    // Note: The Frigate integration only supports continuous PTZ movements
    // (regardless of the actual underlying camera capability).
    const panTilt: PTZMovementType[] = [
      ...(ptzInfo.features?.includes('pt') ? [PTZMovementType.Continuous] : []),
    ];
    const zoom: PTZMovementType[] = [
      ...(ptzInfo.features?.includes('zoom') ? [PTZMovementType.Continuous] : []),
    ];
    const presets = ptzInfo.presets;

    if (panTilt.length || zoom.length || presets?.length) {
      return {
        ...(panTilt && {
          left: panTilt,
          right: panTilt,
          up: panTilt,
          down: panTilt,
        }),
        ...(zoom && { zoomIn: zoom, zoomOut: zoom }),
        ...(presets && { presets: presets }),
      };
    }
    return null;
  }

  /**
   * Get the motion sensor entity for a given camera.
   * @param cache The EntityCache of entity registry information.
   * @param cameraConfig The camera config in question.
   * @returns The entity id of the motion sensor or null.
   */
  protected _getMotionSensor(
    cameraConfig: CameraConfig,
    entities: Entity[],
  ): string | null {
    if (cameraConfig.frigate.camera_name) {
      return (
        entities.find(
          (entity) =>
            typeof entity.unique_id === 'string' &&
            !!entity.unique_id?.match(
              new RegExp(`:motion_sensor:${cameraConfig.frigate.camera_name}`),
            ),
        )?.entity_id ?? null
      );
    }
    return null;
  }

  /**
   * Get the occupancy sensor entity for a given camera.
   * @param cache The EntityCache of entity registry information.
   * @param cameraConfig The camera config in question.
   * @returns The entity id of the occupancy sensor or null.
   */
  protected _getOccupancySensor(
    cameraConfig: CameraConfig,
    entities: Entity[],
  ): string[] | null {
    const entityIDs: string[] = [];
    const addEntityIDIfFound = (cameraOrZone: string, label: string): void => {
      const entityID =
        entities.find(
          (entity) =>
            typeof entity.unique_id === 'string' &&
            !!entity.unique_id?.match(
              new RegExp(`:occupancy_sensor:${cameraOrZone}_${label}`),
            ),
        )?.entity_id ?? null;
      if (entityID) {
        entityIDs.push(entityID);
      }
    };

    if (cameraConfig.frigate.camera_name) {
      // If zone(s) are specified, the master occupancy sensor for the overall
      // camera is not used by default (but could be manually added by the
      // user).
      const camerasAndZones = cameraConfig.frigate.zones?.length
        ? cameraConfig.frigate.zones
        : [cameraConfig.frigate.camera_name];

      const labels = cameraConfig.frigate.labels?.length
        ? cameraConfig.frigate.labels
        : ['all'];
      for (const cameraOrZone of camerasAndZones) {
        for (const label of labels) {
          addEntityIDIfFound(cameraOrZone, label);
        }
      }

      if (entityIDs.length) {
        return entityIDs;
      }
    }
    return null;
  }

  protected async _subscribeToEvents(
    hass: HomeAssistant,
    frigateEventWatcher: FrigateEventWatcherSubscriptionInterface,
  ): Promise<void> {
    const config = this.getConfig();
    if (!config.triggers.events.length || !config.frigate.camera_name) {
      return;
    }

    /* istanbul ignore next -- exercising the matcher is not possible when the
    test uses an event watcher -- @preserve */
    const request: FrigateEventWatcherRequest = {
      instanceID: config.frigate.client_id,
      callback: (event: FrigateEventChange) => this._frigateEventHandler(event),
      matcher: (event: FrigateEventChange): boolean =>
        event.after.camera === config.frigate.camera_name,
    };

    await frigateEventWatcher.subscribe(hass, request);
    this._onDestroy(() => frigateEventWatcher.unsubscribe(request));
  }

  protected _frigateEventHandler = (ev: FrigateEventChange): void => {
    const snapshotChange =
      (!ev.before.has_snapshot && ev.after.has_snapshot) ||
      ev.before.snapshot?.frame_time !== ev.after.snapshot?.frame_time;
    const clipChange = !ev.before.has_clip && ev.after.has_clip;

    const config = this.getConfig();
    if (
      (config.frigate.zones?.length &&
        !config.frigate.zones.some((zone) => ev.after.current_zones.includes(zone))) ||
      (config.frigate.labels?.length && !config.frigate.labels.includes(ev.after.label))
    ) {
      return;
    }

    const eventsToTriggerOn = config.triggers.events;
    if (
      !(
        eventsToTriggerOn.includes('events') ||
        (eventsToTriggerOn.includes('snapshots') && snapshotChange) ||
        (eventsToTriggerOn.includes('clips') && clipChange)
      )
    ) {
      return;
    }

    this._eventCallback?.({
      fidelity: 'high',
      cameraID: this.getID(),
      type: ev.type,
      // In cases where there are both clip and snapshot media, ensure to only
      // trigger on the media type that is allowed by the configuration.
      clip: clipChange && eventsToTriggerOn.includes('clips'),
      snapshot: snapshotChange && eventsToTriggerOn.includes('snapshots'),
    });
  };
}



================================================
FILE: src/camera-manager/frigate/engine-frigate.ts
================================================
import { add, endOfHour, format, fromUnixTime, startOfHour } from 'date-fns';
import { isEqual, orderBy, throttle, uniqWith } from 'lodash-es';
import { StateWatcherSubscriptionInterface } from '../../card-controller/hass/state-watcher';
import { CameraConfig } from '../../config/schema/cameras';
import { getEntityTitle } from '../../ha/get-entity-title';
import { EntityRegistryManager } from '../../ha/registry/entity/types';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import {
  allPromises,
  formatDate,
  prettifyTitle,
  runWhenIdleIfSupported,
} from '../../utils/basic';
import { ViewMedia, ViewMediaType } from '../../view/item';
import { ViewItemClassifier } from '../../view/item-classifier';
import { ViewItemCapabilities } from '../../view/types';
import { RecordingSegmentsCache } from '../cache';
import { Camera } from '../camera';
import {
  CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT,
  CameraManagerEngine,
} from '../engine';
import { GenericCameraManagerEngine } from '../generic/engine-generic';
import { DateRange } from '../range';
import { CameraManagerReadOnlyConfigStore } from '../store';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraEventCallback,
  CameraManagerCameraMetadata,
  CameraManagerRequestCache,
  CameraQuery,
  Engine,
  EngineOptions,
  EventQuery,
  EventQueryResults,
  EventQueryResultsMap,
  MediaMetadataQuery,
  MediaMetadataQueryResults,
  MediaMetadataQueryResultsMap,
  PartialEventQuery,
  PartialRecordingQuery,
  PartialRecordingSegmentsQuery,
  QueryResults,
  QueryResultsType,
  QueryReturnType,
  QueryType,
  RecordingQuery,
  RecordingQueryResults,
  RecordingQueryResultsMap,
  RecordingSegment,
  RecordingSegmentsQuery,
  RecordingSegmentsQueryResultsMap,
} from '../types';
import { getDefaultGo2RTCEndpoint } from '../utils/go2rtc-endpoint';
import { FrigateCamera, isBirdseye } from './camera';
import { FrigateEventWatcher } from './event-watcher';
import { FrigateViewMediaFactory } from './media';
import { FrigateViewMediaClassifier } from './media-classifier';
import {
  NativeFrigateEventQuery,
  NativeFrigateRecordingSegmentsQuery,
  getEventSummary,
  getEvents,
  getRecordingSegments,
  getRecordingsSummary,
  retainEvent,
} from './requests';
import {
  FrigateEventQueryResults,
  FrigateRecording,
  FrigateRecordingQueryResults,
  FrigateRecordingSegmentsQueryResults,
} from './types';

const EVENT_REQUEST_CACHE_MAX_AGE_SECONDS = 60;
const RECORDING_SUMMARY_REQUEST_CACHE_MAX_AGE_SECONDS = 60;
const MEDIA_METADATA_REQUEST_CACHE_AGE_SECONDS = 60;

class FrigateQueryResultsClassifier {
  public static isFrigateEventQueryResults(
    results: QueryResults,
  ): results is FrigateEventQueryResults {
    return results.engine === Engine.Frigate && results.type === QueryResultsType.Event;
  }

  public static isFrigateRecordingQueryResults(
    results: QueryResults,
  ): results is FrigateRecordingQueryResults {
    return (
      results.engine === Engine.Frigate && results.type === QueryResultsType.Recording
    );
  }

  public static isFrigateRecordingSegmentsResults(
    results: QueryResults,
  ): results is FrigateRecordingSegmentsQueryResults {
    return (
      results.engine === Engine.Frigate &&
      results.type === QueryResultsType.RecordingSegments
    );
  }
}

export class FrigateCameraManagerEngine
  extends GenericCameraManagerEngine
  implements CameraManagerEngine
{
  protected _entityRegistryManager: EntityRegistryManager;
  protected _frigateEventWatcher: FrigateEventWatcher;
  protected _recordingSegmentsCache: RecordingSegmentsCache;
  protected _requestCache: CameraManagerRequestCache;

  // Garbage collect segments at most once an hour.
  protected _throttledSegmentGarbageCollector = throttle(
    this._garbageCollectSegments.bind(this),
    60 * 60 * 1000,
    { leading: false, trailing: true },
  );

  constructor(
    entityRegistryManager: EntityRegistryManager,
    stateWatcher: StateWatcherSubscriptionInterface,
    recordingSegmentsCache: RecordingSegmentsCache,
    requestCache: CameraManagerRequestCache,
    eventCallback?: CameraEventCallback,
  ) {
    super(stateWatcher, eventCallback);
    this._entityRegistryManager = entityRegistryManager;
    this._frigateEventWatcher = new FrigateEventWatcher();
    this._recordingSegmentsCache = recordingSegmentsCache;
    this._requestCache = requestCache;
  }

  public getEngineType(): Engine {
    return Engine.Frigate;
  }

  public async createCamera(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): Promise<Camera> {
    const camera = new FrigateCamera(cameraConfig, this, {
      eventCallback: this._eventCallback,
    });
    return await camera.initialize({
      hass,
      entityRegistryManager: this._entityRegistryManager,
      stateWatcher: this._stateWatcher,
      frigateEventWatcher: this._frigateEventWatcher,
    });
  }

  public async getMediaDownloadPath(
    _hass: HomeAssistant,
    cameraConfig: CameraConfig,
    media: ViewMedia,
  ): Promise<Endpoint | null> {
    if (FrigateViewMediaClassifier.isFrigateEvent(media)) {
      return {
        endpoint:
          `/api/frigate/${cameraConfig.frigate.client_id}` +
          `/notifications/${media.getID()}/` +
          `${ViewItemClassifier.isClip(media) ? 'clip.mp4' : 'snapshot.jpg'}` +
          `?download=true`,
        sign: true,
      };
    } else if (FrigateViewMediaClassifier.isFrigateRecording(media)) {
      return {
        endpoint:
          `/api/frigate/${cameraConfig.frigate.client_id}` +
          `/recording/${cameraConfig.frigate.camera_name}` +
          `/start/${Math.floor(media.getStartTime().getTime() / 1000)}` +
          `/end/${Math.floor(media.getEndTime().getTime() / 1000)}` +
          `?download=true`,
        sign: true,
      };
    }
    return null;
  }

  public generateDefaultEventQuery(
    store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query?: PartialEventQuery,
  ): EventQuery[] | null {
    const relevantCameraConfigs = [...store.getCameraConfigs(cameraIDs)];

    // If all cameras specify exactly the same zones or labels (incl. none), we
    // can use a single batch query which will be better performance wise,
    // otherwise we must fan out to multiple queries in order to precisely match
    // the user's intent.
    const uniqueZoneArrays = uniqWith(
      relevantCameraConfigs.map((config) => config?.frigate.zones),
      isEqual,
    );
    const uniqueLabelArrays = uniqWith(
      relevantCameraConfigs.map((config) => config?.frigate.labels),
      isEqual,
    );

    if (uniqueZoneArrays.length === 1 && uniqueLabelArrays.length === 1) {
      return [
        {
          type: QueryType.Event,
          cameraIDs: cameraIDs,
          ...(uniqueLabelArrays[0] && { what: new Set(uniqueLabelArrays[0]) }),
          ...(uniqueZoneArrays[0] && { where: new Set(uniqueZoneArrays[0]) }),
          ...query,
        },
      ];
    }

    const output: EventQuery[] = [];
    for (const cameraID of cameraIDs) {
      const cameraConfig = store.getCameraConfig(cameraID);
      if (cameraConfig) {
        output.push({
          type: QueryType.Event,
          cameraIDs: new Set([cameraID]),
          ...(cameraConfig.frigate.labels && {
            what: new Set(cameraConfig.frigate.labels),
          }),
          ...(cameraConfig.frigate.zones && {
            where: new Set(cameraConfig.frigate.zones),
          }),
          ...query,
        });
      }
    }
    return output.length ? output : null;
  }

  public generateDefaultRecordingQuery(
    _store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query?: PartialRecordingQuery,
  ): RecordingQuery[] {
    return [
      {
        type: QueryType.Recording,
        cameraIDs: cameraIDs,
        ...query,
      },
    ];
  }

  public generateDefaultRecordingSegmentsQuery(
    _store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
    query: PartialRecordingSegmentsQuery,
  ): RecordingSegmentsQuery[] | null {
    if (!query.start || !query.end) {
      return null;
    }
    return [
      {
        type: QueryType.RecordingSegments,
        cameraIDs: cameraIDs,
        start: query.start,
        end: query.end,
        ...query,
      },
    ];
  }

  public async favoriteMedia(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
    media: ViewMedia,
    favorite: boolean,
  ): Promise<void> {
    if (!FrigateViewMediaClassifier.isFrigateEvent(media)) {
      return;
    }

    await retainEvent(hass, cameraConfig.frigate.client_id, media.getID(), favorite);
    media.setFavorite(favorite);
  }

  protected _buildInstanceToCameraIDMapFromQuery(
    store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
  ): Map<string, Set<string>> {
    const output: Map<string, Set<string>> = new Map();
    for (const cameraID of cameraIDs) {
      const cameraConfig = this._getQueryableCameraConfig(store, cameraID);
      const clientID = cameraConfig?.frigate.client_id;
      if (clientID) {
        if (!output.has(clientID)) {
          output.set(clientID, new Set());
        }
        output.get(clientID)?.add(cameraID);
      }
    }
    return output;
  }

  protected _getFrigateCameraNamesForCameraIDs(
    store: CameraManagerReadOnlyConfigStore,
    cameraIDs: Set<string>,
  ): Set<string> {
    const output = new Set<string>();
    for (const cameraID of cameraIDs) {
      const cameraConfig = this._getQueryableCameraConfig(store, cameraID);
      if (cameraConfig?.frigate.camera_name) {
        output.add(cameraConfig.frigate.camera_name);
      }
    }
    return output;
  }

  public async getEvents(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: EventQuery,
    engineOptions?: EngineOptions,
  ): Promise<EventQueryResultsMap | null> {
    const output: EventQueryResultsMap = new Map();

    const processInstanceQuery = async (
      instanceID: string,
      cameraIDs?: Set<string>,
    ): Promise<void> => {
      if (!cameraIDs || !cameraIDs.size) {
        return;
      }
      const instanceQuery = { ...query, cameraIDs: cameraIDs };
      const cachedResult =
        engineOptions?.useCache ?? true ? this._requestCache.get(instanceQuery) : null;
      if (cachedResult) {
        output.set(query, cachedResult as EventQueryResults);
        return;
      }

      const nativeQuery: NativeFrigateEventQuery = {
        instance_id: instanceID,
        cameras: Array.from(this._getFrigateCameraNamesForCameraIDs(store, cameraIDs)),
        ...(query.what && { labels: Array.from(query.what) }),
        ...(query.where && { zones: Array.from(query.where) }),
        ...(query.tags && { sub_labels: Array.from(query.tags) }),
        ...(query.end && { before: Math.floor(query.end.getTime() / 1000) }),
        ...(query.start && { after: Math.floor(query.start.getTime() / 1000) }),
        ...(query.limit && { limit: query.limit }),
        ...(query.hasClip && { has_clip: query.hasClip }),
        ...(query.hasSnapshot && { has_snapshot: query.hasSnapshot }),
        ...(query.favorite && { favorites: query.favorite }),
        limit: query?.limit ?? CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT,
      };

      const result: FrigateEventQueryResults = {
        type: QueryResultsType.Event,
        engine: Engine.Frigate,
        instanceID: instanceID,
        events: await getEvents(hass, nativeQuery),
        expiry: add(new Date(), { seconds: EVENT_REQUEST_CACHE_MAX_AGE_SECONDS }),
        cached: false,
      };

      if (engineOptions?.useCache ?? true) {
        this._requestCache.set(query, { ...result, cached: true }, result.expiry);
      }
      output.set(instanceQuery, result);
    };

    // Frigate allows multiple cameras to be searched for events in a single
    // query. Break them down into groups of cameras per Frigate instance, then
    // query once per instance for all cameras in that instance.
    const instances = this._buildInstanceToCameraIDMapFromQuery(store, query.cameraIDs);

    await Promise.all(
      Array.from(instances.keys()).map((instanceID) =>
        processInstanceQuery(instanceID, instances.get(instanceID)),
      ),
    );
    return output.size ? output : null;
  }

  public async getRecordings(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: RecordingQuery,
    engineOptions?: EngineOptions,
  ): Promise<RecordingQueryResultsMap | null> {
    const output: RecordingQueryResultsMap = new Map();

    const processQuery = async (
      baseQuery: RecordingQuery,
      cameraID: string,
    ): Promise<void> => {
      const query = { ...baseQuery, cameraIDs: new Set([cameraID]) };
      const cachedResult =
        engineOptions?.useCache ?? true ? this._requestCache.get(query) : null;
      if (cachedResult) {
        output.set(query, cachedResult as RecordingQueryResults);
        return;
      }

      const cameraConfig = this._getQueryableCameraConfig(store, cameraID);
      if (!cameraConfig || !cameraConfig.frigate.camera_name) {
        return;
      }

      const recordingSummary = await getRecordingsSummary(
        hass,
        cameraConfig.frigate.client_id,
        cameraConfig.frigate.camera_name,
      );

      let recordings: FrigateRecording[] = [];

      for (const dayData of recordingSummary ?? []) {
        for (const hourData of dayData.hours) {
          const hour = add(dayData.day, { hours: hourData.hour });
          const startHour = startOfHour(hour);
          const endHour = endOfHour(hour);
          if (
            (!query.start || startHour >= query.start) &&
            (!query.end || endHour <= query.end)
          ) {
            recordings.push({
              cameraID: cameraID,
              startTime: startHour,
              endTime: endHour,
              events: hourData.events,
            });
          }
        }
      }

      if (query.limit !== undefined) {
        // Frigate does not natively support a way to limit recording searches so
        // this simulates it.
        recordings = orderBy(
          recordings,
          (recording: FrigateRecording) => recording.startTime,
          'desc',
        ).slice(0, query.limit);
      }

      const result: FrigateRecordingQueryResults = {
        type: QueryResultsType.Recording,
        engine: Engine.Frigate,
        instanceID: cameraConfig.frigate.client_id,
        recordings: recordings,
        expiry: add(new Date(), {
          seconds: RECORDING_SUMMARY_REQUEST_CACHE_MAX_AGE_SECONDS,
        }),
        cached: false,
      };
      if (engineOptions?.useCache ?? true) {
        this._requestCache.set(query, { ...result, cached: true }, result.expiry);
      }
      output.set(query, result);
    };

    // Frigate recordings can only be queried for a single camera, so fan out
    // the inbound query into multiple outbound queries.
    await Promise.all(
      Array.from(query.cameraIDs).map((cameraID) => processQuery(query, cameraID)),
    );
    return output.size ? output : null;
  }

  public async getRecordingSegments(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: RecordingSegmentsQuery,
    engineOptions?: EngineOptions,
  ): Promise<RecordingSegmentsQueryResultsMap | null> {
    const output: RecordingSegmentsQueryResultsMap = new Map();

    const processQuery = async (
      baseQuery: RecordingSegmentsQuery,
      cameraID: string,
    ): Promise<void> => {
      const query = { ...baseQuery, cameraIDs: new Set([cameraID]) };
      const cameraConfig = this._getQueryableCameraConfig(store, cameraID);
      if (!cameraConfig || !cameraConfig.frigate.camera_name) {
        return;
      }

      const range: DateRange = { start: query.start, end: query.end };

      // A note on Frigate Recording Segments:
      // - There is an internal cache at the engine level for segments to allow
      //   caching "within an existing query" (e.g. if we already cached hour
      //   1-8, we will avoid a fetch if we request hours 2-3 even though the
      //   query is different -- the segments won't be). This is since the
      //   volume of data in segment transfers can be high, and the segments can
      //   be used in high frequency situations (e.g. video seeking).
      const cachedSegments =
        engineOptions?.useCache ?? true
          ? this._recordingSegmentsCache.get(cameraID, range)
          : null;
      if (cachedSegments) {
        output.set(query, <FrigateRecordingSegmentsQueryResults>{
          type: QueryResultsType.RecordingSegments,
          engine: Engine.Frigate,
          instanceID: cameraConfig.frigate.client_id,
          segments: cachedSegments,
          cached: true,
        });
        return;
      }

      const request: NativeFrigateRecordingSegmentsQuery = {
        instance_id: cameraConfig.frigate.client_id,
        camera: cameraConfig.frigate.camera_name,
        after: Math.floor(query.start.getTime() / 1000),
        before: Math.floor(query.end.getTime() / 1000),
      };

      const segments = await getRecordingSegments(hass, request);

      if (engineOptions?.useCache ?? true) {
        this._recordingSegmentsCache.add(cameraID, range, segments);
      }

      output.set(query, <FrigateRecordingSegmentsQueryResults>{
        type: QueryResultsType.RecordingSegments,
        engine: Engine.Frigate,
        instanceID: cameraConfig.frigate.client_id,
        segments: segments,
        cached: false,
      });
    };

    // Frigate recording segments can only be queried for a single camera, so
    // fan out the inbound query into multiple outbound queries.
    await Promise.all(
      Array.from(query.cameraIDs).map((cameraID) => processQuery(query, cameraID)),
    );

    runWhenIdleIfSupported(() => this._throttledSegmentGarbageCollector(hass, store));
    return output.size ? output : null;
  }

  protected _getCameraIDMatch(
    store: CameraManagerReadOnlyConfigStore,
    query: CameraQuery,
    instanceID: string,
    cameraName: string,
  ): string | null {
    // If the query is only for a single cameraID, all results are assumed to
    // belong to it for performance reasons. Otherwise, we need to map the
    // instanceID and camera name for the known cameras, and get the precise
    // cameraID that matches the expected instance ID / camera name.
    if (query.cameraIDs.size === 1) {
      return [...query.cameraIDs][0];
    }
    for (const [cameraID, cameraConfig] of store.getCameraConfigEntries()) {
      if (
        cameraConfig.frigate.client_id === instanceID &&
        cameraConfig.frigate.camera_name === cameraName
      ) {
        return cameraID;
      }
    }
    return null;
  }

  public generateMediaFromEvents(
    _hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: EventQuery,
    results: QueryReturnType<EventQuery>,
  ): ViewMedia[] | null {
    if (!FrigateQueryResultsClassifier.isFrigateEventQueryResults(results)) {
      return null;
    }

    const output: ViewMedia[] = [];
    for (const event of results.events) {
      const cameraID = this._getCameraIDMatch(
        store,
        query,
        results.instanceID,
        event.camera,
      );
      if (!cameraID) {
        continue;
      }
      const cameraConfig = this._getQueryableCameraConfig(store, cameraID);
      if (!cameraConfig) {
        continue;
      }
      let mediaType: ViewMediaType | null = null;
      if (
        !query.hasClip &&
        !query.hasSnapshot &&
        (event.has_clip || event.has_snapshot)
      ) {
        mediaType = event.has_clip ? ViewMediaType.Clip : ViewMediaType.Snapshot;
      } else if (query.hasSnapshot && event.has_snapshot) {
        mediaType = ViewMediaType.Snapshot;
      } else if (query.hasClip && event.has_clip) {
        mediaType = ViewMediaType.Clip;
      }
      if (!mediaType) {
        continue;
      }
      const media = FrigateViewMediaFactory.createEventViewMedia(
        mediaType,
        cameraID,
        cameraConfig,
        event,
        event.sub_label ? this._splitSubLabels(event.sub_label) : undefined,
      );
      if (media) {
        output.push(media);
      }
    }
    return output;
  }

  public generateMediaFromRecordings(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    _query: RecordingQuery,
    results: QueryReturnType<RecordingQuery>,
  ): ViewMedia[] | null {
    if (!FrigateQueryResultsClassifier.isFrigateRecordingQueryResults(results)) {
      return null;
    }

    const output: ViewMedia[] = [];
    for (const recording of results.recordings) {
      const cameraConfig = this._getQueryableCameraConfig(store, recording.cameraID);
      if (!cameraConfig) {
        continue;
      }
      const media = FrigateViewMediaFactory.createRecordingViewMedia(
        recording.cameraID,
        recording,
        cameraConfig,
        this.getCameraMetadata(hass, cameraConfig).title,
      );
      if (media) {
        output.push(media);
      }
    }
    return output;
  }

  public getQueryResultMaxAge(query: CameraQuery): number | null {
    if (query.type === QueryType.Event) {
      return EVENT_REQUEST_CACHE_MAX_AGE_SECONDS;
    } else if (query.type === QueryType.Recording) {
      return RECORDING_SUMMARY_REQUEST_CACHE_MAX_AGE_SECONDS;
    }
    return null;
  }

  public async getMediaSeekTime(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    media: ViewMedia,
    target: Date,
    engineOptions?: EngineOptions,
  ): Promise<number | null> {
    const start = media.getStartTime();
    const end = media.getEndTime();
    const cameraID = media.getCameraID();

    if (!start || !end || target < start || target > end || !cameraID) {
      return null;
    }

    const query: RecordingSegmentsQuery = {
      cameraIDs: new Set([cameraID]),
      start: start,
      end: end,
      type: QueryType.RecordingSegments,
    };

    const results = await this.getRecordingSegments(hass, store, query, engineOptions);

    if (results) {
      return this._getSeekTimeInSegments(
        start,
        target,
        // There will only be a single result since Frigate recording segments
        // searches are per camera which is specified singularly above.
        Array.from(results.values())[0].segments,
      );
    }
    return null;
  }

  protected _getQueryableCameraConfig(
    store: CameraManagerReadOnlyConfigStore,
    cameraID: string,
  ): CameraConfig | null {
    const cameraConfig = store.getCameraConfig(cameraID);
    if (!cameraConfig || isBirdseye(cameraConfig)) {
      return null;
    }
    return cameraConfig;
  }

  protected _splitSubLabels(input: string): string[] {
    // A note on Frigate sub_labels: As of Frigate v0.12 sub_labels is a string
    // (not an array) per event, but may contain comma-separated values (e.g.
    // double-take (https://github.com/jakowenko/double-take) identifying two
    // people in the same photo). When we search for multiple sub_labels, the
    // integration will comma-join them together, then the Frigate backend will
    // do the magic to match exactly or against a comma-separated part.
    return input.split(',').map((s) => s.trim());
  }

  public async getMediaMetadata(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: MediaMetadataQuery,
    engineOptions?: EngineOptions,
  ): Promise<MediaMetadataQueryResultsMap | null> {
    const output: MediaMetadataQueryResultsMap = new Map();
    if ((engineOptions?.useCache ?? true) && this._requestCache.has(query)) {
      const cachedResult = <MediaMetadataQueryResults | null>(
        this._requestCache.get(query)
      );
      if (cachedResult) {
        output.set(query, cachedResult as MediaMetadataQueryResults);
        return output;
      }
    }

    const what: Set<string> = new Set();
    const where: Set<string> = new Set();
    const days: Set<string> = new Set();
    const tags: Set<string> = new Set();

    const instances = this._buildInstanceToCameraIDMapFromQuery(store, query.cameraIDs);

    const processEventSummary = async (
      instanceID: string,
      cameraIDs: Set<string>,
    ): Promise<void> => {
      const cameraNames = this._getFrigateCameraNamesForCameraIDs(store, cameraIDs);
      for (const entry of await getEventSummary(hass, instanceID)) {
        if (!cameraNames.has(entry.camera)) {
          // If this entry applies to a camera that *is* in this Frigate
          // instance, but is *not* a configured camera in the card, skip it.
          continue;
        }
        if (entry.label) {
          what.add(entry.label);
        }
        if (entry.zones.length) {
          entry.zones.forEach(where.add, where);
        }
        if (entry.day) {
          days.add(entry.day);
        }
        if (entry.sub_label) {
          this._splitSubLabels(entry.sub_label).forEach(tags.add, tags);
        }
      }
    };

    const processRecordings = async (cameraIDs: Set<string>): Promise<void> => {
      const recordings = await this.getRecordings(
        hass,
        store,
        {
          type: QueryType.Recording,
          cameraIDs: cameraIDs,
        },
        engineOptions,
      );
      if (!recordings) {
        return;
      }

      for (const result of recordings.values()) {
        if (!FrigateQueryResultsClassifier.isFrigateRecordingQueryResults(result)) {
          continue;
        }

        for (const recording of result.recordings) {
          // Frigate recordings are always 1 hour long, i.e. never span a day.
          days.add(formatDate(recording.startTime));
        }
      }
    };

    await allPromises([...instances.entries()], ([instanceID, cameraIDs]) =>
      (async () => {
        await Promise.all([
          processEventSummary(instanceID, cameraIDs),
          processRecordings(cameraIDs),
        ]);
      })(),
    );

    const result: MediaMetadataQueryResults = {
      type: QueryResultsType.MediaMetadata,
      engine: Engine.Frigate,
      metadata: {
        ...(what.size && { what: what }),
        ...(where.size && { where: where }),
        ...(days.size && { days: days }),
        ...(tags.size && { tags: tags }),
      },
      expiry: add(new Date(), { seconds: MEDIA_METADATA_REQUEST_CACHE_AGE_SECONDS }),
      cached: false,
    };

    if (engineOptions?.useCache ?? true) {
      this._requestCache.set(query, { ...result, cached: true }, result.expiry);
    }
    output.set(query, result);
    return output;
  }

  /**
   * Garbage collect recording segments that no longer feature in the recordings
   * returned by the Frigate backend.
   */
  protected async _garbageCollectSegments(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
  ): Promise<void> {
    const cameraIDs = this._recordingSegmentsCache.getCameraIDs();
    const recordingQuery: RecordingQuery = {
      cameraIDs: new Set(cameraIDs),
      type: QueryType.Recording,
    };

    // Performance: _recordingSegments is potentially very large (e.g. 10K - 1M
    // items) and each item must be examined, so care required here to stick to
    // nothing worse than O(n) performance.
    const getHourID = (cameraID: string, startTime: Date): string => {
      return `${cameraID}/${startTime.getDate()}/${startTime.getHours()}`;
    };

    const results = await this.getRecordings(hass, store, recordingQuery);
    if (!results) {
      return;
    }

    for (const [query, result] of results) {
      if (!FrigateQueryResultsClassifier.isFrigateRecordingQueryResults(result)) {
        continue;
      }

      const goodHours: Set<string> = new Set();
      for (const recording of result.recordings) {
        goodHours.add(getHourID(recording.cameraID, recording.startTime));
      }

      // Frigate recordings are always executed individually, so there'll only
      // be a single results.
      const cameraID = Array.from(query.cameraIDs)[0];
      this._recordingSegmentsCache.expireMatches(
        cameraID,
        (segment: RecordingSegment) => {
          const hourID = getHourID(cameraID, fromUnixTime(segment.start_time));
          // ~O(1) lookup time for a JS set.
          return !goodHours.has(hourID);
        },
      );
    }
  }

  /**
   * Get the number of seconds to seek into a video stream consisting of the
   * provided segments to reach the target time provided.
   * @param startTime The earliest allowable time to seek from.
   * @param targetTime Target time.
   * @param segments An array of segments dataset items. Must be sorted from oldest to youngest.
   * @returns
   */
  protected _getSeekTimeInSegments(
    startTime: Date,
    targetTime: Date,
    segments: RecordingSegment[],
  ): number | null {
    if (!segments.length) {
      return null;
    }
    let seekMilliseconds = 0;

    // Inspired by: https://github.com/blakeblackshear/frigate/blob/release-0.11.0/web/src/routes/Recording.jsx#L27
    for (const segment of segments) {
      const segmentStart = fromUnixTime(segment.start_time);
      if (segmentStart > targetTime) {
        break;
      }
      const segmentEnd = fromUnixTime(segment.end_time);
      const start = segmentStart < startTime ? startTime : segmentStart;
      const end = segmentEnd > targetTime ? targetTime : segmentEnd;
      seekMilliseconds += end.getTime() - start.getTime();
    }
    return seekMilliseconds / 1000;
  }

  public getMediaCapabilities(media: ViewMedia): ViewItemCapabilities {
    return {
      canFavorite: ViewItemClassifier.isEvent(media),
      canDownload: true,
    };
  }

  public getCameraMetadata(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): CameraManagerCameraMetadata {
    return {
      ...super.getCameraMetadata(hass, cameraConfig),
      title:
        cameraConfig.title ??
        getEntityTitle(hass, cameraConfig.camera_entity) ??
        getEntityTitle(hass, cameraConfig.webrtc_card?.entity) ??
        prettifyTitle(cameraConfig.frigate?.camera_name) ??
        cameraConfig.id ??
        '',
      engineIcon: 'frigate',
    };
  }

  public getCameraEndpoints(
    cameraConfig: CameraConfig,
    context?: CameraEndpointsContext,
  ): CameraEndpoints | null {
    const getUIEndpoint = (): Endpoint | null => {
      if (!cameraConfig.frigate.url) {
        return null;
      }
      if (!cameraConfig.frigate.camera_name) {
        return { endpoint: cameraConfig.frigate.url };
      }

      const cameraURL =
        `${cameraConfig.frigate.url}/cameras/` + cameraConfig.frigate.camera_name;

      if (context?.view === 'live') {
        return { endpoint: cameraURL };
      }

      const eventsURL =
        `${cameraConfig.frigate.url}/events?camera=` + cameraConfig.frigate.camera_name;
      const recordingsURL =
        `${cameraConfig.frigate.url}/recording/` + cameraConfig.frigate.camera_name;

      // If media is available, use it since it may result in a more precisely
      // correct URL.
      switch (context?.media?.getMediaType()) {
        case 'clip':
        case 'snapshot':
          return { endpoint: eventsURL };
        case 'recording':
          const startTime = context.media.getStartTime();
          if (startTime) {
            return { endpoint: recordingsURL + format(startTime, 'yyyy-MM-dd/HH') };
          }
      }

      // Otherwise, fall back to just using the view if we have that.
      switch (context?.view) {
        case 'clip':
        case 'clips':
        case 'snapshots':
        case 'snapshot':
          return { endpoint: eventsURL };
        case 'recording':
        case 'recordings':
          return { endpoint: recordingsURL };
      }

      return {
        endpoint: cameraURL,
      };
    };

    const getJSMPEG = (): Endpoint | null => {
      return {
        endpoint:
          `/api/frigate/${cameraConfig.frigate.client_id}` +
          `/jsmpeg/${cameraConfig.frigate.camera_name}`,
        sign: true,
      };
    };

    const ui = getUIEndpoint();
    const go2rtc = getDefaultGo2RTCEndpoint(cameraConfig, {
      url:
        cameraConfig.go2rtc?.url ??
        // go2rtc is exposed by the Frigate integration under the (slightly
        // misleading) 'mse' path, even though that path can serve all go2rtc
        // modes.
        `/api/frigate/${cameraConfig.frigate.client_id}/mse`,
      stream: cameraConfig.go2rtc?.stream ?? cameraConfig.frigate.camera_name,
    });
    const jsmpeg = getJSMPEG();

    return {
      ...super.getCameraEndpoints(cameraConfig, context),
      ...(ui && { ui: ui }),
      ...(go2rtc && { go2rtc: go2rtc }),
      ...(jsmpeg && { jsmpeg: jsmpeg }),
    };
  }
}



================================================
FILE: src/camera-manager/frigate/event-watcher.ts
================================================
import { HomeAssistant } from '../../ha/types';
import { FrigateEventChange, frigateEventChangeSchema } from './types';

export interface FrigateEventWatcherRequest {
  instanceID: string;
  matcher?(event: FrigateEventChange): boolean;
  callback(event: FrigateEventChange): void;
}

export interface FrigateEventWatcherSubscriptionInterface {
  subscribe(hass: HomeAssistant, request: FrigateEventWatcherRequest): Promise<void>;
  unsubscribe(callback: FrigateEventWatcherRequest): void;
}

type SubscriptionUnsubscribe = () => Promise<void>;

export class FrigateEventWatcher implements FrigateEventWatcherSubscriptionInterface {
  protected _requests: FrigateEventWatcherRequest[] = [];
  protected _unsubscribeCallback: Record<string, SubscriptionUnsubscribe> = {};

  public async subscribe(
    hass: HomeAssistant,
    request: FrigateEventWatcherRequest,
  ): Promise<void> {
    const shouldSubscribe = !this._hasSubscribers(request.instanceID);
    this._requests.push(request);
    if (shouldSubscribe) {
      this._unsubscribeCallback[request.instanceID] =
        await hass.connection.subscribeMessage<string>(
          (data) => this._receiveHandler(request.instanceID, data),
          { type: 'frigate/events/subscribe', instance_id: request.instanceID },
        );
    }
  }

  public async unsubscribe(request: FrigateEventWatcherRequest): Promise<void> {
    this._requests = this._requests.filter(
      (existingRequest) => existingRequest !== request,
    );

    if (!this._hasSubscribers(request.instanceID)) {
      await this._unsubscribeCallback[request.instanceID]();
      delete this._unsubscribeCallback[request.instanceID];
    }
  }

  protected _hasSubscribers(instanceID: string): boolean {
    return !!this._requests.filter((request) => request.instanceID === instanceID)
      .length;
  }

  protected _receiveHandler(instanceID: string, data: string): void {
    let json: unknown;
    try {
      json = JSON.parse(data);
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (e) {
      console.warn('Received non-JSON payload as Frigate event', data);
      return;
    }

    const parsedEvent = frigateEventChangeSchema.safeParse(json);
    if (!parsedEvent.success) {
      console.warn('Received malformed Frigate event from Home Assistant', data);
      return;
    }

    for (const request of this._requests) {
      if (
        request.instanceID === instanceID &&
        (!request.matcher || request.matcher(parsedEvent.data))
      ) {
        request.callback(parsedEvent.data);
      }
    }
  }
}



================================================
FILE: src/camera-manager/frigate/media-classifier.ts
================================================
import { ViewMedia } from '../../view/item';
import { FrigateEventViewMedia, FrigateRecordingViewMedia } from './media';

export class FrigateViewMediaClassifier {
  public static isFrigateMedia(
    media: ViewMedia,
  ): media is FrigateEventViewMedia | FrigateRecordingViewMedia {
    return this.isFrigateEvent(media) || this.isFrigateRecording(media);
  }
  public static isFrigateEvent(media: ViewMedia): media is FrigateEventViewMedia {
    return media instanceof FrigateEventViewMedia;
  }
  public static isFrigateRecording(
    media: ViewMedia,
  ): media is FrigateRecordingViewMedia {
    return media instanceof FrigateRecordingViewMedia;
  }
}



================================================
FILE: src/camera-manager/frigate/media.ts
================================================
import { fromUnixTime } from 'date-fns';
import { isEqual } from 'lodash-es';
import { CameraConfig } from '../../config/schema/cameras';
import {
  EventViewMedia,
  RecordingViewMedia,
  VideoContentType,
  ViewMedia,
  ViewMediaType,
} from '../../view/item';
import { FrigateEvent, FrigateRecording } from './types';
import {
  getEventMediaContentID,
  getEventThumbnailURL,
  getEventTitle,
  getRecordingID,
  getRecordingMediaContentID,
  getRecordingTitle,
} from './util';

export class FrigateEventViewMedia extends ViewMedia implements EventViewMedia {
  protected _event: FrigateEvent;
  protected _contentID: string;
  protected _thumbnail: string;
  protected _subLabels: string[] | null;

  constructor(
    mediaType: ViewMediaType,
    cameraID: string,
    event: FrigateEvent,
    contentID: string,
    thumbnail: string,
    // See 'A note on Frigate sub_labels' in engine-frigate.ts for more
    // details about why sub-labels are treated specially. By taking in
    // subLabels as an array here, we can keep a single place that splits
    // sublabels (`_splitSubLabels` in engine-frigate.ts).
    subLabels?: string[],
  ) {
    super(mediaType, { cameraID });
    this._event = event;
    this._contentID = contentID;
    this._thumbnail = thumbnail;
    this._subLabels = subLabels ?? null;
  }

  public getStartTime(): Date {
    return fromUnixTime(this._event.start_time);
  }
  public getEndTime(): Date | null {
    return this._event.end_time ? fromUnixTime(this._event.end_time) : null;
  }
  public inProgress(): boolean | null {
    // In Frigate, events/recordings always have end times unless they are in
    // progress.
    return !this.getEndTime();
  }
  public getVideoContentType(): VideoContentType | null {
    return VideoContentType.HLS;
  }
  public getID(): string {
    return this._event.id;
  }
  public getContentID(): string {
    return this._contentID;
  }
  public getTitle(): string | null {
    return getEventTitle(this._event);
  }
  public getThumbnail(): string | null {
    return this._thumbnail;
  }
  public isFavorite(): boolean | null {
    return this._event.retain_indefinitely ?? null;
  }
  public setFavorite(favorite: boolean): void {
    this._event.retain_indefinitely = favorite;
  }
  public getWhat(): string[] | null {
    return [this._event.label];
  }
  public getWhere(): string[] | null {
    const zones = this._event.zones;
    return zones.length ? zones : null;
  }
  public getScore(): number | null {
    return this._event.top_score;
  }
  public getTags(): string[] | null {
    return this._subLabels;
  }
  public isGroupableWith(that: EventViewMedia): boolean {
    return (
      this.getMediaType() === that.getMediaType() &&
      isEqual(this.getWhere(), that.getWhere()) &&
      isEqual(this.getWhat(), that.getWhat())
    );
  }
}

export class FrigateRecordingViewMedia extends ViewMedia implements RecordingViewMedia {
  protected _recording: FrigateRecording;
  protected _id: string;
  protected _contentID: string;
  protected _title: string;

  constructor(
    mediaType: ViewMediaType,
    cameraID: string,
    recording: FrigateRecording,
    id: string,
    contentID: string,
    title: string,
  ) {
    super(mediaType, { cameraID });
    this._recording = recording;
    this._id = id;
    this._contentID = contentID;
    this._title = title;
  }

  public getID(): string {
    return this._id;
  }
  public getStartTime(): Date {
    return this._recording.startTime;
  }
  public getEndTime(): Date {
    return this._recording.endTime;
  }
  public inProgress(): boolean | null {
    // In Frigate, events/recordings always have end times unless they are in
    // progress.
    return !this.getEndTime();
  }
  public getVideoContentType(): VideoContentType | null {
    return VideoContentType.HLS;
  }
  public getContentID(): string | null {
    return this._contentID;
  }
  public getTitle(): string | null {
    return this._title;
  }
  public getEventCount(): number {
    return this._recording.events;
  }
}

export class FrigateViewMediaFactory {
  static createEventViewMedia(
    mediaType: ViewMediaType,
    cameraID: string,
    cameraConfig: CameraConfig,
    event: FrigateEvent,
    subLabels?: string[],
  ): FrigateEventViewMedia | null {
    if (
      (mediaType === 'clip' && !event.has_clip) ||
      (mediaType === 'snapshot' && !event.has_snapshot) ||
      !cameraConfig.frigate.client_id ||
      !cameraConfig.frigate.camera_name
    ) {
      return null;
    }

    return new FrigateEventViewMedia(
      mediaType,
      cameraID,
      event,
      getEventMediaContentID(
        cameraConfig.frigate.client_id,
        cameraConfig.frigate.camera_name,
        event,
        mediaType === 'clip' ? 'clips' : 'snapshots',
      ),
      getEventThumbnailURL(cameraConfig.frigate.client_id, event),
      subLabels,
    );
  }

  static createRecordingViewMedia(
    cameraID: string,
    recording: FrigateRecording,
    cameraConfig: CameraConfig,
    cameraTitle: string,
  ): FrigateRecordingViewMedia | null {
    if (!cameraConfig.frigate.client_id || !cameraConfig.frigate.camera_name) {
      return null;
    }

    return new FrigateRecordingViewMedia(
      ViewMediaType.Recording,
      cameraID,
      recording,
      getRecordingID(cameraConfig, recording),
      getRecordingMediaContentID(
        cameraConfig.frigate.client_id,
        cameraConfig.frigate.camera_name,
        recording,
      ),
      getRecordingTitle(cameraTitle, recording),
    );
  }
}



================================================
FILE: src/camera-manager/frigate/requests.ts
================================================
import { HomeAssistant } from '../../ha/types';
import { homeAssistantWSRequest } from '../../ha/ws-request';
import { localize } from '../../localize/localize';
import { AdvancedCameraCardError } from '../../types';
import { RecordingSegment } from '../types';
import {
  EventSummary,
  eventSummarySchema,
  FrigateEvent,
  frigateEventsSchema,
  PTZInfo,
  ptzInfoSchema,
  recordingSegmentsSchema,
  RecordingSummary,
  recordingSummarySchema,
  RetainResult,
  retainResultSchema,
} from './types';

/**
 * Get the recordings summary. May throw.
 * @param hass The Home Assistant object.
 * @param clientID The Frigate clientID.
 * @param camera_name The Frigate camera name.
 * @returns A RecordingSummary object.
 */
export const getRecordingsSummary = async (
  hass: HomeAssistant,
  clientID: string,
  camera_name: string,
): Promise<RecordingSummary> => {
  return (await homeAssistantWSRequest(
    hass,
    recordingSummarySchema,
    {
      type: 'frigate/recordings/summary',
      instance_id: clientID,
      camera: camera_name,

      // Ask for the summary relative to HA timezone
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1267
      timezone: hass.config.time_zone,
    },
    true,
    // See: https://github.com/colinhacks/zod/pull/1752
  )) as RecordingSummary;
};

export interface NativeFrigateRecordingSegmentsQuery {
  instance_id: string;
  camera: string;
  after: number;
  before: number;
}

/**
 * Get the recording segments. May throw.
 * @param hass The Home Assistant object.
 * @param params The recording segment query parameters.
 * @returns A RecordingSegments object.
 */
export const getRecordingSegments = async (
  hass: HomeAssistant,
  params: NativeFrigateRecordingSegmentsQuery,
): Promise<RecordingSegment[]> => {
  return await homeAssistantWSRequest(
    hass,
    recordingSegmentsSchema,
    {
      type: 'frigate/recordings/get',
      ...params,
    },
    true,
  );
};

/**
 * Request that Frigate retain an event. May throw.
 * @param hass The HomeAssistant object.
 * @param clientID The Frigate clientID.
 * @param eventID The event ID to retain.
 * @param retain `true` to retain or `false` to unretain.
 */
export async function retainEvent(
  hass: HomeAssistant,
  clientID: string,
  eventID: string,
  retain: boolean,
): Promise<void> {
  const retainRequest = {
    type: 'frigate/event/retain',
    instance_id: clientID,
    event_id: eventID,
    retain: retain,
  };
  const response = await homeAssistantWSRequest<RetainResult>(
    hass,
    retainResultSchema,
    retainRequest,
    true,
  );
  if (!response.success) {
    throw new AdvancedCameraCardError(localize('error.failed_retain'), {
      request: retainRequest,
      response: response,
    });
  }
}

export interface NativeFrigateEventQuery {
  instance_id?: string;
  cameras?: string[];
  labels?: string[];
  zones?: string[];
  after?: number;
  before?: number;
  limit?: number;
  has_clip?: boolean;
  has_snapshot?: boolean;
  favorites?: boolean;
}

/**
 * Get events over websocket. May throw.
 * @param hass The Home Assistant object.
 * @param params The events search parameters.
 * @returns An array of 'FrigateEvent's.
 */
export const getEvents = async (
  hass: HomeAssistant,
  params?: NativeFrigateEventQuery,
): Promise<FrigateEvent[]> => {
  return await homeAssistantWSRequest(
    hass,
    frigateEventsSchema,
    {
      type: 'frigate/events/get',
      ...params,
    },
    true,
  );
};

export const getEventSummary = async (
  hass: HomeAssistant,
  clientID: string,
): Promise<EventSummary> => {
  return await homeAssistantWSRequest(
    hass,
    eventSummarySchema,
    {
      type: 'frigate/events/summary',
      instance_id: clientID,

      // Ask for the summary relative to HA timezone
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1267
      timezone: hass.config.time_zone,
    },
    true,
  );
};

export const getPTZInfo = async (
  hass: HomeAssistant,
  clientID: string,
  cameraName: string,
): Promise<PTZInfo> => {
  return await homeAssistantWSRequest(
    hass,
    ptzInfoSchema,
    {
      type: 'frigate/ptz/info',
      instance_id: clientID,
      camera: cameraName,
    },
    true,
  );
};



================================================
FILE: src/camera-manager/frigate/types.ts
================================================
import { z } from 'zod';
import { dayToDate } from '../../utils/basic';
import {
  Engine,
  EventQueryResults,
  RecordingQueryResults,
  RecordingSegmentsQueryResults,
} from '../types';

const dayStringToDate = (arg: unknown): Date | unknown => {
  return typeof arg === 'string' ? dayToDate(arg) : arg;
};

export const eventSchema = z.object({
  camera: z.string(),
  end_time: z.number().nullable(),
  false_positive: z.boolean().nullable(),
  has_clip: z.boolean(),
  has_snapshot: z.boolean(),
  id: z.string(),
  label: z.string(),
  sub_label: z.string().nullable(),
  start_time: z.number(),
  top_score: z.number().nullable(),
  zones: z.string().array(),
  retain_indefinitely: z.boolean().optional(),
});
export const frigateEventsSchema = eventSchema.array();

export type FrigateEvent = z.infer<typeof eventSchema>;

const recordingSummaryHourSchema = z.object({
  hour: z.preprocess((arg) => Number(arg), z.number().min(0).max(23)),
  duration: z.number().min(0),
  events: z.number().min(0),
});

export const recordingSummarySchema = z
  .object({
    day: z.preprocess(dayStringToDate, z.date()),
    events: z.number(),
    hours: recordingSummaryHourSchema.array(),
  })
  .array();
export type RecordingSummary = z.infer<typeof recordingSummarySchema>;

const recordingSegmentSchema = z.object({
  start_time: z.number(),
  end_time: z.number(),
  id: z.string(),
});
export const recordingSegmentsSchema = recordingSegmentSchema.array();

export const retainResultSchema = z.object({
  success: z.boolean(),
  message: z.string(),
});
export type RetainResult = z.infer<typeof retainResultSchema>;

export interface FrigateRecording {
  cameraID: string;
  startTime: Date;
  endTime: Date;
  events: number;
}

export const eventSummarySchema = z
  .object({
    camera: z.string(),
    // Days in RFC3339 format.
    day: z.string(),
    label: z.string(),
    sub_label: z.string().nullable(),
    zones: z.string().array(),
  })
  .array();
export type EventSummary = z.infer<typeof eventSummarySchema>;

export const ptzInfoSchema = z.object({
  name: z.string().optional(),
  features: z.string().array().optional(),
  presets: z.string().array().optional(),
});
export type PTZInfo = z.infer<typeof ptzInfoSchema>;

const frigateEventChangeBeforeAfterSchema = z.object({
  camera: z.string(),
  snapshot: z
    .object({
      frame_time: z.number(),
    })
    .nullable(),
  has_clip: z.boolean(),
  has_snapshot: z.boolean(),
  label: z.string(),
  current_zones: z.string().array(),
});

export const frigateEventChangeSchema = z.object({
  before: frigateEventChangeBeforeAfterSchema,
  after: frigateEventChangeBeforeAfterSchema,
  type: z.enum(['new', 'update', 'end']),
});
export type FrigateEventChange = z.infer<typeof frigateEventChangeSchema>;

// ==============================
// Frigate concrete query results
// ==============================

export interface FrigateEventQueryResults extends EventQueryResults {
  engine: Engine.Frigate;
  instanceID: string;
  events: FrigateEvent[];
}

export interface FrigateRecordingQueryResults extends RecordingQueryResults {
  engine: Engine.Frigate;
  instanceID: string;
  recordings: FrigateRecording[];
}

export interface FrigateRecordingSegmentsQueryResults
  extends RecordingSegmentsQueryResults {
  engine: Engine.Frigate;
  instanceID: string;
}



================================================
FILE: src/camera-manager/frigate/util.ts
================================================
import { toZonedTime } from 'date-fns-tz';
import { CameraConfig } from '../../config/schema/cameras';
import { ClipsOrSnapshots } from '../../types';
import { formatDateAndTime, prettifyTitle } from '../../utils/basic';
import { FrigateEvent, FrigateRecording } from './types';

/**
 * Given an event generate a title.
 * @param event
 */
export const getEventTitle = (event: FrigateEvent): string => {
  const localTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const durationSeconds = Math.round(
    event.end_time
      ? event.end_time - event.start_time
      : Date.now() / 1000 - event.start_time,
  );
  const score = event.top_score !== null ? ` ${Math.round(event.top_score * 100)}%` : '';

  return `${formatDateAndTime(
    toZonedTime(event.start_time * 1000, localTimezone),
  )} [${durationSeconds}s, ${prettifyTitle(event.label)}${score}]`;
};

export const getRecordingTitle = (
  cameraTitle: string,
  recording: FrigateRecording,
): string => {
  return `${cameraTitle} ${formatDateAndTime(recording.startTime)}`;
};

/**
 * Get a thumbnail URL for an event.
 * @param clientId The Frigate client id.
 * @param event The event.
 * @returns A string URL.
 */
export const getEventThumbnailURL = (clientId: string, event: FrigateEvent): string => {
  return `/api/frigate/${clientId}/thumbnail/${event.id}`;
};

/**
 * Get a media content ID for an event.
 * @param clientId The Frigate client id.
 * @param cameraName The Frigate camera name.
 * @param event The Frigate event.
 * @param mediaType The media type required.
 * @returns A string media content id.
 */
export const getEventMediaContentID = (
  clientId: string,
  cameraName: string,
  event: FrigateEvent,
  mediaType: ClipsOrSnapshots,
): string => {
  return `media-source://frigate/${clientId}/event/${mediaType}/${cameraName}/${event.id}`;
};

/**
 * Generate a recording identifier.
 * @param clientId The Frigate client id.
 * @param cameraName The Frigate camera name.
 * @param recording The Frigate recording.
 * @returns A recording identifier.
 */
export const getRecordingMediaContentID = (
  clientId: string,
  cameraName: string,
  recording: FrigateRecording,
): string => {
  return [
    'media-source://frigate',
    clientId,
    'recordings',
    cameraName,
    `${recording.startTime.getFullYear()}-${String(
      recording.startTime.getMonth() + 1,
    ).padStart(2, '0')}-${String(
      String(recording.startTime.getDate()).padStart(2, '0'),
    )}`,
    String(recording.startTime.getHours()).padStart(2, '0'),
  ].join('/');
};

/**
 * Get a recording ID for internal de-duping.
 */
export const getRecordingID = (
  cameraConfig: CameraConfig,
  recording: FrigateRecording,
): string => {
  // ID name is derived from the real camera name (not CameraID) since the
  // recordings for the same camera across multiple zones will be the same and
  // can be dedup'd from this id.
  return `${cameraConfig.frigate?.client_id ?? ''}/${
    cameraConfig.frigate.camera_name ?? ''
  }/${recording.startTime.getTime()}/${recording.endTime.getTime()}`;
};



================================================
FILE: src/camera-manager/generic/engine-generic.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */

import { StateWatcherSubscriptionInterface } from '../../card-controller/hass/state-watcher';
import { CameraConfig } from '../../config/schema/cameras';
import { getEntityTitle } from '../../ha/get-entity-title';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import { ViewMedia } from '../../view/item';
import { ViewItemCapabilities } from '../../view/types';
import { Camera } from '../camera';
import { Capabilities } from '../capabilities';
import { CameraManagerEngine } from '../engine';
import { CameraManagerReadOnlyConfigStore } from '../store';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraEventCallback,
  CameraManagerCameraMetadata,
  CameraQuery,
  Engine,
  EngineOptions,
  EventQuery,
  EventQueryResultsMap,
  MediaMetadataQuery,
  MediaMetadataQueryResultsMap,
  PartialEventQuery,
  PartialRecordingQuery,
  PartialRecordingSegmentsQuery,
  QueryReturnType,
  RecordingQuery,
  RecordingQueryResultsMap,
  RecordingSegmentsQuery,
  RecordingSegmentsQueryResultsMap,
} from '../types';
import { getCameraEntityFromConfig } from '../utils/camera-entity-from-config';
import { getDefaultGo2RTCEndpoint } from '../utils/go2rtc-endpoint';
import { getPTZCapabilitiesFromCameraConfig } from '../utils/ptz';

export class GenericCameraManagerEngine implements CameraManagerEngine {
  protected _eventCallback?: CameraEventCallback;
  protected _stateWatcher: StateWatcherSubscriptionInterface;

  constructor(
    stateWatcher: StateWatcherSubscriptionInterface,
    eventCallback?: CameraEventCallback,
  ) {
    this._stateWatcher = stateWatcher;
    this._eventCallback = eventCallback;
  }

  public getEngineType(): Engine {
    return Engine.Generic;
  }

  public async createCamera(
    _hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): Promise<Camera> {
    return await new Camera(cameraConfig, this, {
      capabilities: new Capabilities(
        {
          'favorite-events': false,
          'favorite-recordings': false,
          'remote-control-entity': true,
          clips: false,
          live: true,
          menu: true,
          recordings: false,
          seek: false,
          snapshots: false,
          substream: true,
          trigger: true,
          ptz: getPTZCapabilitiesFromCameraConfig(cameraConfig) ?? undefined,
        },
        {
          disable: cameraConfig.capabilities?.disable,
          disableExcept: cameraConfig.capabilities?.disable_except,
        },
      ),
      eventCallback: this._eventCallback,
    }).initialize({ stateWatcher: this._stateWatcher });
  }

  public generateDefaultEventQuery(
    _store: CameraManagerReadOnlyConfigStore,
    _cameraIDs: Set<string>,
    _query: PartialEventQuery,
  ): EventQuery[] | null {
    return null;
  }

  public generateDefaultRecordingQuery(
    _store: CameraManagerReadOnlyConfigStore,
    _cameraIDs: Set<string>,
    _query: PartialRecordingQuery,
  ): RecordingQuery[] | null {
    return null;
  }

  public generateDefaultRecordingSegmentsQuery(
    _store: CameraManagerReadOnlyConfigStore,
    _cameraIDs: Set<string>,
    _query: PartialRecordingSegmentsQuery,
  ): RecordingSegmentsQuery[] | null {
    return null;
  }

  public async getEvents(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: EventQuery,
    _engineOptions?: EngineOptions,
  ): Promise<EventQueryResultsMap | null> {
    return null;
  }

  public async getRecordings(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: RecordingQuery,
    _engineOptions?: EngineOptions,
  ): Promise<RecordingQueryResultsMap | null> {
    return null;
  }

  public async getRecordingSegments(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: RecordingSegmentsQuery,
    _engineOptions?: EngineOptions,
  ): Promise<RecordingSegmentsQueryResultsMap | null> {
    return null;
  }

  public generateMediaFromEvents(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: EventQuery,
    _results: QueryReturnType<EventQuery>,
  ): ViewMedia[] | null {
    return null;
  }

  public generateMediaFromRecordings(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: RecordingQuery,
    _results: QueryReturnType<RecordingQuery>,
  ): ViewMedia[] | null {
    return null;
  }

  public async getMediaDownloadPath(
    _hass: HomeAssistant,
    _cameraConfig: CameraConfig,
    _media: ViewMedia,
  ): Promise<Endpoint | null> {
    return null;
  }

  public async favoriteMedia(
    _hass: HomeAssistant,
    _cameraConfig: CameraConfig,
    _media: ViewMedia,
    _favorite: boolean,
  ): Promise<void> {
    return;
  }

  public getQueryResultMaxAge(_query: CameraQuery): number | null {
    return null;
  }

  public async getMediaSeekTime(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _media: ViewMedia,
    _target: Date,
    _engineOptions?: EngineOptions,
  ): Promise<number | null> {
    return null;
  }

  public async getMediaMetadata(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: MediaMetadataQuery,
    _engineOptions?: EngineOptions,
  ): Promise<MediaMetadataQueryResultsMap | null> {
    return null;
  }

  public getCameraMetadata(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): CameraManagerCameraMetadata {
    const cameraEntity = getCameraEntityFromConfig(cameraConfig);
    return {
      title:
        cameraConfig.title ??
        getEntityTitle(hass, cameraConfig.camera_entity) ??
        getEntityTitle(hass, cameraConfig.webrtc_card?.entity) ??
        cameraConfig.id ??
        '',
      icon: {
        entity: cameraEntity ?? undefined,
        icon: cameraConfig.icon,
        fallback: 'mdi:video',
      },
    };
  }

  public getMediaCapabilities(_media: ViewMedia): ViewItemCapabilities | null {
    return null;
  }

  public getCameraEndpoints(
    cameraConfig: CameraConfig,
    _context?: CameraEndpointsContext,
  ): CameraEndpoints | null {
    const getWebRTCCard = (): Endpoint | null => {
      // The user may override this in their webrtc_card configuration.
      const endpoint = cameraConfig.camera_entity ? cameraConfig.camera_entity : null;
      return endpoint ? { endpoint: endpoint } : null;
    };

    const go2rtc = getDefaultGo2RTCEndpoint(cameraConfig);
    const webrtcCard = getWebRTCCard();

    return go2rtc || webrtcCard
      ? {
          ...(go2rtc && { go2rtc: go2rtc }),
          ...(webrtcCard && { webrtcCard: webrtcCard }),
        }
      : null;
  }
}



================================================
FILE: src/camera-manager/motioneye/camera.ts
================================================
import { BrowseMediaCamera } from '../browse-media/camera';
import { CameraProxyConfig } from '../types';

export class MotionEyeCamera extends BrowseMediaCamera {
  public getProxyConfig(): CameraProxyConfig {
    return {
      ...super.getProxyConfig(),

      // For motionEye, media is always proxied unless explicitly turned off.
      media: this._config.proxy.media === 'auto' ? true : this._config.proxy.media,
    };
  }
}



================================================
FILE: src/camera-manager/motioneye/engine-motioneye.ts
================================================
import { add, endOfDay, parse, startOfDay } from 'date-fns';
import { orderBy } from 'lodash-es';
import { CameraConfig } from '../../config/schema/cameras';
import { getViewMediaFromBrowseMediaArray } from '../../ha/browse-media/browse-media-to-view-media';
import {
  BROWSE_MEDIA_CACHE_SECONDS,
  BrowseMedia,
  BrowseMediaCache,
  BrowseMediaMetadata,
  MEDIA_CLASS_IMAGE,
  MEDIA_CLASS_VIDEO,
  RichBrowseMedia,
} from '../../ha/browse-media/types';
import { BrowseMediaStep, BrowseMediaTarget } from '../../ha/browse-media/walker';
import { isMediaWithinDates } from '../../ha/browse-media/within-dates';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import { allPromises, formatDate, isValidDate } from '../../utils/basic';
import { ViewMedia } from '../../view/item';
import { BrowseMediaCamera } from '../browse-media/camera';
import { BrowseMediaCameraManagerEngine } from '../browse-media/engine-browse-media';
import { Camera } from '../camera';
import { Capabilities } from '../capabilities';
import { CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT } from '../engine';
import { CameraManagerReadOnlyConfigStore } from '../store';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraManagerCameraMetadata,
  Engine,
  EngineOptions,
  EventQuery,
  EventQueryResults,
  EventQueryResultsMap,
  MediaMetadataQuery,
  MediaMetadataQueryResults,
  MediaMetadataQueryResultsMap,
  QueryResults,
  QueryResultsType,
  QueryReturnType,
} from '../types';
import { getPTZCapabilitiesFromCameraConfig } from '../utils/ptz';
import { MotionEyeCamera } from './camera';
import { MotionEyeEventQueryResults } from './types';

class MotionEyeQueryResultsClassifier {
  public static isMotionEyeEventQueryResults(
    results: QueryResults,
  ): results is MotionEyeEventQueryResults {
    return (
      results.engine === Engine.MotionEye && results.type === QueryResultsType.Event
    );
  }
}

const MOTIONEYE_REPL_SUBSTITUTIONS: Record<string, string> = {
  '%Y': 'yyyy',
  '%m': 'MM',
  '%d': 'dd',
  '%H': 'HH',
  '%M': 'mm',
  '%S': 'ss',
};
const MOTIONEYE_REPL_REGEXP = new RegExp(/(%Y|%m|%d|%H|%M|%S)/g);

export class MotionEyeCameraManagerEngine extends BrowseMediaCameraManagerEngine {
  protected _directoryCache = new BrowseMediaCache<BrowseMediaMetadata>();
  protected _fileCache = new BrowseMediaCache<BrowseMediaMetadata>();

  public getEngineType(): Engine {
    return Engine.MotionEye;
  }

  public async createCamera(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): Promise<Camera> {
    const camera = new MotionEyeCamera(cameraConfig, this, {
      capabilities: new Capabilities(
        {
          'favorite-events': false,
          'favorite-recordings': false,
          'remote-control-entity': true,
          clips: true,
          live: true,
          menu: true,
          recordings: false,
          seek: false,
          snapshots: true,
          substream: true,
          trigger: true,
          ptz: getPTZCapabilitiesFromCameraConfig(cameraConfig) ?? undefined,
        },
        {
          disable: cameraConfig.capabilities?.disable,
          disableExcept: cameraConfig.capabilities?.disable_except,
        },
      ),
      eventCallback: this._eventCallback,
    });
    return await camera.initialize({
      entityRegistryManager: this._entityRegistryManager,
      hass,
      stateWatcher: this._stateWatcher,
    });
  }

  protected _convertMotionEyeTimeFormatToDateFNS(part: string): string {
    return part.replace(
      MOTIONEYE_REPL_REGEXP,
      (_, key) => MOTIONEYE_REPL_SUBSTITUTIONS[key],
    );
  }

  // Get metadata for a MotionEye media file.
  protected _motionEyeMetadataGeneratorFile(
    cameraID: string,
    dateFormat: string | null,
    media: BrowseMedia,
    parent?: RichBrowseMedia<BrowseMediaMetadata>,
  ): BrowseMediaMetadata | null {
    let startDate = parent?._metadata?.startDate ?? new Date();
    if (dateFormat) {
      const extensionlessTitle = media.title.replace(/\.[^/.]+$/, '');
      startDate = parse(extensionlessTitle, dateFormat, startDate);
      if (!isValidDate(startDate)) {
        return null;
      }
    }
    return {
      cameraID: cameraID,
      startDate: startDate,
      // MotionEye only has start times, the event is effectively a 'point'
      endDate: startDate,
    };
  }

  // Get metadata for a MotionEye media directory.
  protected _motionEyeMetadataGeneratorDirectory(
    cameraID: string,
    dateFormat: string | null,
    media: BrowseMedia,
    parent?: RichBrowseMedia<BrowseMediaMetadata>,
  ): BrowseMediaMetadata | null {
    let startDate = parent?._metadata?.startDate ?? new Date();
    if (dateFormat) {
      const parsedDate = parse(media.title, dateFormat, startDate);
      if (!isValidDate(parsedDate)) {
        return null;
      }
      startDate = startOfDay(parsedDate);
    }
    return {
      cameraID: cameraID,
      startDate,
      endDate: parent?._metadata?.endDate ?? endOfDay(startDate),
    };
  }

  // Get media directories that match a given criteria.
  protected async _getMatchingDirectories(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    cameraID: string,
    matchOptions?: {
      start?: Date;
      end?: Date;
      hasClip?: boolean;
      hasSnapshot?: boolean;
    } | null,
    engineOptions?: EngineOptions,
  ): Promise<RichBrowseMedia<BrowseMediaMetadata>[] | null> {
    const camera = store.getCamera(cameraID);
    const cameraConfig = camera?.getConfig();

    if (!(camera instanceof BrowseMediaCamera) || !cameraConfig) {
      return null;
    }

    const entity = camera.getEntity();
    const configID = entity?.config_entry_id;
    const deviceID = entity?.device_id;

    if (!configID || !deviceID) {
      return null;
    }

    const generateNextStep = (
      parts: string[],
      media: BrowseMediaTarget<BrowseMediaMetadata>[],
    ): BrowseMediaStep<BrowseMediaMetadata>[] => {
      const next = parts.shift();
      if (!next) {
        return [];
      }

      const dateFormat = next.includes('%')
        ? this._convertMotionEyeTimeFormatToDateFNS(next)
        : null;

      return [
        {
          targets: media,
          metadataGenerator: (
            media: BrowseMedia,
            parent?: RichBrowseMedia<BrowseMediaMetadata>,
          ) =>
            this._motionEyeMetadataGeneratorDirectory(
              cameraID,
              dateFormat,
              media,
              parent,
            ),
          matcher: (media: RichBrowseMedia<BrowseMediaMetadata>) =>
            media.can_expand &&
            (!!dateFormat || media.title === next) &&
            isMediaWithinDates(media, matchOptions?.start, matchOptions?.end),
          advance: (media) => generateNextStep(parts, media),
        },
      ];
    };

    // For motionEye snapshots and clips are mutually exclusive.
    return await this._browseMediaWalker.walk(
      hass,
      [
        ...(matchOptions?.hasClip !== false && !matchOptions?.hasSnapshot
          ? generateNextStep(
              cameraConfig.motioneye.movies.directory_pattern.split('/'),
              [`media-source://motioneye/${configID}#${deviceID}#movies`],
            )
          : []),
        ...(matchOptions?.hasSnapshot !== false && !matchOptions?.hasClip
          ? generateNextStep(
              cameraConfig.motioneye.images.directory_pattern.split('/'),
              [`media-source://motioneye/${configID}#${deviceID}#images`],
            )
          : []),
      ],
      {
        ...(engineOptions?.useCache !== false && { cache: this._directoryCache }),
      },
    );
  }

  public async getEvents(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: EventQuery,
    engineOptions?: EngineOptions,
  ): Promise<EventQueryResultsMap | null> {
    // MotionEye does not support these query types and they will never match.
    if (query.favorite || query.tags?.size || query.what?.size || query.where?.size) {
      return null;
    }

    const output: EventQueryResultsMap = new Map();
    const getEventsForCamera = async (cameraID: string): Promise<void> => {
      const perCameraQuery = { ...query, cameraIDs: new Set([cameraID]) };
      const cachedResult =
        engineOptions?.useCache ?? true ? this._requestCache.get(perCameraQuery) : null;
      if (cachedResult) {
        output.set(perCameraQuery, cachedResult as EventQueryResults);
        return;
      }

      const cameraConfig = store.getCameraConfig(cameraID);
      if (!cameraConfig) {
        return;
      }

      const directories = await this._getMatchingDirectories(
        hass,
        store,
        cameraID,
        perCameraQuery,
        engineOptions,
      );
      if (!directories || !directories.length) {
        return;
      }

      const moviesDateFormat = this._convertMotionEyeTimeFormatToDateFNS(
        cameraConfig.motioneye.movies.file_pattern,
      );
      const imagesDateFormat = this._convertMotionEyeTimeFormatToDateFNS(
        cameraConfig.motioneye.images.file_pattern,
      );

      const limit = perCameraQuery.limit ?? CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT;
      const media = await this._browseMediaWalker.walk(
        hass,
        [
          {
            targets: directories,
            metadataGenerator: (
              media: BrowseMedia,
              parent?: RichBrowseMedia<BrowseMediaMetadata>,
            ) => {
              if (
                media.media_class === MEDIA_CLASS_IMAGE ||
                media.media_class === MEDIA_CLASS_VIDEO
              ) {
                return this._motionEyeMetadataGeneratorFile(
                  cameraID,
                  media.media_class === MEDIA_CLASS_IMAGE
                    ? imagesDateFormat
                    : moviesDateFormat,
                  media,
                  parent,
                );
              }
              return null;
            },
            earlyExit: (media) => media.length >= limit,
            matcher: (media: RichBrowseMedia<BrowseMediaMetadata>) =>
              !media.can_expand &&
              isMediaWithinDates(media, perCameraQuery.start, perCameraQuery.end),
          },
        ],
        {
          ...(engineOptions?.useCache !== false && { cache: this._fileCache }),
        },
      );

      // Sort by most recent then slice at the query limit.
      const sortedMedia = orderBy(
        media,
        (media: RichBrowseMedia<BrowseMediaMetadata>) => media._metadata?.startDate,
        'desc',
      ).slice(0, perCameraQuery.limit ?? CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT);

      const result: MotionEyeEventQueryResults = {
        type: QueryResultsType.Event,
        engine: Engine.MotionEye,
        browseMedia: sortedMedia,
      };

      if (engineOptions?.useCache ?? true) {
        this._requestCache.set(
          perCameraQuery,
          { ...result, cached: true },
          result.expiry,
        );
      }
      output.set(perCameraQuery, result);
    };

    await allPromises(query.cameraIDs, (cameraID) => getEventsForCamera(cameraID));
    return output.size ? output : null;
  }

  public generateMediaFromEvents(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: EventQuery,
    results: QueryReturnType<EventQuery>,
  ): ViewMedia[] | null {
    if (!MotionEyeQueryResultsClassifier.isMotionEyeEventQueryResults(results)) {
      return null;
    }
    return getViewMediaFromBrowseMediaArray(results.browseMedia);
  }

  public async getMediaMetadata(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: MediaMetadataQuery,
    engineOptions?: EngineOptions,
  ): Promise<MediaMetadataQueryResultsMap | null> {
    const output: MediaMetadataQueryResultsMap = new Map();
    if ((engineOptions?.useCache ?? true) && this._requestCache.has(query)) {
      const cachedResult = <MediaMetadataQueryResults | null>(
        this._requestCache.get(query)
      );
      if (cachedResult) {
        output.set(query, cachedResult as MediaMetadataQueryResults);
        return output;
      }
    }

    const days: Set<string> = new Set();
    const getDaysForCamera = async (cameraID: string): Promise<void> => {
      const directories = await this._getMatchingDirectories(
        hass,
        store,
        cameraID,
        null,
        engineOptions,
      );
      for (const dayDirectory of directories ?? []) {
        if (dayDirectory._metadata?.startDate) {
          days.add(formatDate(dayDirectory._metadata.startDate));
        }
      }
    };

    await allPromises(query.cameraIDs, (cameraID) => getDaysForCamera(cameraID));

    const result: MediaMetadataQueryResults = {
      type: QueryResultsType.MediaMetadata,
      engine: Engine.MotionEye,
      metadata: {
        ...(days.size && { days: days }),
      },
      expiry: add(new Date(), { seconds: BROWSE_MEDIA_CACHE_SECONDS }),
      cached: false,
    };

    if (engineOptions?.useCache ?? true) {
      this._requestCache.set(query, { ...result, cached: true }, result.expiry);
    }
    output.set(query, result);
    return output;
  }

  public getCameraMetadata(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): CameraManagerCameraMetadata {
    return {
      ...super.getCameraMetadata(hass, cameraConfig),
      engineIcon: 'motioneye',
    };
  }

  public getCameraEndpoints(
    cameraConfig: CameraConfig,
    context?: CameraEndpointsContext,
  ): CameraEndpoints | null {
    const getUIEndpoint = (): Endpoint | null => {
      return cameraConfig.motioneye?.url
        ? {
            endpoint: cameraConfig.motioneye.url,
          }
        : null;
    };
    const ui = getUIEndpoint();
    return {
      ...super.getCameraEndpoints(cameraConfig, context),
      ...(ui && { ui: ui }),
    };
  }
}



================================================
FILE: src/camera-manager/motioneye/types.ts
================================================
import { BrowseMediaMetadata, RichBrowseMedia } from '../../ha/browse-media/types';
import { Engine, EventQueryResults } from '../types';

// ================================
// MotionEye concrete query results
// ================================

export interface MotionEyeEventQueryResults extends EventQueryResults {
  engine: Engine.MotionEye;
  browseMedia: RichBrowseMedia<BrowseMediaMetadata>[];
}



================================================
FILE: src/camera-manager/reolink/camera.ts
================================================
import { ActionsExecutor } from '../../card-controller/actions/types';
import { PTZAction, PTZActionPhase } from '../../config/schema/actions/custom/ptz';
import { Entity, EntityRegistryManager } from '../../ha/registry/entity/types';
import { HomeAssistant } from '../../ha/types';
import { localize } from '../../localize/localize';
import { PTZCapabilities, PTZMovementType } from '../../types';
import { createSelectOptionAction } from '../../utils/action.js';
import { BrowseMediaCamera } from '../browse-media/camera';
import { Camera, CameraInitializationOptions } from '../camera';
import { Capabilities } from '../capabilities';
import { CameraInitializationError } from '../error';
import { CameraProxyConfig } from '../types';
import { getPTZCapabilitiesFromCameraConfig } from '../utils/ptz';

// Reolink channels are zero indexed.
const REOLINK_DEFAULT_CHANNEL = 0;

interface ReolinkCameraInitializationOptions extends CameraInitializationOptions {
  entityRegistryManager: EntityRegistryManager;
  hass: HomeAssistant;
}

class ReolinkInitializationError extends CameraInitializationError {}

interface PTZEntities {
  stop?: string;
  left?: string;
  right?: string;
  up?: string;
  down?: string;
  zoom_in?: string;
  zoom_out?: string;
  presets?: string;
}
type PTZEntity = keyof PTZEntities;

export class ReolinkCamera extends BrowseMediaCamera {
  // The HostID identifying the camera or NVR.
  protected _reolinkHostID: string | null = null;

  // For NVRs, the Camera UID.
  protected _reolinkCameraUID: string | null = null;

  // The channel number as used by the Reolink integration.
  protected _reolinkChannel: number | null = null;

  // Entities used for PTZ control.
  protected _ptzEntities: PTZEntities | null = null;

  public async initialize(options: ReolinkCameraInitializationOptions): Promise<Camera> {
    await super.initialize(options);
    this._initializeChannel();
    await this._initializeCapabilities(options.hass, options.entityRegistryManager);
    return this;
  }

  protected _initializeChannel(): void {
    const uniqueID = this._entity?.unique_id;

    // Reolink camera unique IDs are dual-mode, they may be in either of these
    // forms:
    //  - Directly connected cameras: [HostID]_[Channel #]_[...]
    //    (e.g. `95270002FS8D4RUP_0_sub`)
    //  - NVR/Hub connected cameras: [HostID]_[Camera UID]_[...]
    //    (e.g. `9527000HXU4V1VHZ_9527000I7E5F1GYU_sub`)
    //
    // The channel number is always numeric and assumed to be <1000, see similar
    // comparisons in the integration itself:
    // https://github.com/home-assistant/core/blob/dev/homeassistant/components/reolink/media_source.py#L174
    //
    // In the latter form, the channel number cannot be inferred from the entity
    // and must only be taken from the user config instead.

    const match = uniqueID
      ? String(uniqueID).match(
          /^(?<hostid>[A-Za-z0-9]+)_(?<channel_or_uid>[A-Za-z0-9]+)_/,
        )
      : null;

    const hostid = match?.groups?.hostid ?? null;
    const channelOrUID = match?.groups?.channel_or_uid ?? null;

    if (hostid === null || channelOrUID === null) {
      throw new ReolinkInitializationError(
        localize('error.camera_initialization_reolink'),
        this.getConfig(),
      );
    }

    const channelCandidate = Number(channelOrUID);
    const isValidChannel = !isNaN(channelCandidate) && channelCandidate <= 999;
    const channel =
      this._config.reolink.channel ??
      (isValidChannel ? channelCandidate : REOLINK_DEFAULT_CHANNEL);
    const reolinkCameraUID = !isValidChannel ? channelOrUID : null;

    this._reolinkChannel = channel;
    this._reolinkHostID = hostid;
    this._reolinkCameraUID = reolinkCameraUID;
  }

  protected async _initializeCapabilities(
    hass: HomeAssistant,
    entityRegistry: EntityRegistryManager,
  ): Promise<void> {
    const config = this.getConfig();
    const configPTZCapabilities = getPTZCapabilitiesFromCameraConfig(this.getConfig());
    const ptzEntities = await this._getPTZEntities(hass, entityRegistry);
    const reolinkPTZCapabilities = ptzEntities
      ? this._entitiesToCapabilities(hass, ptzEntities)
      : null;

    const combinedPTZCapabilities: PTZCapabilities | null =
      configPTZCapabilities || reolinkPTZCapabilities
        ? {
            ...reolinkPTZCapabilities,
            ...configPTZCapabilities,
          }
        : null;

    this._capabilities = new Capabilities(
      {
        'favorite-events': false,
        'favorite-recordings': false,
        'remote-control-entity': true,
        clips: true,
        live: true,
        menu: true,
        recordings: false,
        seek: false,
        snapshots: false,
        substream: true,
        trigger: true,
        ...(combinedPTZCapabilities && { ptz: combinedPTZCapabilities }),
      },
      {
        disable: config.capabilities?.disable,
        disableExcept: config.capabilities?.disable_except,
      },
    );
    this._ptzEntities = ptzEntities;
  }

  protected _entitiesToCapabilities(
    hass: HomeAssistant,
    ptzEntities: PTZEntities,
  ): PTZCapabilities | null {
    const reolinkPTZCapabilities: PTZCapabilities = {};
    for (const key of Object.keys(ptzEntities)) {
      switch (key) {
        case 'left':
        case 'right':
        case 'up':
        case 'down':
          reolinkPTZCapabilities[key] = [PTZMovementType.Continuous];
          break;
        case 'zoom_in':
          reolinkPTZCapabilities.zoomIn = [PTZMovementType.Continuous];
          break;
        case 'zoom_out':
          reolinkPTZCapabilities.zoomOut = [PTZMovementType.Continuous];
          break;
      }
    }

    const ptzPresetsEntityState = ptzEntities?.presets
      ? hass.states[ptzEntities.presets]
      : null;
    if (Array.isArray(ptzPresetsEntityState?.attributes.options)) {
      reolinkPTZCapabilities.presets = ptzPresetsEntityState.attributes.options;
    }

    /* istanbul ignore next: this path cannot be reached as ptzEntities will
    always have contents when this function is called  -- @preserve */
    return Object.keys(reolinkPTZCapabilities).length ? reolinkPTZCapabilities : null;
  }

  protected async _getPTZEntities(
    hass: HomeAssistant,
    entityRegistry: EntityRegistryManager,
  ): Promise<PTZEntities | null> {
    /* istanbul ignore next: this path cannot be reached as an exception is
       thrown in initialize() if this value is not found -- @preserve */
    if (!this._reolinkHostID) {
      return null;
    }

    const uniqueIDPrefix = this._getPTZEntityUniqueIDPrefix();
    const allRelevantEntities = await entityRegistry.getMatchingEntities(
      hass,
      (ent: Entity) =>
        ent.config_entry_id === this._entity?.config_entry_id &&
        !!ent.unique_id &&
        String(ent.unique_id).startsWith(uniqueIDPrefix) &&
        !ent.disabled_by,
    );
    const buttonEntities = allRelevantEntities.filter((ent: Entity) =>
      ent.entity_id.startsWith('button.'),
    );
    const ptzPresetEntities = allRelevantEntities.filter(
      (ent: Entity) =>
        ent.unique_id === `${uniqueIDPrefix}ptz_preset` &&
        ent.entity_id.startsWith('select.'),
    );

    const uniqueSuffixes: PTZEntity[] = [
      'stop',
      'left',
      'right',
      'up',
      'down',
      'zoom_in',
      'zoom_out',
    ];

    const ptzEntities: PTZEntities = {};
    for (const buttonEntity of buttonEntities) {
      for (const uniqueIDSuffix of uniqueSuffixes) {
        if (
          buttonEntity.unique_id &&
          String(buttonEntity.unique_id).endsWith(uniqueIDSuffix)
        ) {
          ptzEntities[uniqueIDSuffix] = buttonEntity.entity_id;
        }
      }
    }

    if (ptzPresetEntities.length === 1) {
      ptzEntities.presets = ptzPresetEntities[0].entity_id;
    }

    return Object.keys(ptzEntities).length ? ptzEntities : null;
  }

  public getChannel(): number | null {
    return this._reolinkChannel;
  }

  protected _getPTZEntityUniqueIDPrefix(): string {
    return `${this._reolinkHostID}_${this._reolinkCameraUID ?? this._reolinkChannel}_`;
  }

  public getProxyConfig(): CameraProxyConfig {
    return {
      ...super.getProxyConfig(),

      // For reolink, media is always proxied unless explicitly turned off.
      media: this._config.proxy.media === 'auto' ? true : this._config.proxy.media,

      // Reolink does not verify SSL certificates since they may be self-signed.
      ssl_verification:
        this._config.proxy.ssl_verification === 'auto'
          ? false
          : this._config.proxy.ssl_verification,

      // Through experimentation 'intermediate' is the "highest
      // lowest-common-denominator" Reolink devices appear to support.
      ssl_ciphers:
        this._config.proxy.ssl_ciphers === 'auto'
          ? 'intermediate'
          : this._config.proxy.ssl_ciphers,
    };
  }

  public async executePTZAction(
    executor: ActionsExecutor,
    action: PTZAction,
    options?: {
      phase?: PTZActionPhase;
      preset?: string;
    },
  ): Promise<boolean> {
    if (await super.executePTZAction(executor, action, options)) {
      return true;
    }

    if (!this._ptzEntities) {
      return false;
    }

    if (action === 'preset') {
      const entityID = this._ptzEntities.presets;
      const preset = options?.preset;
      if (!preset || !entityID) {
        return false;
      }

      await executor.executeActions({
        actions: [createSelectOptionAction('select', entityID, preset)],
      });
      return true;
    }

    const entityID =
      options?.phase === 'start'
        ? this._ptzEntities[action]
        : options?.phase === 'stop'
          ? this._ptzEntities.stop
          : null;
    if (!entityID) {
      return false;
    }

    await executor.executeActions({
      actions: [
        {
          action: 'perform-action',
          perform_action: 'button.press',
          target: { entity_id: entityID },
        },
      ],
    });
    return true;
  }
}



================================================
FILE: src/camera-manager/reolink/engine-reolink.ts
================================================
import { add, endOfDay, parse, startOfDay } from 'date-fns';
import { orderBy } from 'lodash-es';
import { CameraConfig } from '../../config/schema/cameras';
import { getViewMediaFromBrowseMediaArray } from '../../ha/browse-media/browse-media-to-view-media';
import { sortMostRecentFirst } from '../../ha/browse-media/sort';
import {
  BROWSE_MEDIA_CACHE_SECONDS,
  BrowseMedia,
  BrowseMediaCache,
  BrowseMediaMetadata,
  MEDIA_CLASS_VIDEO,
  RichBrowseMedia,
} from '../../ha/browse-media/types';
import { isMediaWithinDates } from '../../ha/browse-media/within-dates';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import { allPromises, formatDate, isValidDate } from '../../utils/basic';
import { ViewMedia } from '../../view/item';
import { BrowseMediaCameraManagerEngine } from '../browse-media/engine-browse-media';
import { Camera } from '../camera';
import { CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT } from '../engine';
import { CameraManagerReadOnlyConfigStore } from '../store';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraManagerCameraMetadata,
  Engine,
  EngineOptions,
  EventQuery,
  EventQueryResults,
  EventQueryResultsMap,
  MediaMetadataQuery,
  MediaMetadataQueryResults,
  MediaMetadataQueryResultsMap,
  QueryResults,
  QueryResultsType,
  QueryReturnType,
} from '../types';
import { ReolinkCamera } from './camera';
import { BrowseMediaReolinkCameraMetadata, ReolinkEventQueryResults } from './types';

export class ReolinkQueryResultsClassifier {
  public static isReolinkEventQueryResults(
    results: QueryResults,
  ): results is ReolinkEventQueryResults {
    return results.engine === Engine.Reolink && results.type === QueryResultsType.Event;
  }
}

export class ReolinkCameraManagerEngine extends BrowseMediaCameraManagerEngine {
  protected _camerasCache = new BrowseMediaCache<BrowseMediaReolinkCameraMetadata>();
  protected _cache = new BrowseMediaCache<BrowseMediaMetadata>();

  public getEngineType(): Engine {
    return Engine.Reolink;
  }

  protected _reolinkFileMetadataGenerator(
    cameraID: string,
    media: BrowseMedia,
    parent?: RichBrowseMedia<BrowseMediaMetadata>,
  ): BrowseMediaMetadata | null {
    /* istanbul ignore next: This situation cannot happen as the directory would
    be rejected by _reolinkDirectoryMetadataGenerator if there was no start date
    -- @preserve */
    if (!parent?._metadata?.startDate || media.media_class !== MEDIA_CLASS_VIDEO) {
      return null;
    }

    // Titles may be of the form:
    //  - "21:47:03 0:00:44"
    //  - "21:47:03 0:00:44 Person" (https://github.com/dermotduffy/advanced-camera-card/issues/1870)
    //  - "21:47:03 0:00:44 Vehicle Person" (https://github.com/dermotduffy/advanced-camera-card/issues/1870)
    const parts = media.title.split(/ +/);

    const startDate = parse(parts[0], 'HH:mm:ss', parent._metadata.startDate);
    if (!isValidDate(startDate)) {
      return null;
    }

    const durationMatch =
      parts.length > 1
        ? parts[1].match(/(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)/)
        : null;

    const duration = durationMatch?.groups
      ? {
          hours: Number(durationMatch.groups.hours),
          minutes: Number(durationMatch.groups.minutes),
          seconds: Number(durationMatch.groups.seconds),
        }
      : null;

    const what =
      parts.length > 2
        ? parts
            .splice(2)
            .map((l) => l.toLowerCase())
            .sort()
        : null;

    return {
      cameraID: cameraID,
      startDate: startDate,
      endDate: duration ? add(startDate, duration) : startDate,
      ...(what && { what: what }),
    };
  }

  protected _reolinkDirectoryMetadataGenerator(
    cameraID: string,
    media: BrowseMedia,
  ): BrowseMediaMetadata | null {
    // Title of the form: "2024/9/29"
    const parsedDate = parse(media.title, 'yyyy/M/d', new Date());

    return isValidDate(parsedDate)
      ? {
          cameraID: cameraID,
          startDate: startOfDay(parsedDate),
          endDate: endOfDay(parsedDate),
        }
      : null;
  }

  protected _reolinkCameraMetadataGenerator(
    media: BrowseMedia,
  ): BrowseMediaReolinkCameraMetadata | null {
    // Example: "media-source://reolink/CAM|01J8XHYTNH77WE3C654K03KX1F|0"
    const result = media.media_content_id.match(
      /^media-source:\/\/reolink\/CAM\|(?<configEntryID>.+)\|(?<channel>\d+)$/,
    );
    return result?.groups
      ? {
          configEntryID: result.groups.configEntryID,
          channel: Number(result.groups.channel),
        }
      : null;
  }

  public async createCamera(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): Promise<Camera> {
    const camera = new ReolinkCamera(cameraConfig, this, {
      eventCallback: this._eventCallback,
    });
    return await camera.initialize({
      entityRegistryManager: this._entityRegistryManager,
      hass,
      stateWatcher: this._stateWatcher,
    });
  }

  protected async _getMatchingDirectories(
    hass: HomeAssistant,
    camera: ReolinkCamera,
    matchOptions?: {
      start?: Date;
      end?: Date;
    } | null,
    engineOptions?: EngineOptions,
  ): Promise<RichBrowseMedia<BrowseMediaMetadata>[] | null> {
    const cameraConfig = camera.getConfig();
    const entity = camera.getEntity();
    const configID = entity?.config_entry_id;

    if (camera.getChannel() === null || !configID) {
      return null;
    }

    // First fetch all the Reolink cameras that show up under the media root,
    // that match the expected camera. Some Reolink cameras will not show up
    // here causing errors.
    // https://github.com/dermotduffy/advanced-camera-card/issues/1723
    const camerasWithMedia = await this._browseMediaWalker.walk(
      hass,
      [
        {
          targets: [`media-source://reolink`],
          metadataGenerator: (
            media: BrowseMedia,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _parent?: RichBrowseMedia<BrowseMediaReolinkCameraMetadata>,
          ) => this._reolinkCameraMetadataGenerator(media),
          matcher: (media: RichBrowseMedia<BrowseMediaReolinkCameraMetadata>): boolean =>
            media._metadata?.channel === camera.getChannel() &&
            media._metadata?.configEntryID === configID,
        },
      ],
      {
        ...(engineOptions?.useCache !== false && { cache: this._camerasCache }),
      },
    );

    if (!camerasWithMedia?.length) {
      return null;
    }

    return await this._browseMediaWalker.walk(
      hass,
      [
        {
          targets: [
            `media-source://reolink/RES|${configID}|${camera.getChannel()}|` +
              `${cameraConfig.reolink?.media_resolution === 'low' ? 'sub' : 'main'}`,
          ],
          metadataGenerator: (
            media: BrowseMedia,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _parent?: RichBrowseMedia<BrowseMediaMetadata>,
          ) => this._reolinkDirectoryMetadataGenerator(camera.getID(), media),
          matcher: (media: RichBrowseMedia<BrowseMediaMetadata>) =>
            media.can_expand &&
            isMediaWithinDates(media, matchOptions?.start, matchOptions?.end),
          sorter: (media: RichBrowseMedia<BrowseMediaMetadata>[]) =>
            sortMostRecentFirst(media),
        },
      ],
      {
        ...(engineOptions?.useCache !== false && { cache: this._cache }),
      },
    );
  }

  public async getEvents(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: EventQuery,
    engineOptions?: EngineOptions,
  ): Promise<EventQueryResultsMap | null> {
    // Reolink does not support these query types and they will never match.
    if (
      query.favorite ||
      query.tags?.size ||
      query.what?.size ||
      query.where?.size ||
      query.hasSnapshot
    ) {
      return null;
    }

    const output: EventQueryResultsMap = new Map();
    const getEventsForCamera = async (cameraID: string): Promise<void> => {
      const perCameraQuery = { ...query, cameraIDs: new Set([cameraID]) };
      const cachedResult =
        engineOptions?.useCache ?? true ? this._requestCache.get(perCameraQuery) : null;
      if (cachedResult) {
        output.set(perCameraQuery, cachedResult as EventQueryResults);
        return;
      }

      const camera = store.getCamera(cameraID);
      const directories =
        camera && camera instanceof ReolinkCamera
          ? await this._getMatchingDirectories(
              hass,
              camera,
              perCameraQuery,
              engineOptions,
            )
          : null;
      const limit = perCameraQuery.limit ?? CAMERA_MANAGER_ENGINE_EVENT_LIMIT_DEFAULT;
      let media: RichBrowseMedia<BrowseMediaMetadata>[] = [];

      if (directories?.length) {
        media = await this._browseMediaWalker.walk(
          hass,
          [
            {
              targets: directories,
              concurrency: 1,
              metadataGenerator: (
                media: BrowseMedia,
                parent?: RichBrowseMedia<BrowseMediaMetadata>,
              ) => this._reolinkFileMetadataGenerator(cameraID, media, parent),
              earlyExit: (media) => media.length >= limit,
              matcher: (media: RichBrowseMedia<BrowseMediaMetadata>) =>
                !media.can_expand &&
                isMediaWithinDates(media, perCameraQuery.start, perCameraQuery.end),
              sorter: (media: RichBrowseMedia<BrowseMediaMetadata>[]) =>
                sortMostRecentFirst(media),
            },
          ],
          {
            ...(engineOptions?.useCache !== false && { cache: this._cache }),
          },
        );
      }

      // Sort by most recent then slice at the query limit.
      const sortedMedia = orderBy(
        media,
        (media: RichBrowseMedia<BrowseMediaMetadata>) => media._metadata?.startDate,
        'desc',
      ).slice(0, limit);

      const result: ReolinkEventQueryResults = {
        type: QueryResultsType.Event,
        engine: Engine.Reolink,
        browseMedia: sortedMedia,
      };

      if (engineOptions?.useCache ?? true) {
        this._requestCache.set(
          perCameraQuery,
          { ...result, cached: true },
          result.expiry,
        );
      }
      output.set(perCameraQuery, result);
    };

    await allPromises(query.cameraIDs, (cameraID) => getEventsForCamera(cameraID));
    return output;
  }

  public generateMediaFromEvents(
    _hass: HomeAssistant,
    _store: CameraManagerReadOnlyConfigStore,
    _query: EventQuery,
    results: QueryReturnType<EventQuery>,
  ): ViewMedia[] | null {
    if (!ReolinkQueryResultsClassifier.isReolinkEventQueryResults(results)) {
      return null;
    }
    return getViewMediaFromBrowseMediaArray(results.browseMedia);
  }

  public async getMediaMetadata(
    hass: HomeAssistant,
    store: CameraManagerReadOnlyConfigStore,
    query: MediaMetadataQuery,
    engineOptions?: EngineOptions,
  ): Promise<MediaMetadataQueryResultsMap | null> {
    const output: MediaMetadataQueryResultsMap = new Map();
    const cachedResult =
      engineOptions?.useCache ?? true ? this._requestCache.get(query) : null;

    if (cachedResult) {
      output.set(query, cachedResult as MediaMetadataQueryResults);
      return output;
    }

    const days: Set<string> = new Set();
    const getDaysForCamera = async (cameraID: string): Promise<void> => {
      const camera = store.getCamera(cameraID);
      if (!camera || !(camera instanceof ReolinkCamera)) {
        return;
      }
      const directories = await this._getMatchingDirectories(
        hass,
        camera,
        null,
        engineOptions,
      );
      for (const dayDirectory of directories ?? []) {
        /* istanbul ignore next: This situation cannot happen as the directory
        will not match without metadata -- @preserve */
        if (dayDirectory._metadata?.startDate) {
          days.add(formatDate(dayDirectory._metadata.startDate));
        }
      }
    };

    await allPromises(query.cameraIDs, (cameraID) => getDaysForCamera(cameraID));

    const result: MediaMetadataQueryResults = {
      type: QueryResultsType.MediaMetadata,
      engine: Engine.Reolink,
      metadata: {
        ...(days.size && { days: days }),
      },
      expiry: add(new Date(), { seconds: BROWSE_MEDIA_CACHE_SECONDS }),
      cached: false,
    };

    if (engineOptions?.useCache ?? true) {
      this._requestCache.set(query, { ...result, cached: true }, result.expiry);
    }
    output.set(query, result);
    return output;
  }

  public getCameraMetadata(
    hass: HomeAssistant,
    cameraConfig: CameraConfig,
  ): CameraManagerCameraMetadata {
    return {
      ...super.getCameraMetadata(hass, cameraConfig),
      engineIcon: 'reolink',
    };
  }

  public getCameraEndpoints(
    cameraConfig: CameraConfig,
    context?: CameraEndpointsContext,
  ): CameraEndpoints | null {
    const getUIEndpoint = (): Endpoint | null => {
      return cameraConfig.reolink?.url
        ? {
            endpoint: cameraConfig.reolink.url,
          }
        : null;
    };
    const ui = getUIEndpoint();
    return {
      ...super.getCameraEndpoints(cameraConfig, context),
      ...(ui && { ui: ui }),
    };
  }
}



================================================
FILE: src/camera-manager/reolink/types.ts
================================================
import { BrowseMediaMetadata, RichBrowseMedia } from '../../ha/browse-media/types';
import { Engine, EventQueryResults } from '../types';

export interface BrowseMediaReolinkCameraMetadata {
  configEntryID: string;
  channel: number;
}

// ==============================
// Reolink concrete query results
// ==============================

export interface ReolinkEventQueryResults extends EventQueryResults {
  engine: Engine.Reolink;
  browseMedia: RichBrowseMedia<BrowseMediaMetadata>[];
}



================================================
FILE: src/camera-manager/utils/camera-entity-from-config.ts
================================================
import { CameraConfig } from '../../config/schema/cameras';

export const getCameraEntityFromConfig = (
  cameraConfig?: CameraConfig,
): string | null => {
  return cameraConfig?.camera_entity ?? cameraConfig?.webrtc_card?.entity ?? null;
};



================================================
FILE: src/camera-manager/utils/cap-end-date.ts
================================================
export const capEndDate = (end: Date): Date => {
  const now = new Date();
  return end > now ? now : end;
};



================================================
FILE: src/camera-manager/utils/go2rtc-endpoint.ts
================================================
import { CameraConfig } from '../../config/schema/cameras';
import { Endpoint } from '../../types';

export const getDefaultGo2RTCEndpoint = (
  cameraConfig: CameraConfig,
  options?: {
    url?: string;
    stream?: string;
  },
): Endpoint | null => {
  const url = options?.url ?? cameraConfig.go2rtc?.url;
  const stream = options?.stream ?? cameraConfig.go2rtc?.stream;

  if (!url || !stream) {
    return null;
  }
  const endpoint = `${url}/api/ws?src=${stream}`;

  return {
    endpoint: endpoint,

    // Only sign the endpoint if it's local to HA.
    sign: endpoint.startsWith('/'),
  };
};



================================================
FILE: src/camera-manager/utils/ptz.ts
================================================
import {
  PTZAction,
  PTZActionPhase,
  PTZBaseAction,
} from '../../config/schema/actions/custom/ptz';
import { ActionConfig } from '../../config/schema/actions/types';
import { CameraConfig } from '../../config/schema/cameras';
import { PTZCapabilities, PTZMovementType } from '../../types';

export const getConfiguredPTZAction = (
  cameraConfig: CameraConfig,
  action: PTZAction,
  options?: {
    phase?: PTZActionPhase;
    preset?: string;
  },
): ActionConfig | ActionConfig[] | null => {
  if (action === 'preset') {
    return (options?.preset ? cameraConfig.ptz.presets?.[options.preset] : null) ?? null;
  }

  if (options?.phase) {
    return cameraConfig.ptz[`actions_${action}_${options.phase}`] ?? null;
  }

  return cameraConfig.ptz[`actions_${action}`] ?? null;
};

const hasConfiguredPTZAction = (
  cameraConfig: CameraConfig,
  action: PTZBaseAction,
  options?: {
    phase?: PTZActionPhase;
    preset?: string;
  },
): boolean => {
  return !!getConfiguredPTZAction(cameraConfig, action, options);
};

export const getConfiguredPTZMovementType = (
  cameraConfig: CameraConfig,
  action: PTZBaseAction,
): PTZMovementType[] | null => {
  const continuous =
    hasConfiguredPTZAction(cameraConfig, action, { phase: 'start' }) &&
    hasConfiguredPTZAction(cameraConfig, action, { phase: 'stop' });
  const relative = hasConfiguredPTZAction(cameraConfig, action);

  return continuous || relative
    ? [
        ...(continuous ? [PTZMovementType.Continuous] : []),
        ...(relative ? [PTZMovementType.Relative] : []),
      ]
    : null;
};

export const getPTZCapabilitiesFromCameraConfig = (
  cameraConfig: CameraConfig,
): PTZCapabilities | null => {
  const left = getConfiguredPTZMovementType(cameraConfig, 'left');
  const right = getConfiguredPTZMovementType(cameraConfig, 'right');
  const up = getConfiguredPTZMovementType(cameraConfig, 'up');
  const down = getConfiguredPTZMovementType(cameraConfig, 'down');
  const zoomIn = getConfiguredPTZMovementType(cameraConfig, 'zoom_in');
  const zoomOut = getConfiguredPTZMovementType(cameraConfig, 'zoom_out');
  const presets = cameraConfig.ptz.presets
    ? Object.keys(cameraConfig.ptz.presets)
    : undefined;

  return left?.length ||
    right?.length ||
    up?.length ||
    down?.length ||
    zoomIn?.length ||
    zoomOut?.length ||
    presets?.length
    ? {
        // Only return keys with some capability (to aid with action merging
        // later).
        ...(left ? { left } : {}),
        ...(right ? { right } : {}),
        ...(up ? { up } : {}),
        ...(down ? { down } : {}),
        ...(zoomIn ? { zoomIn } : {}),
        ...(zoomOut ? { zoomOut } : {}),
        ...(presets ? { presets } : {}),
      }
    : null;
};



================================================
FILE: src/camera-manager/utils/range-to-cache-friendly.ts
================================================
import { endOfDay, endOfHour, endOfMinute, startOfDay, startOfHour } from 'date-fns';
import { DateRange } from '../range';
import { capEndDate } from './cap-end-date';

export const convertRangeToCacheFriendlyTimes = (
  range: DateRange,
  options?: {
    endCap?: boolean;
  },
): DateRange => {
  const widthSeconds = (range.end.getTime() - range.start.getTime()) / 1000;
  let cacheableStart: Date;
  let cacheableEnd: Date;

  if (widthSeconds <= 60 * 60) {
    cacheableStart = startOfHour(range.start);
    cacheableEnd = endOfHour(range.end);
  } else {
    cacheableStart = startOfDay(range.start);
    cacheableEnd = endOfDay(range.end);
  }

  if (options?.endCap) {
    cacheableEnd = endOfMinute(capEndDate(cacheableEnd));
  }

  return {
    start: cacheableStart,
    end: cacheableEnd,
  };
};



================================================
FILE: src/card-controller/automations-manager.ts
================================================
import { ConditionsManager } from '../conditions/conditions-manager.js';
import { ConditionsEvaluationResult } from '../conditions/types.js';
import { Automation, AutomationActions } from '../config/schema/automations.js';
import { localize } from '../localize/localize.js';
import { CardAutomationsAPI, TaggedAutomation } from './types.js';

const MAX_NESTED_AUTOMATION_EXECUTIONS = 10;

export class AutomationsManager {
  protected _api: CardAutomationsAPI;

  protected _automations = new Map<TaggedAutomation, ConditionsManager>();

  // A counter to avoid infinite loops, increases every time actions are run,
  // decreases every time actions are complete.
  protected _nestedAutomationExecutions = 0;

  constructor(api: CardAutomationsAPI) {
    this._api = api;
  }

  public deleteAutomations(tag?: unknown) {
    for (const [automation, conditionManager] of this._automations) {
      if (automation.tag === tag) {
        this._automations.delete(automation);
        conditionManager.destroy();
      }
    }
  }

  public addAutomations(automations: TaggedAutomation[]): void {
    for (const automation of automations) {
      const conditionManager = new ConditionsManager(
        automation.conditions,
        this._api.getConditionStateManager(),
      );
      conditionManager.addListener((result: ConditionsEvaluationResult) =>
        this._execute(automation, result),
      );
      this._automations.set(automation, conditionManager);
    }
  }

  protected _execute(automation: Automation, result: ConditionsEvaluationResult): void {
    if (
      !this._api.getHASSManager().hasHASS() ||
      // Never execute automations if the card hasn't finished initializing, as
      // it could cause a view change when camera loads are not finished.
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1407
      !this._api.getInitializationManager().isInitializedMandatory() ||
      // Never execute automations if there's an error (as our automation loop
      // avoidance -- which shows as an error -- would not work!).
      this._api.getMessageManager().hasErrorMessage()
    ) {
      return;
    }

    const shouldExecute = result.result;
    const actions = shouldExecute ? automation.actions : automation.actions_not;

    if (!actions?.length) {
      return;
    }

    const runActions = async (actions: AutomationActions): Promise<void> => {
      ++this._nestedAutomationExecutions;

      if (this._nestedAutomationExecutions > MAX_NESTED_AUTOMATION_EXECUTIONS) {
        this._api.getMessageManager().setMessageIfHigherPriority({
          type: 'error',
          message: localize('error.too_many_automations'),
        });
        return;
      }

      await this._api
        .getActionsManager()
        .executeActions({ actions, triggerData: result.triggerData });

      --this._nestedAutomationExecutions;
    };
    runActions(actions);
  }
}



================================================
FILE: src/card-controller/camera-url-manager.ts
================================================
import { ViewItemClassifier } from '../view/item-classifier';
import { CardCameraURLAPI } from './types';

export class CameraURLManager {
  protected _api: CardCameraURLAPI;

  constructor(api: CardCameraURLAPI) {
    this._api = api;
  }

  public openURL(): void {
    const url = this.getCameraURL();
    if (url) {
      window.open(url);
    }
  }

  public hasCameraURL(): boolean {
    return !!this.getCameraURL();
  }

  public getCameraURL(): string | null {
    const view = this._api.getViewManager().getView();
    const item = view?.queryResults?.getSelectedResult() ?? null;
    const endpoints = view?.camera
      ? this._api.getCameraManager().getCameraEndpoints(view.camera, {
          view: view.view,
          ...(item && ViewItemClassifier.isMedia(item) && { media: item }),
        }) ?? null
      : null;
    return endpoints?.ui?.endpoint ?? null;
  }
}



================================================
FILE: src/card-controller/card-element-manager.ts
================================================
import { LitElement, ReactiveControllerHost } from 'lit';
import { ActionEventTarget } from '../action-handler-directive';
import { isCardInPanel } from '../ha/panel';
import { setOrRemoveAttribute } from '../utils/basic';
import { isBeingCasted } from '../utils/casting';
import { ActionExecutionRequestEventTarget } from './actions/utils/execution-request';
import { InitializationAspect } from './initialization-manager';
import { CardElementAPI } from './types';

export type ScrollCallback = () => void;
export type MenuToggleCallback = () => void;

export type CardHTMLElement = LitElement &
  ReactiveControllerHost &
  ActionEventTarget &
  ActionExecutionRequestEventTarget;

export class CardElementManager {
  protected _api: CardElementAPI;

  protected _element: CardHTMLElement;
  protected _scrollCallback: ScrollCallback;
  protected _menuToggleCallback: MenuToggleCallback;

  constructor(
    api: CardElementAPI,
    element: CardHTMLElement,
    scrollCallback: ScrollCallback,
    menuToggleCallback: MenuToggleCallback,
  ) {
    this._api = api;

    this._element = element;
    this._scrollCallback = scrollCallback;
    this._menuToggleCallback = menuToggleCallback;
  }

  public getElement(): HTMLElement {
    return this._element;
  }

  public scrollReset(): void {
    this._scrollCallback();
  }

  public toggleMenu(): void {
    this._menuToggleCallback();
  }

  public update = (): void => {
    this._element.requestUpdate();
  };

  public hasUpdated(): boolean {
    return this._element.hasUpdated;
  }

  public elementConnected(): void {
    // Set initial condition state. Must be done after the element is connected to
    // allow callbacks to interact with the card.
    this._api.getInteractionManager().initialize();
    this._api.getFullscreenManager().initialize();
    this._api.getExpandManager().initialize();
    this._api.getMediaLoadedInfoManager().initialize();
    this._api.getMicrophoneManager().initialize();
    this._api.getKeyboardStateManager().initialize();

    // These initializers are called when the config is updated, but on initial
    // creation of the card hass is not yet available when the config is first
    // loaded.
    this._api.getDefaultManager().initialize();
    this._api.getMediaPlayerManager().initialize();

    this._api
      .getHASSManager()
      .getStateWatcher()
      ?.subscribe(this.update, [
        ...(this._api.getConfigManager().getConfig()?.view.render_entities ?? []),

        // Refresh the card if media player state changes:
        // https://github.com/dermotduffy/advanced-camera-card/issues/881
        ...(this._api.getMediaPlayerManager().getMediaPlayers() ?? []),
      ]);

    // Whether or not the card is in panel mode on the dashboard.
    setOrRemoveAttribute(this._element, isCardInPanel(this._element), 'panel');
    setOrRemoveAttribute(this._element, isBeingCasted(), 'casted');

    this._api.getFullscreenManager().connect();

    this._element.addEventListener(
      'mousemove',
      this._api.getInteractionManager().reportInteraction,
    );
    this._element.addEventListener(
      'wheel',
      this._api.getInteractionManager().reportInteraction,
    );
    this._element.addEventListener(
      'll-custom',
      this._api.getActionsManager().handleCustomActionEvent,
    );
    this._element.addEventListener(
      'action',
      this._api.getActionsManager().handleInteractionEvent,
    );
    this._element.addEventListener(
      'action',
      this._api.getInteractionManager().reportInteraction,
    );
    this._element.addEventListener(
      'advanced-camera-card:action:execution-request',
      this._api.getActionsManager().handleActionExecutionRequestEvent,
    );

    // Listen for HA `navigate` actions.
    // See: https://github.com/home-assistant/frontend/blob/273992c8e9c3062c6e49481b6d7d688a07067232/src/common/navigate.ts#L43
    window.addEventListener(
      'location-changed',
      this._api.getQueryStringManager().requestExecution,
    );

    // Listen for history state changes (i.e. user using the browser
    // back/forward controls).
    window.addEventListener(
      'popstate',
      this._api.getQueryStringManager().requestExecution,
    );

    this._api.getConditionStateManager()?.setState({
      userAgent: navigator.userAgent,
    });

    // Manually request query string execute as the card will be
    // disconnected/reconnected when dashboard 'tab' changes happen within HA.
    this._api.getQueryStringManager().requestExecution();

    // Make sure reconnections call the initialization code.
    this._element.requestUpdate();
  }

  public elementDisconnected(): void {
    setOrRemoveAttribute(this._element, false, 'panel');
    setOrRemoveAttribute(this._element, false, 'tabindex');
    setOrRemoveAttribute(this._element, false, 'casted');

    // When the dashboard 'tab' is changed, the media is effectively unloaded.
    this._api.getMediaLoadedInfoManager().clear();
    this._api.getFullscreenManager().disconnect();
    this._api.getKeyboardStateManager().uninitialize();
    this._api.getActionsManager().uninitialize();
    this._api.getDefaultManager().uninitialize();
    this._api.getHASSManager().getStateWatcher()?.unsubscribe(this.update);

    // Uninitialize cameras to cause them to reinitialize on
    // reconnection, to ensure the state subscription/unsubscription works
    // correctly for triggers.
    this._api.getInitializationManager().uninitialize(InitializationAspect.CAMERAS);
    this._api.getCameraManager().destroy();

    this._element.removeEventListener(
      'mousemove',
      this._api.getInteractionManager().reportInteraction,
    );
    this._element.removeEventListener(
      'wheel',
      this._api.getInteractionManager().reportInteraction,
    );
    this._element.removeEventListener(
      'll-custom',
      this._api.getActionsManager().handleCustomActionEvent,
    );
    this._element.removeEventListener(
      'action',
      this._api.getActionsManager().handleInteractionEvent,
    );
    this._element.removeEventListener(
      'action',
      this._api.getInteractionManager().reportInteraction,
    );
    this._element.removeEventListener(
      'advanced-camera-card:action:execution-request',
      this._api.getActionsManager().handleActionExecutionRequestEvent,
    );

    window.removeEventListener(
      'location-changed',
      this._api.getQueryStringManager().requestExecution,
    );
    window.removeEventListener(
      'popstate',
      this._api.getQueryStringManager().requestExecution,
    );
  }
}



================================================
FILE: src/card-controller/controller.ts
================================================
import { ReactiveController } from 'lit';
import { CameraManager } from '../camera-manager/manager';
import { ConditionStateManager } from '../conditions/state-manager';
import { AdvancedCameraCardConfig } from '../config/schema/types';
import { DeviceRegistryManager } from '../ha/registry/device';
import { DeviceCache } from '../ha/registry/device/types';
import { EntityRegistryManagerLive } from '../ha/registry/entity';
import { EntityCache, EntityRegistryManager } from '../ha/registry/entity/types';
import { ResolvedMediaCache } from '../ha/resolved-media';
import { LovelaceCardEditor } from '../ha/types';
import { ActionsManager } from './actions/actions-manager';
import { AutomationsManager } from './automations-manager';
import { CameraURLManager } from './camera-url-manager';
import {
  CardElementManager,
  CardHTMLElement,
  MenuToggleCallback,
  ScrollCallback,
} from './card-element-manager';
import { ConfigManager } from './config/config-manager';
import { DefaultManager } from './default-manager';
import { ExpandManager } from './expand-manager';
import { FoldersManager } from './folders/manager';
import { FullscreenManager } from './fullscreen/fullscreen-manager';
import { HASSManager } from './hass/hass-manager';
import { InitializationManager } from './initialization-manager';
import { InteractionManager } from './interaction-manager';
import { KeyboardStateManager } from './keyboard-state-manager';
import { MediaLoadedInfoManager } from './media-info-manager';
import { MediaPlayerManager } from './media-player-manager';
import { MessageManager } from './message-manager';
import { MicrophoneManager } from './microphone-manager';
import { QueryStringManager } from './query-string-manager';
import { StatusBarItemManager } from './status-bar-item-manager';
import { StyleManager } from './style-manager';
import { TemplateRenderer } from './templates';
import { TriggersManager } from './triggers-manager';
import {
  CardActionsManagerAPI,
  CardAutomationsAPI,
  CardCameraAPI,
  CardCameraURLAPI,
  CardConditionAPI,
  CardConfigAPI,
  CardDefaultManagerAPI,
  CardDownloadAPI,
  CardElementAPI,
  CardExpandAPI,
  CardFullscreenAPI,
  CardHASSAPI,
  CardInitializerAPI,
  CardInteractionAPI,
  CardKeyboardStateAPI,
  CardMediaLoadedAPI,
  CardMediaPlayerAPI,
  CardMessageAPI,
  CardMicrophoneAPI,
  CardQueryStringAPI,
  CardStyleAPI,
  CardTriggersAPI,
  CardViewAPI,
} from './types';
import { ViewItemManager } from './view/item-manager';
import { ViewManager } from './view/view-manager';

export class CardController
  implements
    CardActionsManagerAPI,
    CardAutomationsAPI,
    CardCameraAPI,
    CardCameraURLAPI,
    CardConditionAPI,
    CardConfigAPI,
    CardDefaultManagerAPI,
    CardDownloadAPI,
    CardElementAPI,
    CardExpandAPI,
    CardFullscreenAPI,
    CardHASSAPI,
    CardInitializerAPI,
    CardInteractionAPI,
    CardKeyboardStateAPI,
    CardMediaLoadedAPI,
    CardMediaPlayerAPI,
    CardMessageAPI,
    CardMicrophoneAPI,
    CardQueryStringAPI,
    CardStyleAPI,
    CardTriggersAPI,
    CardViewAPI,
    ReactiveController
{
  protected _conditionStateManager = new ConditionStateManager();

  // These properties may be used in the construction of 'managers' (and should
  // be created first).
  protected _deviceRegistryManager = new DeviceRegistryManager(new DeviceCache());
  protected _entityRegistryManager = new EntityRegistryManagerLive(new EntityCache());
  protected _resolvedMediaCache = new ResolvedMediaCache();

  protected _actionsManager = new ActionsManager(this, new TemplateRenderer());
  protected _automationsManager = new AutomationsManager(this);
  protected _cameraManager = new CameraManager(this);
  protected _cameraURLManager = new CameraURLManager(this);
  protected _cardElementManager: CardElementManager;
  protected _configManager = new ConfigManager(this);
  protected _defaultManager = new DefaultManager(this);
  protected _expandManager = new ExpandManager(this);
  protected _foldersManager = new FoldersManager(this);
  protected _fullscreenManager = new FullscreenManager(this);
  protected _hassManager = new HASSManager(this);
  protected _initializationManager = new InitializationManager(this);
  protected _interactionManager = new InteractionManager(this);
  protected _keyboardStateManager = new KeyboardStateManager(this);
  protected _mediaLoadedInfoManager = new MediaLoadedInfoManager(this);
  protected _mediaPlayerManager = new MediaPlayerManager(this);
  protected _messageManager = new MessageManager(this);
  protected _microphoneManager = new MicrophoneManager(this);
  protected _queryStringManager = new QueryStringManager(this);
  protected _statusBarItemManager = new StatusBarItemManager(this);
  protected _styleManager = new StyleManager(this);
  protected _triggersManager = new TriggersManager(this);
  protected _viewManager = new ViewManager(this);
  protected _viewItemManager = new ViewItemManager(this);

  constructor(
    host: CardHTMLElement,
    scrollCallback: ScrollCallback,
    menuToggleCallback: MenuToggleCallback,
  ) {
    host.addController(this);

    this._cardElementManager = new CardElementManager(
      this,
      host,
      scrollCallback,
      menuToggleCallback,
    );
  }

  // *************************************************************************
  //                           Accessors
  // *************************************************************************

  public getActionsManager(): ActionsManager {
    return this._actionsManager;
  }

  public getAutomationsManager(): AutomationsManager {
    return this._automationsManager;
  }

  public getCameraManager(): CameraManager {
    return this._cameraManager;
  }
  public createCameraManager(): void {
    this._cameraManager = new CameraManager(this);
  }

  public getCameraURLManager(): CameraURLManager {
    return this._cameraURLManager;
  }

  public getCardElementManager(): CardElementManager {
    return this._cardElementManager;
  }

  public getConditionStateManager(): ConditionStateManager {
    return this._conditionStateManager;
  }

  public static async getConfigElement(): Promise<LovelaceCardEditor> {
    await import('../editor.js');
    return document.createElement('advanced-camera-card-editor');
  }

  public getConfigManager(): ConfigManager {
    return this._configManager;
  }

  public getDefaultManager(): DefaultManager {
    return this._defaultManager;
  }

  public getDeviceRegistryManager(): DeviceRegistryManager {
    return this._deviceRegistryManager;
  }

  public getEntityRegistryManager(): EntityRegistryManager {
    return this._entityRegistryManager;
  }

  public getExpandManager(): ExpandManager {
    return this._expandManager;
  }

  public getFoldersManager(): FoldersManager {
    return this._foldersManager;
  }

  public getFullscreenManager(): FullscreenManager {
    return this._fullscreenManager;
  }

  public getHASSManager(): HASSManager {
    return this._hassManager;
  }

  public getInitializationManager(): InitializationManager {
    return this._initializationManager;
  }

  public getInteractionManager(): InteractionManager {
    return this._interactionManager;
  }

  public getKeyboardStateManager(): KeyboardStateManager {
    return this._keyboardStateManager;
  }

  public getMediaLoadedInfoManager(): MediaLoadedInfoManager {
    return this._mediaLoadedInfoManager;
  }

  public getMediaPlayerManager(): MediaPlayerManager {
    return this._mediaPlayerManager;
  }

  public getMessageManager(): MessageManager {
    return this._messageManager;
  }

  public getMicrophoneManager(): MicrophoneManager {
    return this._microphoneManager;
  }
  public createMicrophoneManager(): void {
    this._microphoneManager = new MicrophoneManager(this);
  }

  public getQueryStringManager(): QueryStringManager {
    return this._queryStringManager;
  }

  public getResolvedMediaCache(): ResolvedMediaCache {
    return this._resolvedMediaCache;
  }

  public getStatusBarItemManager(): StatusBarItemManager {
    return this._statusBarItemManager;
  }

  public static getStubConfig(entities: string[]): AdvancedCameraCardConfig {
    const cameraEntity = entities.find((element) => element.startsWith('camera.'));
    return {
      cameras: [
        {
          camera_entity: cameraEntity ?? 'camera.demo',
        },
      ],
      // Need to use 'as unknown' to convince Typescript that this really isn't a
      // mistake, despite the miniscule size of the configuration vs the full type
      // description.
    } as unknown as AdvancedCameraCardConfig;
  }

  public getStyleManager(): StyleManager {
    return this._styleManager;
  }

  public getTriggersManager(): TriggersManager {
    return this._triggersManager;
  }

  public getViewManager(): ViewManager {
    return this._viewManager;
  }

  public getViewItemManager(): ViewItemManager {
    return this._viewItemManager;
  }

  // *************************************************************************
  //                            Handlers
  // *************************************************************************

  public hostConnected(): void {
    this.getCardElementManager().elementConnected();
  }

  public hostDisconnected(): void {
    this.getCardElementManager().elementDisconnected();
  }
}



================================================
FILE: src/card-controller/default-manager.ts
================================================
import { isEqual } from 'lodash-es';
import { AdvancedCameraCardConfig } from '../config/schema/types';
import { createGeneralAction } from '../utils/action';
import { isActionAllowedBasedOnInteractionState } from '../utils/interaction-mode';
import { Timer } from '../utils/timer';
import { CardDefaultManagerAPI } from './types';

/**
 * Manages automated resetting to the default view.
 */
export class DefaultManager {
  protected _timer = new Timer();
  protected _api: CardDefaultManagerAPI;

  constructor(api: CardDefaultManagerAPI) {
    this._api = api;
  }

  public async initializeIfNecessary(
    previousConfig: AdvancedCameraCardConfig | null,
  ): Promise<void> {
    if (
      !isEqual(
        previousConfig?.view.default_reset,
        this._api.getConfigManager().getConfig()?.view.default_reset,
      )
    ) {
      await this.initialize();
    }
  }

  /**
   * This needs to be public since the first initialization requires both hass
   * and the config, so it is not suitable from calling exclusively from the
   * config manager.
   */
  public async initialize(): Promise<boolean> {
    this.uninitialize();

    const config = this._api.getConfigManager().getConfig()?.view.default_reset;
    if (config?.entities.length) {
      this._api
        .getHASSManager()
        .getStateWatcher()
        .subscribe(this._stateChangeHandler, config.entities);
    }

    const timerSeconds = this._api.getConfigManager().getConfig()?.view
      .default_reset.every_seconds;
    if (timerSeconds) {
      this._timer.startRepeated(timerSeconds, () => this._setToDefaultIfAllowed());
    }

    if (this._api.getConfigManager().getConfig()?.view.default_reset.after_interaction) {
      this._api.getAutomationsManager().addAutomations([
        {
          actions: [createGeneralAction('default')],
          conditions: [
            {
              condition: 'interaction' as const,
              interaction: false,
            },
          ],
          tag: this,
        },
      ]);
    }

    return true;
  }

  public uninitialize(): void {
    this._timer.stop();
    this._api.getHASSManager().getStateWatcher().unsubscribe(this._stateChangeHandler);
    this._api.getAutomationsManager().deleteAutomations(this);
  }

  protected _stateChangeHandler = (): void => {
    this._setToDefaultIfAllowed();
  };

  protected _setToDefaultIfAllowed(): void {
    if (this._isAutomatedUpdateAllowed()) {
      this._api.getViewManager().setViewDefault();
    }
  }

  protected _isAutomatedUpdateAllowed(): boolean {
    const interactionMode = this._api.getConfigManager().getConfig()?.view
      .default_reset.interaction_mode;
    return (
      !!interactionMode &&
      isActionAllowedBasedOnInteractionState(
        interactionMode,
        this._api.getInteractionManager().hasInteraction(),
      )
    );
  }
}



================================================
FILE: src/card-controller/expand-manager.ts
================================================
import { CardExpandAPI } from './types';

export class ExpandManager {
  protected _expanded = false;
  protected _api: CardExpandAPI;

  constructor(api: CardExpandAPI) {
    this._api = api;
  }

  public initialize(): void {
    this._setConditionState();
  }

  public isExpanded(): boolean {
    return this._expanded;
  }

  public toggleExpanded(): void {
    this.setExpanded(!this._expanded);
  }

  public setExpanded(expanded: boolean): void {
    if (expanded && this._api.getFullscreenManager().isInFullscreen()) {
      // Fullscreen and expanded mode are mutually exclusive.
      this._api.getFullscreenManager().setFullscreen(false);
    }

    this._expanded = expanded;
    this._setConditionState();
    this._api.getCardElementManager().update();
  }

  protected _setConditionState(): void {
    this._api.getConditionStateManager()?.setState({
      expand: this._expanded,
    });
  }
}



================================================
FILE: src/card-controller/initialization-manager.ts
================================================
import PQueue from 'p-queue';
import { loadLanguages } from '../localize/localize';
import { sideLoadHomeAssistantElements } from '../ha/side-load-ha-elements';
import { Initializer } from '../utils/initializer/initializer';
import { CardInitializerAPI } from './types';

export enum InitializationAspect {
  LANGUAGES = 'languages',
  SIDE_LOAD_ELEMENTS = 'side-load-elements',
  CAMERAS = 'cameras',
  MICROPHONE_CONNECT = 'microphone-connect',
  VIEW = 'view',

  // The initial triggering must happen after both the config is set (and
  // cameras initialized), and hass is set.
  INITIAL_TRIGGER = 'initial-trigger',
}

// =========================================================================
// Rules for initialization. Initializers must be reentrant as these situations
// may occur:
//
// 1. Multiple JS async contexts may execute these functions at the same time.
// 2. At any point, something may uninitialize a part of the card (including
//    while a different async context is in the middle of running the
//    initialization method).
// =========================================================================

export class InitializationManager {
  protected _api: CardInitializerAPI;

  // A concurrency limit is placed to ensure that on card load multiple async
  // contexts do not attempt to initialize the card at the same time. This is
  // not strictly necessary, just more efficient, as long as the "Rules for
  // initialization" (above) are followed.
  protected _initializationQueue = new PQueue({ concurrency: 1 });
  protected _initializer: Initializer;
  protected _everInitialized = false;

  constructor(api: CardInitializerAPI, initializer?: Initializer) {
    this._api = api;
    this._initializer = initializer ?? new Initializer();
  }

  public wasEverInitialized(): boolean {
    return this._everInitialized;
  }

  public isInitialized(aspect: InitializationAspect): boolean {
    return this._initializer.isInitialized(aspect);
  }

  public isInitializedMandatory(): boolean {
    const config = this._api.getConfigManager().getConfig();
    if (!config) {
      return false;
    }

    return this._initializer.isInitializedMultiple([
      InitializationAspect.LANGUAGES,
      InitializationAspect.SIDE_LOAD_ELEMENTS,
      InitializationAspect.CAMERAS,
      ...(this._api.getMicrophoneManager().shouldConnectOnInitialization()
        ? [InitializationAspect.MICROPHONE_CONNECT]
        : []),
      InitializationAspect.VIEW,
      InitializationAspect.INITIAL_TRIGGER,
    ]);
  }

  /**
   * Initialize the hard requirements for rendering anything.
   * @returns `true` if card rendering can continue.
   */
  public async initializeMandatory(): Promise<void> {
    await this._initializationQueue.add(() => this._initializeMandatory());
  }

  protected async _initializeMandatory(): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();
    if (!hass || this.isInitializedMandatory()) {
      return;
    }

    if (
      !(await this._initializer.initializeMultipleIfNecessary({
        // Caution: Ensure nothing in this set of initializers requires
        // config or languages since they will not yet have been initialized.
        [InitializationAspect.LANGUAGES]: async () => await loadLanguages(hass),
        [InitializationAspect.SIDE_LOAD_ELEMENTS]: async () =>
          await sideLoadHomeAssistantElements(),
      }))
    ) {
      return;
    }

    const config = this._api.getConfigManager().getConfig();
    if (!config) {
      return;
    }

    if (
      !(await this._initializer.initializeMultipleIfNecessary({
        [InitializationAspect.CAMERAS]: async () => {
          // Recreate the camera manager to guarantee an immediate re-render.
          // See: https://github.com/dermotduffy/advanced-camera-card/issues/1811
          // See: https://github.com/dermotduffy/advanced-camera-card/issues/1769
          this._api.createCameraManager();
          return await this._api.getCameraManager().initializeCamerasFromConfig();
        },

        // Connecting the microphone (if configured) is considered mandatory to
        // avoid issues with some cameras that only allow 2-way audio on the
        // first stream initialized.
        // See: https://github.com/dermotduffy/advanced-camera-card/issues/1235
        ...(this._api.getMicrophoneManager().shouldConnectOnInitialization() && {
          [InitializationAspect.MICROPHONE_CONNECT]: async () => {
            // Recreate the microphone manager to guarantee an immediate
            // re-render.
            this._api.createMicrophoneManager();
            return await this._api.getMicrophoneManager().connect();
          },
        }),
      }))
    ) {
      return;
    }

    if (
      this._api.getMessageManager().hasMessage() ||
      !(await this._initializer.initializeIfNecessary(
        InitializationAspect.VIEW,
        this._api.getViewManager().initialize,
      ))
    ) {
      return;
    }

    if (
      !(await this._initializer.initializeIfNecessary(
        InitializationAspect.INITIAL_TRIGGER,
        async (): Promise<boolean> => {
          await this._api.getTriggersManager().handleInitialCameraTriggers();

          // Force a card update to continue the initialization.
          this._api.getCardElementManager().update();
          return true;
        },
      ))
    ) {
      return;
    }

    this._everInitialized = true;

    // When the card is initialized, both the initialization state (will never
    // change again), and the config are set in the condition state. The
    // config is set here, rather than in the ConfigManager, in order to
    // ensure actions (that trigger on config change) are not run before hass
    // is available and the card is initialzied (the first config is set in
    // the card *before* hass is set in the card).
    this._api.getConditionStateManager().setState({
      config: config,
      initialized: this._everInitialized,
    });

    this._api.getCardElementManager().update();
  }

  public uninitialize(aspect: InitializationAspect): void {
    this._initializer.uninitialize(aspect);
  }
}



================================================
FILE: src/card-controller/interaction-manager.ts
================================================
import { throttle } from 'lodash-es';
import { setOrRemoveAttribute } from '../utils/basic';
import { Timer } from '../utils/timer';
import { CardInteractionAPI } from './types';

export class InteractionManager {
  protected _timer = new Timer();
  protected _api: CardInteractionAPI;
  protected _interacted = false;

  constructor(api: CardInteractionAPI) {
    this._api = api;
  }

  // The mouse handler may be called continually, throttle it to at most once
  // per second for performance reasons.
  public reportInteraction = throttle(() => {
    this._reportInteraction();
  }, 1 * 1000);

  public initialize(): void {
    this._setInteraction(false);
  }

  public hasInteraction(): boolean {
    return this._interacted;
  }

  protected _setInteraction(val: boolean): void {
    this._interacted = val;
    setOrRemoveAttribute(
      this._api.getCardElementManager().getElement(),
      val,
      'interaction',
    );
    this._api.getConditionStateManager().setState({ interaction: val });
  }

  protected _reportInteraction(): void {
    this._timer.stop();
    this._setInteraction(true);

    const timeoutSeconds = this._api.getConfigManager().getConfig()
      ?.view.interaction_seconds;
    if (timeoutSeconds) {
      this._timer.start(timeoutSeconds, () => {
        this._setInteraction(false);
      });
    }
  }
}



================================================
FILE: src/card-controller/keyboard-state-manager.ts
================================================
import { CardKeyboardStateAPI, KeysState } from './types';
import { isEqual } from 'lodash-es';

export class KeyboardStateManager {
  protected _api: CardKeyboardStateAPI;
  protected _state: KeysState = {};

  constructor(api: CardKeyboardStateAPI) {
    this._api = api;
  }

  public initialize(): void {
    const element = this._api.getCardElementManager().getElement();
    element.addEventListener('keydown', this._handleKeydown);
    element.addEventListener('keyup', this._handleKeyup);
    element.addEventListener('blur', this._handleBlur);
  }

  public uninitialize(): void {
    const element = this._api.getCardElementManager().getElement();
    element.removeEventListener('keydown', this._handleKeydown);
    element.removeEventListener('keyup', this._handleKeyup);
    element.removeEventListener('blur', this._handleBlur);
  }

  protected _handleKeydown = (ev: KeyboardEvent): void => {
    const keyObj = {
      state: 'down' as const,
      ctrl: ev.ctrlKey,
      alt: ev.altKey,
      meta: ev.metaKey,
      shift: ev.shiftKey,
    };

    if (!isEqual(this._state[ev.key], keyObj)) {
      this._state[ev.key] = keyObj;
      this._processStateChange();
    }
  };

  protected _handleKeyup = (ev: KeyboardEvent): void => {
    if (ev.key in this._state && this._state[ev.key].state === 'down') {
      this._state[ev.key].state = 'up';
      this._processStateChange();
    }
  };

  protected _handleBlur = (): void => {
    if (Object.keys(this._state).length) {
      // State is emptied if the element loses focus.
      this._state = {};
      this._processStateChange();
    }
  };

  protected _processStateChange(): void {
    this._api.getConditionStateManager().setState({ keys: this._state });
  }
}



================================================
FILE: src/card-controller/media-info-manager.ts
================================================
import { MediaLoadedInfo } from '../types';
import { log } from '../utils/debug';
import { isValidMediaLoadedInfo } from '../utils/media-info';
import { CardMediaLoadedAPI } from './types';

export class MediaLoadedInfoManager {
  protected _api: CardMediaLoadedAPI;
  protected _current: MediaLoadedInfo | null = null;
  protected _lastKnown: MediaLoadedInfo | null = null;

  constructor(api: CardMediaLoadedAPI) {
    this._api = api;
  }

  public initialize(): void {
    this.clear();
  }

  public set(mediaLoadedInfo: MediaLoadedInfo): void {
    if (!isValidMediaLoadedInfo(mediaLoadedInfo)) {
      return;
    }

    log(
      this._api.getConfigManager().getCardWideConfig(),
      `Advanced Camera Card media load: `,
      mediaLoadedInfo,
    );

    this._current = mediaLoadedInfo;
    this._lastKnown = mediaLoadedInfo;

    this._api.getConditionStateManager().setState({ mediaLoadedInfo: mediaLoadedInfo });

    // Fresh media information may change how the card is rendered.
    this._api.getStyleManager().setExpandedMode();
    this._api.getCardElementManager().update();
  }

  public get(): MediaLoadedInfo | null {
    return this._current;
  }

  public getLastKnown(): MediaLoadedInfo | null {
    return this._lastKnown;
  }

  public clear(): void {
    this._current = null;
    this._api.getConditionStateManager().setState({ mediaLoadedInfo: null });
  }

  public has(): boolean {
    return !!this._current;
  }
}



================================================
FILE: src/card-controller/media-player-manager.ts
================================================
import { CameraConfig } from '../config/schema/cameras';
import { AdvancedCameraCardConfig } from '../config/schema/types';
import {
  MEDIA_PLAYER_SUPPORT_BROWSE_MEDIA,
  MEDIA_PLAYER_SUPPORT_STOP,
  MEDIA_PLAYER_SUPPORT_TURN_OFF,
} from '../const';
import { Entity } from '../ha/registry/entity/types';
import { supportsFeature } from '../ha/supports-feature';
import { localize } from '../localize/localize';
import { errorToConsole } from '../utils/basic';
import { ViewMedia } from '../view/item';
import { ViewItemClassifier } from '../view/item-classifier';
import { CardMediaPlayerAPI } from './types';

export class MediaPlayerManager {
  protected _mediaPlayers: string[] = [];

  protected _api: CardMediaPlayerAPI;

  constructor(api: CardMediaPlayerAPI) {
    this._api = api;
  }

  public getMediaPlayers(): string[] {
    return this._mediaPlayers;
  }

  public hasMediaPlayers(): boolean {
    return this._mediaPlayers.length > 0;
  }

  public async initializeIfNecessary(
    previousConfig: AdvancedCameraCardConfig | null,
  ): Promise<void> {
    if (
      previousConfig?.menu.buttons.media_player.enabled !==
      this._api.getConfigManager().getConfig()?.menu.buttons.media_player.enabled
    ) {
      await this.initialize();
    }
  }

  public async initialize(): Promise<boolean> {
    const hass = this._api.getHASSManager().getHASS();
    if (
      !hass ||
      !this._api.getConfigManager().getConfig()?.menu.buttons.media_player.enabled
    ) {
      return false;
    }

    const isValidMediaPlayer = (entityID: string): boolean => {
      if (entityID.startsWith('media_player.')) {
        const stateObj = hass.states[entityID];
        if (
          stateObj &&
          stateObj.state !== 'unavailable' &&
          supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_BROWSE_MEDIA)
        ) {
          return true;
        }
      }
      return false;
    };

    const mediaPlayers = Object.keys(hass.states).filter(isValidMediaPlayer);
    let mediaPlayerEntities: Map<string, Entity> | null = null;
    try {
      mediaPlayerEntities = await this._api
        .getEntityRegistryManager()
        .getEntities(hass, mediaPlayers);
    } catch (e) {
      // Failing to fetch media player information is not considered
      // sufficiently serious to block card startup -- it is just logged and we
      // move on.
      errorToConsole(e as Error);
    }

    // Filter out entities that are marked as hidden (this information is not
    // available in the HA state, only in the registry).
    this._mediaPlayers = mediaPlayers.filter((entityID) => {
      // Specifically allow for media players that are not found in the entity registry:
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1016
      const entity = mediaPlayerEntities?.get(entityID);
      return !entity || !entity.hidden_by;
    });

    return true;
  }

  public async stop(mediaPlayer: string): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();
    const stateObj = hass?.states[mediaPlayer];
    if (!stateObj) {
      return;
    }

    let service: string;
    if (supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_STOP)) {
      service = 'media_stop';
    } else if (supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_TURN_OFF)) {
      // Google Cast devices don't support media_stop, but turning off has the
      // same effect.
      service = 'turn_off';
    } else {
      return;
    }

    await hass.callService('media_player', service, {
      entity_id: mediaPlayer,
    });
  }

  public async playLive(mediaPlayer: string, cameraID: string): Promise<void> {
    const cameraConfig = this._api
      .getCameraManager()
      .getStore()
      .getCameraConfig(cameraID);
    if (!cameraConfig) {
      return;
    }

    if (cameraConfig.cast?.method === 'dashboard') {
      await this._playLiveDashboard(mediaPlayer, cameraConfig);
    } else {
      await this._playLiveStandard(mediaPlayer, cameraID, cameraConfig);
    }
  }

  protected async _playLiveStandard(
    mediaPlayer: string,
    cameraID: string,
    cameraConfig: CameraConfig,
  ): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();
    const cameraEntity = cameraConfig?.camera_entity ?? null;

    if (!hass || !cameraEntity) {
      return;
    }

    const title =
      this._api.getCameraManager().getCameraMetadata(cameraID)?.title ?? null;
    const thumbnail = hass.states[cameraEntity]?.attributes?.entity_picture ?? null;

    await hass.callService('media_player', 'play_media', {
      entity_id: mediaPlayer,
      media_content_id: `media-source://camera/${cameraEntity}`,
      media_content_type: 'application/vnd.apple.mpegurl',
      extra: {
        ...(title && { title: title }),
        ...(thumbnail && { thumb: thumbnail }),
      },
    });
  }

  protected async _playLiveDashboard(
    mediaPlayer: string,
    cameraConfig: CameraConfig,
  ): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();
    if (!hass) {
      return;
    }

    const dashboardConfig = cameraConfig.cast?.dashboard;
    if (!dashboardConfig?.dashboard_path || !dashboardConfig?.view_path) {
      this._api.getMessageManager().setMessageIfHigherPriority({
        type: 'error',
        icon: 'mdi:cast',
        message: localize('error.no_dashboard_or_view'),
      });
      return;
    }

    // When this bug is closed, a query string could be included:
    // https://github.com/home-assistant/core/issues/98316
    await hass.callService('cast', 'show_lovelace_view', {
      entity_id: mediaPlayer,
      dashboard_path: dashboardConfig.dashboard_path,
      view_path: dashboardConfig.view_path,
    });
  }

  public async playMedia(mediaPlayer: string, media?: ViewMedia | null): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();

    if (!hass || !media) {
      return;
    }

    const title = media.getTitle();
    const thumbnail = media.getThumbnail();

    await hass.callService('media_player', 'play_media', {
      entity_id: mediaPlayer,
      media_content_id: media.getContentID(),
      media_content_type: ViewItemClassifier.isVideo(media) ? 'video' : 'image',
      extra: {
        ...(title && { title: title }),
        ...(thumbnail && { thumb: thumbnail }),
      },
    });
  }
}



================================================
FILE: src/card-controller/message-manager.ts
================================================
import { AdvancedCameraCardError, Message, MessageType } from '../types';
import { errorToConsole } from '../utils/basic';
import { CardMessageAPI } from './types';

type MessagePriority = {
  [type in MessageType]: number;
};

const MESSAGE_TYPE_PRIORITIES: MessagePriority = {
  info: 10,
  error: 20,
  connection: 30,
  diagnostics: 40,
};

export class MessageManager {
  protected _message: Message | null = null;
  protected _api: CardMessageAPI;

  constructor(api: CardMessageAPI) {
    this._api = api;
  }

  public getMessage(): Message | null {
    return this._message;
  }

  public hasMessage(): boolean {
    return !!this._message;
  }

  public hasErrorMessage(): boolean {
    return this._message?.type === 'error';
  }

  public reset(): void {
    const hadMessage = this.hasMessage();
    this._message = null;

    if (hadMessage) {
      this._api.getCardElementManager().update();
    }
  }

  public resetType(type: MessageType): void {
    if (this._message?.type === type) {
      this.reset();
    }
  }

  public setErrorIfHigherPriority(error: unknown, prefix?: string): void {
    // This object should accept unknown objects to be able to seamlessly
    // process arguments to catch() which can only be unknown/any. HA may throw
    // non Error() based errors.
    if (!error || typeof error !== 'object' || !('message' in error)) {
      return;
    }

    errorToConsole(error);
    this.setMessageIfHigherPriority({
      message: prefix ? `${prefix}: ${error.message}` : String(error.message),
      type: 'error',
      ...(error instanceof AdvancedCameraCardError && { context: error.context }),
    });
  }

  public setMessageIfHigherPriority(message: Message): boolean {
    const resolveMessageType = (message: Message): MessageType => {
      return message.type ?? 'info';
    };
    const currentPriority = this._message
      ? MESSAGE_TYPE_PRIORITIES[resolveMessageType(this._message)]
      : 0;
    const newPriority = MESSAGE_TYPE_PRIORITIES[resolveMessageType(message)];

    if (this._message && newPriority < currentPriority) {
      return false;
    }

    this._message = message;

    // When a message is displayed it effectively unloads the media.
    this._api.getMediaLoadedInfoManager().clear();
    this._api.getCardElementManager().scrollReset();
    this._api.getCardElementManager().update();
    return true;
  }
}



================================================
FILE: src/card-controller/microphone-manager.ts
================================================
import { errorToConsole } from '../utils/basic';
import { Timer } from '../utils/timer';
import { CardMicrophoneAPI, MicrophoneState } from './types';

export class MicrophoneManager {
  protected _api: CardMicrophoneAPI;
  protected _stream?: MediaStream | null;
  protected _timer = new Timer();

  protected _state: MicrophoneState = {
    connected: false,
    muted: true,
    forbidden: false,
  };

  // We keep desired mute state separate from the overall state so that
  // mute/unmute can be expressed before the stream is even created -- and when
  // it's created it will have the right mute status.
  protected _desireMute = true;

  constructor(api: CardMicrophoneAPI) {
    this._api = api;
  }

  public getState(): MicrophoneState {
    return this._state;
  }

  public initialize(): void {
    this._setState();
  }

  public shouldConnectOnInitialization(): boolean {
    return (
      !!this._api.getConfigManager().getConfig()?.live.microphone?.always_connected &&
      // If it won't be possible to connect the microphone at all, we do not
      // block the initialization of the card (the microphone just won't work)
      this.isSupported()
    );
  }

  public isSupported(): boolean {
    // Some browsers will have mediaDevices/getUserMedia as undefined if
    // accessed over http.
    // See: https://github.com/dermotduffy/advanced-camera-card/issues/1543
    return !!navigator.mediaDevices?.getUserMedia;
  }

  public async connect(): Promise<boolean> {
    if (!this.isSupported()) {
      return false;
    }

    try {
      this._stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false,
      });
    } catch (e: unknown) {
      errorToConsole(e as Error);

      this._stream = null;
      this._setState();
      return false;
    }
    this._setDesiredMuteOnStream();
    this._setState();
    return true;
  }

  public disconnect(): void {
    this._stream?.getTracks().forEach((track) => track.stop());

    this._stream = undefined;
    this._setState();
  }

  public getStream(): MediaStream | undefined {
    return this._stream ?? undefined;
  }

  public mute(): void {
    this._desireMute = true;
    this._setDesiredMuteOnStream();
    this._setState();
  }

  public async unmute(): Promise<void> {
    if (!this.isSupported()) {
      return;
    }

    this._desireMute = false;

    if (!this.isConnected() && !this.isForbidden()) {
      // Connecting will automatically set the desired mute.
      await this.connect();
    } else if (this.isConnected()) {
      this._setDesiredMuteOnStream();
      this._setState();
    }
  }

  public isConnected(): boolean {
    return !!this._stream;
  }

  public isForbidden(): boolean {
    return this._stream === null;
  }

  public isMuted(): boolean {
    // For safety, this function always returns the stream mute status directly
    // (rather the desired internal state).
    return !this._stream || this._stream.getTracks().every((track) => !track.enabled);
  }

  protected _setDesiredMuteOnStream(): void {
    this._stream?.getTracks().forEach((track) => {
      track.enabled = !this._desireMute;
    });

    this._startDisconnectTimer();
  }

  protected _startDisconnectTimer(): void {
    const microphoneConfig = this._api.getConfigManager().getConfig()?.live.microphone;

    if (microphoneConfig?.always_connected) {
      return;
    }

    const disconnectSeconds = microphoneConfig?.disconnect_seconds ?? 0;

    if (disconnectSeconds) {
      this._timer.start(disconnectSeconds, () => {
        this.disconnect();
      });
    }
  }

  protected _setState(): void {
    this._state = {
      stream: this._stream,
      connected: this.isConnected(),
      muted: this.isMuted(),
      forbidden: this.isForbidden(),
    };
    this._api.getConditionStateManager().setState({
      microphone: this._state,
    });
    this._api.getCardElementManager().update();
  }
}



================================================
FILE: src/card-controller/query-string-manager.ts
================================================
import { ViewActionConfig } from '../config/schema/actions/custom/view';
import { AdvancedCameraCardCustomActionConfig } from '../config/schema/actions/types';
import {
  createCameraAction,
  createGeneralAction,
  createViewAction,
} from '../utils/action.js';
import { ViewParameters } from '../view/view';
import { CardQueryStringAPI } from './types';
import { SubstreamSelectViewModifier } from './view/modifiers/substream-select';

interface QueryStringViewIntent {
  view?: Partial<ViewParameters> & {
    default?: boolean;
    substream?: string;
  };
  other?: AdvancedCameraCardCustomActionConfig[];
}

export class QueryStringManager {
  protected _api: CardQueryStringAPI;
  protected _shouldRun = true;

  constructor(api: CardQueryStringAPI) {
    this._api = api;
  }

  public hasViewRelatedActionsToRun(): boolean {
    return !!this._calculateIntent().view && this._shouldRun;
  }

  public requestExecution = (): void => {
    this._shouldRun = true;
    this._api.getCardElementManager().update();
  };

  public executeIfNecessary = async (): Promise<void> => {
    if (this._shouldRun) {
      this._shouldRun = false;
      await this._executeViewRelated(this._calculateIntent());
      await this._executeNonViewRelated(this._calculateIntent());
    }
  };

  protected async _executeViewRelated(intent: QueryStringViewIntent): Promise<void> {
    if (intent.view) {
      if (intent.view.default) {
        await this._api.getViewManager().setViewDefaultWithNewQuery({
          params: {
            camera: intent.view.camera,
          },
          ...(intent.view.substream && {
            modifiers: [new SubstreamSelectViewModifier(intent.view.substream)],
          }),
        });
      } else {
        await this._api.getViewManager().setViewByParametersWithNewQuery({
          params: {
            ...(intent.view.view && { view: intent.view.view }),
            ...(intent.view.camera && { camera: intent.view.camera }),
          },
          ...(intent.view.substream && {
            modifiers: [new SubstreamSelectViewModifier(intent.view.substream)],
          }),
        });
      }
    }
  }

  protected async _executeNonViewRelated(intent: QueryStringViewIntent): Promise<void> {
    if (intent.other) {
      await this._api.getActionsManager().executeActions({ actions: intent.other });
    }
  }

  protected _calculateIntent(): QueryStringViewIntent {
    const result: QueryStringViewIntent = {};
    for (const action of this._getActions()) {
      if (this._isViewAction(action)) {
        (result.view ??= {}).view = action.advanced_camera_card_action;
        (result.view ??= {}).default = undefined;
      } else if (action.advanced_camera_card_action === 'default') {
        (result.view ??= {}).default = true;
        (result.view ??= {}).view = undefined;
      } else if (action.advanced_camera_card_action === 'camera_select') {
        (result.view ??= {}).camera = action.camera;
      } else if (action.advanced_camera_card_action === 'live_substream_select') {
        (result.view ??= {}).substream = action.camera;
      } else {
        (result.other ??= []).push(action);
      }
    }
    return result;
  }

  protected _getActions(): AdvancedCameraCardCustomActionConfig[] {
    const params = new URLSearchParams(window.location.search);
    const actions: AdvancedCameraCardCustomActionConfig[] = [];
    const actionRE = new RegExp(
      /^(advanced-camera-card|frigate-card)-action([.:](?<cardID>\w+))?[.:](?<action>\w+)/,
    );
    for (const [key, value] of params.entries()) {
      const match = key.match(actionRE);
      if (!match || !match.groups) {
        continue;
      }
      const cardID: string | undefined = match.groups['cardID'];
      const actionName = match.groups['action'];

      let action: AdvancedCameraCardCustomActionConfig | null = null;
      switch (actionName) {
        case 'camera_select':
        case 'live_substream_select':
          if (value) {
            action = createCameraAction(actionName, value, {
              cardID: cardID,
            });
          }
          break;
        case 'camera_ui':
        case 'default':
        case 'download':
        case 'expand':
        case 'menu_toggle':
          action = createGeneralAction(actionName, {
            cardID: cardID,
          });
          break;
        case 'clip':
        case 'clips':
        case 'diagnostics':
        case 'image':
        case 'live':
        case 'recording':
        case 'recordings':
        case 'snapshot':
        case 'snapshots':
        case 'timeline':
          action = createViewAction(actionName, {
            cardID: cardID,
          });
          break;
        default:
          console.warn(
            `Advanced Camera Card received unknown card action in query string: ${actionName}`,
          );
      }
      if (action) {
        actions.push(action);
      }
    }
    return actions;
  }

  protected _isViewAction = (
    action: AdvancedCameraCardCustomActionConfig,
  ): action is ViewActionConfig => {
    switch (action.advanced_camera_card_action) {
      case 'clip':
      case 'clips':
      case 'diagnostics':
      case 'image':
      case 'live':
      case 'recording':
      case 'recordings':
      case 'snapshot':
      case 'snapshots':
      case 'timeline':
        return true;
    }
    return false;
  };
}



================================================
FILE: src/card-controller/status-bar-item-manager.ts
================================================
import { isEqual } from 'lodash-es';
import { CameraManager } from '../camera-manager/manager';
import { StatusBarItem } from '../config/schema/actions/types';
import { StatusBarConfig } from '../config/schema/status-bar';
import { MediaLoadedInfo } from '../types';
import { View } from '../view/view';
import { CardStatusBarAPI } from './types';

const RESOLUTION_TOLERANCE_PCT = 0.01;

export class StatusBarItemManager {
  protected _api: CardStatusBarAPI;

  constructor(api: CardStatusBarAPI) {
    this._api = api;
  }

  protected _items: StatusBarItem[] = [];
  protected _dynamicItems: StatusBarItem[] = [];

  public addDynamicStatusBarItem(item: StatusBarItem): void {
    if (!this._dynamicItems.includes(item)) {
      this._dynamicItems.push(item);
    }
    this._api.getCardElementManager().update();
  }

  public removeDynamicStatusBarItem(item: StatusBarItem): void {
    this._dynamicItems = this._dynamicItems.filter(
      (existingItem) => !isEqual(existingItem, item),
    );
    this._api.getCardElementManager().update();
  }

  public removeAllDynamicStatusBarItems(): void {
    this._dynamicItems = [];
    this._api.getCardElementManager().update();
  }

  public calculateItems(options?: {
    statusConfig?: StatusBarConfig | null;
    cameraManager?: CameraManager | null;
    view?: View | null;
    mediaLoadedInfo?: MediaLoadedInfo | null;
  }): StatusBarItem[] {
    const cameraMetadata = options?.view
      ? options?.cameraManager?.getCameraMetadata(options?.view?.camera)
      : null;
    const engineIcon = cameraMetadata?.engineIcon ?? null;
    const title = options?.view?.is('live')
      ? cameraMetadata?.title ?? null
      : options?.view?.isViewerView()
        ? options?.view.queryResults?.getSelectedResult()?.getTitle() ?? null
        : null;
    const resolution = options?.mediaLoadedInfo
      ? this._calculateResolution(options?.mediaLoadedInfo)
      : null;
    const technology = options?.mediaLoadedInfo?.technology?.length
      ? options?.mediaLoadedInfo.technology[0]
      : null;

    return [
      ...(title
        ? [
            {
              type: 'custom:advanced-camera-card-status-bar-string' as const,
              string: title,
              expand: true,
              sufficient: true,
              ...options?.statusConfig?.items.title,
            },
          ]
        : []),

      ...(resolution
        ? [
            {
              type: 'custom:advanced-camera-card-status-bar-string' as const,
              string: resolution,
              ...options?.statusConfig?.items.resolution,
            },
          ]
        : []),

      ...(technology && technology === 'webrtc'
        ? [
            {
              type: 'custom:advanced-camera-card-status-bar-icon' as const,
              icon: 'mdi:webrtc',
              ...options?.statusConfig?.items.technology,
            },
          ]
        : !!technology
          ? [
              {
                type: 'custom:advanced-camera-card-status-bar-string' as const,
                string: technology.toUpperCase(),
                ...options?.statusConfig?.items.technology,
              },
            ]
          : []),

      ...(engineIcon
        ? [
            {
              type: 'custom:advanced-camera-card-status-bar-icon' as const,
              icon: engineIcon,
              ...options?.statusConfig?.items.engine,
            },
          ]
        : []),
      ...this._dynamicItems,
    ];
  }

  protected _matchesWidthHeight(
    mediaLoadedInfo: MediaLoadedInfo | null,
    width: number,
    height: number,
  ): boolean {
    const widthMin = width * (1 - RESOLUTION_TOLERANCE_PCT);
    const widthMax = width * (1 + RESOLUTION_TOLERANCE_PCT);
    const heightMin = height * (1 - RESOLUTION_TOLERANCE_PCT);
    const heightMax = height * (1 + RESOLUTION_TOLERANCE_PCT);

    const matchesDimension = (val: number, min: number, max: number): boolean => {
      return val >= min && val <= max;
    };

    // Allows matching the resolution width and height in either orientation,
    // and within RESOLUTION_TOLERANCE_PCT of the resolution.
    return (
      !!mediaLoadedInfo &&
      ((matchesDimension(mediaLoadedInfo.width, widthMin, widthMax) &&
        matchesDimension(mediaLoadedInfo.height, heightMin, heightMax)) ||
        (matchesDimension(mediaLoadedInfo.height, widthMin, widthMax) &&
          matchesDimension(mediaLoadedInfo.width, heightMin, heightMax)))
    );
  }

  protected _calculateResolution(mediaLoadedInfo: MediaLoadedInfo): string {
    // Ordered roughly by a guess at most common towards the top.
    if (this._matchesWidthHeight(mediaLoadedInfo, 1920, 1080)) {
      return '1080p';
    } else if (this._matchesWidthHeight(mediaLoadedInfo, 1280, 720)) {
      return '720p';
    } else if (this._matchesWidthHeight(mediaLoadedInfo, 640, 480)) {
      return 'VGA';
    } else if (this._matchesWidthHeight(mediaLoadedInfo, 3840, 2160)) {
      return '4K';
    } else if (this._matchesWidthHeight(mediaLoadedInfo, 720, 480)) {
      return '480p';
    } else if (this._matchesWidthHeight(mediaLoadedInfo, 720, 576)) {
      return '576p';
    } else if (this._matchesWidthHeight(mediaLoadedInfo, 7680, 4320)) {
      return '8K';
    } else {
      return `${mediaLoadedInfo.width}x${mediaLoadedInfo.height}`;
    }
  }
}



================================================
FILE: src/card-controller/style-manager.ts
================================================
import { StyleInfo } from 'lit/directives/style-map';
import { AdvancedCameraCardConfig, configDefaults } from '../config/schema/types';
import { ThemeConfig, ThemeName } from '../config/schema/view';
import { aspectRatioToStyle, setOrRemoveAttribute } from '../utils/basic';
import { View } from '../view/view';
import { CardStyleAPI } from './types';

export class StyleManager {
  protected _api: CardStyleAPI;

  constructor(api: CardStyleAPI) {
    this._api = api;
  }

  public setExpandedMode(): void {
    const card = this._api.getCardElementManager().getElement();
    const view = this._api.getViewManager().getView();

    // When a new media loads, set the aspect ratio for when the card is
    // expanded/popped-up. This is based exclusively on last media content,
    // as dimension configuration does not apply in fullscreen or expanded mode.
    const lastKnown = this._api.getMediaLoadedInfoManager().getLastKnown();
    card.style.setProperty(
      '--advanced-camera-card-expand-aspect-ratio',
      view?.isAnyMediaView() && lastKnown
        ? `${lastKnown.width} / ${lastKnown.height}`
        : 'unset',
    );
    // Non-media may have no intrinsic dimensions (or multiple media items in a
    // grid) and so we need to explicit request the dialog to use all available
    // space.
    const isGrid = view?.isGrid();
    card.style.setProperty(
      '--advanced-camera-card-expand-width',
      !isGrid && view?.isAnyMediaView()
        ? 'none'
        : 'var(--advanced-camera-card-expand-max-width)',
    );
    card.style.setProperty(
      '--advanced-camera-card-expand-height',
      !isGrid && view?.isAnyMediaView()
        ? 'none'
        : 'var(--advanced-camera-card-expand-max-height)',
    );
  }

  public updateFromConfig(): void {
    this.applyTheme();
    this._setMinMaxHeight();
    this._setPerformance();
    this._setDimmable();
  }

  public applyTheme() {
    const themeConfig = this._api.getConfigManager().getConfig()?.view.theme;
    if (!themeConfig) {
      return;
    }

    const element = this._api.getCardElementManager().getElement();
    const themes = this._getThemeNames(themeConfig);

    setOrRemoveAttribute(element, !!themes, 'themes', themes?.join(' '));

    if (themeConfig.overrides) {
      for (const [key, value] of Object.entries(themeConfig.overrides)) {
        element.style.setProperty(key, value);
      }
    }
  }

  protected _getThemeNames(themeConfig: ThemeConfig): ThemeName[] | null {
    return themeConfig.themes.length
      ? themeConfig.themes
      : configDefaults.view.theme.themes;
  }

  protected _setDimmable(): void {
    const config = this._api.getConfigManager().getConfig();
    setOrRemoveAttribute(
      this._api.getCardElementManager().getElement(),
      !!config?.view.dim,
      'dimmable',
    );
  }

  protected _setMinMaxHeight(): void {
    const config = this._api.getConfigManager().getConfig();
    if (config) {
      const card = this._api.getCardElementManager().getElement();
      card.style.setProperty('--advanced-camera-card-height', config.dimensions.height);
    }
  }

  protected _setPerformance(): void {
    const STYLE_DISABLE_MAP = {
      box_shadow: 'none',
      border_radius: '0px',
    };
    const element = this._api.getCardElementManager().getElement();
    const performance = this._api.getConfigManager().getCardWideConfig()?.performance;

    const styles = performance?.style ?? {};
    for (const configKey of Object.keys(styles)) {
      const CSSKey = `--advanced-camera-card-css-${configKey.replaceAll('_', '-')}`;
      if (styles[configKey] === false) {
        element.style.setProperty(CSSKey, STYLE_DISABLE_MAP[configKey]);
      } else {
        element.style.removeProperty(CSSKey);
      }
    }
  }

  protected _isAspectRatioEnforced(
    config: AdvancedCameraCardConfig,
    view?: View | null,
  ): boolean {
    const aspectRatioMode = config.dimensions.aspect_ratio_mode;

    // Do not artifically constrain aspect ratio if:
    // - It's fullscreen.
    // - It's in expanded mode.
    // - Aspect ratio enforcement is disabled.
    // - Aspect ratio enforcement is dynamic and it's a media view (i.e. not the
    //   gallery) or diagnostics / timeline.
    return !(
      this._api.getFullscreenManager().isInFullscreen() ||
      this._api.getExpandManager().isExpanded() ||
      aspectRatioMode === 'unconstrained' ||
      (aspectRatioMode === 'dynamic' &&
        (!view ||
          view?.isAnyMediaView() ||
          view?.is('timeline') ||
          view?.is('diagnostics')))
    );
  }

  /**
   * Get the aspect ratio padding required to enforce the aspect ratio (if it is
   * required).
   * @returns A padding percentage.
   */
  public getAspectRatioStyle(): StyleInfo {
    const config = this._api.getConfigManager().getConfig();
    const view = this._api.getViewManager().getView();

    if (config) {
      if (!this._isAspectRatioEnforced(config, view)) {
        return aspectRatioToStyle();
      }

      const aspectRatioMode = config.dimensions.aspect_ratio_mode;

      const lastKnown = this._api.getMediaLoadedInfoManager().getLastKnown();
      if (lastKnown && aspectRatioMode === 'dynamic') {
        return aspectRatioToStyle({ ratio: [lastKnown.width, lastKnown.height] });
      }
      return aspectRatioToStyle({ ratio: config.dimensions.aspect_ratio });
    }
    return aspectRatioToStyle({ defaultStatic: true });
  }
}



================================================
FILE: src/card-controller/triggers-manager.ts
================================================
import { orderBy, throttle } from 'lodash-es';
import { CameraEvent } from '../camera-manager/types';
import { isTriggeredState } from '../ha/is-triggered-state';
import { Timer } from '../utils/timer';
import { CardTriggersAPI } from './types';

export class TriggersManager {
  protected _api: CardTriggersAPI;

  protected _triggeredCameras: Map<string, Date> = new Map();
  protected _triggeredCameraTimers: Map<string, Timer> = new Map();

  protected _throttledTriggerAction = throttle(this._triggerAction.bind(this), 1000, {
    trailing: true,
  });

  constructor(api: CardTriggersAPI) {
    this._api = api;
  }

  public getTriggeredCameraIDs(): Set<string> {
    return new Set(this._triggeredCameras.keys());
  }

  public isTriggered(): boolean {
    return !!this._triggeredCameras.size;
  }

  public getMostRecentlyTriggeredCameraID(): string | null {
    const sorted = orderBy(
      [...this._triggeredCameras.entries()],
      (entry) => entry[1].getTime(),
      'desc',
    );
    return sorted.length ? sorted[0][0] : null;
  }

  public handleInitialCameraTriggers = async (): Promise<boolean> => {
    const hass = this._api.getHASSManager().getHASS();
    let triggered = false;

    for (const [cameraID, camera] of this._api
      .getCameraManager()
      .getStore()
      .getCameras()) {
      if (
        camera
          .getConfig()
          .triggers.entities.some((entityID) =>
            isTriggeredState(hass?.states[entityID]?.state),
          )
      ) {
        triggered = true;
        await this.handleCameraEvent({
          cameraID,
          type: 'new',
        });
      }
    }
    return triggered;
  };

  public async handleCameraEvent(ev: CameraEvent): Promise<void> {
    const triggersConfig = this._api.getConfigManager().getConfig()?.view.triggers;
    const selectedCameraID = this._api.getViewManager().getView()?.camera;

    if (!triggersConfig || !selectedCameraID) {
      return;
    }

    const dependentCameraIDs = this._api
      .getCameraManager()
      .getStore()
      .getAllDependentCameras(selectedCameraID);

    if (triggersConfig.filter_selected_camera && !dependentCameraIDs.has(ev.cameraID)) {
      return;
    }

    if (ev.type === 'end') {
      this._startUntriggerTimer(ev.cameraID);
      return;
    }

    this._triggeredCameras.set(ev.cameraID, new Date());
    this._setConditionStateIfNecessary();
    await this._throttledTriggerAction(ev);
  }

  protected _hasAllowableInteractionStateForAction(): boolean {
    const triggersConfig = this._api.getConfigManager().getConfig()?.view.triggers;
    const hasInteraction = this._api.getInteractionManager().hasInteraction();

    return (
      !!triggersConfig &&
      (triggersConfig.actions.interaction_mode === 'all' ||
        (triggersConfig.actions.interaction_mode === 'active' && hasInteraction) ||
        (triggersConfig.actions.interaction_mode === 'inactive' && !hasInteraction))
    );
  }

  protected async _triggerAction(ev: CameraEvent): Promise<void> {
    const triggerAction = this._api.getConfigManager().getConfig()?.view.triggers
      .actions.trigger;
    const defaultView = this._api.getConfigManager().getConfig()?.view.default;

    // If this is a high-fidelity event where we are certain about new media,
    // don't take action unless it's to change to live (Frigate engine may pump
    // out events where there's no new media to show). Other trigger actions
    // (e.g. media, update) do not make sense without having some new media.
    if (
      ev.fidelity === 'high' &&
      !ev.snapshot &&
      !ev.clip &&
      !(
        triggerAction === 'live' ||
        (triggerAction === 'default' && defaultView === 'live')
      )
    ) {
      return;
    }

    if (this._hasAllowableInteractionStateForAction()) {
      if (triggerAction === 'update') {
        await this._api.getViewManager().setViewByParametersWithNewQuery({
          queryExecutorOptions: { useCache: false },
        });
      } else if (triggerAction === 'live') {
        await this._api.getViewManager().setViewByParametersWithNewQuery({
          params: {
            view: 'live',
            camera: ev.cameraID,
          },
        });
      } else if (triggerAction === 'default') {
        await this._api.getViewManager().setViewDefaultWithNewQuery({
          params: {
            camera: ev.cameraID,
          },
        });
      } else if (ev.fidelity === 'high' && triggerAction === 'media') {
        await this._api.getViewManager().setViewByParametersWithNewQuery({
          params: {
            view: ev.clip ? 'clip' : 'snapshot',
            camera: ev.cameraID,
          },
        });
      }
    }

    // Must update master element to add border pulsing to live view.
    this._api.getCardElementManager().update();
  }

  protected _setConditionStateIfNecessary(): void {
    const triggeredCameraIDs = new Set(this._triggeredCameras.keys());
    const triggeredState = triggeredCameraIDs.size ? triggeredCameraIDs : undefined;

    this._api.getConditionStateManager().setState({
      triggered: triggeredState,
    });
  }

  protected async _untriggerAction(cameraID: string): Promise<void> {
    const action = this._api.getConfigManager().getConfig()?.view.triggers
      .actions.untrigger;

    if (action === 'default' && this._hasAllowableInteractionStateForAction()) {
      await this._api.getViewManager().setViewDefaultWithNewQuery();
    }
    this._triggeredCameras.delete(cameraID);
    this._deleteTimer(cameraID);
    this._setConditionStateIfNecessary();

    // Must update master element to remove border pulsing from live view.
    this._api.getCardElementManager().update();
  }

  protected _startUntriggerTimer(cameraID: string): void {
    this._deleteTimer(cameraID);

    const timer = new Timer();
    this._triggeredCameraTimers.set(cameraID, timer);
    timer.start(
      /* istanbul ignore next: the case of config being null here cannot be
         reached, as there's no way to have the untrigger call happen without
         a config. -- @preserve */
      this._api.getConfigManager().getConfig()?.view.triggers.untrigger_seconds ?? 0,
      async () => {
        await this._untriggerAction(cameraID);
      },
    );
  }

  protected _deleteTimer(cameraID: string): void {
    this._triggeredCameraTimers.get(cameraID)?.stop();
    this._triggeredCameraTimers.delete(cameraID);
  }
}



================================================
FILE: src/card-controller/types.ts
================================================
import type { CameraManager } from '../camera-manager/manager';
import type { ConditionStateManager } from '../conditions/state-manager';
import type { Automation } from '../config/schema/automations';
import type { EntityRegistryManager } from '../ha/registry/entity/types';
import type { ResolvedMediaCache } from '../ha/resolved-media';
import type { ActionsManager } from './actions/actions-manager';
import type { AutomationsManager } from './automations-manager';
import type { CameraURLManager } from './camera-url-manager';
import type { CardElementManager } from './card-element-manager';
import type { ConfigManager } from './config/config-manager';
import type { DefaultManager } from './default-manager';
import type { ExpandManager } from './expand-manager';
import type { FoldersManager } from './folders/manager';
import type { FullscreenManager } from './fullscreen/fullscreen-manager';
import type { HASSManager } from './hass/hass-manager';
import type { InitializationManager } from './initialization-manager';
import type { InteractionManager } from './interaction-manager';
import type { KeyboardStateManager } from './keyboard-state-manager';
import type { MediaLoadedInfoManager } from './media-info-manager';
import type { MediaPlayerManager } from './media-player-manager';
import type { MessageManager } from './message-manager';
import type { MicrophoneManager } from './microphone-manager';
import type { QueryStringManager } from './query-string-manager';
import type { StatusBarItemManager } from './status-bar-item-manager';
import type { StyleManager } from './style-manager';
import type { TriggersManager } from './triggers-manager';
import type { ViewItemManager } from './view/item-manager';
import type { ViewManager } from './view/view-manager';

// *************************************************************************
//                             Manager APIs
// This defines a series of limited APIs that various managers use to control
// the card. Explicitly specifying them helps make coupling intentional and
// reduce cyclic dependencies.
// *************************************************************************

export interface CardActionsAPI {
  getActionsManager(): ActionsManager;
  getCameraManager(): CameraManager;
  getCameraURLManager(): CameraURLManager;
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getExpandManager(): ExpandManager;
  getFoldersManager(): FoldersManager;
  getFullscreenManager(): FullscreenManager;
  getHASSManager(): HASSManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getMediaPlayerManager(): MediaPlayerManager;
  getMessageManager(): MessageManager;
  getMicrophoneManager(): MicrophoneManager;
  getStatusBarItemManager(): StatusBarItemManager;
  getTriggersManager(): TriggersManager;
  getViewItemManager(): ViewItemManager;
  getViewManager(): ViewManager;
}
export type CardActionsManagerAPI = CardActionsAPI;

export interface CardAutomationsAPI {
  getActionsManager(): ActionsManager;
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getHASSManager(): HASSManager;
  getInitializationManager(): InitializationManager;
  getMessageManager(): MessageManager;
}

export interface CardCameraAPI {
  getActionsManager(): ActionsManager;
  getConfigManager(): ConfigManager;
  getEntityRegistryManager(): EntityRegistryManager;
  getHASSManager(): HASSManager;
  getMessageManager(): MessageManager;
  getResolvedMediaCache(): ResolvedMediaCache;
  getTriggersManager(): TriggersManager;
}

export interface CardCameraURLAPI {
  getCameraManager(): CameraManager;
  getViewManager(): ViewManager;
}

export interface CardConditionAPI {
  getAutomationsManager(): AutomationsManager;
  getConfigManager(): ConfigManager;
}

export interface CardConfigAPI {
  getAutomationsManager(): AutomationsManager;
  getCameraManager(): CameraManager;
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getDefaultManager(): DefaultManager;
  getFoldersManager(): FoldersManager;
  getHASSManager(): HASSManager;
  getInitializationManager(): InitializationManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getMediaPlayerManager(): MediaPlayerManager;
  getMessageManager(): MessageManager;
  getMicrophoneManager(): MicrophoneManager;
  getStatusBarItemManager(): StatusBarItemManager;
  getStyleManager(): StyleManager;
  getViewManager(): ViewManager;
}

export interface CardConfigLoaderAPI {
  getAutomationsManager(): AutomationsManager;
  getConfigManager(): ConfigManager;
  getFoldersManager(): FoldersManager;
  getMessageManager(): MessageManager;
  getHASSManager(): HASSManager;
}

export interface CardDefaultManagerAPI {
  getAutomationsManager(): AutomationsManager;
  getConfigManager(): ConfigManager;
  getHASSManager(): HASSManager;
  getInteractionManager(): InteractionManager;
  getTriggersManager(): TriggersManager;
  getViewManager(): ViewManager;
}

export interface CardDownloadAPI {
  getCameraManager(): CameraManager;
  getHASSManager(): HASSManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getMessageManager(): MessageManager;
  getViewManager(): ViewManager;
}

export interface CardElementAPI {
  getActionsManager(): ActionsManager;
  getCameraManager(): CameraManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getDefaultManager(): DefaultManager;
  getExpandManager(): ExpandManager;
  getFullscreenManager(): FullscreenManager;
  getInitializationManager(): InitializationManager;
  getInteractionManager(): InteractionManager;
  getHASSManager(): HASSManager;
  getKeyboardStateManager(): KeyboardStateManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getMediaPlayerManager(): MediaPlayerManager;
  getMicrophoneManager(): MicrophoneManager;
  getQueryStringManager(): QueryStringManager;
}

export interface CardExpandAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getFullscreenManager(): FullscreenManager;
}

export interface CardFoldersAPI {
  getConfigManager(): ConfigManager;
  getHASSManager(): HASSManager;
  getResolvedMediaCache(): ResolvedMediaCache;
}

export interface CardFullscreenAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getExpandManager(): ExpandManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getMediaPlayerManager(): MediaPlayerManager;
}

export interface CardHASSAPI {
  getCameraManager(): CameraManager;
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getDefaultManager(): DefaultManager;
  getInteractionManager(): InteractionManager;
  getMediaPlayerManager(): MediaPlayerManager;
  getMessageManager(): MessageManager;
  getStyleManager(): StyleManager;
  getTriggersManager(): TriggersManager;
  getViewManager(): ViewManager;
}

export interface CardInitializerAPI {
  createCameraManager(): void;
  getCameraManager(): CameraManager;

  createMicrophoneManager(): void;
  getMicrophoneManager(): MicrophoneManager;

  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getConditionStateManager(): ConditionStateManager;
  getDefaultManager(): DefaultManager;
  getEntityRegistryManager(): EntityRegistryManager;
  getHASSManager(): HASSManager;
  getMediaPlayerManager(): MediaPlayerManager;
  getMessageManager(): MessageManager;
  getQueryStringManager(): QueryStringManager;
  getResolvedMediaCache(): ResolvedMediaCache;
  getTriggersManager(): TriggersManager;
  getViewManager(): ViewManager;
}

export interface CardInteractionAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getStyleManager(): StyleManager;
  getTriggersManager(): TriggersManager;
  getViewManager(): ViewManager;
}

export interface CardKeyboardStateAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
}

export interface CardMediaLoadedAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getFullscreenManager(): FullscreenManager;
  getStyleManager(): StyleManager;
}

export interface CardMediaPlayerAPI {
  getCameraManager(): CameraManager;
  getConfigManager(): ConfigManager;
  getEntityRegistryManager(): EntityRegistryManager;
  getHASSManager(): HASSManager;
  getMessageManager(): MessageManager;
  getQueryStringManager(): QueryStringManager;
}

export interface CardMessageAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
}

export interface CardMicrophoneAPI {
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
}

export interface CardQueryStringAPI {
  getActionsManager(): ActionsManager;
  getCardElementManager(): CardElementManager;
  getViewManager(): ViewManager;
}

export interface CardStatusBarAPI {
  getCardElementManager(): CardElementManager;
}

export interface CardStyleAPI {
  getCardElementManager(): CardElementManager;
  getConfigManager(): ConfigManager;
  getExpandManager(): ExpandManager;
  getFullscreenManager(): FullscreenManager;
  getHASSManager(): HASSManager;
  getInteractionManager(): InteractionManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getViewManager(): ViewManager;
}

export interface CardTriggersAPI {
  getCameraManager(): CameraManager;
  getConditionStateManager(): ConditionStateManager;
  getCardElementManager(): CardElementManager;
  getConfigManager(): ConfigManager;
  getHASSManager(): HASSManager;
  getInteractionManager(): InteractionManager;
  getViewManager(): ViewManager;
}

export interface CardViewAPI {
  getCameraManager(): CameraManager;
  getCardElementManager(): CardElementManager;
  getConditionStateManager(): ConditionStateManager;
  getConfigManager(): ConfigManager;
  getFoldersManager(): FoldersManager;
  getHASSManager(): HASSManager;
  getInitializationManager(): InitializationManager;
  getMediaLoadedInfoManager(): MediaLoadedInfoManager;
  getMessageManager(): MessageManager;
  getQueryStringManager(): QueryStringManager;
  getStyleManager(): StyleManager;
  getTriggersManager(): TriggersManager;
}

// *************************************************************************
//                             Common Types
// *************************************************************************

export interface KeysState {
  [key: string]: {
    state: 'down' | 'up';
    ctrl: boolean;
    shift: boolean;
    alt: boolean;
    meta: boolean;
  };
}

export interface MicrophoneState {
  stream?: MediaStream | null;
  connected: boolean;
  muted: boolean;
  forbidden: boolean;
}

export interface TaggedAutomation extends Automation {
  tag?: unknown;
}



================================================
FILE: src/card-controller/actions/actions-manager.ts
================================================
import { ActionContext } from 'action';
import { z } from 'zod';
import {
  ActionConfig,
  Actions,
  ActionsConfig,
} from '../../config/schema/actions/types.js';
import { forwardHaptic } from '../../ha/haptic.js';
import {
  getActionConfigGivenAction,
  isAdvancedCameraCardCustomAction,
} from '../../utils/action.js';
import { allPromises, errorToConsole } from '../../utils/basic.js';
import { TemplateRenderer } from '../templates/index.js';
import { CardActionsManagerAPI } from '../types.js';
import { ActionSet } from './actions/set.js';
import { ActionsExecutionRequest, ActionsExecutor } from './types.js';

const INTERACTIONS = ['tap', 'double_tap', 'hold', 'start_tap', 'end_tap'] as const;
export type InteractionName = (typeof INTERACTIONS)[number];

const interactionSchema = z.object({
  action: z.enum(INTERACTIONS),
});
export type Interaction = z.infer<typeof interactionSchema>;

const interactionEventSchema = z.object({
  detail: interactionSchema,
});

export class ActionsManager implements ActionsExecutor {
  protected _api: CardActionsManagerAPI;
  protected _actionsInFlight: ActionSet[] = [];
  protected _actionContext: ActionContext = {};
  protected _templateRenderer: TemplateRenderer | null;

  constructor(api: CardActionsManagerAPI, templateRenderer?: TemplateRenderer) {
    this._api = api;
    this._templateRenderer = templateRenderer ?? null;
  }

  /**
   * Merge card-wide and view-specific actions.
   * @returns A combined set of action.
   */
  public getMergedActions(): ActionsConfig {
    const view = this._api.getViewManager().getView();
    if (this._api.getMessageManager().hasMessage()) {
      return {};
    }

    const config = this._api.getConfigManager().getConfig();
    let specificActions: Actions | undefined = undefined;
    if (view?.is('live')) {
      specificActions = config?.live.actions;
    } else if (view?.isMediaGalleryView()) {
      specificActions = config?.media_gallery?.actions;
    } else if (view?.isViewerView()) {
      specificActions = config?.media_viewer.actions;
    } else if (view?.is('image')) {
      specificActions = config?.image?.actions;
    } else {
      return {};
    }
    return { ...config?.view.actions, ...specificActions };
  }

  /**
   * Handle an human interaction called on an element (e.g. 'tap').
   */
  public handleInteractionEvent = async (ev: Event): Promise<void> => {
    const result = interactionEventSchema.safeParse(ev);
    if (!result.success) {
      return;
    }
    const interaction = result.data.detail.action;
    const config = this.getMergedActions();
    const actionConfig = getActionConfigGivenAction(interaction, config);
    if (
      config &&
      interaction &&
      // Don't execute unless there is explicitly an action defined (as it uses
      // a default that is unhelpful for views that have default tap/click
      // actions).
      actionConfig
    ) {
      await this.executeActions({ actions: actionConfig, config });
    }
  };

  /**
   * This method is called when an ll-custom event is fired. This is used by
   * cards to fire custom actions. This card itself should not call this, but
   * embedded elements may.
   */
  public handleCustomActionEvent = async (
    ev: Event | CustomEvent<ActionConfig>,
  ): Promise<void> => {
    if (!('detail' in ev)) {
      // The event may or may not be a CustomEvent object. For example, whilst
      // this card doesn't use custom-card-helpers, embedded elements may:
      // https://github.com/custom-cards/custom-card-helpers/blob/master/src/fire-event.ts#L70
      return;
    }
    const action: ActionConfig = ev.detail;

    // If the received action is not a custom action specifically for this card
    // to handle, ignore it. Otherwise, we can get action "loops". See:
    // https://github.com/dermotduffy/advanced-camera-card/issues/1969
    if (!isAdvancedCameraCardCustomAction(action)) {
      return;
    }

    await this.executeActions({ actions: action });
  };

  /**
   * This method handles actions requested by components of the Advanced Camera
   * Card itself (e.g. menu, PTZ controller).
   */
  public handleActionExecutionRequestEvent = async (
    ev: CustomEvent<ActionsExecutionRequest>,
  ): Promise<void> => {
    await this.executeActions(ev.detail);
  };

  public async uninitialize(): Promise<void> {
    // If there are any long-running actions, ensure they are stopped.
    await allPromises(this._actionsInFlight, (actionSet) => actionSet.stop());
  }

  public async executeActions(request: ActionsExecutionRequest): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();
    const renderedAction: ActionConfig | ActionConfig[] =
      hass && this._templateRenderer
        ? (this._templateRenderer.renderRecursively(hass, request.actions, {
            conditionState: this._api.getConditionStateManager().getState(),
            triggerData: request?.triggerData,
          }) as ActionConfig | ActionConfig[])
        : request.actions;

    const actionSet = new ActionSet(this._actionContext, renderedAction, {
      config: request.config,
      cardID: this._api.getConfigManager().getConfig()?.card_id,
    });

    this._actionsInFlight.push(actionSet);

    try {
      await actionSet.execute(this._api);
      forwardHaptic('success');
    } catch (e) {
      errorToConsole(e as Error);
      forwardHaptic('warning');
    }
    this._actionsInFlight = this._actionsInFlight.filter((a) => a !== actionSet);
  }
}



================================================
FILE: src/card-controller/actions/factory.ts
================================================
import { ActionContext } from 'action';
import { INTERNAL_CALLBACK_ACTION } from '../../config/schema/actions/custom/internal';
import { ActionConfig, AuxillaryActionConfig } from '../../config/schema/actions/types';
import { isAdvancedCameraCardCustomAction } from '../../utils/action';
import { CallServiceAction } from './actions/call-service';
import { CameraSelectAction } from './actions/camera-select';
import { CameraUIAction } from './actions/camera-ui';
import { CustomAction } from './actions/custom';
import { DefaultAction } from './actions/default';
import { DisplayModeSelectAction } from './actions/display-mode-select';
import { DownloadAction } from './actions/download';
import { ExpandAction } from './actions/expand';
import { FoldersViewAction } from './actions/folders-view';
import { FullscreenAction } from './actions/fullscreen';
import { InternalCallbackAction } from './actions/internal-callback';
import { LogAction } from './actions/log';
import { MediaPlayerAction } from './actions/media-player';
import { MenuToggleAction } from './actions/menu-toggle';
import { MicrophoneConnectAction } from './actions/microphone-connect';
import { MicrophoneDisconnectAction } from './actions/microphone-disconnect';
import { MicrophoneMuteAction } from './actions/microphone-mute';
import { MicrophoneUnmuteAction } from './actions/microphone-unmute';
import { MoreInfoAction } from './actions/more-info';
import { MuteAction } from './actions/mute';
import { NavigateAction } from './actions/navigate';
import { NoneAction } from './actions/none';
import { PauseAction } from './actions/pause';
import { PerformActionAction } from './actions/perform-action';
import { PlayAction } from './actions/play';
import { PTZAction } from './actions/ptz';
import { PTZControlsAction } from './actions/ptz-controls';
import { PTZDigitalAction } from './actions/ptz-digital';
import { PTZMultiAction } from './actions/ptz-multi';
import { ScreenshotAction } from './actions/screenshot';
import { SleepAction } from './actions/sleep';
import { StatusBarAction } from './actions/status-bar';
import { SubstreamOffAction } from './actions/substream-off';
import { SubstreamOnAction } from './actions/substream-on';
import { SubstreamSelectAction } from './actions/substream-select';
import { ToggleAction } from './actions/toggle';
import { UnmuteAction } from './actions/unmute';
import { URLAction } from './actions/url';
import { ViewAction } from './actions/view';
import { Action } from './types';

export class ActionFactory {
  public createAction(
    context: ActionContext,
    action: ActionConfig,
    options?: {
      config?: AuxillaryActionConfig;
      cardID?: string;
    },
  ): Action | null {
    if (
      // Command not intended for this card (e.g. query string command).
      action.card_id &&
      action.card_id !== options?.cardID
    ) {
      return null;
    }

    switch (action.action) {
      case 'more-info':
        return new MoreInfoAction(context, action, options?.config);
      case 'toggle':
        return new ToggleAction(context, action, options?.config);
      case 'navigate':
        return new NavigateAction(context, action, options?.config);
      case 'url':
        return new URLAction(context, action, options?.config);
      case 'perform-action':
        return new PerformActionAction(context, action, options?.config);
      case 'call-service':
        return new CallServiceAction(context, action, options?.config);
      case 'none':
        return new NoneAction(context, action, options?.config);
    }

    if (!isAdvancedCameraCardCustomAction(action)) {
      return new CustomAction(context, action, options?.config);
    }

    switch (action.advanced_camera_card_action) {
      case 'default':
        return new DefaultAction(context, action, options?.config);
      case 'clip':
      case 'clips':
      case 'image':
      case 'live':
      case 'recording':
      case 'recordings':
      case 'snapshot':
      case 'snapshots':
      case 'timeline':
      case 'diagnostics':
        return new ViewAction(context, action, options?.config);
      case 'sleep':
        return new SleepAction(context, action, options?.config);
      case 'download':
        return new DownloadAction(context, action, options?.config);
      case 'camera_ui':
        return new CameraUIAction(context, action, options?.config);
      case 'expand':
        return new ExpandAction(context, action, options?.config);
      case 'fullscreen':
        return new FullscreenAction(context, action, options?.config);
      case 'menu_toggle':
        return new MenuToggleAction(context, action, options?.config);
      case 'camera_select':
        return new CameraSelectAction(context, action, options?.config);
      case 'live_substream_select':
        return new SubstreamSelectAction(context, action, options?.config);
      case 'live_substream_off':
        return new SubstreamOffAction(context, action, options?.config);
      case 'live_substream_on':
        return new SubstreamOnAction(context, action, options?.config);
      case 'media_player':
        return new MediaPlayerAction(context, action, options?.config);
      case 'microphone_connect':
        return new MicrophoneConnectAction(context, action, options?.config);
      case 'microphone_disconnect':
        return new MicrophoneDisconnectAction(context, action, options?.config);
      case 'microphone_mute':
        return new MicrophoneMuteAction(context, action, options?.config);
      case 'microphone_unmute':
        return new MicrophoneUnmuteAction(context, action, options?.config);
      case 'mute':
        return new MuteAction(context, action, options?.config);
      case 'unmute':
        return new UnmuteAction(context, action, options?.config);
      case 'play':
        return new PlayAction(context, action, options?.config);
      case 'pause':
        return new PauseAction(context, action, options?.config);
      case 'screenshot':
        return new ScreenshotAction(context, action, options?.config);
      case 'display_mode_select':
        return new DisplayModeSelectAction(context, action, options?.config);
      case 'ptz':
        return new PTZAction(context, action, options?.config);
      case 'ptz_digital':
        return new PTZDigitalAction(context, action, options?.config);
      case 'ptz_multi':
        return new PTZMultiAction(context, action, options?.config);
      case 'ptz_controls':
        return new PTZControlsAction(context, action, options?.config);
      case 'log':
        return new LogAction(context, action, options?.config);
      case 'status_bar':
        return new StatusBarAction(context, action, options?.config);
      case INTERNAL_CALLBACK_ACTION:
        return new InternalCallbackAction(context, action, options?.config);
      case 'folder':
      case 'folders':
        return new FoldersViewAction(context, action, options?.config);
    }

    /* istanbul ignore next: this path cannot be reached -- @preserve */
    console.warn(
      `Advanced Camera Card received unknown card action: ${action['advanced_camera_card_action']}`,
    );
    /* istanbul ignore next: this path cannot be reached -- @preserve */
    return null;
  }
}



================================================
FILE: src/card-controller/actions/types.ts
================================================
import { ConditionsTriggerData } from '../../conditions/types.js';
import {
  ActionConfig,
  AuxillaryActionConfig,
} from '../../config/schema/actions/types.js';
import { AdvancedCameraCardError } from '../../types.js';
import { CardActionsAPI } from '../types';

export interface Action {
  execute(api: CardActionsAPI): Promise<void>;
  stop(): Promise<void>;
}

export interface ActionsExecutionRequest {
  actions: ActionConfig[] | ActionConfig;
  config?: AuxillaryActionConfig;
  triggerData?: ConditionsTriggerData;
}

export interface ActionsExecutor {
  executeActions(request: ActionsExecutionRequest): Promise<void>;
}

export interface TargetedActionContext {
  [targetID: string]: {
    inProgressAction?: Action;
  };
}

export class ActionAbortError extends AdvancedCameraCardError {}



================================================
FILE: src/card-controller/actions/actions/base.ts
================================================
import { ActionContext } from 'action';
import {
  ActionConfig,
  AuxillaryActionConfig,
} from '../../../config/schema/actions/types.js';
import { localize } from '../../../localize/localize.js';
import { isAdvancedCameraCardCustomAction } from '../../../utils/action';
import { CardActionsAPI } from '../../types';
import { Action, ActionAbortError } from '../types';

export class BaseAction<T extends ActionConfig> implements Action {
  protected _context: ActionContext;
  protected _action: T;
  protected _config?: AuxillaryActionConfig;

  constructor(context: ActionContext, action: T, config?: AuxillaryActionConfig) {
    this._context = context;
    this._action = action;
    this._config = config;
  }

  protected _shouldSeekConfirmation(api: CardActionsAPI): boolean {
    const hass = api.getHASSManager().getHASS();

    return (
      (typeof this._action.confirmation === 'boolean' && this._action.confirmation) ||
      (typeof this._action.confirmation === 'object' &&
        (!this._action.confirmation.exemptions ||
          !this._action.confirmation.exemptions.some(
            (entry) => entry.user === hass?.user.id,
          )))
    );
  }

  public async execute(api: CardActionsAPI): Promise<void> {
    if (this._shouldSeekConfirmation(api)) {
      const actionName = isAdvancedCameraCardCustomAction(this._action)
        ? this._action.advanced_camera_card_action
        : this._action.action;
      const text =
        (typeof this._action.confirmation === 'object'
          ? this._action.confirmation.text
          : null) ?? `${localize('actions.confirmation')}: ${actionName}`;
      if (!confirm(text)) {
        throw new ActionAbortError(localize('actions.abort'));
      }
    }
  }

  public async stop(): Promise<void> {
    // Pass.
  }
}

export class AdvancedCameraCardAction<T extends ActionConfig> extends BaseAction<T> {}



================================================
FILE: src/card-controller/actions/actions/call-service.ts
================================================
import { CallServiceActionConfig } from '../../../config/schema/actions/stock/call-service';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class CallServiceAction extends AdvancedCameraCardAction<CallServiceActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const hass = api.getHASSManager().getHASS();
    if (!hass) {
      return;
    }

    const [domain, service] = this._action.service.split('.', 2);
    await hass.callService(domain, service, this._action.data, this._action.target);
  }
}



================================================
FILE: src/card-controller/actions/actions/camera-select.ts
================================================
import { CameraSelectActionConfig } from '../../../config/schema/actions/custom/camera-select';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class CameraSelectAction extends AdvancedCameraCardAction<CameraSelectActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const selectCameraID =
      this._action.camera ??
      (this._action.triggered
        ? api.getTriggersManager().getMostRecentlyTriggeredCameraID()
        : null);
    const view = api.getViewManager().getView();
    const config = api.getConfigManager().getConfig();

    // Don't do anything if the camera is already selected (especially important
    // for control entities, as otherwise every camera change will generate a
    // double request for events, once when the camera changes and another when
    // the observed state of the control entity changes to match).
    if (selectCameraID && view && selectCameraID !== view.camera) {
      const viewOnCameraSelect = config?.view.camera_select ?? 'current';
      const targetViewName =
        viewOnCameraSelect === 'current' ? view.view : viewOnCameraSelect;
      await api.getViewManager().setViewByParametersWithNewQuery({
        params: {
          view: targetViewName,
          camera: selectCameraID,
        },
        failSafe: true,
      });
    }
  }
}



================================================
FILE: src/card-controller/actions/actions/camera-ui.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class CameraUIAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getCameraURLManager().openURL();
  }
}



================================================
FILE: src/card-controller/actions/actions/custom.ts
================================================
import { CustomActionConfig } from '../../../config/schema/actions/stock/custom';
import { fireHASSEvent } from '../../../ha/fire-hass-event';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class CustomAction extends AdvancedCameraCardAction<CustomActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    fireHASSEvent(api.getCardElementManager().getElement(), 'll-custom', this._action);
  }
}



================================================
FILE: src/card-controller/actions/actions/default.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class DefaultAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getViewManager().setViewDefaultWithNewQuery();
  }
}



================================================
FILE: src/card-controller/actions/actions/display-mode-select.ts
================================================
import { DisplayModeActionConfig } from '../../../config/schema/actions/custom/display-mode';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class DisplayModeSelectAction extends AdvancedCameraCardAction<DisplayModeActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getViewManager().setViewByParametersWithNewQuery({
      params: {
        displayMode: this._action.display_mode,
      },
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/download.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class DownloadAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const item = api.getViewManager().getView()?.queryResults?.getSelectedResult();
    if (item) {
      await api.getViewItemManager().download(item);
    }
  }
}



================================================
FILE: src/card-controller/actions/actions/expand.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class ExpandAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getExpandManager().toggleExpanded();
  }
}



================================================
FILE: src/card-controller/actions/actions/folders-view.ts
================================================
import { FoldersViewActionConfig } from '../../../config/schema/actions/custom/folders-view';
import { FolderViewQuery } from '../../../view/query';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class FoldersViewAction extends AdvancedCameraCardAction<FoldersViewActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const folder = api.getFoldersManager().getFolder(this._action.folder);
    if (!folder) {
      return;
    }

    const query = api.getFoldersManager().generateDefaultFolderQuery(folder);
    if (!query) {
      return;
    }

    await api.getViewManager().setViewByParametersWithExistingQuery({
      params: {
        // Supports both 'folder' and 'folders' views.
        view: this._action.advanced_camera_card_action,
        query: new FolderViewQuery(query),
      },
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/fullscreen.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class FullscreenAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getFullscreenManager().toggleFullscreen();
  }
}



================================================
FILE: src/card-controller/actions/actions/internal-callback.ts
================================================
import { InternalCallbackActionConfig } from '../../../config/schema/actions/custom/internal';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class InternalCallbackAction extends AdvancedCameraCardAction<InternalCallbackActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await this._action.callback(api);
  }
}



================================================
FILE: src/card-controller/actions/actions/log.ts
================================================
import { LogActionConfig } from '../../../config/schema/actions/custom/log';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class LogAction extends AdvancedCameraCardAction<LogActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    console[this._action.level](this._action.message);
  }
}



================================================
FILE: src/card-controller/actions/actions/media-player.ts
================================================
import { MediaPlayerActionConfig } from '../../../config/schema/actions/custom/media-player';
import { getStreamCameraID } from '../../../utils/substream';
import { ViewItemClassifier } from '../../../view/item-classifier';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MediaPlayerAction extends AdvancedCameraCardAction<MediaPlayerActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const mediaPlayer = this._action.media_player;
    const mediaPlayerController = api.getMediaPlayerManager();

    if (this._action.media_player_action === 'stop') {
      await mediaPlayerController.stop(mediaPlayer);
      return;
    }

    const view = api.getViewManager().getView();
    const item = view?.queryResults?.getSelectedResult() ?? null;

    if (view?.is('live')) {
      await mediaPlayerController.playLive(mediaPlayer, getStreamCameraID(view));
    } else if (view?.isViewerView() && item && ViewItemClassifier.isMedia(item)) {
      await mediaPlayerController.playMedia(mediaPlayer, item);
    }
  }
}



================================================
FILE: src/card-controller/actions/actions/menu-toggle.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MenuToggleAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getCardElementManager().toggleMenu();
  }
}



================================================
FILE: src/card-controller/actions/actions/microphone-connect.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MicrophoneConnectAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getMicrophoneManager().connect();
  }
}



================================================
FILE: src/card-controller/actions/actions/microphone-disconnect.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MicrophoneDisconnectAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getMicrophoneManager().disconnect();
  }
}



================================================
FILE: src/card-controller/actions/actions/microphone-mute.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MicrophoneMuteAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getMicrophoneManager().mute();
  }
}



================================================
FILE: src/card-controller/actions/actions/microphone-unmute.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MicrophoneUnmuteAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getMicrophoneManager().unmute();
  }
}



================================================
FILE: src/card-controller/actions/actions/more-info.ts
================================================
import { MoreInfoActionConfig } from '../../../config/schema/actions/stock/more-info';
import { fireHASSEvent } from '../../../ha/fire-hass-event';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MoreInfoAction extends AdvancedCameraCardAction<MoreInfoActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const entityID = this._action.entity ?? this._config?.entity ?? null;
    if (!entityID) {
      return;
    }

    fireHASSEvent(api.getCardElementManager().getElement(), 'hass-more-info', {
      entityId: entityID,
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/mute.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class MuteAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getMediaLoadedInfoManager().get()?.mediaPlayerController?.mute();
  }
}



================================================
FILE: src/card-controller/actions/actions/navigate.ts
================================================
import { NavigateActionConfig } from '../../../config/schema/actions/stock/navigate';
import { fireHASSEvent } from '../../../ha/fire-hass-event';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class NavigateAction extends AdvancedCameraCardAction<NavigateActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    if (!!this._action.navigation_replace) {
      history.replaceState(null, '', this._action.navigation_path);
    } else {
      history.pushState(null, '', this._action.navigation_path);
    }
    fireHASSEvent(window, 'location-changed', {
      replace: !!this._action.navigation_replace,
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/none.ts
================================================
import { NoneActionConfig } from '../../../config/schema/actions/stock/none';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class NoneAction extends AdvancedCameraCardAction<NoneActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);
  }
}



================================================
FILE: src/card-controller/actions/actions/pause.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class PauseAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getMediaLoadedInfoManager().get()?.mediaPlayerController?.pause();
  }
}



================================================
FILE: src/card-controller/actions/actions/perform-action.ts
================================================
import { PerformActionActionConfig } from '../../../config/schema/actions/stock/perform-action';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class PerformActionAction extends AdvancedCameraCardAction<PerformActionActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const hass = api.getHASSManager().getHASS();
    if (!hass) {
      return;
    }

    const [domain, service] = this._action.perform_action.split('.', 2);
    await hass.callService(domain, service, this._action.data, this._action.target);
  }
}



================================================
FILE: src/card-controller/actions/actions/play.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class PlayAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getMediaLoadedInfoManager().get()?.mediaPlayerController?.play();
  }
}



================================================
FILE: src/card-controller/actions/actions/ptz-controls.ts
================================================
import { PTZControlsActionConfig } from '../../../config/schema/actions/custom/ptz-controls';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class PTZControlsAction extends AdvancedCameraCardAction<PTZControlsActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getViewManager().setViewWithMergedContext({
      ptzControls: { enabled: this._action.enabled },
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/ptz-digital.ts
================================================
import { clamp } from 'lodash-es';
import {
  PartialZoomSettings,
  ZOOM_DEFAULT_PAN_X,
  ZOOM_DEFAULT_PAN_Y,
  ZOOM_DEFAULT_SCALE,
} from '../../../components-lib/zoom/types';
import { generateViewContextForZoom } from '../../../components-lib/zoom/zoom-view-context';
import { PTZDigitialActionConfig } from '../../../config/schema/actions/custom/ptz-digital';
import { ZOOM_MAX, ZOOM_MIN } from '../../../config/schema/common/zoom';
import { getPTZTarget } from '../../../utils/ptz';
import { Timer } from '../../../utils/timer';
import { CardActionsAPI } from '../../types';
import { TargetedActionContext } from '../types';
import {
  setInProgressForThisTarget,
  stopInProgressForThisTarget,
} from '../utils/action-state';
import { AdvancedCameraCardAction } from './base';

const STEP_DELAY_SECONDS = 0.1;
const STEP_ZOOM = 0.1;
const STEP_PAN = 5;

declare module 'action' {
  interface ActionContext {
    ptzDigital?: TargetedActionContext;
  }
}

export class PTZDigitalAction extends AdvancedCameraCardAction<PTZDigitialActionConfig> {
  protected _timer = new Timer();

  protected async _stepChange(api: CardActionsAPI, targetID: string): Promise<void> {
    api.getViewManager().setViewWithMergedContext(
      generateViewContextForZoom(targetID, {
        requested: this._convertActionToZoomSettings(
          api.getViewManager().getView()?.context?.zoom?.[targetID]?.observed,
        ),
      }),
    );
  }

  public async stop(): Promise<void> {
    this._timer.stop();
  }

  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const view = api.getViewManager().getView();
    if (!view) {
      return;
    }

    const targetID =
      this._action.target_id ??
      getPTZTarget(view, { type: 'digital', cameraManager: api.getCameraManager() })
        ?.targetID;
    if (!targetID) {
      return;
    }

    if (!!this._action.absolute || !this._action.ptz_phase) {
      return await this._stepChange(api, targetID);
    }

    /* istanbul ignore else: the else path cannot be reached -- @preserve */
    if (this._action.ptz_phase === 'start') {
      await stopInProgressForThisTarget(targetID, this._context.ptzDigital);
      setInProgressForThisTarget(targetID, this._context, 'ptzDigital', this);

      await this._stepChange(api, targetID);
      this._timer.startRepeated(STEP_DELAY_SECONDS, () =>
        this._stepChange(api, targetID),
      );
    } else if (this._action.ptz_phase === 'stop') {
      await stopInProgressForThisTarget(targetID, this._context.ptzDigital);
      delete this._context.ptzDigital?.[targetID];
    }
  }

  protected _convertActionToZoomSettings(
    base?: PartialZoomSettings,
  ): PartialZoomSettings {
    if (!this._action.absolute && !this._action.ptz_action) {
      // If neither an absolute position nor an action are specified, the request
      // is assumed to be to return to default.
      return {};
    }

    if (this._action.absolute) {
      return this._action.absolute;
    }

    const zoom = base?.zoom ?? ZOOM_DEFAULT_SCALE;
    const pan = {
      x: base?.pan?.x ?? ZOOM_DEFAULT_PAN_X,
      y: base?.pan?.y ?? ZOOM_DEFAULT_PAN_Y,
    };

    const zoomDelta =
      this._action.ptz_action === 'zoom_in'
        ? STEP_ZOOM
        : this._action.ptz_action === 'zoom_out'
          ? -STEP_ZOOM
          : 0;
    const xDelta =
      this._action.ptz_action === 'left'
        ? -STEP_PAN
        : this._action.ptz_action === 'right'
          ? STEP_PAN
          : 0;
    const yDelta =
      this._action.ptz_action === 'up'
        ? -STEP_PAN
        : this._action.ptz_action === 'down'
          ? STEP_PAN
          : 0;

    return {
      zoom: clamp(zoom + zoomDelta, ZOOM_MIN, ZOOM_MAX),
      pan: {
        x: clamp(pan.x + xDelta, 0, 100),
        y: clamp(pan.y + yDelta, 0, 100),
      },
    };
  }
}



================================================
FILE: src/card-controller/actions/actions/ptz-multi.ts
================================================
import { PTZMultiActionConfig } from '../../../config/schema/actions/custom/ptz-multi';
import { createPTZAction, createPTZDigitalAction } from '../../../utils/action';
import { PTZType, getPTZTarget, hasCameraTruePTZ } from '../../../utils/ptz';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';
import { PTZAction } from './ptz';
import { PTZDigitalAction } from './ptz-digital';

export class PTZMultiAction extends AdvancedCameraCardAction<PTZMultiActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const view = api.getViewManager().getView();
    let targetID: string | null = null;
    let type: PTZType | null = null;

    if (this._action.target_id) {
      targetID = this._action.target_id;
      type = hasCameraTruePTZ(api.getCameraManager(), targetID) ? 'ptz' : 'digital';
    } else if (view) {
      const multiTarget = getPTZTarget(view, { cameraManager: api.getCameraManager() });
      targetID = multiTarget?.targetID ?? null;
      type = multiTarget?.type ?? null;
    }

    if (!targetID || type === null) {
      return;
    }

    (type === 'ptz'
      ? this._toPTZAction(targetID)
      : this._toPTZDigitalAction(targetID)
    ).execute(api);
  }

  protected _toPTZAction(targetID: string): PTZAction {
    return new PTZAction(
      this._context,
      createPTZAction({
        cardID: this._action.card_id,
        cameraID: targetID,
        ptzAction: this._action.ptz_action,
        ptzPhase: this._action.ptz_phase,
        ptzPreset: this._action.ptz_preset,
      }),
      this._config,
    );
  }

  protected _toPTZDigitalAction(targetID: string): PTZDigitalAction {
    return new PTZDigitalAction(
      this._context,
      createPTZDigitalAction({
        cardID: this._action.card_id,
        ptzPhase: this._action.ptz_phase,
        ptzAction: this._action.ptz_action,
        targetID: targetID,
      }),
      this._config,
    );
  }
}



================================================
FILE: src/card-controller/actions/actions/ptz.ts
================================================
import { PTZActionConfig } from '../../../config/schema/actions/custom/ptz';
import { PTZMovementType } from '../../../types';
import { getPTZTarget, ptzActionToCapabilityKey } from '../../../utils/ptz';
import { Timer } from '../../../utils/timer';
import { CardActionsAPI } from '../../types';
import {
  setInProgressForThisTarget,
  stopInProgressForThisTarget,
} from '../utils/action-state';
import { AdvancedCameraCardAction } from './base';

interface PTZContext {
  [cameraID: string]: {
    inProgressAction?: PTZAction;
  };
}

declare module 'action' {
  interface ActionContext {
    ptz?: PTZContext;
  }
}

export class PTZAction extends AdvancedCameraCardAction<PTZActionConfig> {
  protected _timer = new Timer();
  protected _stopped = false;

  public async stop(): Promise<void> {
    this._stopped = true;
    this._timer.stop();
  }

  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const view = api.getViewManager().getView();
    if (!view) {
      return;
    }

    const ptzCameraID =
      this._action.camera ??
      getPTZTarget(view, { type: 'ptz', cameraManager: api.getCameraManager() })
        ?.targetID ??
      null;
    const ptzCapabilities = ptzCameraID
      ? api.getCameraManager().getCameraCapabilities(ptzCameraID)?.getPTZCapabilities()
      : null;
    const ptzConfiguration = ptzCameraID
      ? api.getCameraManager().getStore().getCameraConfig(ptzCameraID)?.ptz
      : null;
    if (!ptzCameraID || !ptzCapabilities || !ptzConfiguration) {
      return;
    }

    if (!this._action.ptz_action) {
      if (ptzCapabilities.presets && ptzCapabilities.presets.length >= 1) {
        await api.getCameraManager().executePTZAction(ptzCameraID, 'preset', {
          phase: this._action.ptz_phase,
          preset: ptzCapabilities.presets[0],
        });
      }
      return;
    }

    const capabilityKey = ptzActionToCapabilityKey(this._action.ptz_action);
    if (
      (capabilityKey &&
        ptzCapabilities[capabilityKey]?.includes(
          this._action.ptz_phase ? PTZMovementType.Continuous : PTZMovementType.Relative,
        )) ||
      this._action.ptz_action === 'preset'
    ) {
      // Scenario: Camera natively supports requested move type.
      return await api
        .getCameraManager()
        .executePTZAction(ptzCameraID, this._action.ptz_action, {
          phase: this._action.ptz_phase,
          preset: this._action.ptz_preset,
        });
    }

    if (this._action.ptz_phase === 'start') {
      // Scenario: Asked to start a continuous move, camera only supports relative moves natively.
      await stopInProgressForThisTarget(ptzCameraID, this._context.ptz);
      setInProgressForThisTarget(ptzCameraID, this._context, 'ptz', this);

      const singleStep = async (): Promise<void> => {
        /* istanbul ignore else: the else path cannot be reached as ptz_action
        being present is checked above -- @preserve */
        if (this._action.ptz_action) {
          await api
            .getCameraManager()
            .executePTZAction(ptzCameraID, this._action.ptz_action, {
              preset: this._action.ptz_preset,
            });
        }

        if (!this._stopped) {
          // Only start the timer for the next step after this step returns, and
          // only if this action has not been stopped.
          // See: https://github.com/dermotduffy/advanced-camera-card/issues/1967
          this._timer.start(
            ptzConfiguration.r2c_delay_between_calls_seconds,
            singleStep,
          );
        }
      };

      this._stopped = false;
      await singleStep();
    } else if (this._action.ptz_phase === 'stop') {
      // Scenario: Asked to stop continuous move, camera only supports relative moves natively.
      await stopInProgressForThisTarget(ptzCameraID, this._context.ptz);
    } else {
      this._stopped = false;

      // Relative move (but camera only supports continuous).
      await api
        .getCameraManager()
        .executePTZAction(ptzCameraID, this._action.ptz_action, {
          preset: this._action.ptz_preset,
          phase: 'start',
        });

      this._timer.start(ptzConfiguration.c2r_delay_between_calls_seconds, async () => {
        /* istanbul ignore else: the else path cannot be reached as ptz_action
        being present is checked above -- @preserve */
        if (this._action.ptz_action) {
          await api
            .getCameraManager()
            .executePTZAction(ptzCameraID, this._action.ptz_action, {
              preset: this._action.ptz_preset,
              phase: 'stop',
            });
        }
      });
    }
  }
}



================================================
FILE: src/card-controller/actions/actions/screenshot.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { downloadURL } from '../../../utils/download';
import { generateScreenshotFilename } from '../../../utils/screenshot';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class ScreenshotAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const url = await api
      .getMediaLoadedInfoManager()
      .get()
      ?.mediaPlayerController?.getScreenshotURL();

    if (url) {
      downloadURL(url, generateScreenshotFilename(api.getViewManager().getView()));
    }
  }
}



================================================
FILE: src/card-controller/actions/actions/set.ts
================================================
import { ActionContext } from 'action';
import {
  ActionConfig,
  AuxillaryActionConfig,
} from '../../../config/schema/actions/types';
import { arrayify } from '../../../utils/basic';
import { CardActionsAPI } from '../../types';
import { ActionFactory } from '../factory';
import { Action } from '../types';

export class ActionSet implements Action {
  protected _context: ActionContext;
  protected _actions: Action[] = [];
  protected _factory = new ActionFactory();
  protected _stopped = false;

  constructor(
    context: ActionContext,
    actions: ActionConfig | ActionConfig[],
    options?: {
      config?: AuxillaryActionConfig;
      cardID?: string;
    },
  ) {
    this._context = context;
    for (const actionObj of arrayify(actions)) {
      const action = this._factory.createAction(context, actionObj, options);
      if (action) {
        this._actions.push(action);
      }
    }
  }

  public async execute(api: CardActionsAPI): Promise<void> {
    for (const action of this._actions) {
      if (this._stopped) {
        break;
      }

      await action.execute(api);
    }
  }

  public async stop(): Promise<void> {
    this._stopped = true;
  }
}



================================================
FILE: src/card-controller/actions/actions/sleep.ts
================================================
import { SleepActionConfig } from '../../../config/schema/actions/custom/sleep';
import { sleep } from '../../../utils/sleep';
import { CardActionsAPI } from '../../types';
import { timeDeltaToSeconds } from '../utils/time-delta';
import { AdvancedCameraCardAction } from './base';

export class SleepAction extends AdvancedCameraCardAction<SleepActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await sleep(timeDeltaToSeconds(this._action.duration));
  }
}



================================================
FILE: src/card-controller/actions/actions/status-bar.ts
================================================
import { StatusBarActionConfig } from '../../../config/schema/actions/types';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class StatusBarAction extends AdvancedCameraCardAction<StatusBarActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    switch (this._action.status_bar_action) {
      case 'reset':
        api.getStatusBarItemManager().removeAllDynamicStatusBarItems();
        break;
      case 'add':
        this._action.items?.forEach((item) =>
          api.getStatusBarItemManager().addDynamicStatusBarItem(item),
        );
        break;
      case 'remove':
        this._action.items?.forEach((item) =>
          api.getStatusBarItemManager().removeDynamicStatusBarItem(item),
        );
        break;
    }
  }
}



================================================
FILE: src/card-controller/actions/actions/substream-off.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { SubstreamOffViewModifier } from '../../view/modifiers/substream-off';
import { AdvancedCameraCardAction } from './base';

export class SubstreamOffAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getViewManager().setViewByParameters({
      modifiers: [new SubstreamOffViewModifier()],
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/substream-on.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { SubstreamOnViewModifier } from '../../view/modifiers/substream-on';
import { AdvancedCameraCardAction } from './base';

export class SubstreamOnAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getViewManager().setViewByParameters({
      modifiers: [new SubstreamOnViewModifier(api)],
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/substream-select.ts
================================================
import { SubstreamSelectActionConfig } from '../../../config/schema/actions/custom/substream-select';
import { CardActionsAPI } from '../../types';
import { SubstreamSelectViewModifier } from '../../view/modifiers/substream-select';
import { AdvancedCameraCardAction } from './base';

export class SubstreamSelectAction extends AdvancedCameraCardAction<SubstreamSelectActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    api.getViewManager().setViewByParameters({
      modifiers: [new SubstreamSelectViewModifier(this._action.camera)],
    });
  }
}



================================================
FILE: src/card-controller/actions/actions/toggle.ts
================================================
import { ToggleActionConfig } from '../../../config/schema/actions/stock/toggle';
import { computeDomain } from '../../../ha/compute-domain';
import { STATES_OFF } from '../../../ha/const';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class ToggleAction extends AdvancedCameraCardAction<ToggleActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    const hass = api.getHASSManager().getHASS();
    const entityID = this._config?.entity;
    if (!hass || !entityID) {
      return;
    }
    const entityState = hass.states[entityID]?.state;
    if (!entityState) {
      return;
    }

    const turnOn = STATES_OFF.includes(entityState);
    const stateDomain = computeDomain(entityID);
    const serviceDomain = stateDomain === 'group' ? 'homeassistant' : stateDomain;
    const service =
      stateDomain === 'lock'
        ? turnOn
          ? 'unlock'
          : 'lock'
        : stateDomain === 'cover'
          ? turnOn
            ? 'open_cover'
            : 'close_cover'
          : turnOn
            ? 'turn_on'
            : 'turn_off';
    await hass.callService(serviceDomain, service, { entity_id: entityID });
  }
}



================================================
FILE: src/card-controller/actions/actions/unmute.ts
================================================
import { GeneralActionConfig } from '../../../config/schema/actions/custom/general';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class UnmuteAction extends AdvancedCameraCardAction<GeneralActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getMediaLoadedInfoManager().get()?.mediaPlayerController?.unmute();
  }
}



================================================
FILE: src/card-controller/actions/actions/url.ts
================================================
import { URLActionConfig } from '../../../config/schema/actions/stock/url';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class URLAction extends AdvancedCameraCardAction<URLActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    window.open(this._action.url_path);
  }
}



================================================
FILE: src/card-controller/actions/actions/view.ts
================================================
import { ViewActionConfig } from '../../../config/schema/actions/custom/view';
import { CardActionsAPI } from '../../types';
import { AdvancedCameraCardAction } from './base';

export class ViewAction extends AdvancedCameraCardAction<ViewActionConfig> {
  public async execute(api: CardActionsAPI): Promise<void> {
    await super.execute(api);

    await api.getViewManager().setViewByParametersWithNewQuery({
      params: {
        view: this._action.advanced_camera_card_action,
      },
    });
  }
}



================================================
FILE: src/card-controller/actions/utils/action-state.ts
================================================
import { merge } from 'lodash-es';
import { Action, TargetedActionContext } from '../types';
import { ActionContext } from 'action';

export const stopInProgressForThisTarget = async (
  targetID: string,
  context?: TargetedActionContext,
): Promise<void> => {
  await context?.[targetID]?.inProgressAction?.stop();
};

export const setInProgressForThisTarget = (
  targetID: string,
  context: ActionContext,
  contextKey: keyof ActionContext,
  action: Action,
): void => {
  merge(context, {
    [contextKey]: {
      [targetID]: {
        inProgressAction: action,
      },
    },
  });
};



================================================
FILE: src/card-controller/actions/utils/execution-request.ts
================================================
import { fireAdvancedCameraCardEvent } from '../../../utils/fire-advanced-camera-card-event';
import { ActionsExecutionRequest } from '../types';

export const dispatchActionExecutionRequest = (
  element: HTMLElement,
  request: ActionsExecutionRequest,
) => {
  fireAdvancedCameraCardEvent(element, 'action:execution-request', request);
};

export interface ActionExecutionRequestEventTarget extends EventTarget {
  addEventListener(
    event: 'advanced-camera-card:action:execution-request',
    listener: (
      this: ActionExecutionRequestEventTarget,
      ev: CustomEvent<ActionsExecutionRequest>,
    ) => void,
    options?: AddEventListenerOptions | boolean,
  ): void;
  addEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: AddEventListenerOptions | boolean,
  ): void;
  removeEventListener(
    event: 'advanced-camera-card:action:execution-request',
    listener: (
      this: ActionExecutionRequestEventTarget,
      ev: CustomEvent<ActionsExecutionRequest>,
    ) => void,
    options?: boolean | EventListenerOptions,
  ): void;
  removeEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions,
  ): void;
}



================================================
FILE: src/card-controller/actions/utils/time-delta.ts
================================================
import { TimeDelta } from '../../../config/schema/actions/custom/sleep';

export const timeDeltaToSeconds = (timeDelta: TimeDelta): number => {
  return (
    (timeDelta.h ?? 0) * 3600 +
    (timeDelta.m ?? 0) * 60 +
    (timeDelta.s ?? 0) +
    (timeDelta.ms ?? 0) / 1000
  );
};



================================================
FILE: src/card-controller/config/config-manager.ts
================================================
import { isEqual } from 'lodash-es';
import { isConfigUpgradeable } from '../../config/management.js';
import { setProfiles } from '../../config/profiles/set-profiles.js';
import {
  AdvancedCameraCardConfig,
  CardWideConfig,
  advancedCameraCardConfigSchema,
} from '../../config/schema/types.js';
import { RawAdvancedCameraCardConfig } from '../../config/types.js';
import { localize } from '../../localize/localize.js';
import { getParseErrorPaths } from '../../utils/zod.js';
import { InitializationAspect } from '../initialization-manager.js';
import { CardConfigAPI } from '../types.js';
import { setAutomationsFromConfig } from './load-automations.js';
import { setRemoteControlEntityFromConfig } from './load-control-entities.js';
import { setFoldersFromConfig } from './load-folders.js';
import { setKeyboardShortcutsFromConfig } from './load-keyboard-shortcuts.js';
import { OverridesManager } from './overrides-manager.js';

export class ConfigManager {
  protected _api: CardConfigAPI;

  // The main base configuration object. For most usecases use getConfig() to
  // get the correct configuration (which will return overrides as appropriate).
  // This variable must be called `_config` or `config` to be compatible with
  // card-mod.
  protected _config: AdvancedCameraCardConfig | null = null;
  protected _overriddenConfig: AdvancedCameraCardConfig | null = null;
  protected _rawConfig: RawAdvancedCameraCardConfig | null = null;
  protected _cardWideConfig: CardWideConfig | null = null;
  protected _overridesManager = new OverridesManager(() =>
    this._processOverrideConfig(),
  );

  constructor(api: CardConfigAPI) {
    this._api = api;
  }

  public hasConfig(): boolean {
    return !!this.getConfig();
  }

  public getConfig(): AdvancedCameraCardConfig | null {
    return this._overriddenConfig ?? this._config;
  }

  public getCardWideConfig(): CardWideConfig | null {
    return this._cardWideConfig;
  }

  public getNonOverriddenConfig(): AdvancedCameraCardConfig | null {
    return this._config;
  }

  public getRawConfig(): RawAdvancedCameraCardConfig | null {
    return this._rawConfig;
  }

  public setConfig(inputConfig?: RawAdvancedCameraCardConfig): void {
    if (!inputConfig) {
      throw new Error(localize('error.invalid_configuration'));
    }

    const parseResult = advancedCameraCardConfigSchema.safeParse(inputConfig);
    if (!parseResult.success) {
      const configUpgradeable = isConfigUpgradeable(inputConfig);
      const hint = getParseErrorPaths(parseResult.error);
      let upgradeMessage = '';
      if (configUpgradeable) {
        upgradeMessage = `${localize('error.upgrade_available')}. `;
      }
      throw new Error(
        upgradeMessage +
          `${localize('error.invalid_configuration')}: ` +
          (hint && hint.size
            ? JSON.stringify([...hint], null, ' ')
            : localize('error.invalid_configuration_no_hint')),
      );
    }
    const config = setProfiles(inputConfig, parseResult.data, parseResult.data.profiles);

    this._rawConfig = inputConfig;
    if (isEqual(this._config, config)) {
      return;
    }

    this._config = config;
    this._cardWideConfig = {
      performance: config.performance,
      debug: config.debug,
    };

    this._overridesManager.set(
      this._api.getConditionStateManager(),
      this._config.overrides,
    );

    this._api.getConditionStateManager().setState({
      view: undefined,
      displayMode: undefined,
      camera: undefined,
    });
    this._api.getMediaLoadedInfoManager().clear();

    this._api.getInitializationManager().uninitialize(InitializationAspect.VIEW);
    this._api.getViewManager().reset();

    this._api.getMessageManager().reset();
    this._api.getStatusBarItemManager().removeAllDynamicStatusBarItems();

    setKeyboardShortcutsFromConfig(this._api);
    setRemoteControlEntityFromConfig(this._api);
    setAutomationsFromConfig(this._api);

    this._processOverrideConfig();

    this._api.getCardElementManager().update();
  }

  protected _processOverrideConfig(): void {
    const overriddenConfig = this._getOverriddenConfig();

    // Save on Lit re-rendering costs by only updating the configuration if it
    // actually changes.
    if (!overriddenConfig || isEqual(overriddenConfig, this._overriddenConfig)) {
      return;
    }

    const previousConfig = this._overriddenConfig;
    this._overriddenConfig = overriddenConfig;

    setFoldersFromConfig(this._api);
    this._api.getStyleManager().updateFromConfig();

    if (
      previousConfig &&
      (!isEqual(previousConfig?.cameras, this._overriddenConfig?.cameras) ||
        !isEqual(previousConfig?.cameras_global, this._overriddenConfig?.cameras_global))
    ) {
      this._api.getInitializationManager().uninitialize(InitializationAspect.CAMERAS);
      this._api.getCameraManager().destroy();
    }

    if (
      previousConfig &&
      previousConfig?.live.microphone.always_connected !==
        this._overriddenConfig?.live.microphone.always_connected
    ) {
      this._api
        .getInitializationManager()
        .uninitialize(InitializationAspect.MICROPHONE_CONNECT);
    }

    /* async */ this._initializeBackgroundAndUpdate(previousConfig);
  }

  protected _getOverriddenConfig(): AdvancedCameraCardConfig | null {
    /* istanbul ignore if: No (current) way to reach this code -- @preserve */
    if (!this._config) {
      return null;
    }

    try {
      return this._overridesManager.getConfig(this._config);
    } catch (ev) {
      this._api.getMessageManager().setErrorIfHigherPriority(ev);
      return null;
    }
  }

  /**
   * Initialize config dependent items in the background. For items that the
   * card hard requires, use InitializationManager instead.
   */
  protected async _initializeBackgroundAndUpdate(
    previousConfig: AdvancedCameraCardConfig | null,
  ): Promise<void> {
    await this._api.getDefaultManager().initializeIfNecessary(previousConfig);
    await this._api.getMediaPlayerManager().initializeIfNecessary(previousConfig);

    // The config is only set in the state if the card is already fully
    // initialized. If not, the config will be set post initialization in the
    // InitializationManager.
    if (
      this._overriddenConfig &&
      this._api.getInitializationManager().isInitializedMandatory()
    ) {
      this._api.getConditionStateManager().setState({
        config: this._overriddenConfig,
      });
    }

    this._api.getCardElementManager().update();
  }
}



================================================
FILE: src/card-controller/config/load-automations.ts
================================================
import { CardConfigLoaderAPI } from '../types';

export const setAutomationsFromConfig = (api: CardConfigLoaderAPI): void => {
  api.getAutomationsManager().deleteAutomations();
  api
    .getAutomationsManager()
    .addAutomations(api.getConfigManager().getNonOverriddenConfig()?.automations ?? []);
};



================================================
FILE: src/card-controller/config/load-control-entities.ts
================================================
import { isEqual } from 'lodash-es';
import { RemoteControlEntityPriority } from '../../config/schema/remote-control';
import {
  createCameraAction,
  createInternalCallbackAction,
  createSelectOptionAction,
} from '../../utils/action';
import { CardActionsAPI, CardConfigLoaderAPI, TaggedAutomation } from '../types';

export const setRemoteControlEntityFromConfig = (api: CardConfigLoaderAPI) => {
  const automationTag = setRemoteControlEntityFromConfig;

  api.getAutomationsManager().deleteAutomations(automationTag);

  const remoteControlConfig = api.getConfigManager().getConfig()?.remote_control;
  const cameraControlEntity = remoteControlConfig?.entities.camera;
  if (!cameraControlEntity) {
    return;
  }

  const cameraPriority: RemoteControlEntityPriority =
    remoteControlConfig.entities.camera_priority;

  // Control entities functionality is implemented entirely by populating
  // automations.

  const automations: TaggedAutomation[] = [
    {
      conditions: [
        {
          condition: 'config' as const,
          paths: ['cameras', 'remote_control.entities.camera'],
        },
      ],
      actions: [
        // Set the possible options on the entity to the camera IDs via a
        // callback to `setCameraOptionsOnEntity` (below).
        createInternalCallbackAction((api: CardActionsAPI) =>
          setCameraOptionsOnEntity(cameraControlEntity, api),
        ),
      ],
      tag: automationTag,
    },
    {
      conditions: [
        {
          condition: 'camera' as const,
        },
      ],
      actions: [
        // When the camera changes, update the entity to match.
        createSelectOptionAction(
          'input_select',
          cameraControlEntity,
          '{{ advanced_camera_card.trigger.camera.to }}',
        ),
      ],
      tag: automationTag,
    },
    {
      // Immediately on the start, the HA state for the entity will be updated.
      // However, that will almost certainly not trigger the condition below
      // this one, as automations only run *after* the card is initialized (and
      // it very likely will not yet be). Instead, wait to be initialized, then
      // set the camera.
      conditions: [
        {
          condition: 'initialized' as const,
        },
      ],
      actions: [
        cameraPriority === 'entity'
          ? // Set the currently selected camera to the state of the entity.
            createCameraAction(
              'camera_select',
              `{{ hass.states["${cameraControlEntity}"].state }}`,
            )
          : // Set the selected option in the entity to the current camera ID.
            createSelectOptionAction(
              'input_select',
              cameraControlEntity,
              '{{ advanced_camera_card.camera }}',
            ),
      ],
      tag: automationTag,
    },
    {
      conditions: [
        {
          condition: 'state' as const,
          entity: cameraControlEntity,
        },
      ],
      actions: [
        // When the entity state changes, updated the selected option.
        createCameraAction(
          'camera_select',
          '{{ advanced_camera_card.trigger.state.to }}',
        ),
      ],
      tag: automationTag,
    },
  ];

  api.getAutomationsManager().addAutomations(automations);
};

const setCameraOptionsOnEntity = async (entity: string, api: CardActionsAPI) => {
  const hass = api.getHASSManager().getHASS();
  const cameraIDs = api.getCameraManager().getStore().getCameraIDs();

  const existingOptions = (hass?.states[entity]?.attributes?.options ?? []).sort();
  const desiredOptions = [...cameraIDs].sort();

  if (isEqual(existingOptions, desiredOptions)) {
    return;
  }

  await hass?.callService(
    'input_select',
    'set_options',
    {
      options: desiredOptions,
    },
    {
      entity_id: entity,
    },
  );
};



================================================
FILE: src/card-controller/config/load-folders.ts
================================================
import { CardConfigLoaderAPI } from '../types';

export const setFoldersFromConfig = (api: CardConfigLoaderAPI): void => {
  api.getFoldersManager().deleteFolders();
  try {
    api
      .getFoldersManager()
      .addFolders(api.getConfigManager().getConfig()?.folders ?? []);
  } catch (ev) {
    api.getMessageManager().setErrorIfHigherPriority(ev);
  }
};



================================================
FILE: src/card-controller/config/load-keyboard-shortcuts.ts
================================================
import { PTZAction } from '../../config/schema/actions/custom/ptz';
import { KeyboardShortcuts, PTZKeyboardShortcutName } from '../../config/schema/view';
import { createPTZMultiAction } from '../../utils/action';
import { CardConfigLoaderAPI, TaggedAutomation } from '../types';

export const setKeyboardShortcutsFromConfig = (api: CardConfigLoaderAPI) => {
  const automationTag = setKeyboardShortcutsFromConfig;
  api.getAutomationsManager().deleteAutomations(automationTag);

  const shortcuts = api.getConfigManager().getConfig()?.view.keyboard_shortcuts;
  if (!shortcuts) {
    return;
  }

  const automations = convertKeyboardShortcutsToAutomations(automationTag, shortcuts);
  if (automations.length) {
    api.getAutomationsManager().addAutomations(automations);
  }
};

const ptzKeyboardShortcutToPTZAction = (
  ptzKbs: PTZKeyboardShortcutName,
): PTZAction | null => {
  switch (ptzKbs) {
    case 'ptz_left':
      return 'left';
    case 'ptz_right':
      return 'right';
    case 'ptz_up':
      return 'up';
    case 'ptz_down':
      return 'down';
    case 'ptz_zoom_in':
      return 'zoom_in';
    case 'ptz_zoom_out':
      return 'zoom_out';
  }
  /* istanbul ignore next: No (current) way to reach this code -- @preserve */
  return null;
};

const convertKeyboardShortcutsToAutomations = (
  tag: unknown,
  shortcuts: KeyboardShortcuts,
): TaggedAutomation[] => {
  if (!shortcuts.enabled) {
    return [];
  }

  const automations: TaggedAutomation[] = [];

  for (const name of [
    'ptz_down',
    'ptz_left',
    'ptz_right',
    'ptz_up',
    'ptz_zoom_in',
    'ptz_zoom_out',
  ] as const) {
    const shortcut = shortcuts[name];
    const ptzAction = ptzKeyboardShortcutToPTZAction(name);
    if (!shortcut || !ptzAction) {
      continue;
    }

    automations.push({
      conditions: [
        {
          condition: 'key' as const,
          key: shortcut.key,
          state: 'down',
          shift: shortcut.shift,
          ctrl: shortcut.ctrl,
          alt: shortcut.alt,
          meta: shortcut.meta,
        },
      ],
      actions: [
        createPTZMultiAction({
          ptzAction: ptzAction,
          ptzPhase: 'start',
        }),
      ],
      tag: tag,
    });

    automations.push({
      conditions: [
        {
          condition: 'key' as const,
          key: shortcut.key,
          state: 'up',
        },
      ],
      actions: [
        createPTZMultiAction({
          ptzAction: ptzAction,
          ptzPhase: 'stop',
        }),
      ],
      tag: tag,
    });
  }

  const homeShortcut = shortcuts.ptz_home;
  if (homeShortcut) {
    automations.push({
      conditions: [
        {
          condition: 'key' as const,
          key: homeShortcut.key,
          state: 'down',
          shift: homeShortcut.shift,
          ctrl: homeShortcut.ctrl,
          alt: homeShortcut.alt,
          meta: homeShortcut.meta,
        },
      ],
      actions: [createPTZMultiAction()],
      tag: tag,
    });
  }

  return automations;
};



================================================
FILE: src/card-controller/config/overrides-manager.ts
================================================
import { merge } from 'lodash-es';
import { ConditionsManager } from '../../conditions/conditions-manager';
import { ConditionStateManagerReadonlyInterface } from '../../conditions/types';
import {
  copyConfig,
  deleteConfigValue,
  getConfigValue,
  setConfigValue,
} from '../../config/management';
import { Override } from '../../config/schema/overrides';
import {
  AdvancedCameraCardConfig,
  advancedCameraCardConfigSchema,
} from '../../config/schema/types';
import { localize } from '../../localize/localize';
import { AdvancedCameraCardError } from '../../types';
import { desparsifyArrays } from '../../utils/basic.js';

type OverridesCallback = () => void;

class OverrideConfigurationError extends AdvancedCameraCardError {}

export class OverridesManager {
  private _overrides = new Map<Override, ConditionsManager>();
  private _callback: OverridesCallback;

  constructor(callback: OverridesCallback) {
    this._callback = callback;
  }

  private _clear(): void {
    this._overrides.forEach((manager) => manager.destroy());
    this._overrides.clear();
  }

  public hasOverrides(): boolean {
    return !!this._overrides.size;
  }

  public set(
    stateManager: ConditionStateManagerReadonlyInterface,
    overrides?: Override[],
  ): void {
    this._clear();

    overrides?.forEach((override) => {
      const manager = new ConditionsManager(override.conditions, stateManager);
      manager.addListener(this._callback);
      this._overrides.set(override, manager);
    });
  }

  public getConfig(base: AdvancedCameraCardConfig): AdvancedCameraCardConfig {
    let output = copyConfig(base);
    let overridden = false;
    let desparsify = false;

    for (const [override, manager] of this._overrides.entries()) {
      if (manager.getEvaluation()?.result) {
        override.delete?.forEach((deletionKey) => {
          deleteConfigValue(output, deletionKey);
          desparsify = true;
        });

        Object.keys(override.set ?? {}).forEach((setKey) => {
          setConfigValue(output, setKey, override.set?.[setKey]);
        });

        Object.keys(override.merge ?? {}).forEach((mergeKey) => {
          setConfigValue(
            output,
            mergeKey,
            merge({}, getConfigValue(output, mergeKey), override.merge?.[mergeKey]),
          );
        });

        overridden = true;
      }
    }

    if (!overridden) {
      // Return the same configuration object if it has not been overridden (to
      // reduce re-renders for a configuration that has not changed).
      return base;
    }

    if (desparsify) {
      // If anything was deleted during this override, empty undefined slots may
      // be left in arrays where values were unset. Desparsify them.
      output = desparsifyArrays(output);
    }

    const parseResult = advancedCameraCardConfigSchema.safeParse(output);
    if (!parseResult.success) {
      throw new OverrideConfigurationError(
        localize('error.invalid_configuration_override'),
        [parseResult.error.errors, output],
      );
    }
    return parseResult.data;
  }
}



================================================
FILE: src/card-controller/folders/executor.ts
================================================
import { ConditionState } from '../../conditions/types';
import { FolderConfig, FolderType, folderTypeSchema } from '../../config/schema/folders';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import { ViewItem } from '../../view/item';
import { ViewItemCapabilities } from '../../view/types';
import { sortItems } from '../view/sort';
import { HAFoldersEngine } from './ha/engine';
import { DownloadHelpers, EngineOptions, FolderQuery, FoldersEngine } from './types';

export class FoldersExecutor {
  private _ha: FoldersEngine;

  constructor(engines?: { ha?: HAFoldersEngine }) {
    this._ha = engines?.ha ?? new HAFoldersEngine();
  }

  public generateDefaultFolderQuery(folder: FolderConfig): FolderQuery | null {
    return (
      this._getFolderEngine(folder.type)?.generateDefaultFolderQuery(folder) ?? null
    );
  }

  public async expandFolder(
    hass: HomeAssistant,
    query: FolderQuery,
    conditionState?: ConditionState,
    engineOptions?: EngineOptions,
  ): Promise<ViewItem[] | null> {
    const results =
      (await this._getFolderEngine(query.folder.type)?.expandFolder(
        hass,
        query,
        conditionState,
        engineOptions,
      )) ?? null;
    return results ? sortItems(results) : null;
  }

  public getItemCapabilities(item: ViewItem): ViewItemCapabilities | null {
    return (
      this._getFolderEngine(item.getFolder()?.type)?.getItemCapabilities(item) ?? null
    );
  }

  public async getDownloadPath(
    hass: HomeAssistant | null,
    item: ViewItem,
    helpers?: DownloadHelpers,
  ): Promise<Endpoint | null> {
    return await (this._getFolderEngine(item.getFolder()?.type)?.getDownloadPath(
      hass,
      item,
      helpers,
    ) ?? null);
  }

  public async favorite(
    hass: HomeAssistant | null,
    item: ViewItem,
    favorite: boolean,
  ): Promise<void> {
    return await this._getFolderEngine(item.getFolder()?.type)?.favorite(
      hass,
      item,
      favorite,
    );
  }

  private _getFolderEngine(type?: FolderType): FoldersEngine | null {
    switch (type) {
      case folderTypeSchema.enum.ha:
        return this._ha;
    }
    return null;
  }
}



================================================
FILE: src/card-controller/folders/manager.ts
================================================
import { cloneDeep } from 'lodash-es';
import { ConditionState } from '../../conditions/types';
import { FolderConfig } from '../../config/schema/folders';
import { localize } from '../../localize/localize';
import { Endpoint } from '../../types';
import { ViewItem } from '../../view/item';
import { ViewItemCapabilities } from '../../view/types';
import { CardFoldersAPI } from '../types';
import { FoldersExecutor } from './executor';
import { EngineOptions, FolderInitializationError, FolderQuery } from './types';

export class FoldersManager {
  private _api: CardFoldersAPI;
  private _executor: FoldersExecutor;
  private _folders: Map<string, FolderConfig> = new Map();

  constructor(api: CardFoldersAPI, executor?: FoldersExecutor) {
    this._api = api;
    this._executor = executor ?? new FoldersExecutor();
  }

  public deleteFolders(): void {
    this._folders.clear();
  }

  public addFolders(folders: FolderConfig[]): void {
    for (const folder of folders) {
      const folderNumber = this._folders.size;
      const id = folder.id ?? `folder/${folderNumber.toString()}`;
      if (this._folders.has(id)) {
        throw new FolderInitializationError(
          localize('error.duplicate_folder_id'),
          folder,
        );
      }

      this._folders.set(id, {
        title: `${localize('common.folder')} ${folderNumber}`,
        ...cloneDeep(folder),
        id,
      });
    }
  }

  public hasFolders(): boolean {
    return this._folders.size > 0;
  }
  public getFolderCount(): number {
    return this._folders.size;
  }
  public getFolders(): MapIterator<[string, FolderConfig]> {
    return this._folders.entries();
  }
  public getFolder(id?: string): FolderConfig | null {
    return id
      ? this._folders.get(id) ?? null
      : this._folders.values().next().value ?? null;
  }

  public generateDefaultFolderQuery(folder?: FolderConfig): FolderQuery | null {
    const _folder = folder ?? this.getFolder();
    return _folder ? this._executor.generateDefaultFolderQuery(_folder) : null;
  }

  public async expandFolder(
    query: FolderQuery,
    conditionState?: ConditionState,
    engineOptions?: EngineOptions,
  ): Promise<ViewItem[] | null> {
    const hass = this._api.getHASSManager().getHASS();
    return hass
      ? this._executor.expandFolder(hass, query, conditionState, engineOptions)
      : null;
  }

  public getItemCapabilities(item: ViewItem): ViewItemCapabilities | null {
    return this._executor.getItemCapabilities(item);
  }

  public async getDownloadPath(item: ViewItem): Promise<Endpoint | null> {
    return await this._executor.getDownloadPath(
      this._api.getHASSManager().getHASS(),
      item,
      {
        resolvedMediaCache: this._api.getResolvedMediaCache(),
      },
    );
  }

  public async favorite(item: ViewItem, favorite: boolean): Promise<void> {
    return await this._executor.favorite(
      this._api.getHASSManager().getHASS(),
      item,
      favorite,
    );
  }
}



================================================
FILE: src/card-controller/folders/types.ts
================================================
import { NonEmptyTuple } from 'type-fest';
import { ConditionState } from '../../conditions/types';
import { FolderConfig, HAFolderPathComponent } from '../../config/schema/folders';
import { ResolvedMediaCache } from '../../ha/resolved-media';
import { HomeAssistant } from '../../ha/types';
import { Endpoint } from '../../types';
import { AdvancedCameraCardError } from '../../types.js';
import { ViewFolder, ViewItem } from '../../view/item';
import { ViewItemCapabilities } from '../../view/types';

// ====
// Base
// ====

export interface EngineOptions {
  useCache?: boolean;
}

export class FolderInitializationError extends AdvancedCameraCardError {}

// ============
// Folder Query
// ============

export type FolderPathComponent = {
  folder?: ViewFolder;
  ha?: HAFolderPathComponent;
};

export interface FolderQuery {
  folder: FolderConfig;

  // A trail of paths to navigate back to the "root", with the last path being
  // the path that this query directly refers to.
  path: NonEmptyTuple<FolderPathComponent>;
}

// ===============
// Folders Engines
// ===============

export interface DownloadHelpers {
  resolvedMediaCache?: ResolvedMediaCache | null;
}

export interface FoldersEngine {
  generateDefaultFolderQuery(folder: FolderConfig): FolderQuery | null;
  expandFolder(
    hass: HomeAssistant,
    query: FolderQuery,
    conditionState?: ConditionState,
    engineOptions?: EngineOptions,
  ): Promise<ViewItem[] | null>;

  getItemCapabilities(item: ViewItem): ViewItemCapabilities | null;
  getDownloadPath(
    hass: HomeAssistant | null,
    item: ViewItem,
    options?: DownloadHelpers,
  ): Promise<Endpoint | null>;
  favorite(hass: HomeAssistant | null, item: ViewItem, favorite: boolean): Promise<void>;
}



================================================
FILE: src/card-controller/folders/ha/engine.ts
================================================
import { NonEmptyTuple } from 'type-fest';
import { ConditionState } from '../../../conditions/types';
import {
  FolderConfig,
  folderTypeSchema,
  HA_MEDIA_SOURCE_ROOT,
  HAFolderConfig,
  HAFolderPathComponent,
} from '../../../config/schema/folders';
import { getViewItemsFromBrowseMediaArray } from '../../../ha/browse-media/browse-media-to-view-media';
import { BrowseMediaViewFolder } from '../../../ha/browse-media/item';
import {
  BrowseMedia,
  BrowseMediaCache,
  BrowseMediaMetadata,
  RichBrowseMedia,
} from '../../../ha/browse-media/types';
import {
  BrowseMediaStep,
  BrowseMediaTarget,
  BrowseMediaWalker,
} from '../../../ha/browse-media/walker';
import { getMediaDownloadPath } from '../../../ha/download';
import { HomeAssistant } from '../../../ha/types';
import { Endpoint } from '../../../types';
import { ViewItem } from '../../../view/item';
import { ViewItemClassifier } from '../../../view/item-classifier';
import { ViewItemCapabilities } from '../../../view/types';
import {
  DownloadHelpers,
  EngineOptions,
  FolderPathComponent,
  FolderQuery,
  FoldersEngine,
} from '../types';
import { MediaMatcher } from './media-matcher';
import { MetadataGenerator } from './metadata-generator.js';

export class HAFoldersEngine implements FoldersEngine {
  private _browseMediaManager: BrowseMediaWalker;
  private _cache = new BrowseMediaCache<BrowseMediaMetadata>();

  private _metadataGenerator: MetadataGenerator;
  private _mediaMatcher: MediaMatcher;

  public constructor(options?: {
    browseMediaManager?: BrowseMediaWalker;
    metadataGenerator?: MetadataGenerator;
    mediaMatcher?: MediaMatcher;
  }) {
    this._browseMediaManager = options?.browseMediaManager ?? new BrowseMediaWalker();
    this._metadataGenerator = options?.metadataGenerator ?? new MetadataGenerator();
    this._mediaMatcher = options?.mediaMatcher ?? new MediaMatcher();
  }

  public getItemCapabilities(item: ViewItem): ViewItemCapabilities | null {
    return {
      canFavorite: false,
      canDownload: !ViewItemClassifier.isFolder(item),
    };
  }

  public async getDownloadPath(
    hass: HomeAssistant,
    item: ViewItem,
    helpers?: DownloadHelpers,
  ): Promise<Endpoint | null> {
    if (!ViewItemClassifier.isMedia(item)) {
      return null;
    }

    return getMediaDownloadPath(hass, item.getContentID(), helpers?.resolvedMediaCache);
  }

  public async favorite(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _hass: HomeAssistant,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _item: ViewItem,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _favorite: boolean,
  ): Promise<void> {
    return;
  }

  public generateDefaultFolderQuery(folder: FolderConfig): FolderQuery | null {
    if (folder.type !== folderTypeSchema.enum.ha) {
      return null;
    }
    return {
      folder,
      path: this.getDefaultFolderPathComponents(folder.ha),
    };
  }

  private getDefaultFolderPathComponents(
    haFolderConfig?: HAFolderConfig,
  ): NonEmptyTuple<FolderPathComponent> {
    const shouldAddDefaultRoot = !haFolderConfig?.url && !haFolderConfig?.path?.[0]?.id;

    const path: HAFolderPathComponent[] = [
      ...(shouldAddDefaultRoot ? [{ id: HA_MEDIA_SOURCE_ROOT }] : []),
      ...(haFolderConfig?.url ?? []),
      ...(haFolderConfig?.path ?? []),
    ];

    return path.map((component) => ({ ha: component })) as [
      FolderPathComponent,
      ...FolderPathComponent[],
    ];
  }

  public async expandFolder(
    hass: HomeAssistant,
    query: FolderQuery,
    conditionState?: ConditionState,
    engineOptions?: EngineOptions,
  ): Promise<ViewItem[] | null> {
    if (query.folder.type !== folderTypeSchema.enum.ha) {
      return null;
    }

    const pathComponents = [...query.path];

    // Search through the path components from the start to find the last
    // component with a precise media source id, which is where the queries
    // start (and may drill down from).
    let start: string | RichBrowseMedia<BrowseMediaMetadata> | null = null;
    while (pathComponents.length > 0) {
      const folderBrowseMedia =
        pathComponents[0]?.folder instanceof BrowseMediaViewFolder
          ? pathComponents[0].folder.getBrowseMedia()
          : null;

      const validStart = folderBrowseMedia ?? pathComponents[0]?.ha?.id ?? null;
      if (validStart) {
        start = validStart;
        pathComponents.shift();
      } else {
        break;
      }
    }

    // If no media source id is found, return null, as there is no "starting
    // query".
    if (start === null) {
      return null;
    }

    await this._metadataGenerator.prepare(
      pathComponents.flatMap((component) => component.ha?.parsers ?? []),
    );

    // Generate a walk step, optionally matching against the next path component
    // (if any), otherwise just returning all the media at this level.
    const generateStep = (
      targets: BrowseMediaTarget<BrowseMediaMetadata>[],
    ): BrowseMediaStep<BrowseMediaMetadata>[] => {
      const nextComponent = pathComponents.shift();
      return [
        {
          targets,
          metadataGenerator: (media: BrowseMedia, parent?: BrowseMedia) =>
            this._metadataGenerator.generate(media, parent, nextComponent?.ha?.parsers),

          ...(nextComponent && {
            matcher: (media: RichBrowseMedia<BrowseMediaMetadata>) =>
              this._mediaMatcher.match(hass, media, {
                matchers: nextComponent.ha?.matchers,
                // Set foldersOnly to true if there are more stages in the path,
                // as by definition only folders can be matched at this point.
                foldersOnly: pathComponents.length > 0,
                conditionState,
              }),
            advance: (targets) => (pathComponents.length ? generateStep(targets) : []),
          }),
        },
      ];
    };

    const browseMedia = await this._browseMediaManager.walk<BrowseMediaMetadata>(
      hass,
      generateStep([start]),
      {
        ...((engineOptions?.useCache ?? true) && { cache: this._cache }),
      },
    );

    return getViewItemsFromBrowseMediaArray(browseMedia, {
      folder: query.folder,
    });
  }
}



================================================
FILE: src/card-controller/folders/ha/media-matcher.ts
================================================
import { sub } from 'date-fns';
import { ConditionState } from '../../../conditions/types';
import {
  DateMatcher,
  Matcher,
  StartDateMatcher,
  TemplateMatcher,
  TitleMatcher,
} from '../../../config/schema/folders';
import { BrowseMediaMetadata, RichBrowseMedia } from '../../../ha/browse-media/types';
import { HomeAssistant } from '../../../ha/types';
import { regexpExtract } from '../../../utils/regexp-extract';
import { TemplateRenderer } from '../../templates';
import { REGEXP_GROUP_VALUE_KEY } from './types';

export class MediaMatcher {
  private _templateRenderer = new TemplateRenderer();

  public match(
    hass: HomeAssistant,
    media: RichBrowseMedia<BrowseMediaMetadata>,
    options?: {
      foldersOnly?: boolean;
      matchers?: Matcher[];
      conditionState?: ConditionState;
    },
  ): boolean {
    if (options?.foldersOnly && !media.can_expand) {
      return false;
    }

    for (const matcher of options?.matchers ?? []) {
      switch (matcher.type) {
        case 'date':
        case 'startdate':
          if (!this._matchStartDate(matcher, media)) {
            return false;
          }
          break;

        case 'template':
          if (!this._matchTemplate(hass, matcher, media, options?.conditionState)) {
            return false;
          }
          break;

        case 'title':
          if (!this._matchTitle(matcher, media)) {
            return false;
          }
          break;

        case 'or':
          if (
            !matcher.matchers.some((subMatcher) =>
              this.match(hass, media, {
                foldersOnly: options?.foldersOnly,
                matchers: [subMatcher],
                conditionState: options?.conditionState,
              }),
            )
          ) {
            return false;
          }
          break;
      }
    }

    return true;
  }

  private _matchStartDate(
    matcher: DateMatcher | StartDateMatcher,
    media: RichBrowseMedia<BrowseMediaMetadata>,
  ): boolean {
    const startDate = media._metadata?.startDate;
    return (
      !!startDate &&
      startDate >=
        sub(new Date(), {
          years: matcher.since.years ?? 0,
          months: matcher.since.months ?? 0,
          days: matcher.since.days ?? 0,
          hours: matcher.since.hours ?? 0,
          minutes: matcher.since.minutes ?? 0,
        })
    );
  }

  private _matchTemplate(
    hass: HomeAssistant,
    matcher: TemplateMatcher,
    media: RichBrowseMedia<BrowseMediaMetadata>,
    conditionState?: ConditionState,
  ): boolean {
    return (
      this._templateRenderer.renderRecursively(hass, matcher.value_template, {
        conditionState,
        mediaData: {
          title: media.title,
          is_folder: media.can_expand,
        },
      }) === true
    );
  }

  private _matchTitle(
    matcher: TitleMatcher,
    media: RichBrowseMedia<BrowseMediaMetadata>,
  ): boolean {
    const valueToMatch = matcher.regexp
      ? regexpExtract(matcher.regexp, media.title, { groupName: REGEXP_GROUP_VALUE_KEY })
      : media.title;

    if (!valueToMatch) {
      return false;
    }

    if (matcher.title) {
      return valueToMatch === matcher.title;
    }

    return true;
  }
}



================================================
FILE: src/card-controller/folders/ha/metadata-generator.ts
================================================
import { parse } from 'date-fns';
import { Parser } from '../../../config/schema/folders';
import {
  BrowseMedia,
  BrowseMediaMetadata,
  RichBrowseMedia,
} from '../../../ha/browse-media/types';

import parser from 'any-date-parser';
import { isValidDate } from '../../../utils/basic';
import { regexpExtract } from '../../../utils/regexp-extract';
import { REGEXP_GROUP_VALUE_KEY } from './types';

export class MetadataGenerator {
  protected _anyDateParser: typeof parser | null = null;

  public async prepare(parsers?: Parser[]): Promise<void> {
    if (this._anyDateParser) {
      return;
    }

    // Dynamically import the any-date-parser only if we have a parser that
    // requires it, in order to save on bundle size.
    if (
      parsers?.some(
        (parser) => ['date', 'startdate'].includes(parser.type) && !parser.format,
      )
    ) {
      this._anyDateParser = (await import('any-date-parser')).default;
    }
  }

  public generate(
    media: BrowseMedia,
    parent?: RichBrowseMedia<BrowseMediaMetadata>,
    parsers?: Parser[],
  ): BrowseMediaMetadata | null {
    // Always propagate metadata from parent to children.
    const metadata: BrowseMediaMetadata = {
      ...parent?._metadata,
    };

    for (const parser of parsers ?? []) {
      const valueToParse = parser.regexp
        ? regexpExtract(parser.regexp, media.title, {
            groupName: REGEXP_GROUP_VALUE_KEY,
          })
        : media.title;
      if (!valueToParse) {
        continue;
      }
      if (parser.type === 'startdate' || parser.type === 'date') {
        metadata.startDate =
          this._parseDate(
            parser,
            valueToParse,
            metadata.startDate ?? parent?._metadata?.startDate,
          ) ?? undefined;
      }
    }

    return Object.keys(metadata).length > 0 ? metadata : null;
  }

  private _parseDate(parser: Parser, src: string, base?: Date): Date | undefined {
    if (parser.format) {
      return this._parseFormattedDate(parser.format, src, base);
    }
    return this._parseUnknownDate(src, base);
  }

  private _parseFormattedDate(
    format: string,
    src: string,
    base?: Date,
  ): Date | undefined {
    const result = parse(src, format, base ?? new Date());
    return isValidDate(result) ? result : undefined;
  }

  private _parseUnknownDate(src: string, base?: Date): Date | undefined {
    if (!this._anyDateParser) {
      return undefined;
    }
    const result = this._anyDateParser.attempt(src);
    if (!Object.keys(result).length) {
      return undefined;
    }
    const candidate = this._anyDateParser.fromObject({
      ...(base && {
        year: base.getFullYear(),
        month: base.getMonth() + 1,
        day: base.getDate(),
        hour: base.getHours(),
        minute: base.getMinutes(),
        second: base.getSeconds(),
        millisecond: base.getMilliseconds(),
      }),
      ...result,
    });
    return isValidDate(candidate) ? candidate : undefined;
  }
}



================================================
FILE: src/card-controller/folders/ha/types.ts
================================================
export const REGEXP_GROUP_VALUE_KEY = 'value';



================================================
FILE: src/card-controller/fullscreen/factory.ts
================================================
import screenfull from 'screenfull';
import { WebkitHTMLVideoElement } from '../../types';
import { CardFullscreenAPI } from '../types';
import { ScreenfullFullScreenProvider } from './screenfull';
import { FullscreenHandler, FullscreenProvider } from './types';
import { WebkitFullScreenProvider } from './webkit';

export class FullscreenProviderFactory {
  public static create(
    api: CardFullscreenAPI,
    handler: FullscreenHandler,
  ): FullscreenProvider | null {
    if (screenfull.isEnabled) {
      return new ScreenfullFullScreenProvider(api, handler);
    }

    const video = document.createElement('video') as Partial<WebkitHTMLVideoElement>;
    if (!!video.webkitEnterFullscreen) {
      return new WebkitFullScreenProvider(api, handler);
    }

    return null;
  }
}



================================================
FILE: src/card-controller/fullscreen/fullscreen-manager.ts
================================================
import { isBeingCasted } from '../../utils/casting';
import { CardFullscreenAPI } from '../types';
import { FullscreenProviderFactory } from './factory';
import { FullscreenProvider } from './types';

export class FullscreenManager {
  protected _api: CardFullscreenAPI;
  protected _provider: FullscreenProvider | null;

  constructor(api: CardFullscreenAPI, provider?: FullscreenProvider) {
    this._api = api;
    this._provider =
      provider ?? FullscreenProviderFactory.create(api, this._fullscreenHandler);
  }

  public connect(): void {
    this._provider?.connect();
  }

  public disconnect(): void {
    this._provider?.disconnect();
  }

  public setFullscreen(fullscreen: boolean): void {
    this._provider?.setFullscreen(fullscreen);
  }

  public isInFullscreen(): boolean {
    return this._provider?.isInFullscreen() ?? false;
  }

  public isSupported(): boolean {
    if (isBeingCasted()) {
      return false;
    }
    return this._provider?.isSupported() ?? false;
  }

  public initialize(): void {
    this._setConditionState();
  }

  public toggleFullscreen(): void {
    if (this._provider?.isInFullscreen()) {
      this._provider.setFullscreen(false);
    } else {
      this._provider?.setFullscreen(true);
    }
  }

  protected _fullscreenHandler = (): void => {
    this._api.getExpandManager().setExpanded(false);

    this._setConditionState();

    // Re-render after a change to fullscreen mode to take advantage of
    // the expanded screen real-estate (vs staying in aspect-ratio locked
    // modes).
    this._api.getCardElementManager().update();
  };

  protected _setConditionState(): void {
    this._api.getConditionStateManager()?.setState({
      fullscreen: this.isInFullscreen(),
    });
  }
}



================================================
FILE: src/card-controller/fullscreen/provider.ts
================================================
import { CardFullscreenAPI } from '../types';
import { FullscreenHandler } from './types';

export class FullscreenProviderBase {
  protected _api: CardFullscreenAPI;
  protected _handler: FullscreenHandler;

  constructor(api: CardFullscreenAPI, handler: FullscreenHandler) {
    this._api = api;
    this._handler = handler;
  }
}



================================================
FILE: src/card-controller/fullscreen/types.ts
================================================
export type FullscreenHandler = () => void;

export interface FullscreenProvider {
  connect(): void;
  disconnect(): void;

  isInFullscreen(): boolean;
  isSupported(): boolean;

  setFullscreen(fullscreen: boolean): void;
}



================================================
FILE: src/card-controller/fullscreen/screenfull/index.ts
================================================
import screenfull from 'screenfull';
import { FullscreenProviderBase } from '../provider';
import { FullscreenProvider } from '../types';

export class ScreenfullFullScreenProvider
  extends FullscreenProviderBase
  implements FullscreenProvider
{
  public connect(): void {
    if (screenfull.isEnabled) {
      screenfull.on('change', this._handler);
    }
  }

  public disconnect(): void {
    if (screenfull.isEnabled) {
      screenfull.off('change', this._handler);
    }
  }

  public isInFullscreen(): boolean {
    return screenfull.isEnabled && screenfull.isFullscreen;
  }

  public isSupported(): boolean {
    return screenfull.isEnabled;
  }

  public setFullscreen(fullscreen: boolean): void {
    if (!this.isSupported()) {
      return;
    }

    if (fullscreen) {
      screenfull.request(this._api.getCardElementManager().getElement());
    } else {
      screenfull.exit();
    }
  }
}



================================================
FILE: src/card-controller/fullscreen/webkit/index.ts
================================================
import { ConditionStateChange } from '../../../conditions/types';
import { WebkitHTMLVideoElement } from '../../../types';
import { Timer } from '../../../utils/timer';
import { FullscreenProviderBase } from '../provider';
import { FullscreenProvider } from '../types';

const WEBKIT_PLAY_SECONDS = 0.5;

/**
 * Fullscreen implementation for webkit based browsers that do not support the
 * standard Fullscreen API (expected to be exclusively iOS on an iPhone).
 * See: https://github.com/dermotduffy/advanced-camera-card/issues/1444
 */
export class WebkitFullScreenProvider
  extends FullscreenProviderBase
  implements FullscreenProvider
{
  protected _playTimer = new Timer();

  public connect(): void {
    this._api.getConditionStateManager().addListener(this._stateChangeHandler);
  }

  public disconnect(): void {
    this._api.getConditionStateManager().removeListener(this._stateChangeHandler);
  }

  protected _stateChangeHandler = (change: ConditionStateChange): void => {
    if (
      change.old.mediaLoadedInfo?.mediaPlayerController?.getFullscreenElement() !==
      change.new.mediaLoadedInfo?.mediaPlayerController?.getFullscreenElement()
    ) {
      const oldElement =
        change.old.mediaLoadedInfo?.mediaPlayerController?.getFullscreenElement();
      oldElement?.removeEventListener('webkitbeginfullscreen', this._handler);
      oldElement?.removeEventListener('webkitendfullscreen', this._endHandler);

      const newElement =
        change.new.mediaLoadedInfo?.mediaPlayerController?.getFullscreenElement();
      newElement?.addEventListener('webkitbeginfullscreen', this._handler);
      newElement?.addEventListener('webkitendfullscreen', this._endHandler);
    }
  };

  protected _getVideoElement():
    | (HTMLVideoElement & Partial<WebkitHTMLVideoElement>)
    | null {
    const element = this._api
      .getMediaLoadedInfoManager()
      .get()
      ?.mediaPlayerController?.getFullscreenElement();
    return element instanceof HTMLVideoElement ? element : null;
  }

  public isInFullscreen(): boolean {
    return !!this._getVideoElement()?.webkitDisplayingFullscreen;
  }

  public isSupported(): boolean {
    return !!this._getVideoElement()?.webkitSupportsFullscreen;
  }

  public setFullscreen(fullscreen: boolean): void {
    if (!this.isSupported()) {
      return;
    }

    const video = this._getVideoElement();

    if (fullscreen) {
      video?.webkitEnterFullscreen?.();
    } else {
      video?.webkitExitFullscreen?.();
    }
  }

  protected _endHandler = (): void => {
    this._handler();

    // Webkit on iPhone stops the video when exiting fullscreen (why!). This
    // hack workaround has the disadvantage that there's no way to tell if the
    // video was legitimately paused before they user exited fullscreen (as the
    // common path is for exit fullscreen to not involve
    // setFullscreen(...) being called at all, but rather the user simply
    // clicking the 'X' which then fires this event). That's probably the rare
    // case though.
    this._playTimer.start(WEBKIT_PLAY_SECONDS, () => {
      this._getVideoElement()?.play();
    });
  };
}



================================================
FILE: src/card-controller/hass/hass-manager.ts
================================================
import { hasHAConnectionStateChanged } from '../../ha/has-hass-connection-changed';
import { HomeAssistant } from '../../ha/types';
import { localize } from '../../localize/localize';
import { CardHASSAPI } from '../types';
import { StateWatcher, StateWatcherSubscriptionInterface } from './state-watcher';

export class HASSManager {
  protected _hass: HomeAssistant | null = null;
  protected _api: CardHASSAPI;
  protected _stateWatcher: StateWatcher = new StateWatcher();

  constructor(api: CardHASSAPI) {
    this._api = api;
  }

  public getHASS(): HomeAssistant | null {
    return this._hass;
  }

  public hasHASS(): boolean {
    return !!this._hass;
  }

  public getStateWatcher(): StateWatcherSubscriptionInterface {
    return this._stateWatcher;
  }

  public setHASS(hass?: HomeAssistant | null): void {
    if (hasHAConnectionStateChanged(this._hass, hass)) {
      if (!hass?.connected) {
        this._api.getMessageManager().setMessageIfHigherPriority({
          message: localize('error.reconnecting'),
          icon: 'mdi:lan-disconnect',
          type: 'connection',
          dotdotdot: true,
        });
      } else {
        this._api.getMessageManager().resetType('connection');
      }
    }

    if (!hass) {
      return;
    }

    const oldHass = this._hass;
    this._hass = hass;

    this._api.getConditionStateManager().setState({
      hass: this._hass,
    });

    // Theme may depend on HASS.
    this._api.getStyleManager().applyTheme();

    this._stateWatcher.setHASS(oldHass, hass);
  }
}



================================================
FILE: src/card-controller/hass/state-watcher.ts
================================================
import { getHassDifferences } from '../../ha/get-hass-differences';
import { HassStateDifference, HomeAssistant } from '../../ha/types';

type StateWatcherCallback = (difference: HassStateDifference) => void;

export interface StateWatcherSubscriptionInterface {
  subscribe(callback: StateWatcherCallback, entityIDs: string[]): void;
  unsubscribe(callback: StateWatcherCallback): void;
}

export class StateWatcher implements StateWatcherSubscriptionInterface {
  protected _watcherCallbacks = new Map<StateWatcherCallback, string[]>();

  public setHASS(oldHass: HomeAssistant | null, hass: HomeAssistant): void {
    if (!oldHass) {
      return;
    }

    for (const [callback, entityIDs] of this._watcherCallbacks.entries()) {
      const differences = getHassDifferences(hass, oldHass, entityIDs, {
        stateOnly: true,
        firstOnly: true,
      });
      if (differences.length) {
        callback(differences[0]);
      }
    }
  }

  /**
   * Calls callback when the state of any of the entities changes. The callback is
   * called with the state difference of the first entity that changed.
   * @param callback The callback.
   * @param entityIDs An array of entity IDs to watch.
   */
  public subscribe(callback: StateWatcherCallback, entityIDs: string[]): boolean {
    if (!entityIDs.length) {
      return false;
    }
    if (this._watcherCallbacks.has(callback)) {
      this._watcherCallbacks.get(callback)?.push(...entityIDs);
    } else {
      this._watcherCallbacks.set(callback, entityIDs);
    }
    return true;
  }

  public unsubscribe(callback: StateWatcherCallback): void {
    this._watcherCallbacks.delete(callback);
  }
}



================================================
FILE: src/card-controller/templates/index.ts
================================================
import { HASS, renderTemplate } from 'ha-nunjucks/dist';
import { ConditionState, ConditionsTriggerData } from '../../conditions/types';
import { HomeAssistant } from '../../ha/types';

interface TemplateMediaData {
  title: string;
  is_folder: boolean;
}
interface TemplateContextInternal {
  camera?: string;
  view?: string;
  trigger?: ConditionsTriggerData;
  media?: TemplateMediaData;
}

interface TemplateContext {
  advanced_camera_card: TemplateContextInternal;

  // Convenient alias.
  acc: TemplateContextInternal;
}

export class TemplateRenderer {
  public renderRecursively = (
    hass: HomeAssistant,
    data: unknown,
    options?: {
      conditionState?: ConditionState;
      triggerData?: ConditionsTriggerData;
      mediaData?: TemplateMediaData;
    },
  ): unknown => {
    return this._renderTemplateRecursively(
      hass,
      data,
      this._generateTemplateContext(options),
    );
  };

  protected _generateTemplateContext(options?: {
    conditionState?: ConditionState;
    triggerData?: ConditionsTriggerData;
    mediaData?: TemplateMediaData;
  }): TemplateContext | undefined {
    if (
      !options?.conditionState?.camera &&
      !options?.conditionState?.view &&
      !options?.triggerData &&
      !options?.mediaData
    ) {
      return;
    }

    const advancedCameraCardContext: TemplateContextInternal = {
      ...(options?.conditionState?.camera && { camera: options.conditionState.camera }),
      ...(options?.conditionState?.view && { view: options.conditionState.view }),
      ...(options?.triggerData && { trigger: options.triggerData }),
      ...(options?.mediaData && { media: options.mediaData }),
    };

    return {
      acc: advancedCameraCardContext,
      advanced_camera_card: advancedCameraCardContext,
    };
  }

  protected _renderTemplateRecursively(
    hass: HomeAssistant,
    data: unknown,
    templateContext?: TemplateContext,
  ): unknown {
    if (typeof data === 'string') {
      return renderTemplate(
        // ha-nunjucks has a more complete model of the Home Assistant object, but
        // does not export it as a type.
        hass as unknown as typeof HASS,
        data,
        templateContext,
      );
    } else if (Array.isArray(data)) {
      return data.map((item) =>
        this._renderTemplateRecursively(hass, item, templateContext),
      );
    } else if (typeof data === 'object' && data !== null) {
      const result = {};
      for (const key in data) {
        result[key] = this._renderTemplateRecursively(hass, data[key], templateContext);
      }
      return result;
    }
    return data;
  }
}



================================================
FILE: src/card-controller/view/factory.ts
================================================
import { AdvancedCameraCardView, VIEW_DEFAULT } from '../../config/schema/common/const';
import { ViewDisplayMode } from '../../config/schema/common/display';
import { AdvancedCameraCardConfig } from '../../config/schema/types';
import { localize } from '../../localize/localize';
import { View, ViewParameters } from '../../view/view';
import { getCameraIDsForViewName } from '../../view/view-to-cameras';
import { CardViewAPI } from '../types';
import { applyViewModifiers } from './modifiers';
import { ViewFactoryOptions, ViewIncompatible, ViewNoCameraError } from './types';

export class ViewFactory {
  protected _api: CardViewAPI;

  constructor(api: CardViewAPI) {
    this._api = api;
  }

  public getViewDefault(options?: ViewFactoryOptions): View | null {
    const config = this._api.getConfigManager().getConfig();
    if (!config) {
      return null;
    }

    // Neither options.baseView.camera nor options.baseView.view are respected
    // here, since this is the default view / camera.
    // See: https://github.com/dermotduffy/advanced-camera-card/issues/1564

    let cameraID: string | null = null;
    const viewName = options?.params?.view ?? config.view.default;

    if (options?.params?.camera) {
      cameraID = options.params.camera;
    } else {
      const cameraIDs = [
        ...getCameraIDsForViewName(this._api.getCameraManager(), viewName),
      ];

      if (
        cameraIDs.length &&
        options?.baseView?.camera &&
        config.view.default_cycle_camera
      ) {
        const currentIndex = cameraIDs.indexOf(options.baseView.camera);
        const targetIndex = currentIndex + 1 >= cameraIDs.length ? 0 : currentIndex + 1;
        cameraID = cameraIDs[targetIndex];
      } else {
        cameraID = cameraIDs[0] ?? null;
      }
    }

    return this.getViewByParameters({
      params: {
        ...options?.params,
        view: viewName,
        camera: cameraID,
      },
      baseView: options?.baseView,
    });
  }

  public getViewByParameters(options?: ViewFactoryOptions): View | null {
    const config = this._api.getConfigManager().getConfig();
    if (!config) {
      return null;
    }

    let cameraID: string | null =
      options?.params?.camera ?? options?.baseView?.camera ?? null;
    let viewName =
      options?.params?.view ?? options?.baseView?.view ?? config.view.default;

    const allCameraIDs = this._api.getCameraManager().getStore().getCameraIDs();

    if (!cameraID || !allCameraIDs.has(cameraID)) {
      const viewCameraIDs = getCameraIDsForViewName(
        this._api.getCameraManager(),
        viewName,
      );

      // Reset to the default camera.
      cameraID = viewCameraIDs.keys().next().value ?? null;
    }

    if (!cameraID) {
      const camerasToCapabilities = [
        ...this._api.getCameraManager().getStore().getCameras(),
      ].reduce((acc, [cameraID, camera]) => {
        const capabilities = camera.getCapabilities()?.getRawCapabilities();
        if (capabilities) {
          acc[cameraID] = capabilities;
        }
        return acc;
      }, {});

      throw new ViewNoCameraError(localize('error.no_supported_cameras'), {
        view: viewName,
        cameras_capabilities: camerasToCapabilities,
      });
    }

    if (!this.isViewSupportedByCamera(cameraID, viewName)) {
      if (options?.failSafe && this.isViewSupportedByCamera(cameraID, VIEW_DEFAULT)) {
        viewName = VIEW_DEFAULT;
      } else {
        const capabilities = this._api
          .getCameraManager()
          .getStore()
          .getCamera(cameraID)
          ?.getCapabilities()
          ?.getRawCapabilities();

        throw new ViewIncompatible(localize('error.no_supported_camera'), {
          view: viewName,
          camera: cameraID,
          ...(capabilities && { camera_capabilities: capabilities }),
        });
      }
    }
    const configuredDisplayMode = this._getDefaultDisplayModeForView(viewName, config);
    const displayMode =
      // Prioritize the configured display mode (if present).
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1812
      (viewName !== options?.baseView?.view ? configuredDisplayMode : null) ??
      options?.params?.displayMode ??
      options?.baseView?.displayMode ??
      configuredDisplayMode ??
      'single';

    const viewParameters: ViewParameters = {
      ...options?.params,
      view: viewName,
      camera: cameraID,
      displayMode: displayMode,
    };

    const view = options?.baseView
      ? options.baseView.evolve(viewParameters)
      : new View(viewParameters);

    applyViewModifiers(view, options?.modifiers);

    return view;
  }

  public isViewSupportedByCamera(
    cameraID: string,
    view: AdvancedCameraCardView,
  ): boolean {
    return !!getCameraIDsForViewName(this._api.getCameraManager(), view, cameraID).size;
  }

  protected _getDefaultDisplayModeForView(
    viewName: AdvancedCameraCardView,
    config: AdvancedCameraCardConfig,
  ): ViewDisplayMode | null {
    let mode: ViewDisplayMode | null = null;
    switch (viewName) {
      case 'media':
      case 'clip':
      case 'recording':
      case 'snapshot':
        mode = config.media_viewer.display?.mode ?? null;
        break;
      case 'live':
        mode = config.live.display?.mode ?? null;
        break;
    }
    return mode;
  }
}



================================================
FILE: src/card-controller/view/item-manager.ts
================================================
import { format } from 'date-fns';
import { localize } from '../../localize/localize';
import { AdvancedCameraCardError } from '../../types';
import { errorToConsole } from '../../utils/basic';
import { downloadURL } from '../../utils/download';
import { homeAssistantSignPath } from '../../ha/sign-path';
import { ViewItem } from '../../view/item';
import { ViewItemClassifier } from '../../view/item-classifier';
import { ViewItemCapabilities } from '../../view/types';
import { CardViewAPI } from '../types';

enum ViewMediaSource {
  Camera = 'camera',
  Folder = 'folder',
}

export class ViewItemManager {
  private _api: CardViewAPI;

  constructor(api: CardViewAPI) {
    this._api = api;
  }

  public getCapabilities(item: ViewItem): ViewItemCapabilities | null {
    const source = this._getMediaSource(item);
    if (source === ViewMediaSource.Camera && ViewItemClassifier.isMedia(item)) {
      return this._api.getCameraManager().getMediaCapabilities(item);
    }
    if (source === ViewMediaSource.Folder) {
      return this._api.getFoldersManager().getItemCapabilities(item);
    }

    return null;
  }

  public async download(item: ViewItem): Promise<boolean> {
    try {
      await this._download(item);
    } catch (error: unknown) {
      this._api.getMessageManager().setErrorIfHigherPriority(error);
      return false;
    }
    return true;
  }

  public async favorite(item: ViewItem, favorite: boolean): Promise<void> {
    const source = this._getMediaSource(item);
    if (source === ViewMediaSource.Camera && ViewItemClassifier.isMedia(item)) {
      return await this._api.getCameraManager().favoriteMedia(item, favorite);
    }
    /* istanbul ignore else: this path cannot be reached -- @preserve */
    if (source === ViewMediaSource.Folder) {
      return this._api.getFoldersManager().favorite(item, favorite);
    }
  }

  private _getMediaSource(item: ViewItem): ViewMediaSource | null {
    if (ViewItemClassifier.isMedia(item) && item.getCameraID()) {
      return ViewMediaSource.Camera;
    }
    if (ViewItemClassifier.isFolder(item) || item.getFolder()) {
      return ViewMediaSource.Folder;
    }

    /* istanbul ignore next: this path cannot be reached -- @preserve */
    return null;
  }

  private async _download(item: ViewItem): Promise<void> {
    const hass = this._api.getHASSManager().getHASS();
    if (!hass) {
      return;
    }

    const source = this._getMediaSource(item);
    const endpoint =
      source === ViewMediaSource.Camera && ViewItemClassifier.isMedia(item)
        ? await this._api.getCameraManager().getMediaDownloadPath(item)
        : source === ViewMediaSource.Folder
          ? await this._api.getFoldersManager().getDownloadPath(item)
          : null;

    if (!endpoint) {
      throw new AdvancedCameraCardError(localize('error.download_no_media'));
    }

    let finalURL = endpoint.endpoint;
    if (endpoint.sign) {
      let response: string | null | undefined;
      try {
        response = await homeAssistantSignPath(hass, endpoint.endpoint);
      } catch (e) {
        errorToConsole(e as Error);
      }

      if (!response) {
        throw new AdvancedCameraCardError(localize('error.download_sign_failed'));
      }
      finalURL = response;
    }

    downloadURL(finalURL, this._generateDownloadFilename(item));
  }

  private _generateDownloadFilename(item: ViewItem): string {
    const toFilename = (input: string): string => {
      return input.toLowerCase().replaceAll(/[^a-z0-9]/gi, '-');
    };

    if (ViewItemClassifier.isMedia(item)) {
      const cameraID = item.getCameraID();
      const id = item.getID();
      const startTime = item.getStartTime();

      return (
        (cameraID ? toFilename(cameraID) : 'media') +
        (id ? `_${toFilename(id)}` : '') +
        (startTime ? `_${format(startTime, `yyyy-MM-dd-HH-mm-ss`)}` : '') +
        ('.' + (item.getMediaType() === 'clip' ? 'mp4' : 'jpg'))
      );
    }

    /* istanbul ignore else: this path cannot be reached -- @preserve */
    if (ViewItemClassifier.isFolder(item)) {
      return toFilename(item.getTitle() ?? 'media');
    }

    /* istanbul ignore next: this path cannot be reached -- @preserve */
    return 'download';
  }
}



================================================
FILE: src/card-controller/view/query-executor.ts
================================================
import { CapabilitySearchOptions, MediaQuery } from '../../camera-manager/types';
import { MEDIA_CHUNK_SIZE_DEFAULT } from '../../const';
import { ClipsOrSnapshotsOrAll } from '../../types';
import { findBestMediaTimeIndex } from '../../utils/find-best-media-time-index';
import { ViewItem } from '../../view/item';
import {
  EventMediaQuery,
  FolderViewQuery,
  MediaQueries,
  Query,
  RecordingMediaQuery,
} from '../../view/query';
import { QueryClassifier } from '../../view/query-classifier';
import { QueryResults } from '../../view/query-results';
import { CardViewAPI } from '../types';
import { QueryExecutorOptions, QueryExecutorResult } from './types';

export class QueryExecutor {
  protected _api: CardViewAPI;

  constructor(api: CardViewAPI) {
    this._api = api;
  }

  public async executeDefaultEventQuery(options?: {
    cameraID?: string;
    eventsMediaType?: ClipsOrSnapshotsOrAll;
    executorOptions?: QueryExecutorOptions;
  }): Promise<QueryExecutorResult | null> {
    const capabilitySearch: CapabilitySearchOptions =
      !options?.eventsMediaType || options?.eventsMediaType === 'all'
        ? {
            anyCapabilities: ['clips', 'snapshots'],
          }
        : options.eventsMediaType;

    const cameraManager = this._api.getCameraManager();
    const cameraIDs = options?.cameraID
      ? cameraManager
          .getStore()
          .getAllDependentCameras(options.cameraID, capabilitySearch)
      : cameraManager.getStore().getCameraIDsWithCapability(capabilitySearch);
    if (!cameraIDs.size) {
      return null;
    }

    const rawQueries = cameraManager.generateDefaultEventQueries(cameraIDs, {
      limit: this._getChunkLimit(),
      ...(options?.eventsMediaType === 'clips' && { hasClip: true }),
      ...(options?.eventsMediaType === 'snapshots' && { hasSnapshot: true }),
    });
    if (!rawQueries) {
      return null;
    }
    const queries = new EventMediaQuery(rawQueries);
    return await this.executeMediaQuery(queries, options?.executorOptions);
  }

  public async executeDefaultRecordingQuery(options?: {
    cameraID?: string;
    executorOptions?: QueryExecutorOptions;
  }): Promise<QueryExecutorResult | null> {
    const cameraManager = this._api.getCameraManager();
    const cameraIDs = options?.cameraID
      ? cameraManager.getStore().getAllDependentCameras(options.cameraID, 'recordings')
      : cameraManager.getStore().getCameraIDsWithCapability('recordings');
    if (!cameraIDs.size) {
      return null;
    }

    const rawQueries = cameraManager.generateDefaultRecordingQueries(cameraIDs, {
      limit: this._getChunkLimit(),
    });
    if (!rawQueries) {
      return null;
    }
    const queries = new RecordingMediaQuery(rawQueries);
    return await this.executeMediaQuery(queries, options?.executorOptions);
  }

  public async executeQuery(
    query: Query,
    executorOptions?: QueryExecutorOptions,
  ): Promise<QueryExecutorResult | null> {
    /* istanbul ignore else: this path cannot be reached -- @preserve */
    if (QueryClassifier.isMediaQuery(query)) {
      return await this.executeMediaQuery(query, executorOptions);
    } else if (QueryClassifier.isFolderQuery(query)) {
      return await this._executeFolderQuery(query, executorOptions);
    }

    /* istanbul ignore next: this path cannot be reached -- @preserve */
    return null;
  }

  public async executeMediaQuery(
    query: MediaQueries,
    executorOptions?: QueryExecutorOptions,
  ): Promise<QueryExecutorResult | null> {
    const queries = query.getQuery();
    if (!queries) {
      return null;
    }

    const mediaArray = await this._api
      .getCameraManager()
      .executeMediaQueries<MediaQuery>(queries, {
        useCache: executorOptions?.useCache,
      });
    const queryResults = mediaArray
      ? this._generateQueriesResults(mediaArray, executorOptions)
      : null;
    return queryResults ? { query, queryResults } : null;
  }

  private _generateQueriesResults(
    itemArray: ViewItem[],
    executorOptions?: QueryExecutorOptions,
  ): QueryResults | null {
    const queryResults = new QueryResults({ results: itemArray });
    if (executorOptions?.rejectResults?.(queryResults)) {
      return null;
    }

    if (executorOptions?.selectResult?.id) {
      queryResults.selectBestResult((media) =>
        media.findIndex((m) => m.getID() === executorOptions.selectResult?.id),
      );
    } else if (executorOptions?.selectResult?.func) {
      queryResults.selectResultIfFound(executorOptions.selectResult.func);
    } else if (executorOptions?.selectResult?.time) {
      queryResults.selectBestResult((itemArray) =>
        findBestMediaTimeIndex(
          itemArray,
          executorOptions.selectResult?.time?.time as Date,
          executorOptions.selectResult?.time?.favorCameraID,
        ),
      );
    }
    return queryResults;
  }

  public async executeDefaultFolderQuery(
    executorOptions?: QueryExecutorOptions,
  ): Promise<QueryExecutorResult | null> {
    const query = this._api.getFoldersManager().generateDefaultFolderQuery();
    return query
      ? this._executeFolderQuery(new FolderViewQuery(query), executorOptions)
      : null;
  }

  private async _executeFolderQuery(
    query: FolderViewQuery,
    executorOptions?: QueryExecutorOptions,
  ): Promise<QueryExecutorResult | null> {
    const rawQuery = query.getQuery();
    if (!rawQuery) {
      return null;
    }
    const itemArray = await this._api
      .getFoldersManager()
      .expandFolder(rawQuery, this._api.getConditionStateManager().getState(), {
        useCache: executorOptions?.useCache,
      });

    const queryResults = itemArray
      ? this._generateQueriesResults(itemArray, executorOptions)
      : null;
    return queryResults ? { query, queryResults } : null;
  }

  protected _getChunkLimit(): number {
    const cardWideConfig = this._api.getConfigManager().getCardWideConfig();
    return (
      cardWideConfig?.performance?.features.media_chunk_size ?? MEDIA_CHUNK_SIZE_DEFAULT
    );
  }
}



================================================
FILE: src/card-controller/view/sort.ts
================================================
import { orderBy, uniqBy } from 'lodash-es';
import { ViewItem } from '../../view/item';
import { ViewItemClassifier } from '../../view/item-classifier';

export const sortItems = <T extends ViewItem>(itemArray: T[]): T[] => {
  return orderBy(
    // Ensure uniqueness by the ID (if specified), otherwise all elements
    // are assumed to be unique.
    uniqBy(itemArray, (item) => item.getID() ?? item),

    [
      // Pull folders to the front.
      (item) => !ViewItemClassifier.isFolder(item),

      // Sort by time and id.
      (item) =>
        ViewItemClassifier.isMedia(item)
          ? item.getStartTime() ?? item.getID()
          : item.getID(),
    ],
    ['asc', 'asc'],
  );
};



================================================
FILE: src/card-controller/view/types.ts
================================================
import { ViewContext } from 'view';
import { AdvancedCameraCardView } from '../../config/schema/common/const.js';
import { AdvancedCameraCardError } from '../../types.js';
import { ViewItem } from '../../view/item.js';
import { QueryResults } from '../../view/query-results.js';
import { Query } from '../../view/query.js';
import { View, ViewParameters } from '../../view/view.js';

export interface ViewModifier {
  modify(view: View): void;
}

export interface QueryExecutorOptions {
  // Select the result of a query, based on time, an id match or an arbitrary
  // function. If no parameter is specified, the latest media will be selected
  // by default.
  selectResult?: {
    time?: {
      time: Date;
      favorCameraID?: string;
    };
    id?: string;
    func?: (media: ViewItem) => boolean;
  };
  rejectResults?: (results: QueryResults) => boolean;
  useCache?: boolean;
}

export interface QueryExecutorResult {
  query: Query;
  queryResults: QueryResults;
}

export interface ViewFactoryOptions {
  // An existing view to evolve from.
  baseView?: View | null;

  // View parameters to set/evolve.
  params?: Partial<ViewParameters>;

  // Modifiers to the view once created.
  modifiers?: ViewModifier[];

  // When failSafe is true the view will be changed to the default view, or the
  // `live` view if the configured default view is not supported.
  failSafe?: boolean;

  // Options for the query executor that control how a query is executed and the
  // result selected.
  queryExecutorOptions?: QueryExecutorOptions;
}

export interface ViewManagerEpoch {
  manager: ViewManagerInterface;

  oldView?: View;
}

export interface ViewManagerInterface {
  getEpoch(): ViewManagerEpoch;

  getView(): View | null;
  hasView(): boolean;
  reset(): void;

  setViewDefault(options?: ViewFactoryOptions): void;
  setViewByParameters(options?: ViewFactoryOptions): void;

  setViewDefaultWithNewQuery(options?: ViewFactoryOptions): Promise<void>;
  setViewByParametersWithNewQuery(options?: ViewFactoryOptions): Promise<void>;
  setViewByParametersWithExistingQuery(options?: ViewFactoryOptions): Promise<void>;

  setViewWithMergedContext(context: ViewContext | null): void;

  isViewSupportedByCamera(cameraID: string, view: AdvancedCameraCardView): boolean;
  hasMajorMediaChange(oldView?: View | null, newView?: View | null): boolean;
}

export class ViewNoCameraError extends AdvancedCameraCardError {}
export class ViewIncompatible extends AdvancedCameraCardError {}



================================================
FILE: src/card-controller/view/view-manager.ts
================================================
import { ViewContext } from 'view';
import { AdvancedCameraCardView } from '../../config/schema/common/const';
import { log } from '../../utils/debug';
import { getStreamCameraID } from '../../utils/substream';
import { QueryClassifier } from '../../view/query-classifier';
import { View } from '../../view/view';
import { getCameraIDsForViewName } from '../../view/view-to-cameras';
import { InitializationAspect } from '../initialization-manager';
import { CardViewAPI } from '../types';
import { ViewFactory } from './factory';
import { applyViewModifiers } from './modifiers';
import {
  QueryExecutorOptions,
  ViewFactoryOptions,
  ViewManagerEpoch,
  ViewManagerInterface,
  ViewModifier,
} from './types';
import { ViewQueryExecutor } from './view-query-executor';

export class ViewManager implements ViewManagerInterface {
  protected _view: View | null = null;
  protected _viewFactory: ViewFactory;
  protected _viewQueryExecutor: ViewQueryExecutor;
  protected _api: CardViewAPI;
  protected _epoch: ViewManagerEpoch = this._createEpoch();

  // Used to mark as a view as "loading" with a given index. Each subsequent
  // async update will use a higher index.
  protected _loadingIndex = 1;

  constructor(
    api: CardViewAPI,
    options?: {
      viewFactory?: ViewFactory;
      viewQueryExecutor?: ViewQueryExecutor;
    },
  ) {
    this._api = api;
    this._viewFactory = options?.viewFactory ?? new ViewFactory(api);
    this._viewQueryExecutor = options?.viewQueryExecutor ?? new ViewQueryExecutor(api);
  }

  public getEpoch(): ViewManagerEpoch {
    return this._epoch;
  }
  protected _createEpoch(oldView?: View | null): ViewManagerEpoch {
    return {
      manager: this,
      ...(oldView && { oldView }),
    };
  }

  public getView(): View | null {
    return this._view;
  }
  public hasView(): boolean {
    return !!this.getView();
  }
  public reset(): void {
    if (this._view) {
      this._setView(null);
    }
  }

  setViewDefault = (options?: ViewFactoryOptions): void =>
    this._setViewGeneric(
      this._viewFactory.getViewDefault.bind(this._viewFactory),
      options,
    );

  setViewByParameters = (options?: ViewFactoryOptions): void =>
    this._setViewGeneric(
      this._viewFactory.getViewByParameters.bind(this._viewFactory),
      options,
    );

  setViewDefaultWithNewQuery = async (options?: ViewFactoryOptions): Promise<void> =>
    await this._setViewThenModifyAsync(
      this._viewFactory.getViewDefault.bind(this._viewFactory),
      this._viewQueryExecutor.getNewQueryModifiers.bind(this._viewQueryExecutor),
      options,
    );

  setViewByParametersWithNewQuery = async (
    options?: ViewFactoryOptions,
  ): Promise<void> =>
    await this._setViewThenModifyAsync(
      this._viewFactory.getViewByParameters.bind(this._viewFactory),
      this._viewQueryExecutor.getNewQueryModifiers.bind(this._viewQueryExecutor),
      options,
    );

  setViewByParametersWithExistingQuery = async (
    options?: ViewFactoryOptions,
  ): Promise<void> =>
    await this._setViewThenModifyAsync(
      this._viewFactory.getViewByParameters.bind(this._viewFactory),
      this._viewQueryExecutor.getExistingQueryModifiers.bind(this._viewQueryExecutor),
      options,
    );

  protected _setViewGeneric(
    viewFactoryFunc: (options?: ViewFactoryOptions) => View | null,
    options?: ViewFactoryOptions,
  ): void {
    if (!this._isAllowedToSetView()) {
      return;
    }

    let view: View | null = null;
    try {
      view = viewFactoryFunc({
        baseView: this._view,
        ...options,
      });
    } catch (e) {
      this._api.getMessageManager().setErrorIfHigherPriority(e);
    }
    if (view) {
      this._setView(view);
    }
  }

  protected _markViewLoadingQuery(view: View, index: number): View {
    return view.mergeInContext({ loading: { query: index } });
  }
  protected _markViewAsNotLoadingQuery(view: View): View {
    return view.removeContextProperty('loading', 'query');
  }

  protected _isAllowedToSetView(): boolean {
    // It is possible to have a race condition where the view is being set at
    // the same time as the cameras being initialized. Test case: Open
    // folder-based media in the media viewer carousel, then attempt to edit the
    // card -- this causes the cameras to re-initialize at the same time as
    // folder media is reporting observed zoom settings in the view context.
    // Without this check, that will result in a "No cameras support this view"
    // message.
    return this._api
      .getInitializationManager()
      .isInitialized(InitializationAspect.CAMERAS);
  }

  protected async _setViewThenModifyAsync(
    viewFactoryFunc: (options?: ViewFactoryOptions) => View | null,
    viewModifiersFunc: (
      view: View,
      queryExecutorOptions?: QueryExecutorOptions,
    ) => Promise<ViewModifier[] | null>,
    options?: ViewFactoryOptions,
  ): Promise<void> {
    if (!this._isAllowedToSetView()) {
      return;
    }

    let initialView: View | null = null;
    try {
      initialView = viewFactoryFunc({
        baseView: this._view,
        ...options,
        params: {
          query: null,
          queryResults: null,
          ...options?.params,
        },
      });
    } catch (e) {
      this._api.getMessageManager().setErrorIfHigherPriority(e);
    }

    if (!initialView) {
      return;
    }

    if (this._view && this._shouldAdoptQueryAndResults(initialView)) {
      initialView.query = this._view.query;
      initialView.queryResults = this._view.queryResults;
      this._markViewAsNotLoadingQuery(initialView);
      this._setView(initialView);
      return;
    }

    // Mark the view as loading with the current value of _updateIndex. This is
    // used to ensure that the loading state is subsequently only removed for
    // _this_ async update.
    const loadingIndex = this._loadingIndex++;
    this._markViewLoadingQuery(initialView, loadingIndex);

    this._setView(initialView);

    let viewModifiers: ViewModifier[] | null = null;
    let error: Error | null = null;
    try {
      viewModifiers = await viewModifiersFunc(
        initialView,
        options?.queryExecutorOptions,
      );
    } catch (e) {
      error = e as Error;
    }

    if (this._view && this.hasMajorMediaChange(this._view, initialView)) {
      // If there has been a major media change in the time async operations
      // have occurred, ignore the result. For example: A slow Reolink query is
      // dispatched, the user changes the view in the interim, then the query
      // returns -- it should not be applied, nor should any errors be shown. On
      // the contrary, small changes such as the user zooming in are fine to
      // merge into the resultant view.
      if (this._view.context?.loading?.query === loadingIndex) {
        this._setView(this._markViewAsNotLoadingQuery(this._view.clone()));
      }
      return;
    }

    if (error) {
      this._api.getMessageManager().setErrorIfHigherPriority(error);
      return;
    }

    /* istanbul ignore if: the if path cannot be reached as the view is set
    above -- @preserve */
    if (!this._view) {
      return;
    }

    const newView = this._view.clone();
    if (this._view.context?.loading?.query === loadingIndex) {
      this._markViewAsNotLoadingQuery(newView);
    }
    applyViewModifiers(newView, viewModifiers);
    this._setView(newView);
  }

  protected _shouldAdoptQueryAndResults(newView: View): boolean {
    // If the user is currently using the viewer, and then switches to the
    // gallery we make an attempt to keep the query/queryResults the same so
    // the gallery can be used to click back and forth to the viewer, and the
    // selected media can be centered in the gallery. See the matching code in
    // `updated()` in `gallery.ts`. We specifically must ensure that the new
    // target media of the gallery (e.g. clips, snapshots or recordings) is
    // equal to the queries that are currently used in the viewer.
    //
    // See: https://github.com/dermotduffy/advanced-camera-card/issues/885

    const switchingFromViewerToGallery =
      this._view?.isViewerView() && newView?.isMediaGalleryView();
    const newMediaType = newView?.getDefaultMediaType();
    const alreadyHasMatchingQuery =
      QueryClassifier.getMediaType(this._view?.query) === newMediaType;
    return !!switchingFromViewerToGallery && alreadyHasMatchingQuery;
  }

  public setViewWithMergedContext(context: ViewContext | null): void {
    if (this._view) {
      return this._setView(this._view?.clone().mergeInContext(context));
    }
  }

  public isViewSupportedByCamera(
    cameraID: string,
    view: AdvancedCameraCardView,
  ): boolean {
    return !!getCameraIDsForViewName(this._api.getCameraManager(), view, cameraID).size;
  }

  /**
   * Detect if the current view has a major "media change" for the given previous view.
   * @param oldView The previous view.
   * @returns True if the view change is a real media change.
   */
  public hasMajorMediaChange(oldView?: View | null, newView?: View | null): boolean {
    const compareView = newView ?? this._view;

    return (
      !!oldView !== !!compareView ||
      oldView?.view !== compareView?.view ||
      oldView?.camera !== compareView?.camera ||
      // When in live mode, take overrides (substreams) into account in deciding
      // if this is a major media change.
      (compareView?.view === 'live' &&
        oldView &&
        getStreamCameraID(oldView) !== getStreamCameraID(compareView)) ||
      // When in the live view, the queryResults contain the events that
      // happened in the past -- not reflective of the actual live media viewer
      // the user is seeing.
      (compareView?.view !== 'live' &&
        oldView?.queryResults !== compareView?.queryResults)
    );
  }

  public initialize = async (): Promise<boolean> => {
    // If the query string contains a view related action, we don't set any view
    // here and allow that action to be triggered by the next call of to execute
    // query actions (called at least once per render cycle).
    // Related: https://github.com/dermotduffy/advanced-camera-card/issues/1200
    if (!this._api.getQueryStringManager().hasViewRelatedActionsToRun()) {
      // This is not awaited to allow the initialization to complete before the
      // query is answered.
      this.setViewDefaultWithNewQuery({ failSafe: true });
    }
    return true;
  };

  protected _setView(view: Readonly<View> | null): void {
    const oldView = this._view;

    log(
      this._api.getConfigManager().getCardWideConfig(),
      `Advanced Camera Card view change: `,
      view,
    );

    this._view = view;
    this._epoch = this._createEpoch(oldView);

    if (this.hasMajorMediaChange(oldView)) {
      this._api.getMediaLoadedInfoManager().clear();
    }

    if (oldView?.view !== view?.view) {
      this._api.getCardElementManager().scrollReset();
    }

    this._api.getMessageManager().reset();
    this._api.getStyleManager().setExpandedMode();

    this._api.getConditionStateManager()?.setState({
      view: view?.view,
      camera: view?.camera,
      displayMode: view?.displayMode ?? undefined,
    });

    this._api.getCardElementManager().update();
  }
}



================================================
FILE: src/card-controller/view/view-query-executor.ts
================================================
import { sub } from 'date-fns';
import { ClipsOrSnapshotsOrAll } from '../../types';
import { View } from '../../view/view';
import { CardViewAPI } from '../types';
import { MergeContextViewModifier } from './modifiers/merge-context';
import { RemoveContextPropertyViewModifier } from './modifiers/remove-context-property';
import { SetQueryViewModifier } from './modifiers/set-query';
import { QueryExecutor } from './query-executor';
import { QueryExecutorOptions, ViewModifier } from './types';

/**
 * This class executes media queries and returns an array of ViewModifiers that
 * can be applied to a view. This allows a view to be set when the user acts,
 * and if a query is made as part of this view the result can be applied later.
 */
export class ViewQueryExecutor {
  protected _api: CardViewAPI;
  protected _executor: QueryExecutor;

  constructor(api: CardViewAPI, executor?: QueryExecutor) {
    this._api = api;
    this._executor = executor ?? new QueryExecutor(api);
  }

  public async getExistingQueryModifiers(
    view: View,
    queryExecutorOptions?: QueryExecutorOptions,
  ): Promise<ViewModifier[] | null> {
    return view.query
      ? [
          new SetQueryViewModifier({
            queryResults: (
              await this._executor.executeQuery(view.query, queryExecutorOptions)
            )?.queryResults,
          }),
        ]
      : [];
  }

  public async getNewQueryModifiers(
    view: View,
    queryExecutorOptions?: QueryExecutorOptions,
  ): Promise<ViewModifier[] | null> {
    return await this._executeNewQuery(view, {
      useCache: false,
      ...queryExecutorOptions,
    });
  }

  protected async _executeNewQuery(
    view: View,
    queryExecutorOptions?: QueryExecutorOptions,
  ): Promise<ViewModifier[] | null> {
    const config = this._api.getConfigManager().getConfig();
    if (!config) {
      return null;
    }

    const mediaType = view?.getDefaultMediaType();
    const viewModifiers: ViewModifier[] = [];

    const executeMediaQuery = async (
      mediaType: ClipsOrSnapshotsOrAll | 'recordings' | null,
    ): Promise<ViewModifier[]> => {
      /* istanbul ignore if: this path cannot be reached -- @preserve */
      if (!mediaType) {
        return [];
      }

      const results =
        mediaType === 'recordings'
          ? await this._executor.executeDefaultRecordingQuery({
              ...(!view.isGrid() && { cameraID: view.camera }),
              executorOptions: queryExecutorOptions,
            })
          : mediaType === 'clips' || mediaType === 'snapshots' || mediaType === 'all'
            ? await this._executor.executeDefaultEventQuery({
                ...(!view.isGrid() && { cameraID: view.camera }),
                eventsMediaType: mediaType,
                executorOptions: queryExecutorOptions,
              })
            : /* istanbul ignore next -- @preserve */
              null;

      return results ? [new SetQueryViewModifier(results)] : [];
    };

    const executeFolderQuery = async (): Promise<ViewModifier[]> => {
      const results =
        await this._executor.executeDefaultFolderQuery(queryExecutorOptions);
      return results ? [new SetQueryViewModifier(results)] : [];
    };

    switch (view.view) {
      case 'live':
        if (config.live.controls.thumbnails.mode !== 'none') {
          viewModifiers.push(
            ...(await executeMediaQuery(
              config.live.controls.thumbnails.media_type === 'recordings'
                ? 'recordings'
                : config.live.controls.thumbnails.events_media_type,
            )),
          );
        }
        break;

      case 'media':
        // If the user is looking at media in the `media` view and then
        // changes camera (via the menu) it should default to showing clips
        // for the new camera.
        viewModifiers.push(...(await executeMediaQuery('clips')));
        break;

      case 'clip':
      case 'clips':
      case 'snapshot':
      case 'snapshots':
      case 'recording':
      case 'recordings':
        viewModifiers.push(...(await executeMediaQuery(mediaType)));
        break;
      case 'folder':
      case 'folders':
        viewModifiers.push(...(await executeFolderQuery()));
        break;
    }

    viewModifiers.push(...this._getTimelineWindowViewModifier(view));
    viewModifiers.push(
      ...this._getSeekTimeModifier(queryExecutorOptions?.selectResult?.time?.time),
    );
    return viewModifiers;
  }

  protected _getTimelineWindowViewModifier(view: View): ViewModifier[] {
    if (view.is('live')) {
      // For live views, always force the timeline to now, regardless of
      // presence or not of events.
      const now = new Date();
      const liveConfig = this._api.getConfigManager().getConfig()?.live;

      /* istanbul ignore if: this if branch cannot be reached as if the config is
         empty this function is never called -- @preserve */
      if (!liveConfig) {
        return [];
      }

      return [
        new MergeContextViewModifier({
          // Force the window to start at the most recent time, not
          // necessarily when the most recent event/recording was:
          // https://github.com/dermotduffy/advanced-camera-card/issues/1301
          timeline: {
            window: {
              start: sub(now, {
                seconds: liveConfig.controls.timeline.window_seconds,
              }),
              end: now,
            },
          },
        }),
      ];
    } else {
      // For non-live views stick to default timeline behavior (will select and
      // scroll to event).
      return [new RemoveContextPropertyViewModifier('timeline', 'window')];
    }
  }

  protected _getSeekTimeModifier(time?: Date): ViewModifier[] {
    if (time) {
      return [
        new MergeContextViewModifier({
          mediaViewer: {
            seek: time,
          },
        }),
      ];
    } else {
      return [new RemoveContextPropertyViewModifier('mediaViewer', 'seek')];
    }
  }
}



================================================
FILE: src/card-controller/view/modifiers/index.ts
================================================
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export const applyViewModifiers = (
  view: View,
  modifiers?: ViewModifier[] | null,
): void => {
  modifiers?.forEach((modifier) => modifier.modify(view));
};



================================================
FILE: src/card-controller/view/modifiers/merge-context.ts
================================================
import { ViewContext } from 'view';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export class MergeContextViewModifier implements ViewModifier {
  protected _context?: ViewContext | null;

  constructor(context?: ViewContext | null) {
    this._context = context;
  }

  public modify(view: View): void {
    view.mergeInContext(this._context);
  }
}



================================================
FILE: src/card-controller/view/modifiers/remove-context-property.ts
================================================
import { ViewContext } from 'view';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export class RemoveContextPropertyViewModifier implements ViewModifier {
  protected _key: keyof ViewContext;
  protected _property: PropertyKey;

  constructor(key: keyof ViewContext, property: PropertyKey) {
    this._key = key;
    this._property = property;
  }

  public modify(view: View): void {
    view.removeContextProperty(this._key, this._property);
  }
}



================================================
FILE: src/card-controller/view/modifiers/remove-context.ts
================================================
import { ViewContext } from 'view';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export class RemoveContextViewModifier implements ViewModifier {
  protected _keys: (keyof ViewContext)[];

  constructor(keys: (keyof ViewContext)[]) {
    this._keys = keys;
  }

  public modify(view: View): void {
    this._keys.forEach((key) => view.removeContext(key));
  }
}



================================================
FILE: src/card-controller/view/modifiers/set-query.ts
================================================
import { Query } from '../../../view/query';
import { QueryResults } from '../../../view/query-results';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export class SetQueryViewModifier implements ViewModifier {
  protected _query?: Query | null;
  protected _queryResults?: QueryResults | null;

  constructor(options?: { query?: Query | null; queryResults?: QueryResults | null }) {
    this._query = options?.query;
    this._queryResults = options?.queryResults;
  }

  public modify(view: View): void {
    if (this._query !== undefined) {
      view.query = this._query;
    }
    if (this._queryResults !== undefined) {
      view.queryResults = this._queryResults;
    }
  }
}



================================================
FILE: src/card-controller/view/modifiers/substream-off.ts
================================================
import { removeSubstream } from '../../../utils/substream';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export class SubstreamOffViewModifier implements ViewModifier {
  public modify(view: View): void {
    removeSubstream(view);
  }
}



================================================
FILE: src/card-controller/view/modifiers/substream-on.ts
================================================
import { CameraManager } from '../../../camera-manager/manager';
import { getStreamCameraID, setSubstream } from '../../../utils/substream';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

interface SubstreamOnViewModifierAPI {
  getCameraManager(): CameraManager;
}

export class SubstreamOnViewModifier implements ViewModifier {
  protected _api: SubstreamOnViewModifierAPI;

  constructor(api: SubstreamOnViewModifierAPI) {
    this._api = api;
  }

  public modify(view: View): void {
    const dependencies = [
      ...this._api
        .getCameraManager()
        .getStore()
        .getAllDependentCameras(view.camera, 'substream'),
    ];

    if (dependencies.length <= 1) {
      return;
    }

    const currentOverride = getStreamCameraID(view);
    const currentIndex = dependencies.indexOf(currentOverride);
    const newIndex = currentIndex < 0 ? 0 : (currentIndex + 1) % dependencies.length;

    setSubstream(view, dependencies[newIndex]);
  }
}



================================================
FILE: src/card-controller/view/modifiers/substream-select.ts
================================================
import { setSubstream } from '../../../utils/substream';
import { View } from '../../../view/view';
import { ViewModifier } from '../types';

export class SubstreamSelectViewModifier implements ViewModifier {
  protected _substreamID: string;

  constructor(substreamID: string) {
    this._substreamID = substreamID;
  }

  public modify(view: View): void {
    setSubstream(view, this._substreamID);
  }
}



================================================
FILE: src/components/carousel.ts
================================================
import { CreatePluginType, LoosePluginType } from 'embla-carousel/components/Plugins';
import {
  CSSResultGroup,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { Ref, createRef, ref } from 'lit/directives/ref.js';
import { TransitionEffect } from '../config/schema/common/transition-effect';
import carouselStyle from '../scss/carousel.scss';
import {
  CarouselController,
  CarouselDirection,
} from '../utils/embla/carousel-controller';
import { getTextDirection } from '../utils/text-direction';

export type EmblaCarouselPlugins = CreatePluginType<
  LoosePluginType,
  Record<string, unknown>
>[];

@customElement('advanced-camera-card-carousel')
export class AdvancedCameraCardCarousel extends LitElement {
  @property({ attribute: true, reflect: true })
  public direction: CarouselDirection = 'horizontal';

  @property({ attribute: true })
  public transitionEffect?: TransitionEffect;

  @property({ attribute: false })
  public loop?: boolean;

  @property({ attribute: false })
  public dragFree?: boolean;

  @property({ attribute: false })
  public dragEnabled = true;

  @property({ attribute: false })
  public plugins?: EmblaCarouselPlugins;

  @property({ attribute: false })
  public selected = 0;

  protected _refParent: Ref<HTMLSlotElement> = createRef();
  protected _refRoot: Ref<HTMLElement> = createRef();
  protected _carousel: CarouselController | null = null;

  connectedCallback(): void {
    super.connectedCallback();

    // Guarantee recreation of carousel if the component is reconnected.
    this.requestUpdate();
  }

  disconnectedCallback(): void {
    // Destroy the carousel when the component is disconnected, which forces the
    // plugins (which may have registered event handlers) to also be destroyed.
    // The carousel will automatically reconstruct if the component is re-rendered.
    this._carousel?.destroy();
    this._carousel = null;
    super.disconnectedCallback();
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('direction')) {
      this.setAttribute('direction', this.direction);
    }

    const destroyProperties = [
      'direction',
      'dragEnabled',
      'dragFree',
      'loop',
      'plugins',
      'transitionEffect',
    ] as const;
    if (destroyProperties.some((prop) => changedProps.has(prop))) {
      this._carousel?.destroy();
      this._carousel = null;
    }
  }

  protected render(): TemplateResult | void {
    return html` <div class="embla">
      <slot name="left"></slot>
      <div ${ref(this._refRoot)} class="embla__viewport">
        <div class="embla__container">
          <slot ${ref(this._refParent)}></slot>
        </div>
      </div>
      <slot name="right"></slot>
    </div>`;
  }

  protected updated(changedProps: PropertyValues): void {
    if (
      !this._carousel &&
      this._refRoot.value &&
      this._refParent.value &&
      // Never construct a carousel if the node is not connected. There can be a
      // race condition between the Lit update lifecycle, and the
      // disconnect/connect callbacks, causing a carousel to potentially be
      // created after the node is disconnected. This could cause a dangling
      // carousel and hold open connections that should have been closed.
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1992
      this.isConnected
    ) {
      this._carousel = new CarouselController(
        this._refRoot.value,
        this._refParent.value,
        {
          direction: this.direction,
          dragEnabled: this.dragEnabled,
          dragFree: this.dragFree,
          startIndex: this.selected,
          transitionEffect: this.transitionEffect,
          loop: this.loop,
          plugins: this.plugins,
          textDirection: getTextDirection(this),
        },
      );
    } else if (changedProps.has('selected')) {
      this._carousel?.selectSlide(this.selected);
    }
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(carouselStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-carousel': AdvancedCameraCardCarousel;
  }
}



================================================
FILE: src/components/date-picker.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { localize } from '../localize/localize';
import datePickerStyle from '../scss/date-picker.scss';
import { stopEventFromActivatingCardWideActions } from '../utils/action';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event';
import './icon';

export interface DatePickerEvent {
  date: Date | null;
}

@customElement('advanced-camera-card-date-picker')
export class AdvancedCameraCardDatePicker extends LitElement {
  @property({ attribute: false })
  public icon?: string;

  protected _refInput: Ref<HTMLInputElement> = createRef();

  get value(): Date | null {
    return this._refInput.value?.value ? new Date(this._refInput.value.value) : null;
  }

  public reset(): void {
    if (this._refInput.value) {
      this._refInput.value.value = '';
    }
  }

  protected render(): TemplateResult {
    const changed = () => {
      const value = this._refInput.value?.value;

      fireAdvancedCameraCardEvent<DatePickerEvent>(this, 'date-picker:change', {
        date: value ? new Date(value) : null,
      });
    };

    return html`<input
        aria-label="${localize('timeline.select_date')}"
        title="${localize('timeline.select_date')}"
        ${ref(this._refInput)}
        type="datetime-local"
        @input=${() => changed()}
        @change=${() => changed()}
      />
      <advanced-camera-card-icon
        aria-label="${localize('timeline.select_date')}"
        title="${localize('timeline.select_date')}"
        .icon=${{ icon: this.icon ?? `mdi:calendar-search` }}
        @click=${(ev: Event) => {
          stopEventFromActivatingCardWideActions(ev);
          this._refInput.value?.showPicker();
        }}
      >
      </advanced-camera-card-icon>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(datePickerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-date-picker': AdvancedCameraCardDatePicker;
  }
}



================================================
FILE: src/components/diagnostics.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { until } from 'lit/directives/until.js';
import { RawAdvancedCameraCardConfig } from '../config/types';
import { DeviceRegistryManager } from '../ha/registry/device';
import { HomeAssistant } from '../ha/types';
import { localize } from '../localize/localize';
import basicBlockStyle from '../scss/basic-block.scss';
import { getDiagnostics } from '../utils/diagnostics';
import { renderMessage } from './message';

@customElement('advanced-camera-card-diagnostics')
export class AdvancedCameraCardDiagnostics extends LitElement {
  // Not a reactive property to avoid multiple diagnostics fetches.
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public deviceRegistryManager?: DeviceRegistryManager;

  @property({ attribute: false })
  public rawConfig?: RawAdvancedCameraCardConfig;

  protected async _renderDiagnostics(): Promise<TemplateResult> {
    const diagnostics = await getDiagnostics(
      this.hass,
      this.deviceRegistryManager,
      this.rawConfig,
    );

    return renderMessage({
      message: localize('error.diagnostics'),
      icon: 'mdi:cogs',
      context: diagnostics,
    });
  }

  protected render(): TemplateResult | void {
    return html`${until(
      this._renderDiagnostics(),
      renderMessage({
        message: localize('error.fetching_diagnostics'),
        dotdotdot: true,
        icon: 'mdi:cogs',
      }),
    )}`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(basicBlockStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-diagnostics': AdvancedCameraCardDiagnostics;
  }
}



================================================
FILE: src/components/drawer.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import 'side-drawer';
import { SideDrawer } from 'side-drawer';
import drawerInjectStyle from '../scss/drawer-inject.scss';
import drawerStyle from '../scss/drawer.scss';
import { stopEventFromActivatingCardWideActions } from '../utils/action';
import { getChildrenFromElement, isHoverableDevice } from '../utils/basic';
import './icon';

export interface DrawerIcons {
  open?: string;
  closed?: string;
}

@customElement('advanced-camera-card-drawer')
export class AdvancedCameraCardDrawer extends LitElement {
  @property({ attribute: true, reflect: true })
  public location: 'left' | 'right' = 'left';

  @property({ attribute: true, reflect: true, type: Boolean })
  public control = true;

  @property({ type: Boolean, reflect: true, attribute: true })
  public open = false;

  @property({ attribute: false })
  public icons?: DrawerIcons;

  // The 'empty' attribute is used in the styling to change the drawer
  // visibility and that of all descendants if there is no content. Styling is
  // used rather than display or hidden in order to ensure the contents continue
  // to have a measurable size.
  @property({ type: Boolean, reflect: true, attribute: true })
  public empty = true;

  protected _refDrawer: Ref<HTMLElement & { open: boolean }> = createRef();
  protected _refSlot: Ref<HTMLSlotElement> = createRef();

  protected _resizeObserver = new ResizeObserver(() => this._hideDrawerIfNecessary());

  protected readonly _isHoverableDevice = isHoverableDevice();

  /**
   * Called on the first update.
   * @param changedProps The changed properties.
   */
  protected firstUpdated(changedProps: PropertyValues): void {
    super.firstUpdated(changedProps);

    // The `side-drawer` component (and the material drawer for that matter)
    // only do fixed drawers (i.e. a drawer for the whole viewport). Hackily
    // override the style to customize the drawer to be absolute within the div.
    const style = document.createElement('style');
    style.innerHTML = drawerInjectStyle;
    this._refDrawer.value?.shadowRoot?.appendChild(style);
  }

  protected _slotChanged(): void {
    const children = this._refSlot.value
      ? getChildrenFromElement(this._refSlot.value)
      : [];

    // Watch all slot children for size changes.
    this._resizeObserver.disconnect();
    for (const child of children) {
      this._resizeObserver.observe(child);
    }
    this._hideDrawerIfNecessary();
  }

  protected _hideDrawerIfNecessary(): void {
    if (!this._refDrawer.value) {
      return;
    }

    const children = this._refSlot.value
      ? getChildrenFromElement(this._refSlot.value)
      : null;
    this.empty =
      !children ||
      !children.length ||
      children.every((element) => {
        const box = element.getBoundingClientRect();
        return !box.width || !box.height;
      });
  }

  protected render(): TemplateResult {
    return html`
      <side-drawer
        ${ref(this._refDrawer)}
        location="${this.location}"
        ?open=${this.open}
        @mouseleave=${() => {
          this.open = false;
        }}
      >
        ${this.control
          ? html`
              <div
                class="control-surround"
                @click=${(ev: Event) => {
                  stopEventFromActivatingCardWideActions(ev);
                  this.open = !this.open;
                }}
              >
                <advanced-camera-card-icon
                  class="control"
                  .icon="${{
                    icon: this.open
                      ? this.icons?.open ?? 'mdi:menu-open'
                      : this.icons?.closed ?? 'mdi:menu',
                  }}"
                  @mouseenter=${() => {
                    // Only open the drawer on mousenter when the device
                    // supports hover (otherwise iOS may end up passing on
                    // subsequent click events to a different element, see:
                    // https://github.com/dermotduffy/advanced-camera-card/issues/801
                    if (this._isHoverableDevice && !this.open) {
                      this.open = true;
                    }
                  }}
                >
                </advanced-camera-card-icon>
              </div>
            `
          : ''}
        <slot ${ref(this._refSlot)} @slotchange=${() => this._slotChanged()}></slot>
      </side-drawer>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(drawerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-drawer': AdvancedCameraCardDrawer;
    'side-drawer': SideDrawer;
  }
}



================================================
FILE: src/components/elements.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { dispatchAdvancedCameraCardErrorEvent } from '../components-lib/message/dispatch.js';
import { ConditionsManager } from '../conditions/conditions-manager.js';
import { getConditionStateManagerViaEvent } from '../conditions/state-manager-via-event.js';
import {
  StatusBarIcon,
  StatusBarImage,
  StatusBarItem,
  StatusBarString,
} from '../config/schema/actions/types.js';
import { MenuIcon } from '../config/schema/elements/custom/menu/icon.js';
import { MenuStateIcon } from '../config/schema/elements/custom/menu/state-icon.js';
import { MenuSubmenuSelect } from '../config/schema/elements/custom/menu/submenu-select.js';
import { MenuSubmenu } from '../config/schema/elements/custom/menu/submenu.js';
import { MenuItem } from '../config/schema/elements/custom/menu/types.js';
import {
  AdvancedCameraCardConditional,
  PictureElements,
} from '../config/schema/elements/types.js';
import { HomeAssistant } from '../ha/types.js';
import { localize } from '../localize/localize.js';
import elementsStyle from '../scss/elements.scss';
import { AdvancedCameraCardError } from '../types.js';
import { errorToConsole } from '../utils/basic.js';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event.js';

/* A note on picture element rendering:
 *
 * To avoid needing to deal with the rendering of all the picture elements
 * ourselves, instead the card relies on a stock conditional element (with no
 * conditions) to render elements (this._root). This has a few advantages:
 *
 * - Does not depend on (much of!) an internal API -- conditional picture
 *   elements are unlikely to go away or change.
 * - Forces usage of elements that HA understands. If the rendering is done
 *   directly, it is (ask me how I know!) very tempting to render things in such
 *   a way that a nested conditional element would not be able to render, i.e.
 *   the custom rendering logic would only apply at the first level.
 */

/* A note on custom elements:
 *
 * The native HA support for custom elements is used for the menu-icon and
 * menu-state-icon elements. This ensures multi-nested conditionals will work
 * correctly. These custom elements 'render' by firing events that are caught by
 * the card to call for inclusion/exclusion of the menu icon in question.
 *
 * One major complexity here is that the top <advanced-camera-card-elements> element
 * will not necessarily know when a menu icon is no longer rendered because of a
 * conditional that no-longer evaluates to true. As such, it cannot know when to
 * signal for the menu icon removal. Furthermore, the menu icon element itself
 * will only know it's been removed _after_ it's been disconnected from the DOM,
 * so normal event propagation at that point will not work. Instead, we must
 * catch the menu icon _addition_ and register the eventhandler for the removal
 * directly on the child (which will have no parent at time of calling). That
 * then triggers <advanced-camera-card-elements> to re-dispatch a removal event for
 * upper layers to handle correctly.
 */

interface HuiConditionalElement extends HTMLElement {
  hass: HomeAssistant;
  setConfig(config: unknown): void;
}

// A small wrapper around a HA conditional element used to render a set of
// picture elements.
@customElement('advanced-camera-card-elements-core')
export class AdvancedCameraCardElementsCore extends LitElement {
  @property({ attribute: false })
  public elements?: PictureElements;

  protected _root: HuiConditionalElement | null = null;

  @property({ attribute: false })
  public hass?: HomeAssistant;

  /**
   * Create a transparent render root.
   */
  createRenderRoot(): LitElement {
    return this;
  }

  /**
   * Create the root node for our picture elements.
   * @returns The newly created root.
   */
  protected _createRoot(): HuiConditionalElement {
    const elementConstructor = customElements.get('hui-conditional-element');
    if (!elementConstructor || !this.hass) {
      throw new Error(localize('error.could_not_render_elements'));
    }

    const element = new elementConstructor() as HuiConditionalElement;
    element.hass = this.hass;
    const config = {
      type: 'conditional',
      conditions: [],
      elements: this.elements,
    };
    try {
      element.setConfig(config);
    } catch (e) {
      errorToConsole(e as Error, console.error);
      throw new AdvancedCameraCardError(localize('error.invalid_elements_config'));
    }
    return element;
  }

  /**
   * Create the root as necessary prior to rendering.
   */
  protected willUpdate(changedProps: PropertyValues): void {
    try {
      // The root is only created once per elements configuration change, to
      // avoid the elements being continually re-created & destroyed (for some
      // elements, e.g. image, recreation causes a flicker).
      if (this.elements && (!this._root || changedProps.has('elements'))) {
        this._root = this._createRoot();
      }
    } catch (e) {
      return dispatchAdvancedCameraCardErrorEvent(this, e as AdvancedCameraCardError);
    }
  }

  /**
   * Render the elements.
   * @returns A rendered template or void.
   */
  protected render(): TemplateResult | void {
    return html`${this._root || ''}`;
  }

  protected updated(): void {
    if (this.hass && this._root) {
      // Always update hass. It is used as a trigger to re-evaluate conditions
      // down the chain, see the note on AdvancedCameraCardElementsConditional.
      this._root.hass = this.hass;
    }
  }
}

/**
 * The master <advanced-camera-card-elements> class, handles event listeners and styles.
 */
@customElement('advanced-camera-card-elements')
export class AdvancedCameraCardElements extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public elements: PictureElements;

  protected _addHandler(
    target: EventTarget,
    eventName: string,
    handler: (ev: Event) => void,
  ) {
    // Ensure listener is only attached 1 time by removing it first.
    target.removeEventListener(eventName, handler);
    target.addEventListener(eventName, handler);
  }

  protected _menuRemoveHandler = (ev: Event): void => {
    // Re-dispatch event from this element (instead of the disconnected one, as
    // there is no parent of the disconnected element).
    fireAdvancedCameraCardEvent<MenuItem>(
      this,
      'menu:remove',
      (ev as CustomEvent).detail,
    );
  };

  protected _statusBarRemoveHandler = (ev: Event): void => {
    // Re-dispatch event from this element (instead of the disconnected one, as
    // there is no parent of the disconnected element).
    fireAdvancedCameraCardEvent<StatusBarItem>(
      this,
      'status-bar:remove',
      (ev as CustomEvent).detail,
    );
  };

  protected _menuAddHandler = (ev: Event): void => {
    ev = ev as CustomEvent<MenuItem>;
    const path = ev.composedPath();
    if (!path.length) {
      return;
    }
    this._addHandler(
      path[0],
      'advanced-camera-card:menu:remove',
      this._menuRemoveHandler,
    );
  };

  protected _statusBarAddHandler = (ev: Event): void => {
    ev = ev as CustomEvent<MenuItem>;
    const path = ev.composedPath();
    if (!path.length) {
      return;
    }
    this._addHandler(
      path[0],
      'advanced-camera-card:status-bar:add',
      this._statusBarRemoveHandler,
    );
  };

  connectedCallback(): void {
    super.connectedCallback();

    // Catch icons being added to the menu or status-bar (so their removal can
    // be subsequently handled).
    this.addEventListener('advanced-camera-card:menu:add', this._menuAddHandler);
    this.addEventListener(
      'advanced-camera-card:status-bar:add',
      this._statusBarAddHandler,
    );
  }

  disconnectedCallback(): void {
    this.removeEventListener('advanced-camera-card:menu:add', this._menuAddHandler);
    this.addEventListener(
      'advanced-camera-card:status-bar:add',
      this._statusBarAddHandler,
    );
    super.disconnectedCallback();
  }

  protected render(): TemplateResult {
    return html`<advanced-camera-card-elements-core
      .hass=${this.hass}
      .elements=${this.elements}
    >
    </advanced-camera-card-elements-core>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(elementsStyle);
  }
}

/**
 * An element that can render others based on card state (e.g. only show
 * overlays in particular views). This is the Advanced Camera Card equivalent to
 * the HA conditional card.
 */
@customElement('advanced-camera-card-conditional')
export class AdvancedCameraCardElementsConditional extends LitElement {
  protected _config?: AdvancedCameraCardConditional;
  protected _conditionManager: ConditionsManager | null = null;

  // A note on hass as an update mechanism:
  //
  // Every set of hass is treated as a reason to re-evaluate. Given that this
  // node may be buried down the DOM (as a descendent of non-Advanced Camera
  // Card elements), the hass object is used as the (only) trigger for condition
  // re-fetch even if hass itself has not changed.
  @property({ attribute: false, hasChanged: () => true })
  public hass?: HomeAssistant;

  /**
   * Set the card configuration.
   * @param config The card configuration.
   */
  public setConfig(config: AdvancedCameraCardConditional): void {
    this._config = config;
    this._createConditionManager();
  }

  /**
   * Create a root into which to render. This card is "transparent".
   * @returns
   */
  createRenderRoot(): LitElement {
    return this;
  }

  /**
   * Connected callback.
   */
  connectedCallback(): void {
    super.connectedCallback();

    // HA will automatically attach the 'element' class to picture elements. As
    // this is a transparent 'conditional' element (just like the stock HA
    // 'conditional' element), it should not have positioning.
    this.className = '';

    this._createConditionManager();
  }

  disconnectedCallback(): void {
    this._conditionManager?.destroy();
    super.disconnectedCallback();
  }

  protected _createConditionManager(): void {
    const conditionStateManager = getConditionStateManagerViaEvent(this);
    if (!this._config || !conditionStateManager) {
      return;
    }
    this._conditionManager?.destroy();
    this._conditionManager = new ConditionsManager(
      this._config.conditions,
      conditionStateManager,
    );
    this._conditionManager.addListener(() => this.requestUpdate());
  }

  /**
   * Render the card.
   */
  protected render(): TemplateResult | void {
    if (this._conditionManager?.getEvaluation()?.result) {
      return html` <advanced-camera-card-elements-core
        .hass=${this.hass}
        .elements=${this._config?.elements}
      >
      </advanced-camera-card-elements-core>`;
    }
  }
}

// A base class for rendering menu icons / menu state icons.
export class AdvancedCameraCardElementsBaseItem<ConfigType> extends LitElement {
  protected _eventCategory: string;

  constructor(eventCategory: string) {
    super();
    this._eventCategory = eventCategory;
  }

  @state()
  protected _config: ConfigType | null = null;

  public setConfig(config: ConfigType): void {
    this._config = config;
  }

  connectedCallback(): void {
    super.connectedCallback();
    if (this._config) {
      fireAdvancedCameraCardEvent<ConfigType>(
        this,
        `${this._eventCategory}:add`,
        this._config,
      );
    }
  }

  disconnectedCallback(): void {
    if (this._config) {
      fireAdvancedCameraCardEvent<ConfigType>(
        this,
        `${this._eventCategory}:remove`,
        this._config,
      );
    }
    super.disconnectedCallback();
  }
}

export class AdvancedCameraCardElementsBaseMenuItem<
  ConfigType,
> extends AdvancedCameraCardElementsBaseItem<ConfigType> {
  constructor() {
    super('menu');
  }
}

@customElement('advanced-camera-card-menu-icon')
export class AdvancedCameraCardElementsMenuIcon extends AdvancedCameraCardElementsBaseMenuItem<MenuIcon> {}

@customElement('advanced-camera-card-menu-state-icon')
export class AdvancedCameraCardElementsMenuStateIcon extends AdvancedCameraCardElementsBaseMenuItem<MenuStateIcon> {}

@customElement('advanced-camera-card-menu-submenu')
export class AdvancedCameraCardElementsMenuSubmenu extends AdvancedCameraCardElementsBaseMenuItem<MenuSubmenu> {}

@customElement('advanced-camera-card-menu-submenu-select')
export class AdvancedCameraCardElementsMenuSubmenuSelect extends AdvancedCameraCardElementsBaseMenuItem<MenuSubmenuSelect> {}

export class AdvancedCameraCardElementsBaseStatusBarItem<
  ConfigType,
> extends AdvancedCameraCardElementsBaseItem<ConfigType> {
  constructor() {
    super('status-bar');
  }
}

@customElement('advanced-camera-card-status-bar-icon')
export class AdvancedCameraCardElementsStatusBarIcon extends AdvancedCameraCardElementsBaseStatusBarItem<StatusBarIcon> {}

@customElement('advanced-camera-card-status-bar-image')
export class AdvancedCameraCardElementsStatusBarImage extends AdvancedCameraCardElementsBaseStatusBarItem<StatusBarImage> {}

@customElement('advanced-camera-card-status-bar-string')
export class AdvancedCameraCardElementsStatusBarString extends AdvancedCameraCardElementsBaseStatusBarItem<StatusBarString> {}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-conditional': AdvancedCameraCardElementsConditional;
    'advanced-camera-card-elements': AdvancedCameraCardElements;
    'advanced-camera-card-elements-core': AdvancedCameraCardElementsCore;

    'advanced-camera-card-menu-icon': AdvancedCameraCardElementsMenuIcon;
    'advanced-camera-card-menu-state-icon': AdvancedCameraCardElementsMenuStateIcon;
    'advanced-camera-card-menu-submenu': AdvancedCameraCardElementsMenuSubmenu;
    'advanced-camera-card-menu-submenu-select': AdvancedCameraCardElementsMenuSubmenuSelect;

    'advanced-camera-card-status-bar-icon': AdvancedCameraCardElementsStatusBarIcon;
    'advanced-camera-card-status-bar-image': AdvancedCameraCardElementsStatusBarImage;
    'advanced-camera-card-status-bar-string': AdvancedCameraCardElementsStatusBarString;
  }
}



================================================
FILE: src/components/icon.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { IconController } from '../components-lib/icon-controller';
import { HomeAssistant } from '../ha/types';
import iconStyle from '../scss/icon.scss';
import { Icon } from '../types';

@customElement('advanced-camera-card-icon')
export class AdvancedCameraCardIcon extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public icon?: Icon;

  // Note: This attribute will allow non-active entity state styles (e.g. 'off',
  // 'unavailable') to be overriden from outside the icon itself. This is useful
  // in the menu / submenus where we want icons to follow menu theming, unless
  // they are 'active'. This attribute is not used in code, but matched in
  // icon.scss .
  @property({ attribute: 'allow-override-non-active-styles', type: Boolean })
  public allowOverrideNonActiveStyles = false;

  private _controller = new IconController();
  private _svg: HTMLElement | null = null;

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('icon')) {
      const customIcon = this._controller.getCustomIcon(this.icon);
      if (customIcon) {
        const svgElement = document.createElement('svg');
        svgElement.innerHTML = customIcon;
        this._svg = svgElement;
      } else {
        this._svg = null;
      }
    }
  }

  protected render(): TemplateResult {
    if (this._svg) {
      // Use SVG objects (rather than <img>) to ensure styling applies
      // correctly.
      return html`${this._svg}`;
    }
    if (this.hass && this.icon?.entity) {
      const stateObj = this._controller.createStateObjectForStateBadge(
        this.hass,
        this.icon.entity,
      );
      if (stateObj) {
        // As a special case, need to pass in a color in order for the state
        // color to be overridden.
        return html`<state-badge
          .color="${this.style.color ?? undefined}"
          .stateColor=${this.icon.stateColor ?? true}
          .hass=${this.hass}
          .stateObj=${stateObj}
          .overrideIcon=${this.icon.icon}
        ></state-badge>`;
      }
    }
    if (this.icon?.icon) {
      return html`<ha-icon icon="${this.icon.icon}"></ha-icon>`;
    }
    if (this.icon?.fallback) {
      return html`<ha-icon icon="${this.icon.fallback}"></ha-icon>`;
    }
    return html``;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(iconStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-icon': AdvancedCameraCardIcon;
  }
}



================================================
FILE: src/components/image-player.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { ImageMediaPlayerController } from '../components-lib/media-player/image';
import imagePlayerStyle from '../scss/image-player.scss';
import {
  MediaPlayer,
  MediaPlayerController,
  MediaPlayerElement,
  MediaTechnology,
} from '../types';
import { dispatchMediaLoadedEvent } from '../utils/media-info';

/**
 * A simple media player to wrap a single static image.
 */
@customElement('advanced-camera-card-image-player')
export class AdvancedCameraCardImagePlayer extends LitElement implements MediaPlayer {
  @property()
  public url?: string;

  @property()
  public technology?: MediaTechnology;

  protected _refImage: Ref<MediaPlayerElement<HTMLImageElement>> = createRef();
  protected _mediaPlayerController = new ImageMediaPlayerController(
    this,
    () => this._refImage.value ?? null,
  );

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    return this._mediaPlayerController;
  }

  protected render(): TemplateResult | void {
    return html`<img
      ${ref(this._refImage)}
      src="${ifDefined(this.url)}"
      @load=${(ev: Event) => {
        dispatchMediaLoadedEvent(this, ev, {
          ...(this._mediaPlayerController && {
            mediaPlayerController: this._mediaPlayerController,
          }),
          technology: [this.technology ?? ('jpg' as const)],
        });
      }}
    />`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(imagePlayerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-image-player': AdvancedCameraCardImagePlayer;
  }
}



================================================
FILE: src/components/image-updating-player.ts
================================================
import { HassEntity } from 'home-assistant-js-websocket';
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { live } from 'lit/directives/live.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { isEqual } from 'lodash-es';
import { CameraManager } from '../camera-manager/manager.js';
import { getCameraEntityFromConfig } from '../camera-manager/utils/camera-entity-from-config.js';
import { CachedValueController } from '../components-lib/cached-value-controller.js';
import { UpdatingImageMediaPlayerController } from '../components-lib/media-player/updating-image.js';
import { CameraConfig } from '../config/schema/cameras.js';
import { ImageMode } from '../config/schema/common/image.js';
import { ImageViewConfig } from '../config/schema/image.js';
import { isHassDifferent } from '../ha/is-hass-different.js';
import { HomeAssistant } from '../ha/types.js';
import defaultImage from '../images/iris-screensaver.jpg';
import { localize } from '../localize/localize.js';
import imageUpdatingPlayerStyle from '../scss/image-updating-player.scss';
import {
  MediaLoadedInfo,
  MediaPlayer,
  MediaPlayerController,
  Message,
} from '../types.js';
import { contentsChanged } from '../utils/basic.js';
import {
  createMediaLoadedInfo,
  dispatchExistingMediaLoadedInfoAsEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
} from '../utils/media-info.js';
import { View } from '../view/view.js';
import { renderMessage } from './message.js';

// See TOKEN_CHANGE_INTERVAL in https://github.com/home-assistant/core/blob/dev/homeassistant/components/camera/__init__.py .
const HASS_REJECTION_CUTOFF_MS = 5 * 60 * 1000;

export const resolveImageMode = (options?: {
  imageConfig?: ImageViewConfig;
  cameraConfig?: CameraConfig;
}): Exclude<ImageMode, 'auto'> => {
  if (!options?.imageConfig?.mode) {
    return 'screensaver';
  } else if (options?.imageConfig?.mode !== 'auto') {
    return options.imageConfig.mode;
  }

  if (options?.imageConfig?.entity) {
    return 'entity';
  } else if (options?.imageConfig?.url) {
    return 'url';
  } else if (getCameraEntityFromConfig(options.cameraConfig)) {
    return 'camera';
  }

  return 'screensaver';
};

/**
 * A media player to wrap a image that updates continuously.
 */
@customElement('advanced-camera-card-image-updating-player')
export class AdvancedCameraCardImageUpdatingPlayer
  extends LitElement
  implements MediaPlayer
{
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public view?: Readonly<View>;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  // Using contentsChanged to ensure overridden configs (e.g. when the
  // 'show_image_during_load' option is true for live views, an overridden
  // config may be used here).
  @property({ attribute: false, hasChanged: contentsChanged })
  public imageConfig?: ImageViewConfig;

  @state()
  protected _message: Message | null = null;

  protected _refImage: Ref<HTMLImageElement> = createRef();

  protected _cachedValueController?: CachedValueController<string>;
  protected _boundVisibilityHandler = this._visibilityHandler.bind(this);

  protected _mediaLoadedInfo: MediaLoadedInfo | null = null;

  protected _mediaPlayerController = new UpdatingImageMediaPlayerController(
    this,
    () => this._refImage.value ?? null,
    () => this._cachedValueController ?? null,
  );

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    return this._mediaPlayerController;
  }

  /**
   * Determine whether the element should be updated.
   * @param changedProps The changed properties if any.
   * @returns `true` if the element should be updated.
   */
  protected shouldUpdate(changedProps: PropertyValues): boolean {
    if (!this.hass || document.visibilityState !== 'visible') {
      return false;
    }

    const relevantEntity = this._getRelevantEntityForMode(
      resolveImageMode({
        imageConfig: this.imageConfig,
        cameraConfig: this.cameraConfig,
      }),
    );

    if (changedProps.has('hass') && changedProps.size == 1 && relevantEntity) {
      if (isHassDifferent(this.hass, changedProps.get('hass'), [relevantEntity])) {
        // If the state of the camera entity has changed, remove the cached
        // value (will be re-calculated in willUpdate). This is important to
        // ensure a changed access token is immediately used.
        this._cachedValueController?.clearValue();
        return true;
      }
      return !this.hasUpdated;
    }
    return true;
  }

  /**
   * Ensure there is a cached value before an update.
   * @param _changedProps The changed properties
   */
  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('imageConfig')) {
      if (this._cachedValueController) {
        this._cachedValueController.removeController();
      }
      if (this.imageConfig) {
        this._cachedValueController = new CachedValueController(
          this,
          this.imageConfig.refresh_seconds,
          this._getImageSource.bind(this),
          () => dispatchMediaPlayEvent(this),
          () => dispatchMediaPauseEvent(this),
        );
      }
    }

    const relevantEntity = this._getRelevantEntityForMode(
      resolveImageMode({
        imageConfig: this.imageConfig,
        cameraConfig: this.cameraConfig,
      }),
    );

    // If the camera or view changed, immediately discard the old value (view to
    // allow pressing of the image button to fetch a fresh image). Likewise, if
    // the state is not acceptable, discard the old value (to allow a stock or
    // backup image to be displayed).
    if (
      changedProps.has('cameraConfig') ||
      changedProps.has('view') ||
      (relevantEntity && !this._getAcceptableState(relevantEntity))
    ) {
      this._cachedValueController?.clearValue();
    }

    if (!this._cachedValueController?.value) {
      this._cachedValueController?.updateValue();
    }

    if (['imageConfig', 'view'].some((prop) => changedProps.has(prop))) {
      this._message = null;
    }
  }

  /**
   * Determine if a given entity is acceptable as the basis for an image render
   * (detects old or disconnected states). Using an old state is problematic as
   * it runs the risk that the JS has an old access token for the camera, and
   * that results in a notification on the HA UI about a failed login. See:
   * https://github.com/dermotduffy/advanced-camera-card/issues/398 .
   * @param entity The entity.
   * @returns The state or null if not acceptable.
   */
  protected _getAcceptableState(entity: string | null): HassEntity | null {
    const state = (entity ? this.hass?.states[entity] : null) ?? null;

    return !!this.hass &&
      this.hass.connected &&
      !!state &&
      Date.now() - Date.parse(state.last_updated) < HASS_REJECTION_CUTOFF_MS
      ? state
      : null;
  }

  /**
   * Component connected callback.
   */
  connectedCallback(): void {
    super.connectedCallback();
    document.addEventListener('visibilitychange', this._boundVisibilityHandler);
    this._cachedValueController?.startTimer();
  }

  /**
   * Component disconnected callback.
   */
  disconnectedCallback(): void {
    this._cachedValueController?.stopTimer();
    this._message = null;
    document.removeEventListener('visibilitychange', this._boundVisibilityHandler);
    super.disconnectedCallback();
  }

  /**
   * Handle document visibility changes.
   */
  protected _visibilityHandler(): void {
    if (!this._refImage.value) {
      return;
    }
    if (document.visibilityState === 'hidden') {
      // Set the image to default when the document is hidden. This is to avoid
      // some browsers (e.g. Firefox) eagerly re-loading the old image when the
      // document regains visibility -- for some images (e.g. camera mode) the
      // image may be using an old-expired token and re-use prior to
      // re-generation of a new URL would generate an unauthorized request
      // (401), see:
      // https://github.com/dermotduffy/advanced-camera-card/issues/398
      this._cachedValueController?.stopTimer();
      this._cachedValueController?.clearValue();
      this._forceSafeImage();
    } else {
      // If the document is freshly re-visible, immediately re-render it to
      // restore the image src. If the HASS object is old (i.e. browser tab was
      // inactive for some time) this update request may be (correctly)
      // rejected.
      this._cachedValueController?.startTimer();
      this.requestUpdate();
    }
  }

  /**
   * Build a working absolute image URL that the browser will not cache.
   * @param url An input URL (may be relative to document origin)
   * @returns A new URL as a string (absolute, will not be browser cached).
   */
  protected _buildImageURL(url: URL): string {
    url.searchParams.append('_t', String(Date.now()));
    return url.toString();
  }

  protected _addQueryParametersToURL(url: URL, parameters?: string): URL {
    if (parameters) {
      const searchParams = new URLSearchParams(parameters);
      for (const [key, value] of searchParams.entries()) {
        url.searchParams.append(key, value);
      }
    }
    return url;
  }

  protected _getRelevantEntityForMode(mode: Exclude<ImageMode, 'auto'>): string | null {
    return mode === 'camera'
      ? getCameraEntityFromConfig(this.cameraConfig)
      : mode === 'entity'
        ? this.imageConfig?.entity ?? null
        : null;
  }

  protected _getImageSource(): string {
    const mode = resolveImageMode({
      imageConfig: this.imageConfig,
      cameraConfig: this.cameraConfig,
    });

    if (this.hass && mode === 'camera') {
      const state = this._getAcceptableState(
        getCameraEntityFromConfig(this.cameraConfig),
      );
      if (state?.attributes.entity_picture) {
        const urlObj = new URL(state.attributes.entity_picture, document.baseURI);
        this._addQueryParametersToURL(urlObj, this.imageConfig?.entity_parameters);
        return this._buildImageURL(urlObj);
      }
    }

    if (this.hass && mode === 'entity' && this.imageConfig?.entity) {
      const state = this._getAcceptableState(this.imageConfig?.entity);
      if (state?.attributes.entity_picture) {
        const urlObj = new URL(state.attributes.entity_picture, document.baseURI);
        this._addQueryParametersToURL(urlObj, this.imageConfig?.entity_parameters);
        return this._buildImageURL(urlObj);
      }
    }

    if (mode === 'url' && this.imageConfig?.url) {
      return this._buildImageURL(new URL(this.imageConfig.url, document.baseURI));
    }

    return defaultImage;
  }

  /**
   * Force the img element to a safe image.
   */
  protected _forceSafeImage(stockOnly?: boolean): void {
    if (this._refImage.value) {
      this._refImage.value.src =
        !stockOnly && this.imageConfig?.url ? this.imageConfig.url : defaultImage;
    }
  }

  protected render(): TemplateResult | void {
    if (this._message) {
      return renderMessage(this._message);
    }

    const src = this._cachedValueController?.value;
    // Note the use of live() below to ensure the update will restore the image
    // src if it's been changed via _forceSafeImage().
    return src
      ? html`
          <img
            ${ref(this._refImage)}
            src=${live(src)}
            @load=${(ev: Event) => {
              const mediaLoadedInfo = createMediaLoadedInfo(ev, {
                mediaPlayerController: this._mediaPlayerController,
                capabilities: {
                  supportsPause: !!this.imageConfig?.refresh_seconds,
                },
              });
              // Avoid the media being reported as repeatedly loading unless the
              // media info changes.
              if (mediaLoadedInfo && !isEqual(this._mediaLoadedInfo, mediaLoadedInfo)) {
                this._mediaLoadedInfo = mediaLoadedInfo;
                dispatchExistingMediaLoadedInfoAsEvent(this, mediaLoadedInfo);
              }
            }}
            @error=${() => {
              const mode = resolveImageMode({
                imageConfig: this.imageConfig,
                cameraConfig: this.cameraConfig,
              });
              if (mode === 'camera' || mode === 'entity') {
                // In camera or entity mode, the user has likely not made an
                // error, but HA may be unavailble, so show the stock image.
                // Don't let the URL override the stock image in this case, as
                // this could create an error loop if that URL subsequently
                // failed to load.
                this._forceSafeImage(true);
              } else if (mode === 'url') {
                // In url mode, the user likely specified a URL that cannot be
                // resolved. Show an error message.
                this._message = {
                  type: 'error',
                  message: localize('error.image_load_error'),
                  context: this.imageConfig,
                };
              }
            }}
          />
        `
      : html``;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(imageUpdatingPlayerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-image-updating-player': AdvancedCameraCardImageUpdatingPlayer;
  }
}



================================================
FILE: src/components/image.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { guard } from 'lit/directives/guard.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { CameraManager } from '../camera-manager/manager';
import { ViewManagerEpoch } from '../card-controller/view/types';
import { ZoomSettingsObserved } from '../components-lib/zoom/types';
import { handleZoomSettingsObservedEvent } from '../components-lib/zoom/zoom-view-context';
import { CameraConfig } from '../config/schema/cameras';
import { ImageViewConfig } from '../config/schema/image';
import { IMAGE_VIEW_ZOOM_TARGET_SENTINEL } from '../const';
import { HomeAssistant } from '../ha/types';
import imageStyle from '../scss/image.scss';
import { MediaPlayer, MediaPlayerController, MediaPlayerElement } from '../types.js';
import { aspectRatioToString } from '../utils/basic';
import { updateElementStyleFromMediaLayoutConfig } from '../utils/media-layout.js';
import './image-updating-player';
import { resolveImageMode } from './image-updating-player';
import './zoomer.js';

@customElement('advanced-camera-card-image')
export class AdvancedCameraCardImage extends LitElement implements MediaPlayer {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public imageConfig?: ImageViewConfig;

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    await this.updateComplete;
    return (await this._refImage.value?.getMediaPlayerController()) ?? null;
  }

  protected _refImage: Ref<MediaPlayerElement> = createRef();

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('cameraConfig') || changedProps.has('imageConfig')) {
      if (
        resolveImageMode({
          imageConfig: this.imageConfig,
          cameraConfig: this.cameraConfig,
        }) === 'camera'
      ) {
        updateElementStyleFromMediaLayoutConfig(
          this,
          this.cameraConfig?.dimensions?.layout,
        );
        this.style.aspectRatio = aspectRatioToString({
          ratio: this.cameraConfig?.dimensions?.aspect_ratio,
        });
      } else {
        updateElementStyleFromMediaLayoutConfig(this);
        this.style.removeProperty('aspect-ratio');
      }
    }
  }

  protected _useZoomIfRequired(template: TemplateResult): TemplateResult {
    const zoomTarget = IMAGE_VIEW_ZOOM_TARGET_SENTINEL;
    const view = this.viewManagerEpoch?.manager.getView();
    const mode = resolveImageMode({
      imageConfig: this.imageConfig,
      cameraConfig: this.cameraConfig,
    });

    return this.imageConfig?.zoomable
      ? html` <advanced-camera-card-zoomer
          .defaultSettings=${guard(
            [this.imageConfig, this.cameraConfig?.dimensions?.layout],
            () =>
              mode === 'camera' && this.cameraConfig?.dimensions?.layout
                ? {
                    pan: this.cameraConfig.dimensions.layout.pan,
                    zoom: this.cameraConfig.dimensions.layout.zoom,
                  }
                : undefined,
          )}
          .settings=${view?.context?.zoom?.[zoomTarget]?.requested}
          @advanced-camera-card:zoom:change=${(ev: CustomEvent<ZoomSettingsObserved>) =>
            handleZoomSettingsObservedEvent(
              ev,
              this.viewManagerEpoch?.manager,
              zoomTarget,
            )}
        >
          ${template}
        </advanced-camera-card-zoomer>`
      : template;
  }

  protected render(): TemplateResult | void {
    if (!this.hass || !this.cameraConfig) {
      return;
    }

    return this._useZoomIfRequired(html`
      <advanced-camera-card-image-updating-player
        ${ref(this._refImage)}
        .hass=${this.hass}
        .view=${this.viewManagerEpoch?.manager.getView()}
        .imageConfig=${this.imageConfig}
        .cameraConfig=${this.cameraConfig}
      >
      </advanced-camera-card-image-updating-player>
    `);
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(imageStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-image': AdvancedCameraCardImage;
  }
}



================================================
FILE: src/components/key-assigner.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { KeyAssignerController } from '../components-lib/key-assigner-controller';
import { KeyboardShortcut } from '../config/schema/view';
import { localize } from '../localize/localize';
import keyAssignerStyle from '../scss/key-assigner.scss';
import './icon';

@customElement('advanced-camera-card-key-assigner')
export class AdvancedCameraCardKeyAssigner extends LitElement {
  @property({ attribute: false })
  public label?: string;

  @property({ attribute: false })
  public value?: KeyboardShortcut | null;

  protected _controller = new KeyAssignerController(this);

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('value')) {
      this._controller.setValue(this.value ?? null);
    }
  }

  protected render(): TemplateResult | void {
    if (!this.label) {
      return;
    }

    const renderKey = (key: string) => {
      return html`<div class="key">
        <div class="key-inner">${key}</div>
      </div>`;
    };

    return html`
      <div class="label">${this.label}</div>
      <ha-button
        class="assign"
        @click=${() => {
          this._controller.toggleAssigning();
        }}
      >
        <advanced-camera-card-icon .icon=${{ icon: 'mdi:keyboard-settings' }}></advanced-camera-card-icon>
        <span class="${classMap({
          dotdotdot: this._controller.isAssigning(),
        })}">
          ${this._controller.isAssigning() ? '' : localize('key_assigner.assign')}
        </span>
      </ha-button>
      ${
        this._controller.hasValue()
          ? html`<ha-button
              @click=${() => {
                this._controller.setValue(null);
              }}
            >
              <advanced-camera-card-icon
                .icon=${{ icon: 'mdi:keyboard-off' }}
              ></advanced-camera-card-icon>
              <span> ${localize('key_assigner.unassign')} </span>
            </ha-button>`
          : ''
      }
      <div class="key-row">
        ${this.value?.ctrl ? renderKey(localize('key_assigner.modifiers.ctrl')) : ''}
        ${this.value?.shift ? renderKey(localize('key_assigner.modifiers.shift')) : ''}
        ${this.value?.meta ? renderKey(localize('key_assigner.modifiers.meta')) : ''}
        ${this.value?.alt ? renderKey(localize('key_assigner.modifiers.alt')) : ''}
        ${this.value?.key ? renderKey(this.value.key) : ''}
      </div>
      </span>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(keyAssignerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-key-assigner': AdvancedCameraCardKeyAssigner;
  }
}



================================================
FILE: src/components/loading.ts
================================================
import { CSSResultGroup, LitElement, TemplateResult, html, unsafeCSS } from 'lit';
import { customElement } from 'lit/decorators.js';
import loadingStyle from '../scss/loading.scss';
import { getReleaseVersion } from '../utils/diagnostics';
import './icon';

@customElement('advanced-camera-card-loading')
export class AdvancedCameraCardLoading extends LitElement {
  protected render(): TemplateResult {
    return html`<advanced-camera-card-icon
        .icon=${{ icon: 'iris' }}
      ></advanced-camera-card-icon
      ><span>${getReleaseVersion()}</span>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(loadingStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-loading': AdvancedCameraCardLoading;
  }
}



================================================
FILE: src/components/media-filter.ts
================================================
import { ScopedRegistryHost } from '@lit-labs/scoped-registry-mixin';
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { CameraManager } from '../camera-manager/manager';
import { ViewManagerEpoch } from '../card-controller/view/types';
import {
  MediaFilterController,
  MediaFilterCoreFavoriteSelection,
  MediaFilterCoreWhen,
  MediaFilterMediaType,
} from '../components-lib/media-filter-controller';
import { CardWideConfig } from '../config/schema/types';
import { HomeAssistant } from '../ha/types';
import { localize } from '../localize/localize';
import mediaFilterStyle from '../scss/media-filter.scss';
import { AdvancedCameraCardDatePicker } from './date-picker';
import './date-picker.js';
import { AdvancedCameraCardSelect } from './select';
import './select.js';

@customElement('advanced-camera-card-media-filter')
class AdvancedCameraCardMediaFilter extends ScopedRegistryHost(LitElement) {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  static elementDefinitions = {
    'advanced-camera-card-select': AdvancedCameraCardSelect,
    'advanced-camera-card-date-picker': AdvancedCameraCardDatePicker,
  };

  protected _mediaFilterController = new MediaFilterController(this);

  protected _refMediaType: Ref<AdvancedCameraCardSelect> = createRef();
  protected _refCamera: Ref<AdvancedCameraCardSelect> = createRef();
  protected _refWhen: Ref<AdvancedCameraCardSelect> = createRef();
  protected _refWhenFrom: Ref<AdvancedCameraCardDatePicker> = createRef();
  protected _refWhenTo: Ref<AdvancedCameraCardDatePicker> = createRef();
  protected _refWhat: Ref<AdvancedCameraCardSelect> = createRef();
  protected _refWhere: Ref<AdvancedCameraCardSelect> = createRef();
  protected _refFavorite: Ref<AdvancedCameraCardSelect> = createRef();
  protected _refTags: Ref<AdvancedCameraCardSelect> = createRef();

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('viewManagerEpoch')) {
      this._mediaFilterController.setViewManager(this.viewManagerEpoch?.manager ?? null);
    }

    if (changedProps.has('cameraManager') && this.cameraManager) {
      this._mediaFilterController.computeCameraOptions(this.cameraManager);
      this._mediaFilterController.computeMetadataOptions(this.cameraManager);
    }

    // The first time the viewManager is set, compute the initial default selections.
    if (
      !changedProps.get('viewManager') &&
      this.viewManagerEpoch &&
      this.cameraManager
    ) {
      this._mediaFilterController.computeInitialDefaultsFromView(this.cameraManager);
    }
  }

  protected render(): TemplateResult | void {
    const valueChange = async () => {
      if (!this.cameraManager || !this.viewManagerEpoch || !this.cardWideConfig) {
        return;
      }
      await this._mediaFilterController.valueChangeHandler(
        this.cameraManager,
        this.cardWideConfig,
        {
          camera: this._refCamera.value?.value ?? undefined,
          mediaType: (this._refMediaType.value?.value ?? undefined) as
            | MediaFilterMediaType
            | undefined,
          when: {
            selected: this._refWhen.value?.value ?? undefined,
            from: this._refWhenFrom.value?.value,
            to: this._refWhenTo.value?.value,
          },
          favorite: (this._refFavorite.value?.value ?? undefined) as
            | MediaFilterCoreFavoriteSelection
            | undefined,
          where: this._refWhere.value?.value ?? undefined,
          what: this._refWhat.value?.value ?? undefined,
          tags: this._refTags.value?.value ?? undefined,
        },
      );
    };

    // Ensure that the "When" selector and the custom calendar to/from selectors
    // are ~mutually exclusive.
    const whenChange = async (whenPriority?: 'custom' | 'selected'): Promise<void> => {
      if (whenPriority === 'custom' && this._refWhen.value) {
        if (!this._refWhenFrom.value?.value && !this._refWhenTo.value?.value) {
          this._refWhen.value.reset();
        } else {
          this._refWhen.value.value = MediaFilterCoreWhen.Custom;
        }
      } else if (this._refWhen.value?.value !== MediaFilterCoreWhen.Custom) {
        this._refWhenFrom.value?.reset();
        this._refWhenTo.value?.reset();
      }
      await valueChange();
    };

    if (!this.cameraManager || !this.viewManagerEpoch) {
      return;
    }

    const controls = this._mediaFilterController.getControlsToShow(this.cameraManager);
    const defaults = this._mediaFilterController.getDefaults();
    const whatOptions = this._mediaFilterController.getWhatOptions();
    const tagsOptions = this._mediaFilterController.getTagsOptions();
    const whereOptions = this._mediaFilterController.getWhereOptions();

    return html` <advanced-camera-card-select
        ${ref(this._refMediaType)}
        label=${localize('media_filter.media_type')}
        placeholder=${localize('media_filter.select_media_type')}
        .options=${this._mediaFilterController.getMediaTypeOptions()}
        .initialValue=${defaults?.mediaType}
        @advanced-camera-card:select:change=${() => valueChange()}
      >
      </advanced-camera-card-select>
      <div class="when">
        <advanced-camera-card-select
          ${ref(this._refWhen)}
          .label=${localize('media_filter.when')}
          placeholder=${localize('media_filter.select_when')}
          .options=${this._mediaFilterController.getWhenOptions()}
          .initialValue=${defaults?.when}
          clearable
          @advanced-camera-card:select:change=${() => whenChange('selected')}
        >
        </advanced-camera-card-select>
        <advanced-camera-card-date-picker
          class="${classMap({
            selected: !!this._refWhenFrom.value?.value,
            hidden: this._refWhen.value?.value !== MediaFilterCoreWhen.Custom,
          })}"
          ${ref(this._refWhenFrom)}
          .icon=${'mdi:calendar-arrow-right'}
          @advanced-camera-card:date-picker:change=${() => whenChange('custom')}
        >
        </advanced-camera-card-date-picker>
        <advanced-camera-card-date-picker
          class="${classMap({
            selected: !!this._refWhenTo.value?.value,
            hidden: this._refWhen.value?.value !== MediaFilterCoreWhen.Custom,
          })}"
          ${ref(this._refWhenTo)}
          .icon=${'mdi:calendar-arrow-left'}
          @advanced-camera-card:date-picker:change=${() => whenChange('custom')}
        >
        </advanced-camera-card-date-picker>
      </div>
      <advanced-camera-card-select
        ${ref(this._refCamera)}
        .label=${localize('media_filter.camera')}
        placeholder=${localize('media_filter.select_camera')}
        .options=${this._mediaFilterController.getCameraOptions()}
        .initialValue=${defaults?.cameraIDs}
        clearable
        multiple
        @advanced-camera-card:select:change=${() => valueChange()}
      >
      </advanced-camera-card-select>
      ${controls.events && whatOptions.length
        ? html` <advanced-camera-card-select
            ${ref(this._refWhat)}
            label=${localize('media_filter.what')}
            placeholder=${localize('media_filter.select_what')}
            clearable
            multiple
            .options=${whatOptions}
            .initialValue=${defaults?.what}
            @advanced-camera-card:select:change=${() => valueChange()}
          >
          </advanced-camera-card-select>`
        : ''}
      ${controls.events && tagsOptions.length
        ? html` <advanced-camera-card-select
            ${ref(this._refTags)}
            label=${localize('media_filter.tag')}
            placeholder=${localize('media_filter.select_tag')}
            clearable
            multiple
            .options=${tagsOptions}
            .initialValue=${defaults?.tags}
            @advanced-camera-card:select:change=${() => valueChange()}
          >
          </advanced-camera-card-select>`
        : ''}
      ${controls.events && whereOptions.length
        ? html` <advanced-camera-card-select
            ${ref(this._refWhere)}
            label=${localize('media_filter.where')}
            placeholder=${localize('media_filter.select_where')}
            clearable
            multiple
            .options=${whereOptions}
            .initialValue=${defaults?.where}
            @advanced-camera-card:select:change=${() => valueChange()}
          >
          </advanced-camera-card-select>`
        : ''}
      ${controls.favorites
        ? html`
            <advanced-camera-card-select
              ${ref(this._refFavorite)}
              label=${localize('media_filter.favorite')}
              placeholder=${localize('media_filter.select_favorite')}
              .options=${this._mediaFilterController.getFavoriteOptions()}
              .initialValue=${defaults?.favorite}
              clearable
              @advanced-camera-card:select:change=${() => valueChange()}
            >
            </advanced-camera-card-select>
          `
        : ''}`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(mediaFilterStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-media-filter': AdvancedCameraCardMediaFilter;
  }
}



================================================
FILE: src/components/media-grid.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { MediaGridController } from '../components-lib/media-grid-controller.js';
import { ViewDisplayConfig } from '../config/schema/common/display.js';
import mediaGridStyle from '../scss/media-grid.scss';

@customElement('advanced-camera-card-media-grid')
export class AdvancedCameraCardMediaGrid extends LitElement {
  @property({ attribute: false })
  public selected?: string;

  @property({ attribute: false })
  public displayConfig?: ViewDisplayConfig;

  protected _controller: MediaGridController | null = null;
  protected _refSlot: Ref<HTMLSlotElement> = createRef();

  connectedCallback(): void {
    super.connectedCallback();

    // Ensure the controller is recreated.
    this.requestUpdate();
  }

  disconnectedCallback(): void {
    this._controller?.destroy();
    this._controller = null;
    super.disconnectedCallback();
  }

  protected updated(changedProps: PropertyValues): void {
    if (!this._controller && this._refSlot.value) {
      this._controller = new MediaGridController(this._refSlot.value, {
        selected: this.selected,
        displayConfig: this.displayConfig,
      });
    }

    if (changedProps.has('selected')) {
      if (this.selected) {
        this._controller?.selectCell(this.selected);
      } else {
        this._controller?.unselectAll();
      }
    }

    if (changedProps.has('displayConfig')) {
      this._controller?.setDisplayConfig(this.displayConfig ?? null);
    }
  }

  protected render(): TemplateResult | void {
    return html`<slot ${ref(this._refSlot)}></slot> `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(mediaGridStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-media-grid': AdvancedCameraCardMediaGrid;
  }
}



================================================
FILE: src/components/menu.ts
================================================
import { CSSResultGroup, LitElement, TemplateResult, html, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { actionHandler } from '../action-handler-directive.js';
import { MenuController } from '../components-lib/menu-controller.js';
import { MenuItem } from '../config/schema/elements/custom/menu/types.js';
import { MenuConfig } from '../config/schema/menu.js';
import { getEntityTitle } from '../ha/get-entity-title.js';
import { EntityRegistryManager } from '../ha/registry/entity/types.js';
import { HomeAssistant } from '../ha/types.js';
import menuStyle from '../scss/menu.scss';
import { hasAction } from '../utils/action.js';
import './icon.js';
import './submenu/select-button.js';
import './submenu/submenu-button';

@customElement('advanced-camera-card-menu')
export class AdvancedCameraCardMenu extends LitElement {
  protected _controller = new MenuController(this);

  @property({ attribute: false })
  public entityRegistryManager?: EntityRegistryManager;

  @property({ attribute: false })
  public hass?: HomeAssistant;

  set menuConfig(menuConfig: MenuConfig) {
    this._controller.setMenuConfig(menuConfig);
  }

  set buttons(buttons: MenuItem[]) {
    this._controller.setButtons(buttons);
  }

  set expanded(expanded: boolean) {
    this._controller.setExpanded(expanded);
  }

  public toggleMenu(): void {
    this._controller.toggleExpanded();
  }

  protected _renderButton(button: MenuItem): TemplateResult | void {
    if (!this.hass) {
      return;
    }

    if (button.type === 'custom:advanced-camera-card-menu-submenu') {
      return html` <advanced-camera-card-submenu-button
        .hass=${this.hass}
        .submenu=${button}
        @action=${(ev) => this._controller.handleAction(ev)}
      >
      </advanced-camera-card-submenu-button>`;
    } else if (button.type === 'custom:advanced-camera-card-menu-submenu-select') {
      return html` <advanced-camera-card-submenu-select-button
        .hass=${this.hass}
        .submenuSelect=${button}
        .entityRegistryManager=${this.entityRegistryManager}
        @action=${(ev) => this._controller.handleAction(ev)}
      >
      </advanced-camera-card-submenu-select-button>`;
    }

    const title =
      this.hass &&
      button.type === 'custom:advanced-camera-card-menu-state-icon' &&
      !button.title
        ? getEntityTitle(this.hass, button.entity)
        : button.title;

    return html` <ha-icon-button
      .actionHandler=${actionHandler({
        hasHold: hasAction(button.hold_action),
        hasDoubleClick: hasAction(button.double_tap_action),
      })}
      .label=${title ?? ''}
      @action=${(ev) => this._controller.handleAction(ev, button)}
    >
      <advanced-camera-card-icon
        ?allow-override-non-active-styles=${true}
        style="${styleMap(button.style || {})}"
        .hass=${this.hass}
        .icon=${{
          icon: button.icon,
          entity: button.entity,
          stateColor: button.state_color,
          fallback: 'mdi:gesture-tap-button',
        }}
      ></advanced-camera-card-icon>
    </ha-icon-button>`;
  }

  /** Theme-related styling is dynamically injected into the menu depending on
   * the configured position, style and alignment to allow precise theming.
   * The alternative is a massive (post-sass processing) CSS file would need to
   * be shipped to account for every possible combination.
   *
   * Each rule uses 'var' values that have nested fallbacks of decreasing
   * specificity, so the most specific theme variable will match, followed by
   * the next most specific, etc.
   */
  protected _renderPerInstanceStyle(): TemplateResult | void {
    const config = this._controller.getMenuConfig();
    if (!config) {
      return;
    }

    const position = config.position;
    const style = config.style;
    const alignment = config.alignment;

    const generateValue = (suffix: string): string => {
      return `
        var(--advanced-camera-card-menu-override-${suffix},
        var(--advanced-camera-card-menu-position-${position}-alignment-${alignment}-style-${style}-${suffix},
        var(--advanced-camera-card-menu-position-${position}-alignment-${alignment}-${suffix},
        var(--advanced-camera-card-menu-position-${position}-${suffix},
        var(--advanced-camera-card-menu-style-${style}-${suffix},
        var(--advanced-camera-card-menu-alignment-${alignment}-${suffix},
        var(--advanced-camera-card-menu-${suffix})))))))`;
    };

    // By definition `rule` will match the current configuration, the choice is
    // actually which of the var(...) variables will be used after the match.
    const expandedRule = style === 'hidden' ? '[expanded]' : '';
    const rule =
      `[data-position='${position}']` +
      `[data-style='${style}']` +
      `[data-alignment='${alignment}']` +
      expandedRule;

    return html`<style>
      :host(${rule}) {
        background: ${generateValue('background')};

        ha-icon-button {
          color: ${generateValue('button-inactive-color')};
          background: ${generateValue('button-background')};
        }
      }
    </style>`;
  }

  protected render(): TemplateResult | void {
    const config = this._controller.getMenuConfig();
    const style = config?.style;
    if (!config || style === 'none') {
      return;
    }
    const matchingButtons = this._controller.getButtons('matching');
    const opposingButtons = this._controller.getButtons('opposing');

    return html` ${this._renderPerInstanceStyle()}
      <div
        class="matching"
        style="${styleMap({ flex: String(matchingButtons.length) })}"
      >
        ${matchingButtons.map((button) => this._renderButton(button))}
      </div>
      <div
        class="opposing"
        style="${styleMap({ flex: String(opposingButtons.length) })}"
      >
        ${opposingButtons.map((button) => this._renderButton(button))}
      </div>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(menuStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-menu': AdvancedCameraCardMenu;
  }
}



================================================
FILE: src/components/message.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { MessageController } from '../components-lib/message/controller.js';
import messageStyle from '../scss/message.scss';
import { Message } from '../types.js';
import './icon.js';

export function renderMessage(
  message: Message | null,
  renderOptions?: {
    overlay?: boolean;
  },
): TemplateResult {
  return html` <advanced-camera-card-message
    .message=${message}
    ?overlay=${!!renderOptions?.overlay}
  ></advanced-camera-card-message>`;
}
@customElement('advanced-camera-card-message')
export class AdvancedCameraCardMessage extends LitElement {
  @property({ attribute: false })
  public message?: Message;

  @property({ attribute: true, type: Boolean })
  public overlay = false;

  private _controller = new MessageController();

  protected render(): TemplateResult | void {
    if (!this.message) {
      return;
    }

    const url = this._controller.getURL(this.message);
    const messageTemplate = html`
      ${this._controller.getMessageString(this.message)}
      ${url ? html`. <a href="${url.link}">${url.title}</a>` : ''}
    `;

    const icon = this._controller.getIcon(this.message);
    const classes = {
      dotdotdot: !!this.message?.dotdotdot,
    };

    return html` <div class="wrapper">
      <div class="message padded">
        <div class="icon">
          <advanced-camera-card-icon
            part="icon"
            .icon="${{ icon: icon }}"
          ></advanced-camera-card-icon>
        </div>
        <div class="contents">
          <span class="${classMap(classes)}">${messageTemplate}</span>
          ${this._controller
            .getContextStrings(this.message)
            .map((contextItem) => html`<pre>${contextItem}</pre>`)}
        </div>
      </div>
    </div>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(messageStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-message': AdvancedCameraCardMessage;
  }
}



================================================
FILE: src/components/next-prev-control.ts
================================================
import { CSSResultGroup, LitElement, TemplateResult, html, unsafeCSS } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { NextPreviousControlConfig } from '../config/schema/common/controls/next-previous.js';
import { HomeAssistant } from '../ha/types.js';
import controlStyle from '../scss/next-previous-control.scss';
import { Icon } from '../types.js';
import { renderTask } from '../utils/task.js';
import { createFetchThumbnailTask } from '../utils/thumbnail.js';

@customElement('advanced-camera-card-next-previous-control')
export class AdvancedCameraCardNextPreviousControl extends LitElement {
  @property({ attribute: false })
  public side?: 'left' | 'right';

  set controlConfig(controlConfig: NextPreviousControlConfig | undefined) {
    if (controlConfig?.size) {
      this.style.setProperty(
        '--advanced-camera-card-next-prev-size',
        `${controlConfig.size}px`,
      );
    }
    this._controlConfig = controlConfig;
  }

  @property({ attribute: false })
  public hass?: HomeAssistant;

  @state()
  protected _controlConfig?: NextPreviousControlConfig;

  @property({ attribute: false })
  public thumbnail?: string;

  @property({ attribute: false })
  public icon?: Icon;

  @property({ attribute: true, type: Boolean })
  public disabled = false;

  // Label that is used for ARIA support and as tooltip.
  @property() label = '';

  protected _embedThumbnailTask = createFetchThumbnailTask(
    this,
    () => this.hass,
    () => this.thumbnail,
  );

  protected render(): TemplateResult {
    if (this.disabled || !this._controlConfig || this._controlConfig.style == 'none') {
      return html``;
    }

    const shouldRenderIcon =
      !this.thumbnail || ['chevrons', 'icons'].includes(this._controlConfig.style);

    const classesBase = {
      controls: true,
      left: this.side === 'left',
      right: this.side === 'right',
    };

    const renderIcon = (): TemplateResult => {
      const icon =
        this.icon && this._controlConfig?.style !== 'chevrons'
          ? this.icon
          : this.side === 'left'
            ? { icon: 'mdi:chevron-left' }
            : { icon: 'mdi:chevron-right' };

      const classes = {
        ...classesBase,
        icons: true,
      };

      return html` <ha-icon-button class="${classMap(classes)}" .label=${this.label}>
        <advanced-camera-card-icon
          .hass=${this.hass}
          .icon=${icon}
        ></advanced-camera-card-icon>
      </ha-icon-button>`;
    };

    if (shouldRenderIcon) {
      return renderIcon();
    }

    const classes = {
      ...classesBase,
      thumbnails: true,
    };

    return renderTask(
      this._embedThumbnailTask,
      (embeddedThumbnail: string | null) =>
        embeddedThumbnail
          ? html`<img
              src="${embeddedThumbnail}"
              class="${classMap(classes)}"
              title="${this.label}"
              aria-label="${this.label}"
            />`
          : html``,
      {
        inProgressFunc: () => html`<div class=${classMap(classes)}></div>`,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        errorFunc: (_ev: Error) => renderIcon(),
      },
    );
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(controlStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-next-previous-control': AdvancedCameraCardNextPreviousControl;
  }
}



================================================
FILE: src/components/overlay.ts
================================================
import { CSSResultGroup, LitElement, TemplateResult, html, unsafeCSS } from 'lit';
import { customElement } from 'lit/decorators.js';
import overlayStyle from '../scss/overlay.scss';

@customElement('advanced-camera-card-overlay')
export class AdvancedCameraCardOverlay extends LitElement {
  protected render(): TemplateResult | void {
    return html`
      <slot name="top"></slot>
      <slot name="left"></slot>
      <slot name="right"></slot>
      <slot name="bottom"></slot>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(overlayStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-overlay': AdvancedCameraCardOverlay;
  }
}



================================================
FILE: src/components/progress-indicator.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { ClassInfo, classMap } from 'lit/directives/class-map.js';
import { ref, Ref } from 'lit/directives/ref.js';
import { CardWideConfig } from '../config/schema/types';
import messageStyle from '../scss/message.scss';
import './icon.js';

type AdvancedCameraCardProgressIndicatorSize = 'tiny' | 'small' | 'medium' | 'large';

export function renderProgressIndicator(options?: {
  message?: string;
  cardWideConfig?: CardWideConfig | null;
  componentRef?: Ref<HTMLElement>;
  classes?: ClassInfo;
  size?: AdvancedCameraCardProgressIndicatorSize;
}): TemplateResult {
  return html`
    <advanced-camera-card-progress-indicator
      class="${classMap(options?.classes ?? {})}"
      .size=${options?.size}
      ${options?.componentRef ? ref(options.componentRef) : ''}
      .message=${options?.message || ''}
      .animated=${options?.cardWideConfig?.performance?.features
        .animated_progress_indicator ?? true}
    >
    </advanced-camera-card-progress-indicator>
  `;
}

@customElement('advanced-camera-card-progress-indicator')
export class AdvancedCameraCardProgressIndicator extends LitElement {
  @property({ attribute: false })
  public message: string = '';

  @property({ attribute: false })
  public animated = false;

  @property({ attribute: false })
  public size: AdvancedCameraCardProgressIndicatorSize = 'large';

  protected render(): TemplateResult {
    return html` <div class="message vertical">
      ${this.animated
        ? html`<ha-spinner indeterminate size="${this.size}"> </ha-spinner>`
        : html`<advanced-camera-card-icon
            .icon=${{ icon: 'mdi:timer-sand' }}
          ></advanced-camera-card-icon>`}
      ${this.message ? html`<span>${this.message}</span>` : html``}
    </div>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(messageStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-progress-indicator': AdvancedCameraCardProgressIndicator;
  }
}



================================================
FILE: src/components/ptz.ts
================================================
import {
  CSSResultGroup,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { actionHandler } from '../action-handler-directive.js';
import { CameraManager } from '../camera-manager/manager.js';
import { PTZController } from '../components-lib/ptz/ptz-controller.js';
import { PTZControllerActions } from '../components-lib/ptz/types.js';
import { Actions } from '../config/schema/actions/types.js';
import { PTZControlsConfig } from '../config/schema/common/controls/ptz.js';
import { HomeAssistant } from '../ha/types.js';
import { localize } from '../localize/localize.js';
import ptzStyle from '../scss/ptz.scss';
import { Interaction } from '../types.js';
import { hasAction } from '../utils/action.js';
import { prettifyTitle } from '../utils/basic.js';
import './icon.js';
import './submenu';
import { SubmenuInteraction, SubmenuItem } from './submenu/types.js';

@customElement('advanced-camera-card-ptz')
export class AdvancedCameraCardPTZ extends LitElement {
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public config?: PTZControlsConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public cameraID?: string;

  @property({ attribute: false })
  public forceVisibility?: boolean;

  protected _controller = new PTZController(this);
  protected _actions: PTZControllerActions | null = null;

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('config')) {
      this._controller.setConfig(this.config);
    }
    if (changedProps.has('cameraManager') || changedProps.has('cameraID')) {
      this._controller.setCamera(this.cameraManager, this.cameraID);
    }
    if (changedProps.has('forceVisibility')) {
      this._controller.setForceVisibility(this.forceVisibility);
    }
    if (changedProps.has('cameraID') || changedProps.has('cameraManager')) {
      this._actions = this._controller.getPTZActions();
    }
  }

  protected render(): TemplateResult | void {
    if (!this._controller.shouldDisplay()) {
      return;
    }

    const renderIcon = (
      name: string,
      icon: string,
      options?: {
        actions?: Actions | null;
        renderWithoutAction?: boolean;
      },
    ): TemplateResult => {
      const classes = {
        [name]: true,
        disabled: !options?.actions && !options?.renderWithoutAction,
      };

      return options?.actions || options?.renderWithoutAction
        ? html`<advanced-camera-card-icon
            class=${classMap(classes)}
            .icon=${{ icon: icon }}
            .title=${localize(`elements.ptz.${name}`)}
            .actionHandler=${options.actions
              ? actionHandler({
                  hasHold: hasAction(options.actions?.hold_action),
                  hasDoubleClick: hasAction(options.actions?.double_tap_action),
                })
              : undefined}
            @action=${(ev: CustomEvent<Interaction>) =>
              options.actions && this._controller.handleAction(ev, options.actions)}
          ></advanced-camera-card-icon>`
        : html``;
    };

    const presetSubmenuItems: SubmenuItem[] | null = this._actions?.presets?.length
      ? this._actions.presets.map((preset) => ({
          title: prettifyTitle(preset.preset),
          icon: 'mdi:cctv',
          ...preset.actions,
          hold_action: {
            action: 'perform-action',
            perform_action: 'camera.preset_recall',
          },
        }))
      : null;

    const config = this._controller.getConfig();
    return html` <div class="ptz">
      ${!config?.hide_pan_tilt &&
      (this._actions?.left ||
        this._actions?.right ||
        this._actions?.up ||
        this._actions?.down)
        ? html`<div class="ptz-move">
            ${renderIcon('right', 'mdi:arrow-right', { actions: this._actions?.right })}
            ${renderIcon('left', 'mdi:arrow-left', { actions: this._actions?.left })}
            ${renderIcon('up', 'mdi:arrow-up', { actions: this._actions?.up })}
            ${renderIcon('down', 'mdi:arrow-down', { actions: this._actions?.down })}
          </div>`
        : ''}
      ${!config?.hide_zoom && (this._actions?.zoom_in || this._actions?.zoom_out)
        ? html` <div class="ptz-zoom">
            ${renderIcon('zoom_in', 'mdi:plus', { actions: this._actions.zoom_in })}
            ${renderIcon('zoom_out', 'mdi:minus', { actions: this._actions.zoom_out })}
          </div>`
        : html``}
      ${!config?.hide_home && (this._actions?.home || presetSubmenuItems?.length)
        ? html`<div class="ptz-presets">
            ${renderIcon('home', 'mdi:home', { actions: this._actions?.home })}
            ${presetSubmenuItems?.length
              ? html`<advanced-camera-card-submenu
                  class="presets"
                  .hass=${this.hass}
                  .items=${presetSubmenuItems}
                  @action=${(ev: CustomEvent<SubmenuInteraction>) =>
                    this._controller.handleAction(ev)}
                >
                  ${renderIcon(
                    'presets',
                    config?.orientation === 'vertical'
                      ? 'mdi:dots-vertical'
                      : 'mdi:dots-horizontal',
                    {
                      renderWithoutAction: true,
                    },
                  )}
                </advanced-camera-card-submenu>`
              : ''}
          </div>`
        : ''}
    </div>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(ptzStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-ptz': AdvancedCameraCardPTZ;
  }
}



================================================
FILE: src/components/select.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { property } from 'lit/decorators.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import selectStyle from '../scss/select.scss';
import { contentsChanged } from '../utils/basic';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event';
import { ScopedRegistryHost } from '@lit-labs/scoped-registry-mixin';
import { grSelectElements } from '../scoped-elements/gr-select';
import { isEqual } from 'lodash-es';
import '../scoped-elements/gr-select';

export interface SelectOption {
  label: string;
  value: string;
}

export type SelectValues = string | string[];

type SelectElement = HTMLElement & {
  value: SelectValues;
};

export class AdvancedCameraCardSelect extends ScopedRegistryHost(LitElement) {
  @property({ attribute: false, hasChanged: contentsChanged })
  public options?: SelectOption[];

  @property({ attribute: false, hasChanged: contentsChanged })
  public value: SelectValues | null = null;

  @property({ attribute: false, hasChanged: contentsChanged })
  public initialValue?: SelectValues;

  @property({ attribute: true })
  public label?: string;

  @property({ attribute: true })
  public placeholder?: string;

  @property({ attribute: true, type: Boolean })
  public multiple?: boolean = false;

  @property({ attribute: true, type: Boolean })
  public clearable?: boolean = false;

  protected _previouslyReportedValue?: SelectValues;
  protected _refSelect: Ref<SelectElement> = createRef();

  static elementDefinitions = {
    ...grSelectElements,
  };

  public reset(): void {
    this.value = null;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  protected _valueChangedHandler(_ev: CustomEvent<{ value: unknown }>): void {
    const value: SelectValues | undefined = this._refSelect.value?.value;
    // The underlying gr-select element is very sensitive and occasionally fires
    // the change event even if the value has not actually changed. Prevent that
    // from propagating upwards.
    if (value !== undefined && !isEqual(this.value, value)) {
      const initialValueSet = this.value === null;
      this.value = value;

      // The underlying gr-select element will call on the first first value set
      // (even when the user has not interacted with the control). Do not
      // dispatch events for this.
      if (!initialValueSet) {
        fireAdvancedCameraCardEvent(this, 'select:change', value);
      }
    }
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('initialValue') && this.initialValue && !this.value) {
      this.value = this.initialValue;
    }
  }

  protected render(): TemplateResult | void {
    return html` <gr-select
      ${ref(this._refSelect)}
      label=${this.label ?? ''}
      placeholder=${this.placeholder ?? ''}
      size="small"
      ?multiple=${this.multiple}
      ?clearable=${this.clearable}
      .value=${this.value ?? []}
      @gr-change=${this._valueChangedHandler.bind(this)}
    >
      ${this.options?.map(
        (option) =>
          html`<gr-menu-item value="${option.value ?? ''}"
            >${option.label}</gr-menu-item
          >`,
      )}
    </gr-select>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(selectStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-select': AdvancedCameraCardSelect;
  }
}



================================================
FILE: src/components/status-bar.ts
================================================
import {
  CSSResultGroup,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { actionHandler } from '../action-handler-directive.js';
import { StatusBarController } from '../components-lib/status-bar-controller';
import { StatusBarItem } from '../config/schema/actions/types.js';
import { StatusBarConfig } from '../config/schema/status-bar.js';
import statusStyle from '../scss/status.scss';
import { hasAction } from '../utils/action';
import './icon.js';

@customElement('advanced-camera-card-status-bar')
export class AdvancedCameraCardStatusBar extends LitElement {
  protected _controller = new StatusBarController(this);

  @property({ attribute: false })
  public items?: StatusBarItem[];

  @property({ attribute: false })
  public config?: StatusBarConfig;

  protected willUpdate(changedProperties: PropertyValues): void {
    // Always set config before items.
    if (changedProperties.has('config') && this.config) {
      this._controller.setConfig(this.config);
    }

    if (changedProperties.has('items')) {
      this._controller.setItems(this.items ?? []);
    }
  }

  /** Theme-related styling is dynamically injected into the status bar depending on
   * the configured position and style to allow precise theming.
   *
   * Each rule uses 'var' values that have nested fallbacks of decreasing
   * specificity, so the most specific theme variable will match, followed by
   * the next most specific, etc.
   */
  protected _renderPerInstanceStyle(): TemplateResult | void {
    const config = this._controller.getConfig();
    if (!config) {
      return;
    }

    const position = config.position;
    const style = config.style;

    const generateValue = (suffix: string): string => {
      return `
        var(--advanced-camera-card-status-bar-override-${suffix},
        var(--advanced-camera-card-status-bar-position-${position}-style-${style}-${suffix},
        var(--advanced-camera-card-status-bar-position-${position}-${suffix},
        var(--advanced-camera-card-status-bar-style-${style}-${suffix},
        var(--advanced-camera-card-status-bar-${suffix})))))`;
    };

    const rule = `[data-position='${position}']` + `[data-style='${style}']`;

    return html`<style>
      :host(${rule}) {
        color: ${generateValue('color')};
        background: ${generateValue('background')};
      }
    </style>`;
  }

  protected render(): TemplateResult | void {
    if (!this._controller.shouldRender()) {
      return;
    }

    return html`
      ${this._renderPerInstanceStyle()}
      <div class="status">
        ${this._controller.getRenderItems().map((item): TemplateResult | void => {
          if (item.enabled === false) {
            return;
          }

          const classes = classMap({
            item: true,
            expand: !!item.expand,
            action: !!Object.keys(item.actions ?? {}).length,
          });

          const handler = actionHandler({
            hasHold: hasAction(item.actions?.hold_action),
            hasDoubleClick: hasAction(item.actions?.double_tap_action),
          });

          if (item.type === 'custom:advanced-camera-card-status-bar-string') {
            return html`<div
              .actionHandler=${handler}
              class="${classes}"
              @action=${(ev) => this._controller.actionHandler(ev, item.actions)}
            >
              ${item.string}
            </div>`;
          } else if (item.type === 'custom:advanced-camera-card-status-bar-icon') {
            return html`<advanced-camera-card-icon
              .actionHandler=${handler}
              .icon=${{ icon: item.icon }}
              class="${classes}"
              @action=${(ev) => this._controller.actionHandler(ev, item.actions)}
            ></advanced-camera-card-icon>`;
          } else if (item.type === 'custom:advanced-camera-card-status-bar-image') {
            return html`<img
              .actionHandler=${handler}
              class="${classes}"
              src="${item.image}"
              @action=${(ev) => this._controller.actionHandler(ev, item.actions)}
            />`;
          }
        })}
      </div>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(statusStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-status-bar': AdvancedCameraCardStatusBar;
  }
}



================================================
FILE: src/components/surround-basic.ts
================================================
import { CSSResultGroup, LitElement, TemplateResult, html, unsafeCSS } from 'lit';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { customElement, property } from 'lit/decorators.js';
import { DrawerIcons, AdvancedCameraCardDrawer } from './drawer.js';

import './drawer.js';

import surroundBasicStyle from '../scss/surround-basic.scss';

interface AdvancedCameraCardDrawerOpen {
  drawer: 'left' | 'right';
}

@customElement('advanced-camera-card-surround-basic')
export class AdvancedCameraCardSurroundBasic extends LitElement {
  @property({ attribute: false })
  public drawerIcons?: {
    left?: DrawerIcons;
    right?: DrawerIcons;
  };

  protected _refDrawerLeft: Ref<AdvancedCameraCardDrawer> = createRef();
  protected _refDrawerRight: Ref<AdvancedCameraCardDrawer> = createRef();
  protected _boundDrawerHandler = this._drawerHandler.bind(this);

  connectedCallback(): void {
    super.connectedCallback();
    this.addEventListener('advanced-camera-card:drawer:open', this._boundDrawerHandler);
    this.addEventListener('advanced-camera-card:drawer:close', this._boundDrawerHandler);
  }

  disconnectedCallback(): void {
    this.removeEventListener(
      'advanced-camera-card:drawer:open',
      this._boundDrawerHandler,
    );
    this.removeEventListener(
      'advanced-camera-card:drawer:close',
      this._boundDrawerHandler,
    );
    super.disconnectedCallback();
  }

  protected _drawerHandler(ev: Event) {
    const drawer = (ev as CustomEvent<AdvancedCameraCardDrawerOpen>).detail.drawer;
    const open = ev.type.endsWith(':open');
    if (drawer === 'left' && this._refDrawerLeft.value) {
      this._refDrawerLeft.value.open = open;
    } else if (drawer === 'right' && this._refDrawerRight.value) {
      this._refDrawerRight.value.open = open;
    }
  }

  protected render(): TemplateResult | void {
    return html` <slot name="above"></slot>
      <slot></slot>
      <advanced-camera-card-drawer
        ${ref(this._refDrawerLeft)}
        location="left"
        .icons=${this.drawerIcons?.left}
      >
        <slot name="left"></slot>
      </advanced-camera-card-drawer>
      <advanced-camera-card-drawer
        ${ref(this._refDrawerRight)}
        location="right"
        .icons=${this.drawerIcons?.right}
      >
        <slot name="right"></slot>
      </advanced-camera-card-drawer>
      <slot name="below"></slot>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(surroundBasicStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-surround-basic': AdvancedCameraCardSurroundBasic;
  }
}



================================================
FILE: src/components/surround.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { CameraManager } from '../camera-manager/manager.js';
import { ViewItemManager } from '../card-controller/view/item-manager.js';
import { ViewManagerEpoch } from '../card-controller/view/types.js';
import { ThumbnailsControlConfig } from '../config/schema/common/controls/thumbnails.js';
import { MiniTimelineControlConfig } from '../config/schema/common/controls/timeline.js';
import { CardWideConfig } from '../config/schema/types.js';
import { HomeAssistant } from '../ha/types.js';
import basicBlockStyle from '../scss/basic-block.scss';
import { contentsChanged } from '../utils/basic.js';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event.js';
import { QueryClassifier } from '../view/query-classifier.js';
import './surround-basic.js';
import './thumbnail-carousel';

@customElement('advanced-camera-card-surround')
export class AdvancedCameraCardSurround extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false, hasChanged: contentsChanged })
  public thumbnailConfig?: ThumbnailsControlConfig;

  @property({ attribute: false, hasChanged: contentsChanged })
  public timelineConfig?: MiniTimelineControlConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  protected _cameraIDsForTimeline?: Set<string>;

  /**
   * Determine if a drawer is being used.
   * @returns `true` if a drawer is used, `false` otherwise.
   */
  protected _hasDrawer(): boolean {
    return (
      !!this.thumbnailConfig && ['left', 'right'].includes(this.thumbnailConfig.mode)
    );
  }

  protected willUpdate(changedProperties: PropertyValues): void {
    if (this.timelineConfig?.mode && this.timelineConfig.mode !== 'none') {
      import('./timeline-core.js');
    }

    // Only reset the timeline cameraIDs when the media or display mode
    // materially changes (and not on every view change, since the view will
    // change frequently when the user is scrubbing video).
    const view = this.viewManagerEpoch?.manager.getView();
    if (
      changedProperties.has('viewManagerEpoch') &&
      (this.viewManagerEpoch?.manager.hasMajorMediaChange(
        this.viewManagerEpoch?.oldView,
      ) ||
        this.viewManagerEpoch?.oldView?.displayMode !== view?.displayMode)
    ) {
      this._cameraIDsForTimeline = this._getCameraIDsForTimeline() ?? undefined;
    }
  }

  protected _getCameraIDsForTimeline(): Set<string> | null {
    const view = this.viewManagerEpoch?.manager.getView();
    if (!view || !this.cameraManager) {
      return null;
    }

    if (view.is('live')) {
      const capabilitySearch = {
        anyCapabilities: ['clips' as const, 'snapshots' as const, 'recordings' as const],
      };
      if (view.supportsMultipleDisplayModes() && view.isGrid()) {
        return this.cameraManager
          .getStore()
          .getCameraIDsWithCapability(capabilitySearch);
      } else {
        return this.cameraManager
          .getStore()
          .getAllDependentCameras(view.camera, capabilitySearch);
      }
    }

    const queries = view.query;
    if (view.isViewerView() && QueryClassifier.isMediaQuery(queries)) {
      return queries.getQueryCameraIDs() ?? null;
    }
    return null;
  }

  protected render(): TemplateResult | void {
    const view = this.viewManagerEpoch?.manager.getView();
    if (!this.hass || !view) {
      return;
    }

    const changeDrawer = (ev: CustomEvent, action: 'open' | 'close') => {
      // The event catch/re-dispatch below protect encapsulation: Catches the
      // request to view thumbnails and re-dispatches a request to open the drawer
      // (if the thumbnails are in a drawer). The new event needs to be dispatched
      // from the origin of the inbound event, so it can be handled by
      // <advanced-camera-card-surround> .
      if (this.thumbnailConfig && this._hasDrawer()) {
        fireAdvancedCameraCardEvent(ev.composedPath()[0], 'drawer:' + action, {
          drawer: this.thumbnailConfig.mode,
        });
      }
    };

    return html` <advanced-camera-card-surround-basic
      @advanced-camera-card:thumbnails-carousel:media-select=${(ev: CustomEvent) =>
        changeDrawer(ev, 'close')}
    >
      ${this.thumbnailConfig && this.thumbnailConfig.mode !== 'none'
        ? html` <advanced-camera-card-thumbnail-carousel
            slot=${this.thumbnailConfig.mode}
            .hass=${this.hass}
            .config=${this.thumbnailConfig}
            .cameraManager=${this.cameraManager}
            .viewItemManager=${this.viewItemManager}
            .fadeThumbnails=${view.isViewerView()}
            .viewManagerEpoch=${this.viewManagerEpoch}
            .selected=${view.queryResults?.getSelectedIndex() ?? undefined}
          >
          </advanced-camera-card-thumbnail-carousel>`
        : ''}
      ${this.timelineConfig && this.timelineConfig.mode !== 'none'
        ? html` <advanced-camera-card-timeline-core
            slot=${this.timelineConfig.mode}
            .hass=${this.hass}
            .viewManagerEpoch=${this.viewManagerEpoch}
            .itemClickAction=${view.isViewerView() ||
            !this.thumbnailConfig ||
            this.thumbnailConfig?.mode === 'none'
              ? 'play'
              : 'select'}
            .cameraIDs=${this._cameraIDsForTimeline}
            .mini=${true}
            .timelineConfig=${this.timelineConfig}
            .thumbnailConfig=${this.thumbnailConfig}
            .cameraManager=${this.cameraManager}
            .viewItemManager=${this.viewItemManager}
            .cardWideConfig=${this.cardWideConfig}
          >
          </advanced-camera-card-timeline-core>`
        : ''}
      <slot></slot>
    </advanced-camera-card-surround-basic>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(basicBlockStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-surround': AdvancedCameraCardSurround;
  }
}



================================================
FILE: src/components/thumbnail-carousel.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { CameraManager } from '../camera-manager/manager.js';
import { ViewItemManager } from '../card-controller/view/item-manager.js';
import { RemoveContextViewModifier } from '../card-controller/view/modifiers/remove-context.js';
import { ViewManagerEpoch } from '../card-controller/view/types.js';
import {
  getUpFolderMediaItem,
  upFolderClickHandler,
} from '../components-lib/folder/up-folder.js';
import { ThumbnailsControlConfig } from '../config/schema/common/controls/thumbnails.js';
import { HomeAssistant } from '../ha/types.js';
import thumbnailCarouselStyle from '../scss/thumbnail-carousel.scss';
import { stopEventFromActivatingCardWideActions } from '../utils/action.js';
import { CarouselDirection } from '../utils/embla/carousel-controller.js';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event.js';
import { ViewItemClassifier } from '../view/item-classifier.js';
import { ViewItem, ViewMedia } from '../view/item.js';
import { QueryClassifier } from '../view/query-classifier.js';
import './carousel.js';
import './thumbnail/thumbnail.js';

export interface ThumbnailMediaSelect {
  media: ViewMedia;
}

@customElement('advanced-camera-card-thumbnail-carousel')
export class AdvancedCameraCardThumbnailCarousel extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public config?: ThumbnailsControlConfig;

  @property({ attribute: false })
  public fadeThumbnails = false;

  protected _thumbnails: TemplateResult[] = [];

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('config')) {
      if (this.config?.size) {
        this.style.setProperty(
          '--advanced-camera-card-thumbnail-size',
          `${this.config.size}px`,
        );
      }
      const direction = this._getDirection();
      if (direction) {
        this.setAttribute('direction', direction);
      } else {
        this.removeAttribute('direction');
      }
    }

    const renderProperties = [
      'cameraManager',
      'config',
      'transitionEffect',
      'viewManagerEpoch',
    ] as const;
    if (renderProperties.some((prop) => changedProps.has(prop))) {
      this._thumbnails = this._renderThumbnails();
    }

    if (changedProps.has('viewManagerEpoch')) {
      this.style.setProperty(
        '--advanced-camera-card-carousel-thumbnail-opacity',
        !this.fadeThumbnails || this._getSelectedSlide() === null ? '1.0' : '0.4',
      );
    }
  }

  protected _getSelectedSlide(): number | null {
    return (
      this.viewManagerEpoch?.manager.getView()?.queryResults?.getSelectedIndex() ?? null
    );
  }

  protected _itemClickCallback(item: ViewItem, ev: Event): void {
    stopEventFromActivatingCardWideActions(ev);

    const view = this.viewManagerEpoch?.manager.getView();
    const query = view?.query;
    const results = view?.queryResults;

    if (!view || !query || !results) {
      return;
    }

    if (ViewItemClassifier.isMedia(item)) {
      const newResults = results
        .clone()
        .selectResultIfFound((result) => result === item);
      const cameraID = item.getCameraID();

      fireAdvancedCameraCardEvent<ThumbnailMediaSelect>(
        this,
        'thumbnails-carousel:media-select',
        { media: item },
      );
      this.viewManagerEpoch?.manager.setViewByParameters({
        params: {
          view: 'media',
          queryResults: newResults,
          ...(cameraID && { camera: cameraID }),
        },
        modifiers: [new RemoveContextViewModifier(['timeline', 'mediaViewer'])],
      });
    } else if (
      QueryClassifier.isFolderQuery(query) &&
      ViewItemClassifier.isFolder(item)
    ) {
      const rawQuery = query.getQuery();
      if (!rawQuery) {
        return;
      }

      this.viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
        params: {
          query: query.clone().setQuery({
            folder: rawQuery.folder,
            path: [...(rawQuery.path ?? []), { folder: item }],
          }),
        },
      });
    }
  }

  protected _renderThumbnail(
    item: ViewItem,
    selected: boolean,
    clickCallback: (item: ViewItem, ev: Event) => void,
    seekTarget?: Date,
  ): TemplateResult {
    const classes = {
      embla__slide: true,
      'slide-selected': selected,
    };

    return html` <advanced-camera-card-thumbnail
      class="${classMap(classes)}"
      .cameraManager=${this.cameraManager}
      .hass=${this.hass}
      .item=${item}
      .viewManagerEpoch=${this.viewManagerEpoch}
      .viewItemManager=${this.viewItemManager}
      .seek=${seekTarget &&
      ViewItemClassifier.isMedia(item) &&
      item.includesTime(seekTarget)
        ? seekTarget
        : undefined}
      ?details=${!!this.config?.show_details}
      ?show_favorite_control=${this.config?.show_favorite_control}
      ?show_timeline_control=${this.config?.show_timeline_control}
      ?show_download_control=${this.config?.show_download_control}
      @click=${(ev: Event) => clickCallback(item, ev)}
    >
    </advanced-camera-card-thumbnail>`;
  }

  protected _renderThumbnails(): TemplateResult[] {
    const upThumbnail = getUpFolderMediaItem(this.viewManagerEpoch?.manager.getView());
    const thumbnails: TemplateResult[] = [
      ...(upThumbnail
        ? [
            this._renderThumbnail(upThumbnail, false, (item: ViewItem, ev: Event) =>
              upFolderClickHandler(item, ev, this.viewManagerEpoch),
            ),
          ]
        : []),
    ];
    const view = this.viewManagerEpoch?.manager.getView();
    const selectedIndex = this._getSelectedSlide();

    for (const item of view?.queryResults?.getResults() ?? []) {
      thumbnails.push(
        this._renderThumbnail(
          item,
          selectedIndex === thumbnails.length,
          (item: ViewItem, ev: Event) => this._itemClickCallback(item, ev),
          view?.context?.mediaViewer?.seek,
        ),
      );
    }

    return thumbnails;
  }

  protected _getDirection(): CarouselDirection | null {
    if (this.config?.mode === 'left' || this.config?.mode === 'right') {
      return 'vertical';
    } else if (this.config?.mode === 'above' || this.config?.mode === 'below') {
      return 'horizontal';
    }
    return null;
  }

  protected render(): TemplateResult | void {
    const direction = this._getDirection();
    if (!this._thumbnails.length || !this.config || !direction) {
      return;
    }

    return html`<advanced-camera-card-carousel
      direction=${direction}
      .selected=${this._getSelectedSlide() ?? 0}
      .dragFree=${true}
    >
      ${this._thumbnails}
    </advanced-camera-card-carousel>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(thumbnailCarouselStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-thumbnail-carousel': AdvancedCameraCardThumbnailCarousel;
  }
}



================================================
FILE: src/components/timeline-core.ts
================================================
import { add, differenceInSeconds, sub } from 'date-fns';
import {
  CSSResultGroup,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { Ref, createRef, ref } from 'lit/directives/ref.js';
import { isEqual, throttle } from 'lodash-es';
import { ViewContext } from 'view';
import { DataSet } from 'vis-data/esnext';
import type {
  DataGroupCollectionType,
  DateType,
  IdType,
  TimelineFormatOption,
} from 'vis-timeline/esnext';
import {
  Timeline,
  TimelineEventPropertiesResult,
  TimelineItem,
  TimelineOptions,
  TimelineOptionsCluster,
  TimelineWindow,
} from 'vis-timeline/esnext';
import { CameraManager } from '../camera-manager/manager';
import { rangesOverlap } from '../camera-manager/range';
import { MediaQuery } from '../camera-manager/types';
import { convertRangeToCacheFriendlyTimes } from '../camera-manager/utils/range-to-cache-friendly';
import { ViewItemManager } from '../card-controller/view/item-manager';
import { MergeContextViewModifier } from '../card-controller/view/modifiers/merge-context';
import { ViewManagerEpoch } from '../card-controller/view/types';
import {
  AdvancedCameraCardTimelineItem,
  TimelineDataSource,
} from '../components-lib/timeline-source';
import { CameraConfig } from '../config/schema/cameras';
import { AdvancedCameraCardView } from '../config/schema/common/const';
import { ThumbnailsControlBaseConfig } from '../config/schema/common/controls/thumbnails';
import {
  TimelineCoreConfig,
  TimelinePanMode,
} from '../config/schema/common/controls/timeline';
import { CardWideConfig, configDefaults } from '../config/schema/types';
import { HomeAssistant } from '../ha/types';
import { localize } from '../localize/localize';
import timelineCoreStyle from '../scss/timeline-core.scss';
import { stopEventFromActivatingCardWideActions } from '../utils/action';
import {
  contentsChanged,
  formatDateAndTime,
  isHoverableDevice,
  isTruthy,
  setOrRemoveAttribute,
} from '../utils/basic';
import { findBestMediaTimeIndex } from '../utils/find-best-media-time-index';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event';
import { ViewMedia } from '../view/item';
import { ViewItemClassifier } from '../view/item-classifier';
import { EventMediaQuery, MediaQueries, RecordingMediaQuery } from '../view/query';
import { QueryClassifier, QueryType } from '../view/query-classifier';
import { QueryResults } from '../view/query-results';
import { mergeViewContext } from '../view/view';
import './date-picker.js';
import { AdvancedCameraCardDatePicker, DatePickerEvent } from './date-picker.js';
import './icon';
import './thumbnail/thumbnail.js';

interface AdvancedCameraCardGroupData {
  id: string;
  content: string;
}

interface TimelineRangeChange extends TimelineWindow {
  event: Event & { additionalEvent?: string };
  byUser: boolean;
}

interface TimelineViewContext {
  window?: TimelineWindow;
}

type TimelineItemClickAction = 'play' | 'select';

declare module 'view' {
  interface ViewContext {
    timeline?: TimelineViewContext;
  }
}

interface ExtendedTimeline extends Timeline {
  // setCustomTimeMarker currently missing from Timeline types.
  setCustomTimeMarker?(time: DateType, id?: IdType): void;
}

// An event used to fetch data required for thumbnail rendering. See special
// note below on why this is necessary.
interface ThumbnailDataRequest {
  item: IdType;
  hass?: HomeAssistant;
  cameraManager?: CameraManager;
  cameraConfig?: CameraConfig;
  media?: ViewMedia;
  viewManagerEpoch?: ViewManagerEpoch;
  viewItemManager?: ViewItemManager;
}

class ThumbnailDataRequestEvent extends CustomEvent<ThumbnailDataRequest> {}

const TIMELINE_TARGET_BAR_ID = 'target_bar';

/**
 * A simple thumbnail wrapper class for use in the timeline where Lit data
 * bindings are not available.
 */
@customElement('advanced-camera-card-timeline-thumbnail')
export class AdvancedCameraCardTimelineThumbnail extends LitElement {
  @property({ attribute: true })
  public item?: IdType;

  @property({ attribute: true, type: Boolean })
  public details = false;

  /**
   * Master render method.
   * @returns A rendered template.
   */
  protected render(): TemplateResult | void {
    if (!this.item) {
      return html``;
    }

    /* Special note on what's going on here:
     *
     * This component does not have access to a variety of properties required
     * to render a thumbnail component, as there's no way to pass them in via the
     * string-based tooltip that timeline supports. Instead dispatch an event to
     * request HASS which the timeline adds to the event object before execution
     * continues.
     */

    const dataRequest: ThumbnailDataRequest = {
      item: this.item,
    };
    this.dispatchEvent(
      new ThumbnailDataRequestEvent(
        `advanced-camera-card:timeline:thumbnail-data-request`,
        {
          composed: true,
          bubbles: true,
          detail: dataRequest,
        },
      ),
    );

    if (
      !dataRequest.hass ||
      !dataRequest.cameraManager ||
      !dataRequest.cameraConfig ||
      !dataRequest.viewItemManager ||
      !dataRequest.media ||
      !dataRequest.viewManagerEpoch
    ) {
      return html``;
    }

    return html` <advanced-camera-card-thumbnail
      .hass=${dataRequest.hass}
      .cameraManager=${dataRequest.cameraManager}
      .viewItemManager=${dataRequest.viewItemManager}
      .item=${dataRequest.media}
      .viewManagerEpoch=${dataRequest.viewManagerEpoch}
      ?details=${this.details}
    >
    </advanced-camera-card-thumbnail>`;
  }
}

@customElement('advanced-camera-card-timeline-core')
export class AdvancedCameraCardTimelineCore extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false, hasChanged: contentsChanged })
  public timelineConfig?: TimelineCoreConfig;

  @property({ attribute: false })
  public thumbnailConfig?: ThumbnailsControlBaseConfig;

  // Whether or not this is a mini-timeline (in mini-mode the component takes a
  // supportive role for other views).
  @property({ attribute: true, type: Boolean, reflect: true })
  public mini = false;

  // Which cameraIDs to include in the timeline. If not specified, all cameraIDs
  // are shown.
  @property({ attribute: false, hasChanged: contentsChanged })
  public cameraIDs?: Set<string>;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public itemClickAction?: TimelineItemClickAction;

  @state()
  protected _panMode: TimelinePanMode | null = null;

  protected _targetBarVisible = false;

  protected _refDatePicker: Ref<AdvancedCameraCardDatePicker> = createRef();
  protected _refTimeline: Ref<HTMLElement> = createRef();
  protected _timeline?: ExtendedTimeline;

  protected _timelineSource: TimelineDataSource | null = null;

  // Need a way to separate when a user clicks (to pan the timeline) vs when a
  // user clicks (to choose a recording (non-event) to play).
  protected _pointerHeld:
    | (TimelineEventPropertiesResult & { window?: TimelineWindow })
    | null = null;
  protected _ignoreClick = false;

  protected readonly _isHoverableDevice = isHoverableDevice();

  // Range changes are volumonous: throttle the calls on seeking.
  protected _throttledSetViewDuringRangeChange = throttle(
    this._setViewDuringRangeChange.bind(this),
    1000 / 10,
  );

  /**
   * Get a tooltip for a given timeline event.
   * @param item The TimelineItem in question.
   * @returns The tooltip as a string to render.
   */
  protected _getTooltip(item: TimelineItem): string {
    if (!this._isHoverableDevice) {
      // Don't display tooltips on touch devices, they just get in the way of
      // the drawer.
      return '';
    }

    // Cannot use Lit data-bindings as visjs requires a string for tooltips.
    // Note that changes to attributes here must be mirrored in the xss
    // whitelist in `_getOptions()` .
    return `
      <advanced-camera-card-timeline-thumbnail
        item='${item.id}'
        ${this.thumbnailConfig?.show_details ? 'details' : ''}
      >
      </advanced-camera-card-timeline-thumbnail>`;
  }

  protected _handleThumbnailDataRequest(request: ThumbnailDataRequestEvent): void {
    const item = request.detail.item;
    const media = this._timelineSource?.dataset.get(item)?.media;
    const cameraConfig = media
      ? this.cameraManager?.getStore().getCameraConfigForMedia(media) ?? undefined
      : undefined;

    request.detail.hass = this.hass;
    request.detail.cameraConfig = cameraConfig;
    request.detail.cameraManager = this.cameraManager;
    request.detail.viewItemManager = this.viewItemManager;
    request.detail.media = media;
    request.detail.viewManagerEpoch = this.viewManagerEpoch;
  }

  protected render(): TemplateResult | void {
    if (!this.hass || !this.timelineConfig || !this.cameraIDs?.size) {
      return;
    }

    const panMode = this._getEffectivePanMode();

    const panTitle =
      panMode === 'pan'
        ? localize('config.common.controls.timeline.pan_modes.pan')
        : panMode === 'seek'
          ? localize('config.common.controls.timeline.pan_modes.seek')
          : panMode === 'seek-in-media'
            ? localize('config.common.controls.timeline.pan_modes.seek-in-media')
            : localize('config.common.controls.timeline.pan_modes.seek-in-camera');
    const panIcon =
      panMode === 'pan'
        ? 'mdi:pan-horizontal'
        : panMode === 'seek'
          ? 'mdi:filmstrip-box-multiple'
          : panMode === 'seek-in-media'
            ? 'mdi:play-box-lock'
            : 'mdi:camera-lock';

    return html` <div
      @advanced-camera-card:timeline:thumbnail-data-request=${this._handleThumbnailDataRequest.bind(
        this,
      )}
      class="timeline"
      ${ref(this._refTimeline)}
    >
      <div class="timeline-tools">
        ${this._shouldSupportSeeking()
          ? html` <advanced-camera-card-icon
              .icon=${{ icon: panIcon }}
              @click=${() => {
                this._panMode =
                  panMode === 'pan'
                    ? 'seek'
                    : panMode === 'seek'
                      ? 'seek-in-media'
                      : panMode === 'seek-in-media'
                        ? 'seek-in-camera'
                        : 'pan';
              }}
              aria-label="${panTitle}"
              title="${panTitle}"
            >
            </advanced-camera-card-icon>`
          : ''}
        <advanced-camera-card-date-picker
          ${ref(this._refDatePicker)}
          @advanced-camera-card:date-picker:change=${(
            ev: CustomEvent<DatePickerEvent>,
          ) => {
            if (ev.detail.date) {
              this._timeline?.moveTo(ev.detail.date);
            }
          }}
        >
        </advanced-camera-card-date-picker>
      </div>
    </div>`;
  }

  /**
   * Called whenever the range is in the process of being changed.
   * @param properties
   */
  protected _timelineRangeChangeHandler(properties: TimelineRangeChange): void {
    if (this._pointerHeld) {
      this._ignoreClick = true;
    }

    if (
      this._shouldSupportSeeking() &&
      this._timeline &&
      properties.byUser &&
      // Do not adjust select/seek media during zoom events.
      properties.event.type !== 'wheel' &&
      properties.event.additionalEvent !== 'pinchin' &&
      properties.event.additionalEvent !== 'pinchout'
    ) {
      const targetTime = this._pointerHeld?.window
        ? add(properties.start, {
            seconds:
              (this._pointerHeld.time.getTime() -
                this._pointerHeld.window.start.getTime()) /
              1000,
          })
        : properties.end;

      if (this._pointerHeld) {
        this._setTargetBarAppropriately(targetTime);
      }

      this._throttledSetViewDuringRangeChange(targetTime, properties);
    }
  }

  protected _shouldSupportSeeking(): boolean {
    return this.mini;
  }

  /**
   * Set the target bar at a given time.
   * @param targetTime
   */
  protected _setTargetBarAppropriately(targetTime: Date): void {
    if (!this._timeline) {
      return;
    }

    const view = this.viewManagerEpoch?.manager.getView();
    const panMode = this._getEffectivePanMode();
    const targetBarOn =
      this._shouldSupportSeeking() &&
      (panMode === 'seek' ||
        ((panMode === 'seek-in-camera' || panMode === 'seek-in-media') &&
          this._timeline.getSelection().some((id) => {
            const item = this._timelineSource?.dataset?.get(id);
            return (
              panMode !== 'seek-in-camera' ||
                item?.media?.getCameraID() === view?.camera,
              item &&
                item.start &&
                item.end &&
                targetTime.getTime() >= item.start &&
                targetTime.getTime() <= item.end
            );
          })));

    if (targetBarOn) {
      if (!this._targetBarVisible) {
        this._timeline?.addCustomTime(targetTime, TIMELINE_TARGET_BAR_ID);
        this._targetBarVisible = true;
      } else {
        this._timeline?.setCustomTime(targetTime, TIMELINE_TARGET_BAR_ID);
      }

      const window = this._timeline.getWindow();
      const markerProportion =
        (targetTime.getTime() - window.start.getTime()) /
        (window.end.getTime() - window.start.getTime());

      // Position the marker proportionally to how 'far' the pointer is being
      // held relative to the timeline window.
      this.setAttribute(
        'target-bar-marker-direction',
        markerProportion < 0.25 ? 'right' : markerProportion > 0.75 ? 'left' : 'center',
      );
      this._timeline?.setCustomTimeMarker?.(
        formatDateAndTime(targetTime, true),
        TIMELINE_TARGET_BAR_ID,
      );
    } else {
      this._removeTargetBar();
    }
  }

  /**
   * Remove the target bar.
   */
  protected _removeTargetBar(): void {
    this.removeAttribute('target-bar-direction');
    if (this._targetBarVisible) {
      this._timeline?.removeCustomTime(TIMELINE_TARGET_BAR_ID);
      this._targetBarVisible = false;
    }
  }

  /**
   * Set the view during a range change.
   * @param targetTime The target time.
   * @param properties The range change properties.
   * @returns
   */
  protected async _setViewDuringRangeChange(
    targetTime: Date,
    properties: TimelineRangeChange,
  ): Promise<void> {
    const view = this.viewManagerEpoch?.manager.getView();
    const results = view?.queryResults;
    const media = results?.getResults();
    const panMode = this._getEffectivePanMode();
    if (
      !media ||
      !results ||
      !this._timeline ||
      !view ||
      !this.hass ||
      !this.cameraManager ||
      panMode === 'pan'
    ) {
      return;
    }

    const canSeek = this._shouldSupportSeeking();
    let newResults: QueryResults | null = null;

    if (panMode === 'seek') {
      newResults = results
        .clone()
        .selectBestResult(
          (mediaArray) => findBestMediaTimeIndex(mediaArray, targetTime, view?.camera),
          {
            allCameras: true,
            main: true,
          },
        );
    } else if (panMode === 'seek-in-camera') {
      newResults = results
        .clone()
        .selectBestResult(
          (mediaArray) => findBestMediaTimeIndex(mediaArray, targetTime),
          {
            cameraID: view.camera,
          },
        )
        .promoteCameraSelectionToMainSelection(view.camera);
    } else if (panMode === 'seek-in-media') {
      newResults = results;
    }

    const desiredView: AdvancedCameraCardView = this.mini
      ? targetTime >= new Date()
        ? 'live'
        : 'media'
      : view.view;

    const selectedItem = newResults?.getSelectedResult();
    const selectedCamera = ViewItemClassifier.isMedia(selectedItem)
      ? selectedItem.getCameraID()
      : null;

    this.viewManagerEpoch?.manager.setViewByParameters({
      params: {
        ...(selectedCamera && { camera: selectedCamera }),
        view: desiredView,
        queryResults: newResults,
      },
      modifiers: [
        new MergeContextViewModifier({
          ...(canSeek && { mediaViewer: { seek: targetTime } }),
          ...this._getTimelineContext({ start: properties.start, end: properties.end }),
        }),
      ],
    });
  }

  protected _getEffectivePanMode(): TimelinePanMode {
    return this._panMode ?? this.timelineConfig?.pan_mode ?? 'pan';
  }

  /**
   * Called whenever the timeline is clicked.
   * @param properties The properties of the timeline click event.
   */
  protected async _timelineClickHandler(
    properties: TimelineEventPropertiesResult,
  ): Promise<void> {
    // Calls to stopEventFromActivatingCardWideActions() are included for
    // completeness. Timeline does not support card-wide events and they are
    // disabled in card.ts in `_getMergedActions`.
    if (
      this._ignoreClick ||
      (properties.what &&
        ['item', 'background', 'group-label', 'axis'].includes(properties.what))
    ) {
      stopEventFromActivatingCardWideActions(properties.event);
    }

    const view = this.viewManagerEpoch?.manager.getView();

    if (
      this._ignoreClick ||
      !view ||
      !this.viewManagerEpoch ||
      !this._timelineSource ||
      !properties.what
    ) {
      return;
    }

    let drawerAction: 'open' | 'close' = 'close';

    if (
      this.timelineConfig?.show_recordings &&
      properties.time &&
      ['background', 'axis'].includes(properties.what)
    ) {
      const query = this._createMediaQueries('recording');
      if (query) {
        await this.viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
          baseView: view,
          params: { view: 'recording', query: query },
          queryExecutorOptions: {
            selectResult: {
              time: {
                time: properties.time,
              },
            },
          },
        });
      }
    } else if (properties.item && properties.what === 'item') {
      const cameraID = String(properties.group);
      const id = String(properties.item);

      const criteria = {
        main: true,
        ...(cameraID && view.isGrid() && { cameraID: cameraID }),
      };
      const newResults = view.queryResults
        ?.clone()
        .resetSelectedResult()
        .selectResultIfFound((media) => media.getID() === properties.item, criteria);

      const context: ViewContext = mergeViewContext(this._getTimelineContext(), {
        mediaViewer: { seek: properties.time },
      });

      if (!newResults || !newResults.hasSelectedResult()) {
        // This can happen in a few situations:
        // - If this is a recording query (with recorded hours) and an event is
        //   clicked on the timeline
        // - If the current thumbnails/results is a filtered view from the media
        //   gallery (i.e. any case where the thumbnails may not be match the
        //   events on the timeline, e.g. in the snapshots viewer but
        //   mini-timeline showing all media).
        const query = this._createMediaQueries('event');
        if (query) {
          await this.viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
            params: { view: 'media', query: query },
            queryExecutorOptions: {
              selectResult: {
                id: id,
              },
              rejectResults: (results) => !results.hasResults(),
            },
            modifiers: [new MergeContextViewModifier(context)],
          });
        }
      } else {
        this.viewManagerEpoch.manager.setViewByParameters({
          params: {
            queryResults: newResults,
            view: this.itemClickAction === 'play' ? 'media' : view.view,
          },
          modifiers: [new MergeContextViewModifier(context)],
        });
      }

      if (this.itemClickAction === 'select') {
        drawerAction = 'open';
      }
    }

    fireAdvancedCameraCardEvent(this, `thumbnails:${drawerAction}`);

    this._ignoreClick = false;
  }

  /**
   * Get a broader prefetch window from a start and end basis.
   * @param window The window to broaden.
   * @returns A broader timeline.
   */
  protected _getPrefetchWindow(window: TimelineWindow): TimelineWindow {
    const delta = differenceInSeconds(window.end, window.start);
    return {
      start: sub(window.start, { seconds: delta }),
      end: add(window.end, { seconds: delta }),
    };
  }

  /**
   * Handle a range change in the timeline.
   * @param properties vis.js provided range information.
   */
  protected async _timelineRangeChangedHandler(properties: {
    start: Date;
    end: Date;
    byUser: boolean;
    event: Event & { additionalEvent: string };
  }): Promise<void> {
    this._removeTargetBar();
    const view = this.viewManagerEpoch?.manager.getView();

    if (
      !this._timeline ||
      !view ||
      // When in mini mode, something else is in charge of the primary media
      // population (e.g. the live view), in this case only act when the user
      // themselves are interacting with the timeline.
      (this.mini && !properties.byUser)
    ) {
      return;
    }

    await this._timelineSource?.refresh(this._getPrefetchWindow(properties));

    const queryType = QueryClassifier.getQueryType(view.query);
    if (!queryType) {
      return;
    }
    const mediaQuery = this._createMediaQueries(queryType);
    if (!mediaQuery || this._alreadyHasAcceptableMediaQuery(mediaQuery)) {
      return;
    }

    await this.viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
      params: {
        query: mediaQuery,
      },
      queryExecutorOptions: {
        selectResult: {
          id:
            this.viewManagerEpoch?.manager
              .getView()
              ?.queryResults?.getSelectedResult()
              ?.getID() ?? undefined,
        },
      },
      modifiers: [new MergeContextViewModifier(this._getTimelineContext())],
    });
  }

  protected _createMediaQueries(
    type: QueryType,
    options?: {
      window?: TimelineWindow;
    },
  ): MediaQueries | null {
    if (!this._timeline || !this._timelineSource) {
      return null;
    }

    const cacheFriendlyWindow = convertRangeToCacheFriendlyTimes(
      this._getPrefetchWindow(options?.window ?? this._timeline.getWindow()),
    );

    if (type === 'event') {
      const queries = this._timelineSource.getTimelineEventQueries(cacheFriendlyWindow);
      return queries ? new EventMediaQuery(queries) : null;
    } else if (type === 'recording') {
      const queries =
        this._timelineSource.getTimelineRecordingQueries(cacheFriendlyWindow);
      return queries ? new RecordingMediaQuery(queries) : null;
    }
    return null;
  }

  /**
   * Build the visjs dataset to render on the timeline.
   * @returns The dataset.
   */
  protected _getGroups(): DataGroupCollectionType {
    const groups: AdvancedCameraCardGroupData[] = [];
    (this.cameraIDs ?? []).forEach((cameraID: string) => {
      if (!this.hass || !this.cameraManager) {
        return;
      }
      const cameraMetadata = this.cameraManager.getCameraMetadata(cameraID);

      if (cameraMetadata) {
        groups.push({
          id: cameraID,
          content: cameraMetadata.title,
        });
      }
    });
    return new DataSet(groups);
  }

  protected _getPerfectWindowFromMediaStartAndEndTime(
    isEvent: boolean,
    startTime: Date | null,
    endTime: Date | null,
  ): TimelineWindow | null {
    if (isEvent) {
      const windowSeconds = this._getConfiguredWindowSeconds();

      if (startTime && endTime) {
        if (endTime.getTime() - startTime.getTime() > windowSeconds * 1000) {
          // If the event is larger than the configured window, only show the most
          // recent portion of the event that fits in the window.
          return {
            start: sub(endTime, { seconds: windowSeconds }),
            end: endTime,
          };
        } else {
          // If the event is shorter than the configured window, center the event
          // in the window.
          const gap = windowSeconds - (endTime.getTime() - startTime.getTime()) / 1000;
          return {
            start: sub(startTime, { seconds: gap / 2 }),
            end: add(endTime, { seconds: gap / 2 }),
          };
        }
      } else if (startTime) {
        // If there's no end-time yet, place the start-time in the center of the
        // time window.
        return {
          start: sub(startTime, { seconds: windowSeconds / 2 }),
          end: add(startTime, { seconds: windowSeconds / 2 }),
        };
      }
    } else if (startTime && endTime) {
      return {
        start: startTime,
        end: endTime,
      };
    }
    return null;
  }

  /**
   * Get the configured window length in seconds.
   */
  protected _getConfiguredWindowSeconds(): number {
    return this.timelineConfig?.window_seconds ?? configDefaults.timeline.window_seconds;
  }

  /**
   * Get desired timeline start/end time.
   * @returns A tuple of start/end date.
   */
  protected _getDefaultStartEnd(): TimelineWindow {
    const end = new Date();
    const start = sub(end, {
      seconds: this._getConfiguredWindowSeconds(),
    });
    return { start: start, end: end };
  }

  /**
   * Determine if the timeline should use clustering.
   * @returns `true` if the timeline should cluster, `false` otherwise.
   */
  protected _isClustering(): boolean {
    return (
      this.timelineConfig?.style === 'stack' &&
      !!this.timelineConfig?.clustering_threshold &&
      this.timelineConfig.clustering_threshold > 0
    );
  }

  protected _getDateTimeFormat(): TimelineFormatOption {
    const format24Hour = !!this.timelineConfig?.format?.['24h'];

    // See: https://visjs.github.io/vis-timeline/docs/timeline/#Configuration_Options
    return {
      minorLabels: {
        minute: format24Hour ? 'HH:mm' : 'h:mm A',
        hour: format24Hour ? 'HH:mm' : 'h:mm A',
      },
      majorLabels: {
        millisecond: format24Hour ? 'HH:mm:ss' : 'h:mm:ss A',
        second: format24Hour ? 'D MMMM HH:mm' : 'D MMMM h:mm A',
      },
    };
  }

  /**
   * Get timeline options.
   */
  protected _getOptions(): TimelineOptions | null {
    if (!this.timelineConfig) {
      return null;
    }

    const defaultWindow = this._getDefaultStartEnd();
    const stack = this.timelineConfig.style === 'stack';
    // Configuration for the Timeline, see:
    // https://visjs.github.io/vis-timeline/docs/timeline/#Configuration_Options
    return {
      cluster: this._isClustering()
        ? {
            // It would be better to automatically calculate `maxItems` from the
            // rendered height of the timeline (or group within the timeline) so
            // as to not waste vertical space (e.g. after the user changes to
            // fullscreen mode). Unfortunately this is not easy to do, as we
            // don't know the height of the timeline until after it renders --
            // and if we adjust `maxItems` then we can get into an infinite
            // resize loop. Adjusting the `maxItems` of a timeline, after it's
            // created, also does not appear to work as expected.
            maxItems: this.timelineConfig.clustering_threshold,

            clusterCriteria: (first: TimelineItem, second: TimelineItem): boolean => {
              const selectedIDs = this._getAllSelectedMediaIDsFromView();
              const firstMedia = (<AdvancedCameraCardTimelineItem>first).media;
              const secondMedia = (<AdvancedCameraCardTimelineItem>second).media;

              // Never include the currently selected item in a cluster, and
              // never group different object types together (e.g. person and
              // car).
              return (
                first.type !== 'background' &&
                first.type === second.type &&
                !selectedIDs.includes(first.id) &&
                !selectedIDs.includes(second.id) &&
                !!firstMedia &&
                !!secondMedia &&
                ViewItemClassifier.isEvent(firstMedia) &&
                ViewItemClassifier.isEvent(secondMedia) &&
                firstMedia.isGroupableWith(secondMedia)
              );
            },
          }
        : // Timeline type information is incorrect requiring this 'as'.
          (false as unknown as TimelineOptionsCluster),
      minHeight: '100%',
      maxHeight: '100%',
      zoomMax: 1 * 24 * 60 * 60 * 1000,
      zoomMin: 1 * 1000,
      margin: {
        item: {
          // In ribbon mode, a 20px item is reduced to 6px, so need to add a
          // 14px margin to ensure items line up with subgroups.
          vertical: stack ? 10 : 24,
        },
      },
      selectable: true,
      stack: stack,
      start: defaultWindow.start,
      end: defaultWindow.end,
      groupHeightMode: 'auto',
      tooltip: {
        followMouse: true,
        overflowMethod: 'cap',
        template: this._getTooltip.bind(this),
      },
      format: this._getDateTimeFormat(),
      xss: {
        disabled: false,
        filterOptions: {
          whiteList: {
            'advanced-camera-card-timeline-thumbnail': ['details', 'item'],
            div: ['title'],
            span: ['style'],
          },
        },
      },
    };
  }

  /**
   * Determine if the component should be updated.
   * @param _changedProps The changed properties.
   * @returns
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  protected shouldUpdate(_changedProps: PropertyValues): boolean {
    return !!this.hass && !!this.cameraManager;
  }

  protected _getAllSelectedMediaIDsFromView(): IdType[] {
    const view = this.viewManagerEpoch?.manager.getView();
    return (
      view?.queryResults?.getMultipleSelectedResults({
        main: true,
        ...(view.isGrid() && { allCameras: true }),
      }) ?? []
    )
      .filter((media) => ViewItemClassifier.isEvent(media))
      .map((media) => media.getID())
      .filter(isTruthy);
  }

  /**
   * Update the timeline from the view object.
   */
  protected async _updateTimelineFromView(): Promise<void> {
    const view = this.viewManagerEpoch?.manager.getView();
    if (!view || !this.timelineConfig || !this._timelineSource || !this._timeline) {
      return;
    }

    const timelineWindow = this._timeline.getWindow();

    // Calculate the timeline window to show. If there is a window set in the
    // view context, always honor that. Otherwise, if there's a selected media
    // item that is already within the current window (even if it's not
    // perfectly positioned) -- leave it as is. Otherwise, change the window to
    // perfectly center on the media.

    let desiredWindow = timelineWindow;
    const item = view.queryResults?.getSelectedResult();
    const media = item && ViewItemClassifier.isMedia(item) ? item : null;
    const mediaStartTime = media?.getStartTime() ?? null;
    const mediaEndTime = media?.getEndTime() ?? null;
    const mediaIsEvent = media ? ViewItemClassifier.isEvent(media) : false;

    const mediaWindow: TimelineWindow | null =
      media && mediaStartTime
        ? // If this media has no end time, it's just a "point" in time so the
          // range effectively starts/ends at the same time.
          { start: mediaStartTime, end: mediaEndTime ?? mediaStartTime }
        : null;
    const context = view.context?.timeline;

    if (context && context.window) {
      desiredWindow = context.window;
    } else if (mediaWindow && !rangesOverlap(mediaWindow, timelineWindow)) {
      const perfectMediaWindow = this._getPerfectWindowFromMediaStartAndEndTime(
        mediaIsEvent,
        mediaStartTime,
        mediaEndTime,
      );
      if (perfectMediaWindow) {
        desiredWindow = perfectMediaWindow;
      }
    }
    const prefetchedWindow = this._getPrefetchWindow(desiredWindow);

    if (!this._pointerHeld) {
      // Don't fetch any data or touch the timeline in any way if the user is
      // currently interacting with it. Without this the subsequent data fetches
      // (via fetchIfNecessary) may update the timeline contents which causes
      // the visjs timeline to stop dragging/panning operations which is very
      // disruptive to the user.
      await this._timelineSource?.refresh(prefetchedWindow);
    }

    const currentSelection = this._timeline.getSelection();
    const mediaIDsToSelect = this._getAllSelectedMediaIDsFromView();

    const needToSelect = mediaIDsToSelect.some(
      (mediaID) => !currentSelection.includes(mediaID),
    );

    if (needToSelect) {
      if (this._isClustering()) {
        // Hack: Clustering may not update unless the dataset changes, artifically
        // update the dataset to ensure the newly selected item cannot be included
        // in a cluster.

        for (const mediaID of mediaIDsToSelect) {
          // Need to this rewrite prior to setting the selection (just below), or
          // the selection will be lost on rewrite.
          this._timelineSource?.rewriteEvent(mediaID);
        }
      }

      this._timeline?.setSelection(mediaIDsToSelect, {
        focus: false,
        animation: {
          animation: false,
          zoom: false,
        },
      });
    }

    // Set the timeline window if necessary.
    if (!this._pointerHeld && !isEqual(desiredWindow, timelineWindow)) {
      this._timeline.setWindow(desiredWindow.start, desiredWindow.end);
    }

    // Only generate thumbnails if the existing query is not an acceptable
    // match, to avoid getting stuck in a loop (the subsequent fetches will not
    // actually fetch since the data will have been cached).
    //
    // Timeline receives a new `view`
    //  -> Events fetched
    //    -> Thumbnails generated
    //      -> New view dispatched (to load thumbnails into outer carousel).
    //  -> New view received ... [loop]
    //
    // Also don't generate thumbnails in mini-timelines (they will already have
    // been generated).

    const queryType = QueryClassifier.getQueryType(view.query);
    if (!queryType) {
      return;
    }

    const freshMediaQuery = this._createMediaQueries(queryType, {
      window: desiredWindow,
    });

    if (
      !this.mini &&
      freshMediaQuery &&
      !this._alreadyHasAcceptableMediaQuery(freshMediaQuery)
    ) {
      const currentlySelectedResult = this.viewManagerEpoch?.manager
        .getView()
        ?.queryResults?.getSelectedResult();

      await this.viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
        params: {
          query: freshMediaQuery,
        },
        queryExecutorOptions: {
          selectResult: {
            id: currentlySelectedResult?.getID() ?? undefined,
          },
        },
        modifiers: [
          new MergeContextViewModifier(this._getTimelineContext(desiredWindow)),
        ],
      });
    }
  }

  protected _alreadyHasAcceptableMediaQuery(freshMediaQuery: MediaQueries): boolean {
    const view = this.viewManagerEpoch?.manager.getView();
    const query = view?.query;

    if (!this.cameraManager || !query || !QueryClassifier.isMediaQuery(query)) {
      return false;
    }

    const currentQueries = query?.getQuery();
    const currentResultTimestamp = view?.queryResults?.getResultsTimestamp();

    return (
      !!currentQueries &&
      !!currentResultTimestamp &&
      !!query?.isSupersetOf(freshMediaQuery) &&
      this.cameraManager.areMediaQueriesResultsFresh<MediaQuery>(
        currentQueries,
        currentResultTimestamp,
      )
    );
  }

  /**
   * Generate the context for timeline views.
   * @returns The TimelineViewContext object.
   */
  protected _getTimelineContext(window?: TimelineWindow): ViewContext {
    const view = this.viewManagerEpoch?.manager.getView();
    const newWindow = window ?? this._timeline?.getWindow();
    return {
      timeline: {
        ...view?.context?.timeline,
        ...(newWindow && { window: newWindow }),
      },
    };
  }

  /**
   * Called when an update will occur.
   * @param changedProps The changed properties
   */
  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('thumbnailConfig')) {
      if (this.thumbnailConfig) {
        this.style.setProperty(
          '--advanced-camera-card-thumbnail-size',
          `${this.thumbnailConfig.size}px`,
        );
      } else {
        this.style.removeProperty('--advanced-camera-card-thumbnail-size');
      }
    }

    if (changedProps.has('timelineConfig')) {
      setOrRemoveAttribute(this, !!this.timelineConfig?.show_recordings, 'recordings');
      setOrRemoveAttribute(this, this.timelineConfig?.style === 'ribbon', 'ribbon');
      setOrRemoveAttribute(this, this.timelineConfig?.style === 'stack', 'stack');
    }

    if (
      changedProps.has('cameraManager') ||
      changedProps.has('cameras') ||
      changedProps.has('timelineConfig') ||
      changedProps.has('cameraIDs')
    ) {
      if (this.cameraIDs?.size && this.cameraManager && this.timelineConfig) {
        this._timelineSource = new TimelineDataSource(
          this.cameraManager,
          this.cameraIDs,
          this.timelineConfig.events_media_type,
          this.timelineConfig.show_recordings,
        );
      } else {
        this._timelineSource = null;
      }
    }
  }

  /**
   * Destroy/reset the timeline.
   */
  protected _destroy(): void {
    this._timeline?.destroy();
    this._timeline = undefined;
    this._targetBarVisible = false;
    this._pointerHeld = null;
  }

  /**
   * Called when the component is updated.
   * @param changedProperties The changed properties if any.
   */
  protected updated(changedProperties: PropertyValues): void {
    super.updated(changedProperties);

    if (changedProperties.has('cameras') || changedProperties.has('cameraManager')) {
      this._destroy();
    }

    let createdTimeline = false;

    if (
      this._timelineSource &&
      this._refTimeline.value &&
      this.timelineConfig &&
      (!this._timeline ||
        changedProperties.has('timelineConfig') ||
        changedProperties.has('cameraIDs'))
    ) {
      if (this._timeline) {
        this._destroy();
      }

      const groups = this._getGroups();
      if (!groups.length) {
        return;
      }

      const options = this._getOptions();
      if (options) {
        createdTimeline = true;
        const noGroups = this.mini && groups.length === 1;
        if (noGroups) {
          this._timeline = new Timeline(
            this._refTimeline.value,
            this._timelineSource.dataset,
            options,
          ) as Timeline;
        } else {
          this._timeline = new Timeline(
            this._refTimeline.value,
            this._timelineSource.dataset,
            groups,
            options,
          ) as Timeline;
        }
        setOrRemoveAttribute(this, !noGroups, 'groups');

        this._timeline.on('rangechanged', this._timelineRangeChangedHandler.bind(this));
        this._timeline.on('click', this._timelineClickHandler.bind(this));
        this._timeline.on('rangechange', this._timelineRangeChangeHandler.bind(this));

        // This complexity exists to ensure we can tell between a click that
        // causes the timeline zoom/range to change, and a 'static' click on the
        // // timeline (which may need to trigger a card wide event).
        this._timeline.on('mouseDown', (ev: TimelineEventPropertiesResult) => {
          const window = this._timeline?.getWindow();
          this._pointerHeld = {
            ...ev,
            ...(window && { window: window }),
          };
          this._ignoreClick = false;
        });
        this._timeline.on('mouseUp', () => {
          this._pointerHeld = null;
          this._removeTargetBar();
        });
      }
    }

    if (createdTimeline) {
      // If the timeline was just created, give it one frame to draw itself.
      // Failure to do so may result in subsequent calls to
      // `this._timeline.setwindow()` being entirely ignored. Example case:
      // Clicking the timeline control on a recording thumbnail.
      window.requestAnimationFrame(this._updateTimelineFromView.bind(this));
    } else if (changedProperties.has('viewManagerEpoch')) {
      this._updateTimelineFromView();
    }
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(timelineCoreStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-timeline-thumbnail': AdvancedCameraCardTimelineThumbnail;
    'advanced-camera-card-timeline-core': AdvancedCameraCardTimelineCore;
  }
}



================================================
FILE: src/components/timeline.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { CameraManager } from '../camera-manager/manager';
import { ViewItemManager } from '../card-controller/view/item-manager';
import { ViewManagerEpoch } from '../card-controller/view/types';
import { TimelineConfig } from '../config/schema/timeline';
import { CardWideConfig } from '../config/schema/types';
import { HomeAssistant } from '../ha/types';
import basicBlockStyle from '../scss/basic-block.scss';
import './surround.js';
import './timeline-core.js';

@customElement('advanced-camera-card-timeline')
export class AdvancedCameraCardTimeline extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public timelineConfig?: TimelineConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  protected render(): TemplateResult | void {
    if (!this.timelineConfig) {
      return html``;
    }

    return html`
      <advanced-camera-card-timeline-core
        .hass=${this.hass}
        .viewManagerEpoch=${this.viewManagerEpoch}
        .timelineConfig=${this.timelineConfig}
        .thumbnailConfig=${this.timelineConfig.controls.thumbnails}
        .cameraManager=${this.cameraManager}
        .viewItemManager=${this.viewItemManager}
        .cameraIDs=${this.cameraManager?.getStore().getCameraIDsWithCapability({
          anyCapabilities: ['clips', 'snapshots', 'recordings'],
        })}
        .cardWideConfig=${this.cardWideConfig}
        .itemClickAction=${this.timelineConfig.controls.thumbnails.mode === 'none'
          ? 'play'
          : 'select'}
      >
      </advanced-camera-card-timeline-core>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(basicBlockStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-timeline': AdvancedCameraCardTimeline;
  }
}



================================================
FILE: src/components/video-player.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { VideoMediaPlayerController } from '../components-lib/media-player/video';
import videoPlayerStyle from '../scss/video-player.scss';
import { MediaPlayer, MediaPlayerController, MediaPlayerElement } from '../types';
import { mayHaveAudio } from '../utils/audio';
import {
  hideMediaControlsTemporarily,
  MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
} from '../utils/controls';
import {
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
  dispatchMediaVolumeChangeEvent,
} from '../utils/media-info';

@customElement('advanced-camera-card-video-player')
export class AdvancedCameraCardVideoPlayer extends LitElement implements MediaPlayer {
  @property()
  public url?: string;

  @property({ type: Boolean })
  public controls = false;

  protected _refVideo: Ref<MediaPlayerElement<HTMLVideoElement>> = createRef();
  protected _mediaPlayerController = new VideoMediaPlayerController(
    this,
    () => this._refVideo.value ?? null,
    () => this.controls,
  );

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    return this._mediaPlayerController;
  }

  protected render(): TemplateResult | void {
    return html`
      <video
        ${ref(this._refVideo)}
        muted
        playsinline
        crossorigin="anonymous"
        ?autoplay=${false}
        ?controls=${this.controls}
        @loadedmetadata=${(ev: Event) => {
          if (ev.target && this.controls) {
            hideMediaControlsTemporarily(
              ev.target as HTMLVideoElement,
              MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
            );
          }
        }}
        @loadeddata=${(ev: Event) => {
          dispatchMediaLoadedEvent(this, ev, {
            ...(this._mediaPlayerController && {
              mediaPlayerController: this._mediaPlayerController,
            }),
            capabilities: {
              supportsPause: true,
              hasAudio: mayHaveAudio(ev.target as HTMLVideoElement),
            },
            technology: ['mp4'],
          });
        }}
        @volumechange=${() => dispatchMediaVolumeChangeEvent(this)}
        @play=${() => dispatchMediaPlayEvent(this)}
        @pause=${() => dispatchMediaPauseEvent(this)}
      >
        <source src="${ifDefined(this.url)}" type="video/mp4" />
      </video>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(videoPlayerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-video-player': AdvancedCameraCardVideoPlayer;
  }
}



================================================
FILE: src/components/views.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { CameraManager } from '../camera-manager/manager.js';
import { MicrophoneState } from '../card-controller/types.js';
import { ViewItemManager } from '../card-controller/view/item-manager.js';
import { ViewManagerEpoch } from '../card-controller/view/types.js';
import { AdvancedCameraCardConfig, CardWideConfig } from '../config/schema/types.js';
import { RawAdvancedCameraCardConfig } from '../config/types.js';
import { DeviceRegistryManager } from '../ha/registry/device/index.js';
import { ResolvedMediaCache } from '../ha/resolved-media.js';
import { HomeAssistant } from '../ha/types.js';
import viewsStyle from '../scss/views.scss';
import './surround.js';

// As a special case: The diagnostics view is not dynamically loaded in case
// something goes wrong.
import './diagnostics.js';

@customElement('advanced-camera-card-views')
export class AdvancedCameraCardViews extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public config?: AdvancedCameraCardConfig;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public rawConfig?: RawAdvancedCameraCardConfig;

  @property({ attribute: false })
  public resolvedMediaCache?: ResolvedMediaCache;

  @property({ attribute: false })
  public hide?: boolean;

  @property({ attribute: false })
  public microphoneState?: MicrophoneState;

  @property({ attribute: false })
  public triggeredCameraIDs?: Set<string>;

  @property({ attribute: false })
  public deviceRegistryManager?: DeviceRegistryManager;

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('viewManagerEpoch') || changedProps.has('config')) {
      const view = this.viewManagerEpoch?.manager.getView();
      if (view?.is('live') || this._shouldLivePreload()) {
        import('./live/index.js');
      }
      if (view?.isMediaGalleryView() && !view.is('folders')) {
        import('./gallery/media-gallery.js');
      } else if (view?.isViewerView()) {
        import('./viewer/index.js');
      } else if (view?.is('image')) {
        import('./image.js');
      } else if (view?.is('timeline')) {
        import('./timeline.js');
      } else if (view?.is('folders')) {
        import('./gallery/folder-gallery.js');
      }
    }

    if (changedProps.has('hide')) {
      if (this.hide) {
        this.setAttribute('hidden', '');
      } else {
        this.removeAttribute('hidden');
      }
    }
  }

  protected _shouldLivePreload(): boolean {
    const view = this.viewManagerEpoch?.manager.getView();
    return (
      // Special case: Never preload for diagnostics -- we want that to be as
      // minimal as possible.
      !!this.config?.live.preload && !view?.is('diagnostics')
    );
  }

  protected render(): TemplateResult | void {
    // Only essential items should be added to the below list, since we want the
    // overall views pane to render in ~almost all cases (e.g. for a camera
    // initialization error to display, `view` and `cameraConfig` may both be
    // undefined, but we still want to render).
    if (!this.hass || !this.config || !this.cardWideConfig) {
      return html``;
    }

    const view = this.viewManagerEpoch?.manager.getView();

    // Render but hide the live view if there's a message, or if it's preload
    // mode and the view is not live.
    const liveClasses = {
      hidden: this._shouldLivePreload() && !view?.is('live'),
    };
    const overallClasses = {
      hidden: !!this.hide,
    };

    const thumbnailConfig = view?.is('live')
      ? this.config.live.controls.thumbnails
      : view?.isViewerView()
        ? this.config.media_viewer.controls.thumbnails
        : view?.is('timeline')
          ? this.config.timeline.controls.thumbnails
          : undefined;

    const miniTimelineConfig = view?.is('live')
      ? this.config.live.controls.timeline
      : view?.isViewerView()
        ? this.config.media_viewer.controls.timeline
        : undefined;

    const cameraConfig = view
      ? this.cameraManager?.getStore().getCameraConfig(view.camera) ?? null
      : null;

    return html` <advanced-camera-card-surround
      class="${classMap(overallClasses)}"
      .hass=${this.hass}
      .viewManagerEpoch=${this.viewManagerEpoch}
      .thumbnailConfig=${!this.hide ? thumbnailConfig : undefined}
      .timelineConfig=${!this.hide ? miniTimelineConfig : undefined}
      .cameraManager=${this.cameraManager}
      .viewItemManager=${this.viewItemManager}
      .cardWideConfig=${this.cardWideConfig}
    >
      ${!this.hide && view?.is('image') && cameraConfig
        ? html` <advanced-camera-card-image
            .imageConfig=${this.config.image}
            .viewManagerEpoch=${this.viewManagerEpoch}
            .hass=${this.hass}
            .cameraConfig=${cameraConfig}
            .cameraManager=${this.cameraManager}
          >
          </advanced-camera-card-image>`
        : ``}
      ${!this.hide && view?.isMediaGalleryView() && !view.is('folders')
        ? html` <advanced-camera-card-media-gallery
            .hass=${this.hass}
            .viewManagerEpoch=${this.viewManagerEpoch}
            .galleryConfig=${this.config.media_gallery}
            .cameraManager=${this.cameraManager}
            .viewItemManager=${this.viewItemManager}
            .cardWideConfig=${this.cardWideConfig}
          >
          </advanced-camera-card-media-gallery>`
        : ``}
      ${!this.hide && view?.isViewerView()
        ? html`
            <advanced-camera-card-viewer
              .hass=${this.hass}
              .viewManagerEpoch=${this.viewManagerEpoch}
              .viewerConfig=${this.config.media_viewer}
              .resolvedMediaCache=${this.resolvedMediaCache}
              .cameraManager=${this.cameraManager}
              .cardWideConfig=${this.cardWideConfig}
            >
            </advanced-camera-card-viewer>
          `
        : ``}
      ${!this.hide && view?.is('timeline')
        ? html` <advanced-camera-card-timeline
            .hass=${this.hass}
            .viewManagerEpoch=${this.viewManagerEpoch}
            .timelineConfig=${this.config.timeline}
            .cameraManager=${this.cameraManager}
            .viewItemManager=${this.viewItemManager}
            .cardWideConfig=${this.cardWideConfig}
          >
          </advanced-camera-card-timeline>`
        : ``}
      ${!this.hide && view?.is('diagnostics')
        ? html` <advanced-camera-card-diagnostics
            .hass=${this.hass}
            .rawConfig=${this.rawConfig}
            .deviceRegistryManager=${this.deviceRegistryManager}
          >
          </advanced-camera-card-diagnostics>`
        : ``}
      ${!this.hide && view?.is('folders')
        ? html` <advanced-camera-card-folder-gallery
            .hass=${this.hass}
            .viewManagerEpoch=${this.viewManagerEpoch}
            .viewItemManager=${this.viewItemManager}
            .galleryConfig=${this.config.media_gallery}
          ></advanced-camera-card-folder-gallery>`
        : ``}
      ${
        // Note: Subtle difference in condition below vs the other views in
        // order to always render the live view for live.preload mode.
        this._shouldLivePreload() || (!this.hide && view?.is('live'))
          ? html`
              <advanced-camera-card-live
                .hass=${this.hass}
                .viewManagerEpoch=${this.viewManagerEpoch}
                .liveConfig=${this.config.live}
                .cameraManager=${this.cameraManager}
                .cardWideConfig=${this.cardWideConfig}
                .microphoneState=${this.microphoneState}
                .triggeredCameraIDs=${this.triggeredCameraIDs}
                class="${classMap(liveClasses)}"
              >
              </advanced-camera-card-live>
            `
          : ``
      }
    </advanced-camera-card-surround>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(viewsStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-views': AdvancedCameraCardViews;
  }
}



================================================
FILE: src/components/zoomer.ts
================================================
import {
  css,
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { ZoomController } from '../components-lib/zoom/zoom-controller.js';
import { setOrRemoveAttribute } from '../utils/basic.js';
import { PartialZoomSettings } from '../components-lib/zoom/types.js';

@customElement('advanced-camera-card-zoomer')
export class AdvancedCameraCardZoomer extends LitElement {
  protected _zoom: ZoomController | null = null;

  @property({ attribute: false })
  public defaultSettings?: PartialZoomSettings;

  @property({ attribute: false })
  public settings?: PartialZoomSettings | null;

  @state()
  protected _zoomed = false;

  protected _zoomHandler = () => (this._zoomed = true);
  protected _unzoomHandler = () => (this._zoomed = false);

  connectedCallback(): void {
    super.connectedCallback();
    this.addEventListener('advanced-camera-card:zoom:zoomed', this._zoomHandler);
    this.addEventListener('advanced-camera-card:zoom:unzoomed', this._unzoomHandler);

    // Call for an update to activate.
    this.requestUpdate();
  }

  disconnectedCallback(): void {
    this._zoom?.deactivate();
    this.removeEventListener('advanced-camera-card:zoom:zoomed', this._zoomHandler);
    this.removeEventListener('advanced-camera-card:zoom:unzoomed', this._unzoomHandler);
    super.disconnectedCallback();
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('_zoomed')) {
      setOrRemoveAttribute(this, this._zoomed, 'zoomed');
    }

    if (this._zoom) {
      if (changedProps.has('defaultSettings')) {
        this._zoom.setDefaultSettings(this.defaultSettings ?? null);
      }
      // If config is null, make no change to the zoom.
      if (changedProps.has('settings') && this.settings) {
        this._zoom.setSettings(this.settings);
      }
    } else {
      // Ensure that the configuration will be set before activation (vs
      // activating in `connectedCallback`).
      this._zoom = new ZoomController(this, {
        config: this.settings,
        defaultConfig: this.defaultSettings,
      });
      this._zoom.activate();
    }
  }

  protected render(): TemplateResult | void {
    return html` <slot></slot> `;
  }

  static get styles(): CSSResultGroup {
    return css`
      :host {
        width: 100%;
        height: 100%;
        display: block;
        cursor: auto;
      }
      :host([zoomed]) {
        cursor: move;
      }
    `;
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-zoomer': AdvancedCameraCardZoomer;
  }
}



================================================
FILE: src/components/gallery/folder-gallery.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ViewItemManager } from '../../card-controller/view/item-manager.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import {
  getUpFolderMediaItem,
  upFolderClickHandler,
} from '../../components-lib/folder/up-folder.js';
import { FolderGalleryController } from '../../components-lib/gallery/folder-gallery-controller.js';
import { MediaGalleryConfig } from '../../config/schema/media-gallery.js';
import { HomeAssistant } from '../../ha/types.js';
import { localize } from '../../localize/localize';
import folderGalleryStyle from '../../scss/folder-gallery.scss';
import { ViewItem } from '../../view/item.js';
import '../media-filter';
import '../message.js';
import { renderMessage } from '../message.js';
import '../surround-basic';
import '../thumbnail/thumbnail.js';
import './gallery-core.js';

@customElement('advanced-camera-card-folder-gallery')
export class AdvancedCameraCardFolderGallery extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public galleryConfig?: MediaGalleryConfig;

  protected _controller = new FolderGalleryController(this);

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('galleryConfig')) {
      this._controller.setThumbnailSize(this.galleryConfig?.controls.thumbnails.size);
    }
  }

  protected _renderThumbnail(
    item: ViewItem,
    selected: boolean,
    clickCallback: (item: ViewItem, ev: Event) => void,
  ): TemplateResult | void {
    return html`<advanced-camera-card-thumbnail
      class=${classMap({
        selected,
      })}
      .hass=${this.hass}
      .item=${item}
      .viewManagerEpoch=${this.viewManagerEpoch}
      .viewItemManager=${this.viewItemManager}
      ?selected=${selected}
      ?details=${!!this.galleryConfig?.controls.thumbnails.show_details}
      ?show_favorite_control=${!!this.galleryConfig?.controls.thumbnails
        .show_favorite_control}
      ?show_timeline_control=${!!this.galleryConfig?.controls.thumbnails
        .show_timeline_control}
      ?show_download_control=${!!this.galleryConfig?.controls.thumbnails
        .show_download_control}
      @click=${(ev: Event) => clickCallback(item, ev)}
    >
    </advanced-camera-card-thumbnail>`;
  }

  protected _renderThumbnails(): TemplateResult | void {
    const selected = this.viewManagerEpoch?.manager
      .getView()
      ?.queryResults?.getSelectedResult();

    return html`
      ${this.viewManagerEpoch?.manager
        .getView()
        ?.queryResults?.getResults()
        ?.map((item) =>
          this._renderThumbnail(item, item === selected, (item: ViewItem, ev: Event) => {
            const manager = this.viewManagerEpoch?.manager;
            if (manager) {
              this._controller.itemClickHandler(manager, item, ev);
            }
          }),
        )}
    `;
  }

  protected render(): TemplateResult | void {
    const folderIsLoading =
      !!this.viewManagerEpoch?.manager.getView()?.context?.loading?.query;
    const upThumbnail = getUpFolderMediaItem(this.viewManagerEpoch?.manager.getView());

    return html`
      <advanced-camera-card-surround-basic>
        ${!this.viewManagerEpoch?.manager.getView()?.queryResults?.hasResults() &&
        (folderIsLoading || !upThumbnail)
          ? renderMessage({
              type: 'info',
              message: folderIsLoading
                ? localize('error.awaiting_folder')
                : localize('common.no_folder'),
              icon: 'mdi:folder-play',
              dotdotdot: folderIsLoading,
            })
          : html`<advanced-camera-card-gallery-core
              .hass=${this.hass}
              .columnWidth=${this._controller.getColumnWidth(
                this.galleryConfig?.controls.thumbnails,
              )}
              .columnCountRoundMethod=${this._controller.getColumnCountRoundMethod(
                this.galleryConfig?.controls.thumbnails,
              )}
            >
              ${upThumbnail
                ? this._renderThumbnail(
                    upThumbnail,
                    false,
                    (item: ViewItem, ev: Event) =>
                      upFolderClickHandler(item, ev, this.viewManagerEpoch),
                  )
                : ''}
              ${this._renderThumbnails()}
            </advanced-camera-card-gallery-core>`}
      </advanced-camera-card-surround-basic>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(folderGalleryStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-folder-gallery': AdvancedCameraCardFolderGallery;
  }
}



================================================
FILE: src/components/gallery/gallery-core.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import {
  GalleryColumnCountRoundMethod,
  GalleryCoreController,
} from '../../components-lib/gallery/gallery-core-controller.js';
import { THUMBNAIL_WIDTH_DEFAULT } from '../../config/schema/common/controls/thumbnails.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { HomeAssistant } from '../../ha/types.js';
import galleryCoreStyle from '../../scss/gallery-core.scss';
import '../message.js';
import '../progress-indicator.js';
import { renderProgressIndicator } from '../progress-indicator.js';

@customElement('advanced-camera-card-gallery-core')
export class AdvancedCameraCardGalleryCore extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public columnWidth: number = THUMBNAIL_WIDTH_DEFAULT;

  @property({ attribute: false })
  public columnCountRoundMethod?: GalleryColumnCountRoundMethod;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public extendUp = false;

  @property({ attribute: false })
  public extendDown = false;

  private _refSentinelBottom: Ref<HTMLElement> = createRef();
  private _refSlot: Ref<HTMLSlotElement> = createRef();

  private _controller = new GalleryCoreController(
    this,
    () => this._refSlot.value ?? null,
    () => this._refSentinelBottom.value ?? null,
    (show) => {
      this._showLoaderTop = show;
    },
    (show) => {
      this._showSentinelBottom = show;
    },
  );

  // Top loader: A progress indicator is shown across the top of the gallery if
  // the user is _already_ at the top of the gallery and scrolls upwards. This
  // attempts to fetch new content from "later" (more recently) than the current
  // query. This is hidden by default.
  @state()
  private _showLoaderTop = false;

  // Bottom sentinel: A progress indicator shown in a "cell" (not across) at the
  // bottom of the gallery. Once visible an attempt is optionally made to extend
  // the gallery downwards. This is rendered by default (so intersection can be
  // detected), and hidden during fetches.
  @state()
  private _showSentinelBottom = true;

  protected willUpdate(changedProps: PropertyValues): void {
    if (
      ['columnCountRoundMethod', 'columnWidth', 'extendUp', 'extendDown'].some((prop) =>
        changedProps.has(prop),
      )
    ) {
      this._controller.setOptions({
        extendUp: this.extendUp,
        extendDown: this.extendDown,
        columnWidth: this.columnWidth,
        columnCountRoundMethod: this.columnCountRoundMethod,
      });
    }
  }

  protected render(): TemplateResult | void {
    return html` <div class="grid">
      ${this.extendUp && this._showLoaderTop
        ? html`${renderProgressIndicator({
            cardWideConfig: this.cardWideConfig,
            classes: {
              top: true,
            },
            size: 'small',
          })}`
        : ''}
      <slot ${ref(this._refSlot)} @slotchange=${() => this._controller.updateContents()}>
      </slot>
      ${this.extendDown && this._showSentinelBottom
        ? html`${renderProgressIndicator({
            cardWideConfig: this.cardWideConfig,
            componentRef: this._refSentinelBottom,
            size: 'small',
          })}`
        : ''}
    </div>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(galleryCoreStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-gallery-core': AdvancedCameraCardGalleryCore;
  }
}



================================================
FILE: src/components/gallery/media-gallery.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { ViewItemManager } from '../../card-controller/view/item-manager.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { MediaGalleryController } from '../../components-lib/gallery/media-gallery-controller.js';
import { MediaGalleryConfig } from '../../config/schema/media-gallery.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { HomeAssistant } from '../../ha/types.js';
import { localize } from '../../localize/localize';
import mediaGalleryStyle from '../../scss/media-gallery.scss';
import '../media-filter';
import '../message.js';
import { renderMessage } from '../message.js';
import '../surround-basic';
import '../thumbnail/thumbnail.js';
import './gallery-core.js';
import { GalleryExtendEvent } from './types.js';

const MEDIA_GALLERY_FILTER_MENU_ICONS = {
  closed: 'mdi:filter-cog-outline',
  open: 'mdi:filter-cog',
};

@customElement('advanced-camera-card-media-gallery')
export class AdvancedCameraCardMediaGallery extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public galleryConfig?: MediaGalleryConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  protected _controller = new MediaGalleryController(this);

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('viewManagerEpoch')) {
      this._controller.setMediaFromView(
        this.viewManagerEpoch?.manager.getView(),
        this.viewManagerEpoch?.oldView,
      );
    }

    if (changedProps.has('galleryConfig')) {
      this._controller.setThumbnailSize(this.galleryConfig?.controls.thumbnails.size);
    }
  }

  protected _renderThumbnails(): TemplateResult | void {
    const selected = this.viewManagerEpoch?.manager
      .getView()
      ?.queryResults?.getSelectedResult();

    return html`
      ${this._controller.getMedia()?.map(
        (media, index) =>
          html`<advanced-camera-card-thumbnail
            class=${classMap({
              selected: media === selected,
            })}
            .hass=${this.hass}
            .cameraManager=${this.cameraManager}
            .viewItemManager=${this.viewItemManager}
            .item=${media}
            .viewManagerEpoch=${this.viewManagerEpoch}
            ?selected=${media === selected}
            ?details=${!!this.galleryConfig?.controls.thumbnails.show_details}
            ?show_favorite_control=${!!this.galleryConfig?.controls.thumbnails
              .show_favorite_control}
            ?show_timeline_control=${!!this.galleryConfig?.controls.thumbnails
              .show_timeline_control}
            ?show_download_control=${!!this.galleryConfig?.controls.thumbnails
              .show_download_control}
            @click=${(ev: Event) => {
              const manager = this.viewManagerEpoch?.manager;
              if (manager) {
                this._controller.itemClickHandler(manager, index, ev);
              }
            }}
          >
          </advanced-camera-card-thumbnail>`,
      )}
    `;
  }

  protected render(): TemplateResult | void {
    const mediaIsLoading =
      !!this.viewManagerEpoch?.manager.getView()?.context?.loading?.query;

    return html`
      <advanced-camera-card-surround-basic
        .drawerIcons=${{
          ...(this.galleryConfig &&
            this.galleryConfig.controls.filter.mode !== 'none' && {
              [this.galleryConfig.controls.filter.mode]: MEDIA_GALLERY_FILTER_MENU_ICONS,
            }),
        }}
      >
        ${this.galleryConfig && this.galleryConfig.controls.filter.mode !== 'none'
          ? html` <advanced-camera-card-media-filter
              .hass=${this.hass}
              .cameraManager=${this.cameraManager}
              .viewManagerEpoch=${this.viewManagerEpoch}
              .cardWideConfig=${this.cardWideConfig}
              slot=${this.galleryConfig.controls.filter.mode}
            >
            </advanced-camera-card-media-filter>`
          : ''}
        ${!this._controller.getMedia()?.length
          ? renderMessage({
              type: 'info',
              message: mediaIsLoading
                ? localize('error.awaiting_media')
                : localize('common.no_media'),
              icon: 'mdi:multimedia',
              dotdotdot: mediaIsLoading,
            })
          : html`<advanced-camera-card-gallery-core
              .hass=${this.hass}
              .columnWidth=${this._controller.getColumnWidth(
                this.galleryConfig?.controls.thumbnails,
              )}
              .columnCountRoundMethod=${this._controller.getColumnCountRoundMethod(
                this.galleryConfig?.controls.thumbnails,
              )}
              .cardWideConfig=${this.cardWideConfig}
              .extendUp=${true}
              .extendDown=${true}
              @advanced-camera-card:gallery:extend:up=${(
                ev: CustomEvent<GalleryExtendEvent>,
              ) =>
                this._extendGallery(
                  ev,
                  'later',
                  // Avoid use of cache since the user is explicitly looking for
                  // the freshest possible data.
                  false,
                )}
              @advanced-camera-card:gallery:extend:down=${(
                ev: CustomEvent<GalleryExtendEvent>,
              ) => this._extendGallery(ev, 'earlier')}
            >
              ${this._renderThumbnails()}
            </advanced-camera-card-gallery-core>`}
      </advanced-camera-card-surround-basic>
    `;
  }

  protected async _extendGallery(
    ev: CustomEvent<GalleryExtendEvent>,
    direction: 'earlier' | 'later',
    useCache = true,
  ): Promise<void> {
    if (!this.cameraManager || !this.viewManagerEpoch) {
      return;
    }
    await this._controller.extendMediaGallery(
      this.cameraManager,
      this.viewManagerEpoch,
      direction,
      useCache,
    );
    ev.detail.resolve();
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(mediaGalleryStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-media-gallery': AdvancedCameraCardMediaGallery;
  }
}



================================================
FILE: src/components/gallery/types.ts
================================================
export interface GalleryExtendEvent {
  resolve: () => void;
}



================================================
FILE: src/components/live/carousel.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { guard } from 'lit/directives/guard.js';
import { createRef, Ref, ref } from 'lit/directives/ref.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { CameraManagerCameraMetadata } from '../../camera-manager/types.js';
import { MicrophoneState } from '../../card-controller/types.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { MediaActionsController } from '../../components-lib/media-actions-controller.js';
import { MediaHeightController } from '../../components-lib/media-height-controller.js';
import { ZoomSettingsObserved } from '../../components-lib/zoom/types.js';
import { handleZoomSettingsObservedEvent } from '../../components-lib/zoom/zoom-view-context.js';
import { CameraConfig } from '../../config/schema/cameras.js';
import { TransitionEffect } from '../../config/schema/common/transition-effect.js';
import { LiveConfig } from '../../config/schema/live.js';
import { CardWideConfig, configDefaults } from '../../config/schema/types.js';
import { HomeAssistant } from '../../ha/types.js';
import liveCarouselStyle from '../../scss/live-carousel.scss';
import { stopEventFromActivatingCardWideActions } from '../../utils/action.js';
import { CarouselSelected } from '../../utils/embla/carousel-controller.js';
import AutoMediaLoadedInfo from '../../utils/embla/plugins/auto-media-loaded-info/auto-media-loaded-info.js';
import { getStreamCameraID } from '../../utils/substream.js';
import { getTextDirection } from '../../utils/text-direction.js';
import { View } from '../../view/view.js';
import '../carousel';
import { EmblaCarouselPlugins } from '../carousel.js';
import '../next-prev-control.js';
import '../ptz.js';
import { AdvancedCameraCardPTZ } from '../ptz.js';
import './provider.js';

const ADVANCED_CAMERA_CARD_LIVE_PROVIDER = 'advanced-camera-card-live-provider';

interface CameraNeighbor {
  id: string;
  metadata?: CameraManagerCameraMetadata | null;
}

interface CameraNeighbors {
  previous?: CameraNeighbor;
  next?: CameraNeighbor;
}

@customElement('advanced-camera-card-live-carousel')
export class AdvancedCameraCardLiveCarousel extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public liveConfig?: LiveConfig;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public microphoneState?: MicrophoneState;

  @property({ attribute: false })
  public viewFilterCameraID?: string;

  // Index between camera name and slide number.
  protected _cameraToSlide: Record<string, number> = {};
  protected _refPTZControl: Ref<AdvancedCameraCardPTZ> = createRef();
  protected _refCarousel: Ref<HTMLElement> = createRef();

  protected _mediaActionsController = new MediaActionsController();
  protected _mediaHeightController = new MediaHeightController(this, '.embla__slide');

  @state()
  protected _mediaHasLoaded = false;

  public connectedCallback(): void {
    super.connectedCallback();

    this._mediaHeightController.setRoot(this.renderRoot);

    // Request update in order to reinitialize the media action controller.
    this.requestUpdate();
  }

  public disconnectedCallback(): void {
    this._mediaActionsController.destroy();
    this._mediaHeightController.destroy();
    super.disconnectedCallback();
  }

  protected _getTransitionEffect(): TransitionEffect {
    return this.liveConfig?.transition_effect ?? configDefaults.live.transition_effect;
  }

  protected _getSelectedCameraIndex(): number {
    if (this.viewFilterCameraID) {
      // If the carousel is limited to a single cameraID, the first (only)
      // element is always the selected one.
      return 0;
    }

    const cameraIDs = this.cameraManager?.getStore().getCameraIDsWithCapability('live');
    const view = this.viewManagerEpoch?.manager.getView();
    if (!cameraIDs?.size || !view) {
      return 0;
    }
    return Math.max(0, Array.from(cameraIDs).indexOf(view.camera));
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('microphoneState') || changedProps.has('liveConfig')) {
      this._mediaActionsController.setOptions({
        playerSelector: ADVANCED_CAMERA_CARD_LIVE_PROVIDER,
        ...(this.liveConfig?.auto_play && {
          autoPlayConditions: this.liveConfig.auto_play,
        }),
        ...(this.liveConfig?.auto_pause && {
          autoPauseConditions: this.liveConfig.auto_pause,
        }),
        ...(this.liveConfig?.auto_mute && {
          autoMuteConditions: this.liveConfig.auto_mute,
        }),
        ...(this.liveConfig?.auto_unmute && {
          autoUnmuteConditions: this.liveConfig.auto_unmute,
        }),
        ...((this.liveConfig?.auto_unmute || this.liveConfig?.auto_mute) && {
          microphoneState: this.microphoneState,
          microphoneMuteSeconds:
            this.liveConfig.microphone.mute_after_microphone_mute_seconds,
        }),
      });
    }
  }

  protected _getPlugins(): EmblaCarouselPlugins {
    return [AutoMediaLoadedInfo()];
  }

  /**
   * Returns the number of slides to lazily load. 0 means all slides are lazy
   * loaded, 1 means that 1 slide on each side of the currently selected slide
   * should lazy load, etc. `null` means lazy loading is disabled and everything
   * should load simultaneously.
   * @returns
   */
  protected _getLazyLoadCount(): number | null {
    // Defaults to fully-lazy loading.
    return this.liveConfig?.lazy_load === false ? null : 0;
  }

  protected _getSlides(): [TemplateResult[], Record<string, number>] {
    if (!this.cameraManager) {
      return [[], {}];
    }

    const view = this.viewManagerEpoch?.manager.getView();
    const cameraIDs = this.viewFilterCameraID
      ? new Set([this.viewFilterCameraID])
      : this.cameraManager?.getStore().getCameraIDsWithCapability('live');

    const slides: TemplateResult[] = [];
    const cameraToSlide: Record<string, number> = {};

    for (const [cameraID, cameraConfig] of this.cameraManager
      .getStore()
      .getCameraConfigEntries(cameraIDs)) {
      const liveCameraID = this._getSubstreamCameraID(cameraID, view);
      const liveCameraConfig =
        cameraID === liveCameraID
          ? cameraConfig
          : this.cameraManager?.getStore().getCameraConfig(liveCameraID);

      const slide = liveCameraConfig
        ? this._renderLive(liveCameraID, liveCameraConfig)
        : null;
      if (slide) {
        cameraToSlide[cameraID] = slides.length;
        slides.push(slide);
      }
    }
    return [slides, cameraToSlide];
  }

  protected _setViewHandler(ev: CustomEvent<CarouselSelected>): void {
    const cameraIDs = this.cameraManager?.getStore().getCameraIDsWithCapability('live');
    if (cameraIDs?.size && ev.detail.index !== this._getSelectedCameraIndex()) {
      this._setViewCameraID([...cameraIDs][ev.detail.index]);
    }
  }

  protected _setViewCameraID(cameraID?: string | null): void {
    if (cameraID) {
      this.viewManagerEpoch?.manager.setViewByParametersWithNewQuery({
        params: {
          camera: cameraID,
        },
      });
    }
  }

  protected _renderLive(
    cameraID: string,
    cameraConfig: CameraConfig,
  ): TemplateResult | void {
    if (!this.liveConfig || !this.hass || !this.cameraManager) {
      return;
    }

    const cameraMetadata = this.cameraManager.getCameraMetadata(cameraID);
    const view = this.viewManagerEpoch?.manager.getView();

    return html`
      <div class="embla__slide">
        <advanced-camera-card-live-provider
          .microphoneState=${view?.camera === cameraID
            ? this.microphoneState
            : undefined}
          .cameraConfig=${cameraConfig}
          .cameraEndpoints=${guard(
            [this.cameraManager, cameraID],
            () => this.cameraManager?.getCameraEndpoints(cameraID) ?? undefined,
          )}
          .label=${cameraMetadata?.title ?? ''}
          .liveConfig=${this.liveConfig}
          .hass=${this.hass}
          .cardWideConfig=${this.cardWideConfig}
          .zoomSettings=${view?.context?.zoom?.[cameraID]?.requested}
          @advanced-camera-card:zoom:change=${(ev: CustomEvent<ZoomSettingsObserved>) =>
            handleZoomSettingsObservedEvent(
              ev,
              this.viewManagerEpoch?.manager,
              cameraID,
            )}
        >
        </advanced-camera-card-live-provider>
      </div>
    `;
  }

  protected _getSubstreamCameraID(cameraID: string, view?: View | null): string {
    return view?.context?.live?.overrides?.get(cameraID) ?? cameraID;
  }

  protected _getCameraNeighbors(): CameraNeighbors | null {
    const cameraIDs = this.cameraManager
      ? [...this.cameraManager?.getStore().getCameraIDsWithCapability('live')]
      : [];
    const view = this.viewManagerEpoch?.manager.getView();

    if (this.viewFilterCameraID || cameraIDs.length <= 1 || !view || !this.hass) {
      return {};
    }

    const cameraID = this.viewFilterCameraID ?? view.camera;
    const currentIndex = cameraIDs.indexOf(cameraID);

    if (currentIndex < 0) {
      return {};
    }
    const prevID = cameraIDs[currentIndex > 0 ? currentIndex - 1 : cameraIDs.length - 1];
    const nextID = cameraIDs[currentIndex + 1 < cameraIDs.length ? currentIndex + 1 : 0];

    return {
      previous: {
        id: prevID,
        metadata: prevID
          ? this.cameraManager?.getCameraMetadata(
              this._getSubstreamCameraID(prevID, view),
            )
          : null,
      },
      next: {
        id: nextID,
        metadata: nextID
          ? this.cameraManager?.getCameraMetadata(
              this._getSubstreamCameraID(nextID, view),
            )
          : null,
      },
    };
  }

  protected _renderNextPrevious(
    side: 'left' | 'right',
    neighbors: CameraNeighbors | null,
  ): TemplateResult {
    const textDirection = getTextDirection(this);
    const neighbor =
      (textDirection === 'ltr' && side === 'left') ||
      (textDirection === 'rtl' && side === 'right')
        ? neighbors?.previous
        : neighbors?.next;

    return html`<advanced-camera-card-next-previous-control
      slot=${side}
      .hass=${this.hass}
      .side=${side}
      .controlConfig=${this.liveConfig?.controls.next_previous}
      .label=${neighbor?.metadata?.title ?? ''}
      .icon=${neighbor?.metadata?.icon}
      ?disabled=${!neighbor}
      @click=${(ev) => {
        this._setViewCameraID(neighbor?.id);
        stopEventFromActivatingCardWideActions(ev);
      }}
    >
    </advanced-camera-card-next-previous-control>`;
  }

  protected render(): TemplateResult | void {
    const view = this.viewManagerEpoch?.manager.getView();
    if (!this.liveConfig || !this.hass || !view || !this.cameraManager) {
      return;
    }

    const [slides, cameraToSlide] = this._getSlides();
    this._cameraToSlide = cameraToSlide;
    if (!slides.length) {
      return;
    }

    const hasMultipleCameras = slides.length > 1;
    const neighbors = this._getCameraNeighbors();

    const forcePTZVisibility =
      !this._mediaHasLoaded ||
      (!!this.viewFilterCameraID && this.viewFilterCameraID !== view.camera) ||
      view.context?.ptzControls?.enabled === false
        ? false
        : view.context?.ptzControls?.enabled;

    // Notes on the below:
    // - guard() is used to avoid reseting the carousel unless the
    //   options/plugins actually change.

    return html`
      <advanced-camera-card-carousel
        ${ref(this._refCarousel)}
        .loop=${hasMultipleCameras}
        .dragEnabled=${hasMultipleCameras && this.liveConfig?.draggable}
        .plugins=${guard(
          [this.cameraManager, this.liveConfig],
          this._getPlugins.bind(this),
        )}
        .selected=${this._getSelectedCameraIndex()}
        transitionEffect=${this._getTransitionEffect()}
        @advanced-camera-card:carousel:select=${this._setViewHandler.bind(this)}
        @advanced-camera-card:media:loaded=${() => {
          this._mediaHasLoaded = true;
        }}
        @advanced-camera-card:media:unloaded=${() => {
          this._mediaHasLoaded = false;
        }}
      >
        ${this._renderNextPrevious('left', neighbors)}
        <!-- -->
        ${slides}
        <!-- -->
        ${this._renderNextPrevious('right', neighbors)}
      </advanced-camera-card-carousel>
      <advanced-camera-card-ptz
        .hass=${this.hass}
        .config=${this.liveConfig.controls.ptz}
        .cameraManager=${this.cameraManager}
        .cameraID=${getStreamCameraID(view, this.viewFilterCameraID)}
        .forceVisibility=${forcePTZVisibility}
      >
      </advanced-camera-card-ptz>
    `;
  }

  protected _setMediaTarget(): void {
    const view = this.viewManagerEpoch?.manager.getView();
    const selectedCameraIndex = this._getSelectedCameraIndex();

    if (this.viewFilterCameraID) {
      this._mediaActionsController.setTarget(
        selectedCameraIndex,
        // Camera in this carousel is only selected if the camera from the
        // view matches the filtered camera.
        view?.camera === this.viewFilterCameraID,
      );
    } else {
      // Carousel is not filtered, so the targeted camera is always selected.
      this._mediaActionsController.setTarget(selectedCameraIndex, true);
    }

    this._mediaHeightController.setSelected(selectedCameraIndex);
  }

  public updated(changedProperties: PropertyValues): void {
    super.updated(changedProperties);

    const rootChanged = this._refCarousel.value
      ? this._mediaActionsController.setRoot(this._refCarousel.value)
      : false;

    // If the view has changed, or if the media actions controller has just been
    // initialized, then call the necessary media action.
    // See: https://github.com/dermotduffy/advanced-camera-card/issues/1626
    if (rootChanged || changedProperties.has('viewManagerEpoch')) {
      this._setMediaTarget();
    }
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveCarouselStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-carousel': AdvancedCameraCardLiveCarousel;
  }
}



================================================
FILE: src/components/live/grid.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { MicrophoneState } from '../../card-controller/types.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { MediaGridSelected } from '../../components-lib/media-grid-controller.js';
import { LiveConfig } from '../../config/schema/live.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { HomeAssistant } from '../../ha/types.js';
import liveGridStyle from '../../scss/live-grid.scss';
import './carousel.js';

@customElement('advanced-camera-card-live-grid')
export class AdvancedCameraCardLiveGrid extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public liveConfig?: LiveConfig;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public microphoneState?: MicrophoneState;

  @property({ attribute: false })
  public triggeredCameraIDs?: Set<string>;

  protected _renderCarousel(cameraID?: string): TemplateResult {
    const view = this.viewManagerEpoch?.manager.getView();
    const triggeredCameraID = cameraID ?? view?.camera;

    return html`
      <advanced-camera-card-live-carousel
        grid-id=${ifDefined(cameraID)}
        .hass=${this.hass}
        .viewManagerEpoch=${this.viewManagerEpoch}
        .viewFilterCameraID=${cameraID}
        .liveConfig=${this.liveConfig}
        .cardWideConfig=${this.cardWideConfig}
        .cameraManager=${this.cameraManager}
        .microphoneState=${this.microphoneState}
        ?triggered=${triggeredCameraID &&
        !!this.triggeredCameraIDs?.has(triggeredCameraID)}
      >
      </advanced-camera-card-live-carousel>
    `;
  }

  protected _gridSelectCamera(cameraID: string): void {
    this.viewManagerEpoch?.manager.setViewByParameters({
      params: {
        camera: cameraID,
      },
    });
  }

  protected _needsGrid(): boolean {
    const cameraIDs = this.cameraManager?.getStore().getCameraIDsWithCapability('live');
    const view = this.viewManagerEpoch?.manager.getView();
    return (
      !!view?.isGrid() &&
      !!view?.supportsMultipleDisplayModes() &&
      !!cameraIDs &&
      cameraIDs.size > 1
    );
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('viewManagerEpoch') && this._needsGrid()) {
      import('../media-grid.js');
    }
  }

  protected render(): TemplateResult | void {
    const cameraIDs = this.cameraManager?.getStore().getCameraIDsWithCapability('live');
    if (!cameraIDs?.size || !this._needsGrid()) {
      return this._renderCarousel();
    }

    return html`
      <advanced-camera-card-media-grid
        .selected=${this.viewManagerEpoch?.manager.getView()?.camera}
        .displayConfig=${this.liveConfig?.display}
        @advanced-camera-card:media-grid:selected=${(
          ev: CustomEvent<MediaGridSelected>,
        ) => this._gridSelectCamera(ev.detail.selected)}
      >
        ${[...cameraIDs].map((cameraID) => this._renderCarousel(cameraID))}
      </advanced-camera-card-media-grid>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveGridStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-grid': AdvancedCameraCardLiveGrid;
  }
}



================================================
FILE: src/components/live/index.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { MicrophoneState } from '../../card-controller/types.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { LiveController } from '../../components-lib/live/live-controller.js';
import { LiveConfig } from '../../config/schema/live.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { HomeAssistant } from '../../ha/types.js';
import basicBlockStyle from '../../scss/basic-block.scss';
import './grid.js';

@customElement('advanced-camera-card-live')
export class AdvancedCameraCardLive extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public liveConfig?: LiveConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public microphoneState?: MicrophoneState;

  @property({ attribute: false })
  public triggeredCameraIDs?: Set<string>;

  protected _controller = new LiveController(this);

  protected render(): TemplateResult | void {
    if (!this.hass || !this.cameraManager) {
      return;
    }

    // Implementation notes:
    // - See use of liveConfig and not config below -- the underlying carousel
    //   will independently override the liveConfig to reflect the camera in the
    //   carousel (not necessarily the selected camera).
    // - Various events are captured to prevent them propagating upwards if the
    //   card is in the background.
    return html`
      <advanced-camera-card-live-grid
        .hass=${this.hass}
        .viewManagerEpoch=${this.viewManagerEpoch}
        .liveConfig=${this.liveConfig}
        .inBackground=${this._controller.isInBackground()}
        .cardWideConfig=${this.cardWideConfig}
        .cameraManager=${this.cameraManager}
        .microphoneState=${this.microphoneState}
        .triggeredCameraIDs=${this.triggeredCameraIDs}
      >
      </advanced-camera-card-live-grid>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(basicBlockStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live': AdvancedCameraCardLive;
  }
}



================================================
FILE: src/components/live/provider.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { guard } from 'lit/directives/guard.js';
import { createRef, Ref, ref } from 'lit/directives/ref.js';
import { CameraEndpoints } from '../../camera-manager/types.js';
import { MicrophoneState } from '../../card-controller/types.js';
import { LazyLoadController } from '../../components-lib/lazy-load-controller.js';
import { dispatchLiveErrorEvent } from '../../components-lib/live/utils/dispatch-live-error.js';
import { PartialZoomSettings } from '../../components-lib/zoom/types.js';
import { CameraConfig, LiveProvider } from '../../config/schema/cameras.js';
import { LiveConfig } from '../../config/schema/live.js';
import { CardWideConfig, configDefaults } from '../../config/schema/types.js';
import { STREAM_TROUBLESHOOTING_URL } from '../../const.js';
import { HomeAssistant } from '../../ha/types.js';
import { localize } from '../../localize/localize.js';
import liveProviderStyle from '../../scss/live-provider.scss';
import { MediaPlayer, MediaPlayerController, MediaPlayerElement } from '../../types.js';
import { aspectRatioToString } from '../../utils/basic.js';
import { dispatchMediaUnloadedEvent } from '../../utils/media-info.js';
import { updateElementStyleFromMediaLayoutConfig } from '../../utils/media-layout.js';
import '../icon.js';
import { renderMessage } from '../message.js';
import '../next-prev-control.js';
import '../ptz.js';
import '../surround.js';

@customElement('advanced-camera-card-live-provider')
export class AdvancedCameraCardLiveProvider extends LitElement implements MediaPlayer {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: false })
  public cameraEndpoints?: CameraEndpoints;

  @property({ attribute: false })
  public liveConfig?: LiveConfig;

  // Label that is used for ARIA support and as tooltip.
  @property({ attribute: false })
  public label = '';

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public microphoneState?: MicrophoneState;

  @property({ attribute: false })
  public zoomSettings?: PartialZoomSettings | null;

  @state()
  protected _isVideoMediaLoaded = false;

  @state()
  protected _hasProviderError = false;

  @state()
  protected _showStreamTroubleshooting = false;

  protected _refProvider: Ref<MediaPlayerElement> = createRef();
  protected _lazyLoadController: LazyLoadController = new LazyLoadController(this);

  // A note on dynamic imports:
  //
  // We gather the dynamic live provider import promises and do not consider the
  // update of the element complete until these imports have returned. Without
  // this behavior calls to the media methods (e.g. `mute()`) may throw if the
  // underlying code is not yet loaded.
  //
  // Test case: A card with a non-live view, but live pre-loaded, attempts to
  // call mute() when the <advanced-camera-card-live> element first renders in the
  // background. These calls fail without waiting for loading here.
  protected _importPromises: Promise<unknown>[] = [];

  constructor() {
    super();
    this._lazyLoadController.addListener((loaded: boolean) => {
      if (!loaded) {
        this._isVideoMediaLoaded = false;
        dispatchMediaUnloadedEvent(this);
      }
    });
  }

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    await this.updateComplete;
    return (await this._refProvider.value?.getMediaPlayerController()) ?? null;
  }

  /**
   * Get the fully resolved live provider.
   * @returns A live provider (that is not 'auto').
   */
  protected _getResolvedProvider(): Omit<LiveProvider, 'auto'> {
    if (this.cameraConfig?.live_provider === 'auto') {
      if (
        this.cameraConfig?.webrtc_card?.entity ||
        this.cameraConfig?.webrtc_card?.url
      ) {
        return 'webrtc-card';
      } else if (this.cameraConfig?.camera_entity) {
        return 'ha';
      } else if (this.cameraConfig?.frigate.camera_name) {
        return 'jsmpeg';
      }
      return configDefaults.cameras.live_provider;
    }
    return this.cameraConfig?.live_provider || 'image';
  }

  /**
   * Determine if a camera image should be shown in lieu of the real stream
   * whilst loading.
   * @returns`true` if an image should be shown.
   */
  protected _shouldShowImageDuringLoading(): boolean {
    return (
      !this._isVideoMediaLoaded &&
      !!this.cameraConfig?.camera_entity &&
      !!this.hass &&
      !!this.liveConfig?.show_image_during_load &&
      !this._showStreamTroubleshooting &&
      // Do not continue to show image during loading if an error has occurred.
      !this._hasProviderError
    );
  }

  public disconnectedCallback(): void {
    this._isVideoMediaLoaded = false;
    super.disconnectedCallback();
  }

  protected _videoMediaShowHandler(): void {
    this._isVideoMediaLoaded = true;
    this._showStreamTroubleshooting = false;
  }

  protected _providerErrorHandler(): void {
    this._hasProviderError = true;
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (
      changedProps.has('liveConfig') ||
      (!this._lazyLoadController && this.liveConfig)
    ) {
      this._lazyLoadController.setConfiguration(
        this.liveConfig?.lazy_load,
        this.liveConfig?.lazy_unload,
      );
    }

    if (changedProps.has('liveConfig')) {
      if (this.liveConfig?.show_image_during_load) {
        this._importPromises.push(import('./providers/image.js'));
      }
      if (this.liveConfig?.zoomable) {
        this._importPromises.push(import('../zoomer.js'));
      }
    }

    if (changedProps.has('cameraConfig')) {
      const provider = this._getResolvedProvider();
      if (provider === 'jsmpeg') {
        this._importPromises.push(import('./providers/jsmpeg.js'));
      } else if (provider === 'ha') {
        this._importPromises.push(import('./providers/ha.js'));
      } else if (provider === 'webrtc-card') {
        this._importPromises.push(import('./providers/webrtc-card.js'));
      } else if (provider === 'image') {
        this._importPromises.push(import('./providers/image.js'));
      } else if (provider === 'go2rtc') {
        this._importPromises.push(import('./providers/go2rtc/index.js'));
      }

      updateElementStyleFromMediaLayoutConfig(
        this,
        this.cameraConfig?.dimensions?.layout,
      );
      this.style.aspectRatio = aspectRatioToString({
        ratio: this.cameraConfig?.dimensions?.aspect_ratio,
      });
    }
  }

  override async getUpdateComplete(): Promise<boolean> {
    // See 'A note on dynamic imports' above for explanation of why this is
    // necessary.
    const result = await super.getUpdateComplete();
    await Promise.all(this._importPromises);
    this._importPromises = [];
    return result;
  }

  protected _useZoomIfRequired(template: TemplateResult): TemplateResult {
    return this.liveConfig?.zoomable
      ? html` <advanced-camera-card-zoomer
          .defaultSettings=${guard([this.cameraConfig?.dimensions?.layout], () =>
            this.cameraConfig?.dimensions?.layout
              ? {
                  pan: this.cameraConfig.dimensions.layout.pan,
                  zoom: this.cameraConfig.dimensions.layout.zoom,
                }
              : undefined,
          )}
          .settings=${this.zoomSettings}
          @advanced-camera-card:zoom:zoomed=${async () =>
            (await this.getMediaPlayerController())?.setControls(false)}
          @advanced-camera-card:zoom:unzoomed=${async () =>
            (await this.getMediaPlayerController())?.setControls()}
        >
          ${template}
        </advanced-camera-card-zoomer>`
      : template;
  }

  protected render(): TemplateResult | void {
    if (
      !this._lazyLoadController?.isLoaded() ||
      !this.hass ||
      !this.liveConfig ||
      !this.cameraConfig
    ) {
      return;
    }

    // Set title and ariaLabel from the provided label property.
    this.title = this.label;
    this.ariaLabel = this.label;

    const provider = this._getResolvedProvider();
    const showImageDuringLoading = this._shouldShowImageDuringLoading();
    const showLoadingIcon = !this._isVideoMediaLoaded;
    const providerClasses = {
      hidden: showImageDuringLoading,
    };

    if (
      provider === 'ha' ||
      provider === 'image' ||
      (this.cameraConfig?.camera_entity &&
        this.cameraConfig.always_error_if_entity_unavailable)
    ) {
      if (!this.cameraConfig?.camera_entity) {
        dispatchLiveErrorEvent(this);
        return renderMessage({
          message: localize('error.no_live_camera'),
          type: 'error',
          icon: 'mdi:camera',
          context: this.cameraConfig,
        });
      }

      const stateObj = this.hass.states[this.cameraConfig.camera_entity];
      if (!stateObj) {
        dispatchLiveErrorEvent(this);
        return renderMessage({
          message: localize('error.live_camera_not_found'),
          type: 'error',
          icon: 'mdi:camera',
          context: this.cameraConfig,
        });
      }

      if (stateObj.state === 'unavailable') {
        dispatchLiveErrorEvent(this);
        dispatchMediaUnloadedEvent(this);
        return renderMessage({
          message: `${localize('error.live_camera_unavailable')}${
            this.label ? `: ${this.label}` : ''
          }`,
          type: 'info',
          icon: 'mdi:cctv-off',
          dotdotdot: true,
        });
      }
    }

    return html`${this._useZoomIfRequired(html`
      ${showImageDuringLoading || provider === 'image'
        ? html` <advanced-camera-card-live-image
            ${ref(this._refProvider)}
            .hass=${this.hass}
            .cameraConfig=${this.cameraConfig}
            @advanced-camera-card:live:error=${() => this._providerErrorHandler()}
            @advanced-camera-card:media:loaded=${(ev: Event) => {
              if (provider === 'image') {
                // Only count the media has loaded if the required provider is
                // the image (not just the temporary image shown during
                // loading).
                this._videoMediaShowHandler();
              } else {
                ev.stopPropagation();
              }
            }}
          >
          </advanced-camera-card-live-image>`
        : html``}
      ${provider === 'ha'
        ? html` <advanced-camera-card-live-ha
            ${ref(this._refProvider)}
            class=${classMap(providerClasses)}
            .hass=${this.hass}
            .cameraConfig=${this.cameraConfig}
            ?controls=${this.liveConfig.controls.builtin}
            @advanced-camera-card:live:error=${() => this._providerErrorHandler()}
            @advanced-camera-card:media:loaded=${this._videoMediaShowHandler.bind(this)}
          >
          </advanced-camera-card-live-ha>`
        : provider === 'go2rtc'
          ? html`<advanced-camera-card-live-go2rtc
              ${ref(this._refProvider)}
              class=${classMap(providerClasses)}
              .hass=${this.hass}
              .cameraConfig=${this.cameraConfig}
              .cameraEndpoints=${this.cameraEndpoints}
              .microphoneState=${this.microphoneState}
              .microphoneConfig=${this.liveConfig.microphone}
              ?controls=${this.liveConfig.controls.builtin}
              @advanced-camera-card:live:error=${() => this._providerErrorHandler()}
              @advanced-camera-card:media:loaded=${this._videoMediaShowHandler.bind(
                this,
              )}
            >
            </advanced-camera-card-live-go2rtc>`
          : provider === 'webrtc-card'
            ? html`<advanced-camera-card-live-webrtc-card
                ${ref(this._refProvider)}
                class=${classMap(providerClasses)}
                .hass=${this.hass}
                .cameraConfig=${this.cameraConfig}
                .cameraEndpoints=${this.cameraEndpoints}
                .cardWideConfig=${this.cardWideConfig}
                ?controls=${this.liveConfig.controls.builtin}
                @advanced-camera-card:live:error=${() => this._providerErrorHandler()}
                @advanced-camera-card:media:loaded=${this._videoMediaShowHandler.bind(
                  this,
                )}
              >
              </advanced-camera-card-live-webrtc-card>`
            : provider === 'jsmpeg'
              ? html` <advanced-camera-card-live-jsmpeg
                  ${ref(this._refProvider)}
                  class=${classMap(providerClasses)}
                  .hass=${this.hass}
                  .cameraConfig=${this.cameraConfig}
                  .cameraEndpoints=${this.cameraEndpoints}
                  .cardWideConfig=${this.cardWideConfig}
                  @advanced-camera-card:live:error=${() => this._providerErrorHandler()}
                  @advanced-camera-card:media:loaded=${this._videoMediaShowHandler.bind(
                    this,
                  )}
                >
                </advanced-camera-card-live-jsmpeg>`
              : html``}
    `)}
    ${showLoadingIcon
      ? html`<advanced-camera-card-icon
          title=${localize('error.awaiting_live')}
          .icon=${{ icon: 'mdi:progress-helper' }}
          @click=${() => {
            this._showStreamTroubleshooting = !this._showStreamTroubleshooting;
          }}
        ></advanced-camera-card-icon>`
      : ''}
    ${this._showStreamTroubleshooting
      ? renderMessage(
          {
            type: 'error',
            icon: 'mdi:camera-off',
            message: localize('error.stream_not_loading'),
            url: {
              link: STREAM_TROUBLESHOOTING_URL,
              title: localize('error.troubleshooting'),
            },
          },
          { overlay: true },
        )
      : ''}`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveProviderStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-provider': AdvancedCameraCardLiveProvider;
  }
}



================================================
FILE: src/components/live/providers/ha.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { createRef, Ref, ref } from 'lit/directives/ref.js';
import { CameraConfig } from '../../../config/schema/cameras';
import { HomeAssistant } from '../../../ha/types';
import '../../../patches/ha-camera-stream';
import '../../../patches/ha-hls-player.js';
import '../../../patches/ha-web-rtc-player.js';
import liveHAStyle from '../../../scss/live-ha.scss';
import {
  MediaPlayer,
  MediaPlayerController,
  MediaPlayerElement,
} from '../../../types.js';

@customElement('advanced-camera-card-live-ha')
export class AdvancedCameraCardLiveHA extends LitElement implements MediaPlayer {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: true, type: Boolean })
  public controls = false;

  protected _playerRef: Ref<MediaPlayerElement> = createRef();

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    await this.updateComplete;
    return (await this._playerRef.value?.getMediaPlayerController()) ?? null;
  }

  protected render(): TemplateResult | void {
    if (!this.hass) {
      return;
    }

    return html` <advanced-camera-card-ha-camera-stream
      ${ref(this._playerRef)}
      .hass=${this.hass}
      .stateObj=${this.cameraConfig?.camera_entity
        ? this.hass.states[this.cameraConfig.camera_entity]
        : undefined}
      .controls=${this.controls}
      .muted=${true}
    >
    </advanced-camera-card-ha-camera-stream>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveHAStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-ha': AdvancedCameraCardLiveHA;
  }
}



================================================
FILE: src/components/live/providers/image.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { createRef, ref, Ref } from 'lit/directives/ref.js';
import { CameraConfig } from '../../../config/schema/cameras';
import { HomeAssistant } from '../../../ha/types';
import basicBlockStyle from '../../../scss/basic-block.scss';
import {
  MediaPlayer,
  MediaPlayerController,
  MediaPlayerElement,
} from '../../../types.js';
import '../../image-updating-player.js';

@customElement('advanced-camera-card-live-image')
export class AdvancedCameraCardLiveImage extends LitElement implements MediaPlayer {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  protected _refImage: Ref<MediaPlayerElement> = createRef();

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    await this.updateComplete;
    return (await this._refImage.value?.getMediaPlayerController()) ?? null;
  }

  protected render(): TemplateResult | void {
    if (!this.hass || !this.cameraConfig) {
      return;
    }

    return html`
      <advanced-camera-card-image-updating-player
        ${ref(this._refImage)}
        .hass=${this.hass}
        .imageConfig=${this.cameraConfig.image}
        .cameraConfig=${this.cameraConfig}
      >
      </advanced-camera-card-image-updating-player>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(basicBlockStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-image': AdvancedCameraCardLiveImage;
  }
}



================================================
FILE: src/components/live/providers/jsmpeg.ts
================================================
import JSMpeg from '@cycjimmy/jsmpeg-player';
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { until } from 'lit/directives/until.js';
import { CameraEndpoints } from '../../../camera-manager/types.js';
import { dispatchLiveErrorEvent } from '../../../components-lib/live/utils/dispatch-live-error.js';
import { JSMPEGMediaPlayerController } from '../../../components-lib/media-player/jsmpeg.js';
import { CameraConfig } from '../../../config/schema/cameras.js';
import { CardWideConfig } from '../../../config/schema/types.js';
import { HomeAssistant } from '../../../ha/types.js';
import { localize } from '../../../localize/localize.js';
import liveJSMPEGStyle from '../../../scss/live-jsmpeg.scss';
import { MediaPlayer, MediaPlayerController, Message } from '../../../types.js';
import { convertEndpointAddressToSignedWebsocket } from '../../../utils/endpoint.js';
import {
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
} from '../../../utils/media-info.js';
import { Timer } from '../../../utils/timer.js';
import '../../message.js';
import { renderMessage } from '../../message.js';
import '../../progress-indicator.js';
import { renderProgressIndicator } from '../../progress-indicator.js';

// Number of seconds a signed URL is valid for.
const JSMPEG_URL_SIGN_EXPIRY_SECONDS = 24 * 60 * 60;

// Number of seconds before the expiry to trigger a refresh.
const JSMPEG_URL_SIGN_REFRESH_THRESHOLD_SECONDS = 1 * 60 * 60;

@customElement('advanced-camera-card-live-jsmpeg')
export class AdvancedCameraCardLiveJSMPEG extends LitElement implements MediaPlayer {
  protected hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: false })
  public cameraEndpoints?: CameraEndpoints;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @state()
  protected _message: Message | null = null;

  protected _jsmpegCanvasElement?: HTMLCanvasElement;
  protected _jsmpegVideoPlayer?: JSMpeg.VideoElement;
  protected _refreshPlayerTimer = new Timer();

  protected _mediaPlayerController = new JSMPEGMediaPlayerController(
    this,
    () => this._jsmpegVideoPlayer ?? null,
    () => this._jsmpegCanvasElement ?? null,
  );

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    return this._mediaPlayerController;
  }

  protected willUpdate(changedProperties: PropertyValues): void {
    if (
      ['cameraConfig', 'cameraEndpoints'].some((prop) => changedProperties.has(prop))
    ) {
      this._message = null;
    }
  }

  protected async _createJSMPEGPlayer(url: string): Promise<JSMpeg.VideoElement> {
    this._jsmpegVideoPlayer = await new Promise<JSMpeg.VideoElement>((resolve) => {
      let videoDecoded = false;
      const player = new JSMpeg.VideoElement(
        this,
        url,
        {
          canvas: this._jsmpegCanvasElement,
        },
        {
          // The media carousel may automatically pause when the browser tab is
          // inactive, JSMPEG does not need to also do so independently.
          pauseWhenHidden: false,
          autoplay: false,
          protocols: [],
          audio: false,
          videoBufferSize: 1024 * 1024 * 4,

          // Necessary for screenshots.
          preserveDrawingBuffer: true,

          // Override with user-specified options.
          ...this.cameraConfig?.jsmpeg?.options,

          // Don't allow the player to internally reconnect, as it may re-use a
          // URL with a (newly) invalid signature, e.g. during a Home Assistant
          // restart.
          reconnectInterval: 0,
          onVideoDecode: () => {
            // This is the only callback that is called after the dimensions
            // are available. It's called on every frame decode, so just
            // ignore any subsequent calls.
            if (!videoDecoded && this._jsmpegCanvasElement) {
              videoDecoded = true;
              resolve(player);
            }
          },
          onPlay: () => dispatchMediaPlayEvent(this),
          onPause: () => dispatchMediaPauseEvent(this),
        },
      );
    });

    // The media loaded event must be dispatched after the player is assigned to
    // `this._jsmpegVideoPlayer`, since the load call may (will!) result in
    // calls back to the player to check for pause status for menu buttons.
    if (this._jsmpegCanvasElement) {
      dispatchMediaLoadedEvent(this, this._jsmpegCanvasElement, {
        mediaPlayerController: this._mediaPlayerController,
        capabilities: {
          supportsPause: true,
        },
        technology: ['jsmpeg'],
      });
    }
  }

  protected _resetPlayer(): void {
    this._message = null;
    this._refreshPlayerTimer.stop();
    if (this._jsmpegVideoPlayer) {
      try {
        this._jsmpegVideoPlayer.destroy();
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
      } catch (e) {
        // Pass.
      }
      this._jsmpegVideoPlayer = undefined;
    }
    if (this._jsmpegCanvasElement) {
      this._jsmpegCanvasElement.remove();
      this._jsmpegCanvasElement = undefined;
    }
  }

  connectedCallback(): void {
    super.connectedCallback();
    if (this.isConnected) {
      this.requestUpdate();
    }
  }

  disconnectedCallback(): void {
    if (!this.isConnected) {
      this._resetPlayer();
    }
    super.disconnectedCallback();
  }

  protected async _refreshPlayer(): Promise<void> {
    if (!this.hass) {
      return;
    }
    this._resetPlayer();

    this._jsmpegCanvasElement = document.createElement('canvas');
    this._jsmpegCanvasElement.className = 'media';

    const endpoint = this.cameraEndpoints?.jsmpeg;
    if (!endpoint) {
      this._message = {
        message: localize('error.live_camera_no_endpoint'),
        type: 'error',
        context: this.cameraConfig,
      };
      dispatchLiveErrorEvent(this);
      return;
    }

    const address = await convertEndpointAddressToSignedWebsocket(
      this.hass,
      endpoint,
      JSMPEG_URL_SIGN_EXPIRY_SECONDS,
    );
    if (!address) {
      this._message = {
        type: 'error',
        message: localize('error.failed_sign'),
        context: this.cameraConfig,
      };
      dispatchLiveErrorEvent(this);
      return;
    }

    await this._createJSMPEGPlayer(address);
    this._refreshPlayerTimer.start(
      JSMPEG_URL_SIGN_EXPIRY_SECONDS - JSMPEG_URL_SIGN_REFRESH_THRESHOLD_SECONDS,
      () => this.requestUpdate(),
    );
  }

  protected render(): TemplateResult | void {
    if (this._message) {
      return renderMessage(this._message);
    }

    const _render = async (): Promise<TemplateResult | void> => {
      await this._refreshPlayer();

      if (!this._jsmpegVideoPlayer || !this._jsmpegCanvasElement) {
        if (!this._message) {
          this._message = {
            message: localize('error.jsmpeg_no_player'),
            type: 'error',
            context: this.cameraConfig,
          };
          dispatchLiveErrorEvent(this);
        }
        return;
      }
      return html`${this._jsmpegCanvasElement}`;
    };
    return html`${until(
      _render(),
      renderProgressIndicator({
        cardWideConfig: this.cardWideConfig,
      }),
    )}`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveJSMPEGStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-jsmpeg': AdvancedCameraCardLiveJSMPEG;
  }
}



================================================
FILE: src/components/live/providers/webrtc-card.ts
================================================
import { Task } from '@lit-labs/task';
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { CameraEndpoints } from '../../../camera-manager/types.js';
import { dispatchLiveErrorEvent } from '../../../components-lib/live/utils/dispatch-live-error.js';
import { getTechnologyForVideoRTC } from '../../../components-lib/live/utils/get-technology-for-video-rtc.js';
import { VideoMediaPlayerController } from '../../../components-lib/media-player/video.js';
import { CameraConfig } from '../../../config/schema/cameras.js';
import { CardWideConfig } from '../../../config/schema/types.js';
import { HomeAssistant } from '../../../ha/types.js';
import { localize } from '../../../localize/localize.js';
import liveWebRTCCardStyle from '../../../scss/live-webrtc-card.scss';
import {
  AdvancedCameraCardError,
  MediaPlayer,
  MediaPlayerController,
  Message,
} from '../../../types.js';
import { mayHaveAudio } from '../../../utils/audio.js';
import {
  hideMediaControlsTemporarily,
  MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
  setControlsOnVideo,
} from '../../../utils/controls.js';
import {
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
  dispatchMediaVolumeChangeEvent,
} from '../../../utils/media-info.js';
import { renderTask } from '../../../utils/task.js';
import '../../message.js';
import { renderMessage } from '../../message.js';
import '../../progress-indicator.js';
import { renderProgressIndicator } from '../../progress-indicator.js';
import { VideoRTC } from './go2rtc/video-rtc.js';

// Create a wrapper for AlexxIT's WebRTC card
//  - https://github.com/AlexxIT/WebRTC
@customElement('advanced-camera-card-live-webrtc-card')
export class AdvancedCameraCardLiveWebRTCCard extends LitElement implements MediaPlayer {
  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: false })
  public cameraEndpoints?: CameraEndpoints;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: true, type: Boolean })
  public controls = false;

  @state()
  protected _message: Message | null = null;

  protected hass?: HomeAssistant;

  protected _mediaPlayerController = new VideoMediaPlayerController(
    this,
    () => this._getVideo(),
    () => this.controls,
  );

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    return this._mediaPlayerController;
  }

  // A task to await the load of the WebRTC component.
  protected _webrtcTask = new Task(this, this._getWebRTCCardElement, () => [1]);

  connectedCallback(): void {
    super.connectedCallback();

    // Reset the player when reconnected to the DOM.
    // https://github.com/dermotduffy/advanced-camera-card/issues/996
    this.requestUpdate();
  }

  disconnectedCallback(): void {
    this._message = null;
    super.disconnectedCallback();
  }

  protected willUpdate(changedProperties: PropertyValues): void {
    if (
      ['cameraConfig', 'cameraEndpoints'].some((prop) => changedProperties.has(prop))
    ) {
      this._message = null;
    }
  }

  protected _getVideoRTC(): VideoRTC | null {
    return (this.renderRoot?.querySelector('#webrtc') ?? null) as VideoRTC | null;
  }

  /**
   * Get the underlying video player.
   * @returns The player or `null` if not found.
   */
  protected _getVideo(): HTMLVideoElement | null {
    return this._getVideoRTC()?.video ?? null;
  }

  protected async _getWebRTCCardElement(): Promise<
    CustomElementConstructor | undefined
  > {
    await customElements.whenDefined('webrtc-camera');
    return customElements.get('webrtc-camera');
  }

  /**
   * Create the WebRTC element. May throw.
   */
  protected _createWebRTC(): HTMLElement | null {
    const webrtcElement = this._webrtcTask.value;
    if (webrtcElement && this.hass && this.cameraConfig) {
      const webrtc = new webrtcElement() as HTMLElement & {
        hass: HomeAssistant;
        setConfig: (config: Record<string, unknown>) => void;
      };
      const config = {
        // By default, webrtc-card will stop the video when 50% of the video is
        // hidden. This is incompatible with the card zoom support, since the
        // video will easily stop if the user zooms in too much. Disable this
        // feature by default.
        // See: https://github.com/dermotduffy/advanced-camera-card/issues/1614
        intersection: 0,

        // Advanced Camera Card always starts muted (unlike webrtc-card).
        // See: https://github.com/dermotduffy/advanced-camera-card/issues/1654
        muted: true,

        ...this.cameraConfig.webrtc_card,
      };
      if (!config.url && !config.entity && this.cameraEndpoints?.webrtcCard) {
        config.entity = this.cameraEndpoints.webrtcCard.endpoint;
      }
      webrtc.setConfig(config);
      webrtc.hass = this.hass;
      return webrtc;
    }
    return null;
  }

  protected render(): TemplateResult | void {
    if (this._message) {
      return renderMessage(this._message);
    }

    const render = (): TemplateResult | void => {
      let webrtcElement: HTMLElement | null;
      try {
        webrtcElement = this._createWebRTC();
      } catch (e) {
        this._message = {
          type: 'error',
          message:
            e instanceof AdvancedCameraCardError
              ? e.message
              : localize('error.webrtc_card_reported_error') +
                ': ' +
                (e as Error).message,
          context: (e as AdvancedCameraCardError).context,
        };
        dispatchLiveErrorEvent(this);
        return;
      }
      if (webrtcElement) {
        // Set the id to ensure that the relevant CSS styles will have
        // sufficient specifity to overcome some styles that are otherwise
        // applied to <ha-card> in Safari.
        webrtcElement.id = 'webrtc';
      }
      return html`${webrtcElement}`;
    };

    // Use a task to allow us to asynchronously wait for the WebRTC card to
    // load, but yet still have the card load be followed by the updated()
    // lifecycle callback (unlike just using `until`).
    return renderTask(this._webrtcTask, render, {
      inProgressFunc: () =>
        renderProgressIndicator({
          message: localize('error.webrtc_card_waiting'),
          cardWideConfig: this.cardWideConfig,
        }),
    });
  }

  public updated(): void {
    // Extract the video component after it has been rendered and generate the
    // media load event.
    this.updateComplete.then(() => {
      const videoRTC = this._getVideoRTC();
      const video = this._getVideo();
      if (video) {
        setControlsOnVideo(video, this.controls);
        video.onloadeddata = () => {
          if (this.controls) {
            hideMediaControlsTemporarily(video, MEDIA_LOAD_CONTROLS_HIDE_SECONDS);
          }
          dispatchMediaLoadedEvent(this, video, {
            mediaPlayerController: this._mediaPlayerController,
            capabilities: {
              supportsPause: true,
              hasAudio: mayHaveAudio(video),
            },
            ...(videoRTC && { technology: getTechnologyForVideoRTC(videoRTC) }),
          });
        };
        video.onplay = () => dispatchMediaPlayEvent(this);
        video.onpause = () => dispatchMediaPauseEvent(this);
        video.onvolumechange = () => dispatchMediaVolumeChangeEvent(this);
      }
    });
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveWebRTCCardStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-webrtc-card': AdvancedCameraCardLiveWebRTCCard;
  }
}



================================================
FILE: src/components/live/providers/go2rtc/README.md
================================================
# go2rtc Player

This is a modified version of the go2rtc example video player code, modified for
use in the Advanced Camera Card. In order to make future maintenance easier,
modifications have been kept to a minimum.

## Original Example Code

**Link**: https://github.com/AlexxIT/go2rtc/tree/master/www

**Description**: Example video player imported from go2rtc.

**Copyright**: [Alexey Khit](https://github.com/AlexxIT)

**License**: [MIT](https://github.com/AlexxIT/go2rtc/blob/master/LICENSE)



================================================
FILE: src/components/live/providers/go2rtc/index.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { CameraEndpoints } from '../../../../camera-manager/types.js';
import { MicrophoneState } from '../../../../card-controller/types.js';
import { dispatchLiveErrorEvent } from '../../../../components-lib/live/utils/dispatch-live-error.js';
import { VideoMediaPlayerController } from '../../../../components-lib/media-player/video.js';
import { CameraConfig } from '../../../../config/schema/cameras.js';
import { MicrophoneConfig } from '../../../../config/schema/live.js';
import { HomeAssistant } from '../../../../ha/types.js';
import { localize } from '../../../../localize/localize.js';
import liveGo2RTCStyle from '../../../../scss/live-go2rtc.scss';
import { MediaPlayer, MediaPlayerController, Message } from '../../../../types.js';
import { convertEndpointAddressToSignedWebsocket } from '../../../../utils/endpoint.js';
import { renderMessage } from '../../../message.js';
import { VideoRTC } from './video-rtc.js';

customElements.define('advanced-camera-card-live-go2rtc-player', VideoRTC);

// Note (2023-02-18): Depending on the behavior of the player / browser is
// possible this URL will need to be re-signed in order to avoid HA spamming
// logs after the expiry time, but this complexity is not added for now until
// there are verified cases of this being an issue (see equivalent in the JSMPEG
// provider).
const GO2RTC_URL_SIGN_EXPIRY_SECONDS = 24 * 60 * 60;

@customElement('advanced-camera-card-live-go2rtc')
export class AdvancedCameraCardGo2RTC extends LitElement implements MediaPlayer {
  // Not an reactive property to avoid resetting the video.
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraConfig?: CameraConfig;

  @property({ attribute: false })
  public cameraEndpoints?: CameraEndpoints;

  @property({ attribute: false })
  public microphoneState?: MicrophoneState;

  @property({ attribute: false })
  public microphoneConfig?: MicrophoneConfig;

  @property({ attribute: true, type: Boolean })
  public controls = false;

  @state()
  protected _message: Message | null = null;

  protected _player?: VideoRTC;

  protected _mediaPlayerController = new VideoMediaPlayerController(
    this,
    () => this._player?.video ?? null,
    () => this.controls,
  );

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    return this._mediaPlayerController;
  }

  disconnectedCallback(): void {
    this._player = undefined;
    this._message = null;
    super.disconnectedCallback();
  }

  connectedCallback(): void {
    super.connectedCallback();

    // Reset the player when reconnected to the DOM.
    // https://github.com/dermotduffy/advanced-camera-card/issues/996
    this.requestUpdate();
  }

  protected async _createPlayer(): Promise<void> {
    if (!this.hass) {
      return;
    }

    const endpoint = this.cameraEndpoints?.go2rtc;
    if (!endpoint) {
      this._message = {
        type: 'error',
        message: localize('error.live_camera_no_endpoint'),
        context: this.cameraConfig,
      };
      dispatchLiveErrorEvent(this);
      return;
    }

    const address = await convertEndpointAddressToSignedWebsocket(
      this.hass,
      endpoint,
      GO2RTC_URL_SIGN_EXPIRY_SECONDS,
    );
    if (!address) {
      this._message = {
        type: 'error',
        message: localize('error.failed_sign'),
        context: this.cameraConfig,
      };
      dispatchLiveErrorEvent(this);
      return;
    }

    this._player = new VideoRTC();
    this._player.mediaPlayerController = this._mediaPlayerController;
    this._player.microphoneStream = this.microphoneState?.stream ?? null;
    this._player.src = address;
    this._player.visibilityCheck = false;
    this._player.setControls(this.controls);

    if (this.cameraConfig?.go2rtc?.modes && this.cameraConfig.go2rtc.modes.length) {
      this._player.mode = this.cameraConfig.go2rtc.modes.join(',');
    }

    this.requestUpdate();
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('cameraEndpoints')) {
      this._message = null;
    }

    if (!this._message && (!this._player || changedProps.has('cameraEndpoints'))) {
      this._createPlayer();
    }

    if (changedProps.has('controls') && this._player) {
      this._player.setControls(this.controls);
    }

    if (
      this._player &&
      changedProps.has('microphoneState') &&
      this._player.microphoneStream !== (this.microphoneState?.stream ?? null)
    ) {
      this._player.microphoneStream = this.microphoneState?.stream ?? null;

      // Need to force a reconnect if the microphone stream changes since
      // WebRTC cannot introduce a new stream after the offer is already made.
      this._player.reconnect();
    }
  }

  protected render(): TemplateResult | void {
    if (this._message) {
      return renderMessage(this._message);
    }
    return html`${this._player}`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(liveGo2RTCStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-live-go2rtc': AdvancedCameraCardGo2RTC;
  }
}



================================================
FILE: src/components/live/providers/go2rtc/video-rtc.d.ts
================================================
import { MediaPlayerController } from '../../../../types';

export class VideoRTC extends HTMLElement {
  DISCONNECT_TIMEOUT: number;
  RECONNECT_TIMEOUT: number;
  CODECS: string[];
  mode: string;
  background: boolean;
  visibilityThreshold: number;
  visibilityCheck: boolean;
  pcConfig: RTCConfiguration;
  wsState: number;
  pcState: number;
  video: HTMLVideoElement | null;
  ws: WebSocket | null;
  wsURL: string;
  pc: RTCPeerConnection | null;
  connectTS: number;
  mseCodecs: string;

  src: string | URL;

  oninit(): void;
  send(value: unknown): void;
  onpcvideo(ev: Event): void;
  onconnect(): void;
  ondisconnect(): void;
  onclose(): void;
  onopen(): void;
  onwebrtc(): void;
  onmessage: Record<string, (msg: { type: string; value: string }) => void>;

  // Custom methods/members.
  mediaPlayerController: MediaPlayerController | null;
  microphoneStream: MediaStream | null;
  reconnect();
  setControls(controls: boolean): void;
}



================================================
FILE: src/components/live/providers/go2rtc/video-rtc.js
================================================
import { mayHaveAudio } from '../../../../utils/audio';
import {
  hideMediaControlsTemporarily,
  MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
  setControlsOnVideo,
} from '../../../../utils/controls.js';
import {
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
  dispatchMediaVolumeChangeEvent,
} from '../../../../utils/media-info';
import { getTechnologyForVideoRTC } from '../../../../components-lib/live/utils/get-technology-for-video-rtc.js';

/**
 * VideoRTC v1.6.0 - Video player for go2rtc streaming application.
 *
 * All modern web technologies are supported in almost any browser except Apple Safari.
 *
 * Support:
 * - ECMAScript 2017 (ES8) = ES6 + async
 * - RTCPeerConnection for Safari iOS 11.0+
 * - IntersectionObserver for Safari iOS 12.2+
 * - ManagedMediaSource for Safari 17+
 *
 * Doesn't support:
 * - MediaSource for Safari iOS
 * - Customized built-in elements (extends HTMLVideoElement) because Safari
 * - Autoplay for WebRTC in Safari
 */
export class VideoRTC extends HTMLElement {
  constructor() {
    super();

    this.DISCONNECT_TIMEOUT = 5000;
    this.RECONNECT_TIMEOUT = 15000;

    this.CODECS = [
      'avc1.640029', // H.264 high 4.1 (Chromecast 1st and 2nd Gen)
      'avc1.64002A', // H.264 high 4.2 (Chromecast 3rd Gen)
      'avc1.640033', // H.264 high 5.1 (Chromecast with Google TV)
      'hvc1.1.6.L153.B0', // H.265 main 5.1 (Chromecast Ultra)
      'mp4a.40.2', // AAC LC
      'mp4a.40.5', // AAC HE
      'flac', // FLAC (PCM compatible)
      'opus', // OPUS Chrome, Firefox
    ];

    /**
     * [config] Supported modes (webrtc, webrtc/tcp, mse, hls, mp4, mjpeg).
     * @type {string}
     */
    this.mode = 'webrtc,mse,hls,mjpeg';

    /**
     * [Config] Requested medias (video, audio, microphone).
     * @type {string}
     */
    this.media = 'video,audio';

    /**
     * [config] Run stream when not displayed on the screen. Default `false`.
     * @type {boolean}
     */
    this.background = false;

    /**
     * [config] Run stream only when player in the viewport. Stop when user scroll out player.
     * Value is percentage of visibility from `0` (not visible) to `1` (full visible).
     * Default `0` - disable;
     * @type {number}
     */
    this.visibilityThreshold = 0;

    /**
     * [config] Run stream only when browser page on the screen. Stop when user change browser
     * tab or minimise browser windows.
     * @type {boolean}
     */
    this.visibilityCheck = true;

    /**
     * [config] WebRTC configuration
     * @type {RTCConfiguration}
     */
    this.pcConfig = {
      bundlePolicy: 'max-bundle',
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
      sdpSemantics: 'unified-plan', // important for Chromecast 1
    };

    /**
     * [info] WebSocket connection state. Values: CONNECTING, OPEN, CLOSED
     * @type {number}
     */
    this.wsState = WebSocket.CLOSED;

    /**
     * [info] WebRTC connection state.
     * @type {number}
     */
    this.pcState = WebSocket.CLOSED;

    /**
     * @type {HTMLVideoElement}
     */
    this.video = null;

    /**
     * @type {WebSocket}
     */
    this.ws = null;

    /**
     * @type {string|URL}
     */
    this.wsURL = '';

    /**
     * @type {RTCPeerConnection}
     */
    this.pc = null;

    /**
     * @type {number}
     */
    this.connectTS = 0;

    /**
     * @type {string}
     */
    this.mseCodecs = '';

    /**
     * [internal] Disconnect TimeoutID.
     * @type {number}
     */
    this.disconnectTID = 0;

    /**
     * [internal] Reconnect TimeoutID.
     * @type {number}
     */
    this.reconnectTID = 0;

    /**
     * [internal] Handler for receiving Binary from WebSocket.
     * @type {Function}
     */
    this.ondata = null;

    /**
     * [internal] Handlers list for receiving JSON from WebSocket.
     * @type {Object.<string,Function>}
     */
    this.onmessage = null;

    /**
     * A microphone stream to attach to a WebRTC connection.
     * @type {MediaStream}}
     */
    this.microphoneStream = null;

    /**
     * A reference to a MediaPlayerController for this video
     * @type {MediaPlayerController | null}
     */
    this.mediaPlayerController = null;

    /**
     * Whether to show or hide video controls for videos created *in future*.
     * @type {boolean}}
     */
    this.controls = true;
  }

  /**
   * Reconnect the stream.
   */
  reconnect() {
    if (this.wsState !== WebSocket.CLOSED) {
      // The websocket has onclose handlers, so don't call onconnect directly,
      // wait until the eventhandlers are finished..
      this.ws?.addEventListener('close', () => this.onconnect());
      this.ondisconnect();
    } else {
      // Still call ondisconnect() as there may be an RTC connection to
      // terminate even if the websocket is closed.
      this.ondisconnect();
      this.onconnect();
    }
  }

  setControls(controls) {
    this.controls = controls;

    // If the video already exists the controls won't be changed by default.
    if (this.video) {
      setControlsOnVideo(this.video, controls);
    }
  }

  /**
   * Set video source (WebSocket URL). Support relative path.
   * @param {string|URL} value
   */
  set src(value) {
    if (typeof value !== 'string') value = value.toString();
    if (value.startsWith('http')) {
      value = 'ws' + value.substring(4);
    } else if (value.startsWith('/')) {
      value = 'ws' + location.origin.substring(4) + value;
    }

    this.wsURL = value;

    this.onconnect();
  }

  /**
   * Play video. Support automute when autoplay blocked.
   * https://developer.chrome.com/blog/autoplay/
   */
  play() {
    // Advanced Camera Card controls playing at a higher level.
  }

  /**
   * Send message to server via WebSocket
   * @param {Object} value
   */
  send(value) {
    if (this.ws) this.ws.send(JSON.stringify(value));
  }

  /** @param {Function} isSupported */
  codecs(isSupported) {
    return this.CODECS.filter(
      (codec) => this.media.indexOf(codec.indexOf('vc1') > 0 ? 'video' : 'audio') >= 0,
    )
      .filter((codec) => isSupported(`video/mp4; codecs="${codec}"`))
      .join();
  }

  /**
   * `CustomElement`. Invoked each time the custom element is appended into a
   * document-connected element.
   */
  connectedCallback() {
    if (this.disconnectTID) {
      clearTimeout(this.disconnectTID);
      this.disconnectTID = 0;
    }

    // because video autopause on disconnected from DOM
    if (this.video) {
      const seek = this.video.seekable;
      if (seek.length > 0) {
        this.video.currentTime = seek.end(seek.length - 1);
      }
      this.play();
    } else {
      this.oninit();
    }

    this.onconnect();
  }

  /**
   * `CustomElement`. Invoked each time the custom element is disconnected from the
   * document's DOM.
   */
  disconnectedCallback() {
    if (this.background || this.disconnectTID) return;
    if (this.wsState === WebSocket.CLOSED && this.pcState === WebSocket.CLOSED) return;

    this.disconnectTID = setTimeout(() => {
      if (this.reconnectTID) {
        clearTimeout(this.reconnectTID);
        this.reconnectTID = 0;
      }

      this.disconnectTID = 0;

      this.ondisconnect();
    }, this.DISCONNECT_TIMEOUT);
  }

  /**
   * Creates child DOM elements. Called automatically once on `connectedCallback`.
   */
  oninit() {
    this.video = document.createElement('video');
    setControlsOnVideo(this.video, this.controls);
    this.video.playsInline = true;
    this.video.preload = 'auto';

    this.video.style.display = 'block'; // fix bottom margin 4px
    this.video.style.width = '100%';
    this.video.style.height = '100%';

    this.appendChild(this.video);

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    this.video.addEventListener('error', (_ev) => {
      // For Advanced Camera Card, we avoid log spam here from errors, and also don't
      // attempt to close the websocket unless the connection is open (otherwise
      // on reconnect() an exception will be thrown here that we're attempting
      // to close a connection that's not open)

      // console.warn(ev);
      if (this.ws && this.wsState === WebSocket.OPEN) this.ws.close(); // run reconnect for broken MSE stream
    });

    // all Safari lies about supported audio codecs
    const m = window.navigator.userAgent.match(/Version\/(\d+).+Safari/);
    if (m) {
      // AAC from v13, FLAC from v14, OPUS - unsupported
      const skip = m[1] < '13' ? 'mp4a.40.2' : m[1] < '14' ? 'flac' : 'opus';
      this.CODECS.splice(this.CODECS.indexOf(skip));
    }

    if (this.background) return;

    if ('hidden' in document && this.visibilityCheck) {
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.disconnectedCallback();
        } else if (this.isConnected) {
          this.connectedCallback();
        }
      });
    }

    if ('IntersectionObserver' in window && this.visibilityThreshold) {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (!entry.isIntersecting) {
              this.disconnectedCallback();
            } else if (this.isConnected) {
              this.connectedCallback();
            }
          });
        },
        { threshold: this.visibilityThreshold },
      );
      observer.observe(this);
    }

    this.video.onloadeddata = () => {
      if (this.controls) {
        hideMediaControlsTemporarily(this.video, MEDIA_LOAD_CONTROLS_HIDE_SECONDS);
      }
      dispatchMediaLoadedEvent(this, this.video, {
        ...(this.mediaPlayerController && {
          mediaPlayerController: this.mediaPlayerController,
        }),
        capabilities: {
          // 2-way audio is only supported on WebRTC connections. The state of
          // `this.microphoneStream` is not taken into account here since
          // that can be created after the fact -- this is purely saying that
          // were a microphone stream available it could be used usefully.
          supports2WayAudio: !!this.pc,
          supportsPause: true,
          hasAudio: mayHaveAudio(this.video),
        },
        technology: getTechnologyForVideoRTC(this),
      });
    };
    this.video.onvolumechange = () => dispatchMediaVolumeChangeEvent(this);
    this.video.onplay = () => dispatchMediaPlayEvent(this);
    this.video.onpause = () => dispatchMediaPauseEvent(this);
    // Always started muted. Media may be unmuted in accordance with user
    // configuration.
    this.video.muted = true;
  }

  /**
   * Connect to WebSocket. Called automatically on `connectedCallback`.
   * @return {boolean} true if the connection has started.
   */
  onconnect() {
    if (!this.isConnected || !this.wsURL || this.ws || this.pc) return false;

    // CLOSED or CONNECTING => CONNECTING
    this.wsState = WebSocket.CONNECTING;

    this.connectTS = Date.now();

    this.ws = new WebSocket(this.wsURL);
    this.ws.binaryType = 'arraybuffer';
    this.ws.addEventListener('open', (ev) => this.onopen(ev));
    this.ws.addEventListener('close', (ev) => this.onclose(ev));

    return true;
  }

  ondisconnect() {
    this.wsState = WebSocket.CLOSED;
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }

    this.pcState = WebSocket.CLOSED;
    if (this.pc) {
      // Do not close the (microphone) track attached to the peer connection as
      // that is controlled by MicrophoneManager.
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1810

      this.pc.close();
      this.pc = null;
    }

    this.video.src = '';
    this.video.srcObject = null;
  }

  /**
   * @returns {Array.<string>} of modes (mse, webrtc, etc.)
   */
  onopen() {
    // CONNECTING => OPEN
    this.wsState = WebSocket.OPEN;

    this.ws.addEventListener('message', (ev) => {
      if (typeof ev.data === 'string') {
        const msg = JSON.parse(ev.data);
        for (const mode in this.onmessage) {
          this.onmessage[mode](msg);
        }
      } else {
        this.ondata(ev.data);
      }
    });

    this.ondata = null;
    this.onmessage = {};

    const modes = [];

    if (
      this.mode.indexOf('mse') >= 0 &&
      ('MediaSource' in window || 'ManagedMediaSource' in window)
    ) {
      modes.push('mse');
      this.onmse();
    } else if (
      this.mode.indexOf('hls') >= 0 &&
      this.video.canPlayType('application/vnd.apple.mpegurl')
    ) {
      modes.push('hls');
      this.onhls();
    } else if (this.mode.indexOf('mp4') >= 0) {
      modes.push('mp4');
      this.onmp4();
    }

    if (this.mode.indexOf('webrtc') >= 0 && 'RTCPeerConnection' in window) {
      modes.push('webrtc');
      this.onwebrtc();
    }

    if (this.mode.indexOf('mjpeg') >= 0) {
      if (modes.length) {
        this.onmessage['mjpeg'] = (msg) => {
          if (msg.type !== 'error' || msg.value.indexOf(modes[0]) !== 0) return;
          this.onmjpeg();
        };
      } else {
        modes.push('mjpeg');
        this.onmjpeg();
      }
    }

    return modes;
  }

  /**
   * @return {boolean} true if reconnection has started.
   */
  onclose() {
    if (this.wsState === WebSocket.CLOSED) return false;

    // CONNECTING, OPEN => CONNECTING
    this.wsState = WebSocket.CONNECTING;
    this.ws = null;

    // reconnect no more than once every X seconds
    const delay = Math.max(this.RECONNECT_TIMEOUT - (Date.now() - this.connectTS), 0);

    this.reconnectTID = setTimeout(() => {
      this.reconnectTID = 0;
      this.onconnect();
    }, delay);

    return true;
  }

  onmse() {
    /** @type {MediaSource} */
    let ms;

    if ('ManagedMediaSource' in window) {
      const MediaSource = window.ManagedMediaSource;

      ms = new MediaSource();
      ms.addEventListener(
        'sourceopen',
        () => {
          this.send({ type: 'mse', value: this.codecs(MediaSource.isTypeSupported) });
        },
        { once: true },
      );

      this.video.disableRemotePlayback = true;
      this.video.srcObject = ms;
    } else {
      ms = new MediaSource();
      ms.addEventListener(
        'sourceopen',
        () => {
          URL.revokeObjectURL(this.video.src);
          this.send({ type: 'mse', value: this.codecs(MediaSource.isTypeSupported) });
        },
        { once: true },
      );

      this.video.src = URL.createObjectURL(ms);
      this.video.srcObject = null;
    }

    this.play();

    this.mseCodecs = '';

    this.onmessage['mse'] = (msg) => {
      if (msg.type !== 'mse') return;

      this.mseCodecs = msg.value;

      const sb = ms.addSourceBuffer(msg.value);
      sb.mode = 'segments'; // segments or sequence
      sb.addEventListener('updateend', () => {
        if (sb.updating) return;

        try {
          if (bufLen > 0) {
            const data = buf.slice(0, bufLen);
            bufLen = 0;
            sb.appendBuffer(data);
          } else if (sb.buffered && sb.buffered.length) {
            const end = sb.buffered.end(sb.buffered.length - 1) - 15;
            const start = sb.buffered.start(0);
            if (end > start) {
              sb.remove(start, end);
              ms.setLiveSeekableRange(end, end + 15);
            }
            // console.debug("VideoRTC.buffered", start, end);
          }
        } catch (e) {
          // console.debug(e);
        }
      });

      const buf = new Uint8Array(2 * 1024 * 1024);
      let bufLen = 0;

      this.ondata = (data) => {
        if (sb.updating || bufLen > 0) {
          const b = new Uint8Array(data);
          buf.set(b, bufLen);
          bufLen += b.byteLength;
          // console.debug("VideoRTC.buffer", b.byteLength, bufLen);
        } else {
          try {
            sb.appendBuffer(data);
          } catch (e) {
            // console.debug(e);
          }
        }
      };
    };
  }

  onwebrtc() {
    const pc = new RTCPeerConnection(this.pcConfig);

    pc.addEventListener('icecandidate', (ev) => {
      if (
        ev.candidate &&
        this.mode.indexOf('webrtc/tcp') >= 0 &&
        ev.candidate.protocol === 'udp'
      )
        return;

      const candidate = ev.candidate ? ev.candidate.toJSON().candidate : '';
      this.send({ type: 'webrtc/candidate', value: candidate });
    });

    pc.addEventListener('connectionstatechange', () => {
      if (pc.connectionState === 'connected') {
        const tracks = pc
          .getTransceivers()
          .filter((tr) => tr.currentDirection === 'recvonly') // skip inactive
          .map((tr) => tr.receiver.track);
        /** @type {HTMLVideoElement} */
        const video2 = document.createElement('video');
        video2.addEventListener('loadeddata', () => this.onpcvideo(video2), {
          once: true,
        });
        video2.srcObject = new MediaStream(tracks);
      } else if (
        pc.connectionState === 'failed' ||
        pc.connectionState === 'disconnected'
      ) {
        pc.close(); // stop next events

        this.pcState = WebSocket.CLOSED;
        this.pc = null;

        this.onconnect();
      }
    });

    this.onmessage['webrtc'] = (msg) => {
      switch (msg.type) {
        case 'webrtc/candidate':
          if (this.mode.indexOf('webrtc/tcp') >= 0 && msg.value.indexOf(' udp ') > 0)
            return;

          pc.addIceCandidate({ candidate: msg.value, sdpMid: '0' }).catch((er) => {
            console.warn(er);
          });
          break;
        case 'webrtc/answer':
          pc.setRemoteDescription({ type: 'answer', sdp: msg.value }).catch((er) => {
            console.warn(er);
          });
          break;
        case 'error':
          if (msg.value.indexOf('webrtc/offer') < 0) return;
          pc.close();
      }
    };

    this.createOffer(pc).then((offer) => {
      this.send({ type: 'webrtc/offer', value: offer.sdp });
    });

    this.pcState = WebSocket.CONNECTING;
    this.pc = pc;
  }

  /**
   * @param pc {RTCPeerConnection}
   * @return {Promise<RTCSessionDescriptionInit>}
   */
  async createOffer(pc) {
    // Must add microphone tracks prior to making the offer.
    this.microphoneStream?.getTracks().forEach((track) => {
      pc.addTransceiver(track, { direction: 'sendonly' });
    });

    try {
      if (this.media.indexOf('microphone') >= 0) {
        const media = await navigator.mediaDevices.getUserMedia({ audio: true });
        media.getTracks().forEach((track) => {
          pc.addTransceiver(track, { direction: 'sendonly' });
        });
      }
    } catch (e) {
      console.warn(e);
    }

    for (const kind of ['video', 'audio']) {
      if (this.media.indexOf(kind) >= 0) {
        pc.addTransceiver(kind, { direction: 'recvonly' });
      }
    }

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    return offer;
  }

  /**
   * @param video2 {HTMLVideoElement}
   */
  onpcvideo(video2) {
    if (this.pc) {
      // Video+Audio > Video, H265 > H264, Video > Audio, WebRTC > MSE
      let rtcPriority = 0,
        msePriority = 0;

      /** @type {MediaStream} */
      const stream = video2.srcObject;
      if (stream.getVideoTracks().length > 0) rtcPriority += 0x220;
      if (stream.getAudioTracks().length > 0) rtcPriority += 0x102;

      if (this.mseCodecs.indexOf('hvc1.') >= 0) msePriority += 0x230;
      if (this.mseCodecs.indexOf('avc1.') >= 0) msePriority += 0x210;
      if (this.mseCodecs.indexOf('mp4a.') >= 0) msePriority += 0x101;

      if (rtcPriority >= msePriority) {
        this.video.srcObject = stream;
        this.play();

        this.pcState = WebSocket.OPEN;

        this.wsState = WebSocket.CLOSED;
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
      } else {
        this.pcState = WebSocket.CLOSED;
        if (this.pc) {
          this.pc.close();
          this.pc = null;
        }
      }
    }

    video2.srcObject = null;
  }

  onmjpeg() {
    let receivedFirstFrame = false;

    this.ondata = (data) => {
      setControlsOnVideo(this.video, false);
      this.video.poster = 'data:image/jpeg;base64,' + VideoRTC.btoa(data);

      if (!receivedFirstFrame) {
        receivedFirstFrame = true;
        dispatchMediaLoadedEvent(this, this.video, {
          ...(this.mediaPlayerController && {
            mediaPlayerController: this.mediaPlayerController,
          }),
          technology: ['mjpeg'],
        });
      }
    };

    this.send({ type: 'mjpeg' });
  }

  onhls() {
    this.onmessage['hls'] = (msg) => {
      if (msg.type !== 'hls') return;

      const url = 'http' + this.wsURL.substring(2, this.wsURL.indexOf('/ws')) + '/hls/';
      const playlist = msg.value.replace('hls/', url);
      this.video.src = 'data:application/vnd.apple.mpegurl;base64,' + btoa(playlist);
      this.play();
    };

    this.send({
      type: 'hls',
      value: this.codecs((type) => this.video.canPlayType(type)),
    });
  }

  onmp4() {
    /** @type {HTMLCanvasElement} **/
    const canvas = document.createElement('canvas');
    /** @type {CanvasRenderingContext2D} */
    let context;

    /** @type {HTMLVideoElement} */
    const video2 = document.createElement('video');
    video2.autoplay = true;
    video2.playsInline = true;
    video2.muted = true;

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    video2.addEventListener('loadeddata', (_ev) => {
      if (!context) {
        canvas.width = video2.videoWidth;
        canvas.height = video2.videoHeight;
        context = canvas.getContext('2d');

        dispatchMediaLoadedEvent(this, video2, {
          ...(this.mediaPlayerController && {
            mediaPlayerController: this.mediaPlayerController,
          }),
          technology: ['mp4'],
        });
      }

      context.drawImage(video2, 0, 0, canvas.width, canvas.height);

      setControlsOnVideo(this.video, false);
      this.video.poster = canvas.toDataURL('image/jpeg');
    });

    this.ondata = (data) => {
      video2.src = 'data:video/mp4;base64,' + VideoRTC.btoa(data);
    };

    this.send({ type: 'mp4', value: this.codecs(this.video.canPlayType) });
  }

  static btoa(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    let binary = '';
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
}



================================================
FILE: src/components/submenu/index.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { styleMap } from 'lit/directives/style-map.js';
import { actionHandler } from '../../action-handler-directive.js';
import { getEntityTitle } from '../../ha/get-entity-title.js';
import { HomeAssistant } from '../../ha/types.js';
import submenuStyle from '../../scss/submenu.scss';
import {
  hasAction,
  stopEventFromActivatingCardWideActions,
} from '../../utils/action.js';
import '../icon.js';
import { SubmenuInteraction, SubmenuItem } from './types.js';

@customElement('advanced-camera-card-submenu')
export class AdvancedCameraCardSubmenu extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public items?: SubmenuItem[];

  protected _renderItem(item: SubmenuItem): TemplateResult | void {
    if (!this.hass) {
      return;
    }

    const title = item.title ?? getEntityTitle(this.hass, item.entity);
    const style = styleMap(item.style || {});

    return html`
      <mwc-list-item
        graphic=${ifDefined(item.icon || item.entity ? 'icon' : undefined)}
        ?twoline=${!!item.subtitle}
        ?selected=${item.selected}
        ?activated=${item.selected}
        ?disabled=${item.enabled === false}
        aria-label="${title ?? ''}"
        @action=${(ev: CustomEvent<SubmenuInteraction>) => {
          // Attach the item so ascendants have access to it.
          ev.detail.item = item;
        }}
        .actionHandler=${actionHandler({
          allowPropagation: true,
          hasHold: hasAction(item.hold_action),
          hasDoubleClick: hasAction(item.double_tap_action),
        })}
      >
        <span style="${style}">${title ?? ''}</span>
        ${item.subtitle
          ? html`<span slot="secondary" style="${style}">${item.subtitle}</span>`
          : ''}
        <advanced-camera-card-icon
          slot="graphic"
          .hass=${this.hass}
          .icon=${{
            icon: item.icon,
            entity: item.entity,
          }}
          style="${style}"
        ></advanced-camera-card-icon>
      </mwc-list-item>
    `;
  }

  protected render(): TemplateResult {
    return html`
      <ha-button-menu
        fixed
        corner=${'BOTTOM_LEFT'}
        @closed=${
          // Prevent the submenu closing from closing anything upstream (e.g.
          // selecting a submenu in the editor dialog should not close the
          // editor, see https://github.com/dermotduffy/advanced-camera-card/issues/377).
          (ev) => ev.stopPropagation()
        }
        @click=${(ev: Event) => stopEventFromActivatingCardWideActions(ev)}
      >
        <slot slot="trigger"></slot>
        ${this.items?.map(this._renderItem.bind(this))}
      </ha-button-menu>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(submenuStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-submenu': AdvancedCameraCardSubmenu;
  }
}



================================================
FILE: src/components/submenu/select-button.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { MenuSubmenuSelect } from '../../config/schema/elements/custom/menu/submenu-select.js';
import { MenuSubmenuItem } from '../../config/schema/elements/custom/menu/submenu.js';
import { computeDomain } from '../../ha/compute-domain.js';
import { getEntityStateTranslation } from '../../ha/entity-state-translation.js';
import { getEntityTitle } from '../../ha/get-entity-title.js';
import { isHassDifferent } from '../../ha/is-hass-different.js';
import { EntityRegistryManager } from '../../ha/registry/entity/types.js';
import { HomeAssistant } from '../../ha/types.js';
import menuButtonStyle from '../../scss/menu-button.scss';
import { Icon } from '../../types.js';
import { createSelectOptionAction } from '../../utils/action.js';
import '../icon.js';
import './index.js';

@customElement('advanced-camera-card-submenu-select-button')
export class AdvancedCameraCardSubmenuSelectButton extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public submenuSelect?: MenuSubmenuSelect;

  @property({ attribute: false })
  public entityRegistryManager?: EntityRegistryManager;

  @state()
  protected _optionTitles?: Record<string, string>;

  protected _generatedSubmenuItems?: MenuSubmenuItem[];
  protected _generatedIcon?: Icon;

  protected shouldUpdate(changedProps: PropertyValues): boolean {
    // No need to update the submenu unless the select entity has changed.
    const oldHass = changedProps.get('hass') as HomeAssistant | undefined;
    return (
      !changedProps.has('hass') ||
      !oldHass ||
      !this.submenuSelect ||
      isHassDifferent(this.hass, oldHass, [this.submenuSelect.entity])
    );
  }

  protected async _refreshOptionTitles(): Promise<void> {
    if (!this.hass || !this.submenuSelect) {
      return;
    }
    const entityID = this.submenuSelect.entity;
    const stateObj = this.hass.states[entityID];
    const options = stateObj?.attributes?.options;
    const entity =
      (await this.entityRegistryManager?.getEntity(this.hass, entityID)) ?? null;

    const optionTitles = {};
    for (const option of options) {
      const title = getEntityStateTranslation(this.hass, entityID, {
        ...(entity && { entity: entity }),
        state: option,
      });
      if (title) {
        optionTitles[option] = title;
      }
    }

    // This will cause a re-render with the updated title if it is
    // different.
    this._optionTitles = optionTitles;
  }

  protected willUpdate(): void {
    if (!this.submenuSelect || !this.hass) {
      return;
    }

    if (!this._optionTitles) {
      this._refreshOptionTitles();
    }

    const entityID = this.submenuSelect.entity;
    const entityDomain = computeDomain(entityID);
    const stateObj = this.hass.states[entityID];
    const options = stateObj?.attributes?.options;
    if (!stateObj || !options) {
      return;
    }

    const items: MenuSubmenuItem[] = [];

    for (const option of options) {
      const title = this._optionTitles?.[option] ?? option;
      items.push({
        state_color: true,
        selected: stateObj.state === option,
        enabled: true,
        title: title || option,
        ...((entityDomain === 'select' || entityDomain === 'input_select') && {
          tap_action: createSelectOptionAction(entityDomain, entityID, option),
        }),
        // Apply overrides the user may have specified for a given option.
        ...(this.submenuSelect.options && this.submenuSelect.options[option]),
      });
    }

    this._generatedSubmenuItems = items;
    this._generatedIcon = {
      icon: this.submenuSelect.icon,
      entity: entityID,
      fallback: 'mdi:format-list-bulleted',
      stateColor: this.submenuSelect.state_color,
    };
  }

  protected render(): TemplateResult {
    if (!this._generatedSubmenuItems || !this._generatedIcon || !this.submenuSelect) {
      return html``;
    }

    const title = getEntityTitle(this.hass, this.submenuSelect.entity);
    const style = styleMap(this.submenuSelect.style || {});
    return html` <advanced-camera-card-submenu
      .hass=${this.hass}
      .items=${this._generatedSubmenuItems}
    >
      <ha-icon-button style="${style}" .label=${title || ''}>
        <advanced-camera-card-icon
          ?allow-override-non-active-styles=${true}
          style="${style}"
          title=${title || ''}
          .hass=${this.hass}
          .icon=${this._generatedIcon}
        ></advanced-camera-card-icon>
      </ha-icon-button>
    </advanced-camera-card-submenu>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(menuButtonStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-submenu-select-button': AdvancedCameraCardSubmenuSelectButton;
  }
}



================================================
FILE: src/components/submenu/submenu-button.ts
================================================
import { CSSResultGroup, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { actionHandler } from '../../action-handler-directive.js';
import { MenuSubmenu } from '../../config/schema/elements/custom/menu/submenu.js';
import { HomeAssistant } from '../../ha/types.js';
import menuButtonStyle from '../../scss/menu-button.scss';
import { hasAction } from '../../utils/action.js';
import '../icon.js';
import './index.js';

@customElement('advanced-camera-card-submenu-button')
export class AdvancedCameraCardSubmenuButton extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public submenu?: MenuSubmenu;

  protected render(): TemplateResult {
    if (!this.submenu) {
      return html``;
    }

    const style = styleMap(this.submenu.style || {});
    return html` <advanced-camera-card-submenu
      .hass=${this.hass}
      .items=${this.submenu?.items}
    >
      <ha-icon-button style="${style}" .label=${this.submenu.title || ''}>
        <advanced-camera-card-icon
          ?allow-override-non-active-styles=${true}
          style="${style}"
          title=${this.submenu.title || ''}
          .hass=${this.hass}
          .icon=${{ icon: this.submenu.icon }}
          .actionHandler=${actionHandler({
            // Need to allow event to propagate upwards, as it's caught by the
            // <ha-button-menu> trigger slot to open/close the menu. Further
            // propagation is forbidden by the @click handler on
            // <ha-button-menu>.
            allowPropagation: true,
            hasHold: hasAction(this.submenu.hold_action),
            hasDoubleClick: hasAction(this.submenu.double_tap_action),
          })}
        ></advanced-camera-card-icon>
      </ha-icon-button>
    </advanced-camera-card-submenu>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(menuButtonStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-submenu-button': AdvancedCameraCardSubmenuButton;
  }
}



================================================
FILE: src/components/submenu/types.ts
================================================
import { Actions } from '../../config/schema/actions/types';
import { Interaction } from '../../types';

export interface SubmenuItem extends Actions {
  title?: string;
  subtitle?: string;
  icon?: string;
  entity?: string;
  style?: Record<string, string>;
  enabled?: boolean;
  selected?: boolean;
}

export interface SubmenuInteraction extends Interaction {
  item: SubmenuItem;
}



================================================
FILE: src/components/thumbnail/details.ts
================================================
import {
  CSSResult,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { CameraManager } from '../../camera-manager/manager';
import { ThumbnailDetailsController } from '../../components-lib/thumbnail/details-controller';
import { HomeAssistant } from '../../ha/types';
import thumbnailDetailsStyle from '../../scss/thumbnail-details.scss';
import { ViewItem } from '../../view/item';
import '../icon';

@customElement('advanced-camera-card-thumbnail-details')
export class AdvancedCameraCardThumbnailDetails extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public item?: ViewItem;

  @property({ attribute: false })
  public seek?: Date;

  private _controller = new ThumbnailDetailsController();

  protected willUpdate(changedProperties: PropertyValues): void {
    if (['item', 'seek', 'cameraManager'].some((prop) => changedProperties.has(prop))) {
      this._controller.calculate(this.cameraManager, this.item, this.seek);
    }
  }

  protected render(): TemplateResult | void {
    const heading = this._controller.getHeading();
    const details = this._controller.getDetails();

    return html`
      ${heading
        ? html` <div class="heading">
            <span title=${heading}>${heading}</span>
          </div>`
        : ``}
      ${details
        ? html` <div class="details">
            ${details.map(
              (detail) =>
                html`<div>
                  ${detail.icon
                    ? html` <advanced-camera-card-icon
                        title=${detail.hint ?? ''}
                        .icon=${detail.icon}
                      ></advanced-camera-card-icon>`
                    : ''}
                  <span>${detail.title}</span>
                </div>`,
            )}
          </div>`
        : ''}
    `;
  }

  static get styles(): CSSResult {
    return unsafeCSS(thumbnailDetailsStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-thumbnail-details': AdvancedCameraCardThumbnailDetails;
  }
}



================================================
FILE: src/components/thumbnail/thumbnail.ts
================================================
import { CSSResult, html, LitElement, TemplateResult, unsafeCSS } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { FoldersManager } from '../../card-controller/folders/manager.js';
import { ViewItemManager } from '../../card-controller/view/item-manager.js';
import { RemoveContextViewModifier } from '../../card-controller/view/modifiers/remove-context.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { dispatchAdvancedCameraCardErrorEvent } from '../../components-lib/message/dispatch.js';
import { HomeAssistant } from '../../ha/types.js';
import { localize } from '../../localize/localize.js';
import thumbnailStyle from '../../scss/thumbnail.scss';
import { stopEventFromActivatingCardWideActions } from '../../utils/action.js';
import { errorToConsole } from '../../utils/basic.js';
import { ViewItemClassifier } from '../../view/item-classifier.js';
import { ViewItem } from '../../view/item.js';
import './details.js';
import './feature/feature.js';
import './feature/thumbnail.js';

@customElement('advanced-camera-card-thumbnail')
export class AdvancedCameraCardThumbnail extends LitElement {
  // Performance: During timeline scrubbing, hass may be updated continuously.
  // As it is not needed for the thumbnail rendering itself, it does not trigger
  // a re-render. The HomeAssistant object may be required for thumbnail signing
  // (after initial signing the thumbnail is stored in a data URL, so the
  // signing will not expire).
  public hass?: HomeAssistant;

  // Performance: During timeline scrubbing, the view will be updated
  // continuously. As it is not needed for the thumbnail rendering itself, it
  // does not trigger a re-render.
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public viewItemManager?: ViewItemManager;

  @property({ attribute: false })
  public folderManager?: FoldersManager;

  @property({ attribute: false })
  public item?: ViewItem;

  @property({ attribute: true, type: Boolean })
  public details = false;

  @property({ attribute: true, type: Boolean })
  public show_favorite_control = false;

  @property({ attribute: true, type: Boolean })
  public show_timeline_control = false;

  @property({ attribute: true, type: Boolean })
  public show_download_control = false;

  @property({ attribute: false })
  public seek?: Date;

  /**
   * Render the element.
   * @returns A template to display to the user.
   */
  protected render(): TemplateResult | void {
    if (!this.item) {
      return;
    }

    const starClasses = {
      star: true,
      starred: ViewItemClassifier.isMedia(this.item) && !!this.item?.isFavorite(),
    };

    const shouldShowTimelineControl =
      this.show_timeline_control &&
      ((ViewItemClassifier.isEvent(this.item) && this.item.getStartTime()) ||
        (ViewItemClassifier.isRecording(this.item) &&
          this.item.getStartTime() &&
          this.item.getEndTime()));

    const mediaCapabilities = this.viewItemManager?.getCapabilities(this.item) ?? null;

    const shouldShowFavoriteControl =
      this.show_favorite_control &&
      this.item &&
      this.hass &&
      mediaCapabilities?.canFavorite;

    const shouldShowDownloadControl =
      this.show_download_control &&
      this.hass &&
      this.item.getID() &&
      mediaCapabilities?.canDownload;

    return html`
      <advanced-camera-card-thumbnail-feature
        .cameraManager=${this.cameraManager}
        .hasDetails=${this.details}
        .hass=${this.hass}
        .item=${this.item}
      >
      </advanced-camera-card-thumbnail-feature>
      ${shouldShowFavoriteControl
        ? html` <advanced-camera-card-icon
            class="${classMap(starClasses)}"
            title=${localize('thumbnail.retain_indefinitely')}
            .icon=${{ icon: this.item.isFavorite() ? 'mdi:star' : 'mdi:star-outline' }}
            @click=${async (ev: Event) => {
              stopEventFromActivatingCardWideActions(ev);
              if (this.hass && this.item) {
                try {
                  await this.viewItemManager?.favorite(
                    this.item,
                    !this.item.isFavorite(),
                  );
                } catch (e) {
                  errorToConsole(e as Error);
                  return;
                }
                this.requestUpdate();
              }
            }}
          /></advanced-camera-card-icon>`
        : ``}
      ${this.details
        ? html`<advanced-camera-card-thumbnail-details
            .hass=${this.hass}
            .item=${this.item ?? undefined}
            .cameraManager=${this.cameraManager}
            .seek=${this.seek}
          ></advanced-camera-card-thumbnail-details>`
        : ''}
      ${shouldShowTimelineControl
        ? html`<advanced-camera-card-icon
            class="timeline"
            .icon=${{ icon: 'mdi:target' }}
            title=${localize('thumbnail.timeline')}
            @click=${(ev: Event) => {
              stopEventFromActivatingCardWideActions(ev);
              if (!this.viewManagerEpoch || !this.item) {
                return;
              }
              this.viewManagerEpoch.manager.setViewByParameters({
                params: {
                  view: 'timeline',
                  queryResults: this.viewManagerEpoch?.manager
                    .getView()
                    ?.queryResults?.clone()
                    .selectResultIfFound((media) => media === this.item),
                },
                modifiers: [new RemoveContextViewModifier(['timeline'])],
              });
            }}
          ></advanced-camera-card-icon>`
        : ''}
      ${shouldShowDownloadControl
        ? html` <advanced-camera-card-icon
            class="download"
            .icon=${{ icon: 'mdi:download' }}
            title=${localize('thumbnail.download')}
            @click=${async (ev: Event) => {
              stopEventFromActivatingCardWideActions(ev);
              if (this.hass && this.item) {
                try {
                  this.viewItemManager?.download(this.item);
                } catch (error: unknown) {
                  dispatchAdvancedCameraCardErrorEvent(this, error);
                }
              }
            }}
          ></advanced-camera-card-icon>`
        : ``}
    `;
  }

  static get styles(): CSSResult {
    return unsafeCSS(thumbnailStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-thumbnail': AdvancedCameraCardThumbnail;
  }
}



================================================
FILE: src/components/thumbnail/feature/feature.ts
================================================
import {
  CSSResult,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { CameraManager } from '../../../camera-manager/manager';
import { ThumbnailFeatureController } from '../../../components-lib/thumbnail/feature/controller';
import { HomeAssistant } from '../../../ha/types';
import thumbnailFeatureStyle from '../../../scss/thumbnail-feature.scss';
import { ViewItem } from '../../../view/item';
import '../../icon.js';
import './thumbnail.js';

@customElement('advanced-camera-card-thumbnail-feature')
export class AdvancedCameraCardThumbnailFeature extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public item?: ViewItem;

  @property({ attribute: false })
  public hasDetails?: boolean;

  private _controller = new ThumbnailFeatureController();

  protected willUpdate(changedProperties: PropertyValues): void {
    if (
      ['item', 'hasDetails', 'cameraManager'].some((prop) => changedProperties.has(prop))
    ) {
      this._controller.calculate(this.cameraManager, this.item, this.hasDetails);
    }
  }

  protected render(): TemplateResult | void {
    const title = this._controller.getTitle();
    const subtitles = this._controller.getSubtitles();
    const iconClasses = classMap({
      background: title || subtitles.length,
    });

    const thumbnailClass = this._controller.getThumbnailClass();
    const thumbnailClasses = classMap({
      ...(thumbnailClass && { [thumbnailClass]: true }),
    });

    return html`
      ${this._controller.getThumbnail()
        ? html` <advanced-camera-card-thumbnail-feature-thumbnail
            class="${thumbnailClasses}"
            .hass=${this.hass}
            .thumbnail=${this._controller.getThumbnail()}
            aria-label=${this.item?.getTitle() ?? ''}
            title=${this.item?.getTitle() ?? ''}
          ></advanced-camera-card-thumbnail-feature-thumbnail>`
        : this._controller.getIcon()
          ? html`<advanced-camera-card-icon
              class="${iconClasses}"
              .icon=${{ icon: this._controller.getIcon() }}
            ></advanced-camera-card-icon>`
          : ''}
      ${title || subtitles.length
        ? html`
            ${title ? html`<div class="title">${title}</div>` : ''}
            ${subtitles.length
              ? html`<div>
                  ${subtitles.map(
                    (subtitle) => html`<div class="subtitle">${subtitle}</div>`,
                  )}
                </div>`
              : ''}
          `
        : html``}
    `;
  }

  static get styles(): CSSResult {
    return unsafeCSS(thumbnailFeatureStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-thumbnail-feature': AdvancedCameraCardThumbnailFeature;
  }
}



================================================
FILE: src/components/thumbnail/feature/thumbnail.ts
================================================
import { Task, TaskStatus } from '@lit-labs/task';
import {
  CSSResult,
  LitElement,
  PropertyValues,
  TemplateResult,
  html,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { HomeAssistant } from '../../../ha/types';
import { localize } from '../../../localize/localize';
import thumbnailFeatureThumbnailStyle from '../../../scss/thumbnail-feature-thumbnail.scss';
import { renderTask } from '../../../utils/task';
import {
  FetchThumbnailTaskArgs,
  createFetchThumbnailTask,
} from '../../../utils/thumbnail';

@customElement('advanced-camera-card-thumbnail-feature-thumbnail')
export class AdvancedCameraCardThumbnailFeatureThumbnail extends LitElement {
  @property({ attribute: false })
  public thumbnail?: string;

  @property({ attribute: false })
  public hass?: HomeAssistant;

  protected _embedThumbnailTask?: Task<FetchThumbnailTaskArgs, string | null>;

  // Only load thumbnails on view in case there is a very large number of them.
  protected _intersectionObserver = new IntersectionObserver(
    this._intersectionHandler.bind(this),
  );

  connectedCallback(): void {
    super.connectedCallback();
    this._intersectionObserver.observe(this);
  }

  disconnectedCallback(): void {
    this._intersectionObserver.disconnect();
    super.disconnectedCallback();
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('thumbnail')) {
      this._embedThumbnailTask = createFetchThumbnailTask(
        this,
        () => this.hass,
        () => this.thumbnail,
        false,
      );
      // Reset the observer so the initial intersection handler call will set
      // the visibility correctly.
      this._intersectionObserver.unobserve(this);
      this._intersectionObserver.observe(this);
    }
  }

  protected _intersectionHandler(entries: IntersectionObserverEntry[]): void {
    if (
      this._embedThumbnailTask?.status === TaskStatus.INITIAL &&
      entries.some((entry) => entry.isIntersecting)
    ) {
      this._embedThumbnailTask?.run();
    }
  }

  protected render(): TemplateResult | void {
    const imageOff = html`<advanced-camera-card-icon
      .icon=${{ icon: 'mdi:image-off' }}
      title=${localize('thumbnail.no_thumbnail')}
    ></advanced-camera-card-icon> `;

    if (!this._embedThumbnailTask) {
      return imageOff;
    }

    return html`${this.thumbnail
      ? renderTask(
          this._embedThumbnailTask,
          (embeddedThumbnail: string | null) =>
            embeddedThumbnail ? html`<img src="${embeddedThumbnail}" />` : html``,
          {
            inProgressFunc: () =>
              html`<advanced-camera-card-icon
                .icon=${{ icon: 'mdi:image-refresh' }}
                title=${localize('thumbnail.no_thumbnail')}
              ></advanced-camera-card-icon> `,
            errorFunc: () => imageOff,
          },
        )
      : imageOff} `;
  }

  static get styles(): CSSResult {
    return unsafeCSS(thumbnailFeatureThumbnailStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-thumbnail-feature-thumbnail': AdvancedCameraCardThumbnailFeatureThumbnail;
  }
}



================================================
FILE: src/components/viewer/carousel.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { guard } from 'lit/directives/guard.js';
import { createRef, Ref, ref } from 'lit/directives/ref.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { RemoveContextPropertyViewModifier } from '../../card-controller/view/modifiers/remove-context-property.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { MediaActionsController } from '../../components-lib/media-actions-controller.js';
import { MediaHeightController } from '../../components-lib/media-height-controller.js';
import { TransitionEffect } from '../../config/schema/common/transition-effect.js';
import { CardWideConfig, configDefaults } from '../../config/schema/types.js';
import { ViewerConfig } from '../../config/schema/viewer.js';
import { ResolvedMediaCache } from '../../ha/resolved-media.js';
import { HomeAssistant } from '../../ha/types.js';
import { localize } from '../../localize/localize.js';
import '../../patches/ha-hls-player.js';
import viewerCarouselStyle from '../../scss/viewer-carousel.scss';
import { MediaLoadedInfo, MediaPlayerController } from '../../types.js';
import { stopEventFromActivatingCardWideActions } from '../../utils/action.js';
import { contentsChanged, setOrRemoveAttribute } from '../../utils/basic.js';
import { CarouselSelected } from '../../utils/embla/carousel-controller.js';
import AutoMediaLoadedInfo from '../../utils/embla/plugins/auto-media-loaded-info/auto-media-loaded-info.js';
import { getTextDirection } from '../../utils/text-direction.js';
import { ViewItemClassifier } from '../../view/item-classifier.js';
import { ViewMedia } from '../../view/item.js';
import '../carousel';
import type { EmblaCarouselPlugins } from '../carousel.js';
import { renderMessage } from '../message.js';
import '../next-prev-control.js';
import '../ptz.js';
import './provider.js';

interface MediaNeighbor {
  index: number;
  media: ViewMedia;
}

interface MediaNeighbors {
  previous?: MediaNeighbor;
  next?: MediaNeighbor;
}

const ADVANCED_CAMERA_CARD_VIEWER_PROVIDER = 'advanced-camera-card-viewer-provider';

@customElement('advanced-camera-card-viewer-carousel')
export class AdvancedCameraCardViewerCarousel extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public viewFilterCameraID?: string;

  // Resetting the viewer configuration causes a full reset so ensure the config
  // has actually changed with a full comparison (dynamic configuration
  // overrides may causes changes elsewhere in the full card configuration that
  // could lead to the address of the viewerConfig changing without it being
  // semantically different).
  @property({ attribute: false, hasChanged: contentsChanged })
  public viewerConfig?: ViewerConfig;

  @property({ attribute: false })
  public resolvedMediaCache?: ResolvedMediaCache;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public showControls = true;

  @state()
  protected _selected: number | null = null;

  protected _media: ViewMedia[] | null = null;
  protected _mediaActionsController = new MediaActionsController();
  protected _mediaHeightController = new MediaHeightController(this, '.embla__slide');
  protected _loadedMediaPlayerController: MediaPlayerController | null = null;
  protected _refCarousel: Ref<HTMLElement> = createRef();

  public connectedCallback(): void {
    super.connectedCallback();

    this._mediaHeightController.setRoot(this.renderRoot);

    // Request update in order to reinitialize the media action controller.
    this.requestUpdate();
  }

  public disconnectedCallback(): void {
    this._mediaActionsController.destroy();
    this._mediaHeightController.destroy();
    super.disconnectedCallback();
  }

  /**
   * Get the transition effect to use.
   * @returns An TransitionEffect object.
   */
  protected _getTransitionEffect(): TransitionEffect {
    return (
      this.viewerConfig?.transition_effect ??
      configDefaults.media_viewer.transition_effect
    );
  }

  /**
   * Get the Embla plugins to use.
   * @returns A list of EmblaOptionsTypes.
   */
  protected _getPlugins(): EmblaCarouselPlugins {
    return [AutoMediaLoadedInfo()];
  }

  /**
   * Get the previous and next true media items from the current view.
   * @returns A BrowseMediaNeighbors with indices and objects of true media
   * neighbors.
   */
  protected _getMediaNeighbors(): MediaNeighbors | null {
    const mediaCount = this._media?.length ?? 0;
    if (!this._media || this._selected === null) {
      return null;
    }

    const prevIndex = this._selected > 0 ? this._selected - 1 : null;
    const nextIndex = this._selected + 1 < mediaCount ? this._selected + 1 : null;
    return {
      ...(prevIndex !== null && {
        previous: {
          index: prevIndex,
          media: this._media[prevIndex],
        },
      }),
      ...(nextIndex !== null && {
        next: {
          index: nextIndex,
          media: this._media[nextIndex],
        },
      }),
    };
  }

  protected _setViewSelectedIndex(index: number): void {
    const view = this.viewManagerEpoch?.manager.getView();

    if (!this._media || !view) {
      return;
    }

    if (this._selected === index) {
      // The slide may already be selected on load, so don't dispatch a new view
      // unless necessary (i.e. the new index is different from the current
      // index).
      return;
    }
    const newResults = view?.queryResults
      ?.clone()
      .selectResultIfFound((item) => item === this._media?.[index], {
        main: true,
        cameraID: this.viewFilterCameraID,
      });
    if (!newResults) {
      return;
    }

    const selectedItem = newResults.getSelectedResult(this.viewFilterCameraID);
    const cameraID = ViewItemClassifier.isMedia(selectedItem)
      ? selectedItem.getCameraID()
      : null;

    this.viewManagerEpoch?.manager.setViewByParameters({
      params: {
        queryResults: newResults,
        // Always change the camera to the owner of the selected media.
        ...(cameraID && { camera: cameraID }),
      },
      modifiers: [new RemoveContextPropertyViewModifier('mediaViewer', 'seek')],
    });
  }

  /**
   * Get slides to include in the render.
   * @returns The slides to include in the render.
   */
  protected _getSlides(): TemplateResult[] {
    if (!this._media) {
      return [];
    }

    const slides: TemplateResult[] = [];
    for (let i = 0; i < this._media.length; ++i) {
      const media = this._media[i];
      if (media) {
        const slide = this._renderMediaItem(media);
        if (slide) {
          slides[i] = slide;
        }
      }
    }
    return slides;
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('viewerConfig')) {
      this._mediaActionsController.setOptions({
        playerSelector: ADVANCED_CAMERA_CARD_VIEWER_PROVIDER,
        ...(this.viewerConfig?.auto_play && {
          autoPlayConditions: this.viewerConfig.auto_play,
        }),
        ...(this.viewerConfig?.auto_pause && {
          autoPauseConditions: this.viewerConfig.auto_pause,
        }),
        ...(this.viewerConfig?.auto_mute && {
          autoMuteConditions: this.viewerConfig.auto_mute,
        }),
        ...(this.viewerConfig?.auto_unmute && {
          autoUnmuteConditions: this.viewerConfig.auto_unmute,
        }),
      });
    }

    if (changedProps.has('viewManagerEpoch')) {
      const newView = this.viewManagerEpoch?.manager.getView();

      if (!newView?.context?.mediaViewer?.seek) {
        setOrRemoveAttribute(this, false, 'unseekable');
      }

      const oldView = this.viewManagerEpoch?.oldView;
      const oldItems =
        oldView?.queryResults?.getResults(this.viewFilterCameraID) ?? null;
      const newItems =
        newView?.queryResults?.getResults(this.viewFilterCameraID) ?? null;
      let resetMedia = false;
      if (!this._media || oldItems !== newItems) {
        this._media =
          newItems?.filter((item) => ViewItemClassifier.isMedia(item)) ?? null;
        resetMedia = true;
      }

      const oldSelectedItem = oldView?.queryResults?.getSelectedResult(
        this.viewFilterCameraID,
      );
      const newSelectedItem = newView?.queryResults?.getSelectedResult(
        this.viewFilterCameraID,
      );

      // _selected is an index, it needs to be updated if either the selected
      // item or the media changes.
      if (oldSelectedItem !== newSelectedItem || resetMedia) {
        const newSelected =
          this._media?.findIndex((item) => item === newSelectedItem) ?? null;

        // If there's no selected item, just choose the last (most recent one) to
        // avoid rendering a blank. This could happen if the selected item was a
        // folder.
        this._selected =
          newSelected ??
          (this._media && this._media.length ? this._media.length - 1 : null);
      }
    }
  }

  protected _renderNextPrevious(
    side: 'left' | 'right',
    neighbors?: MediaNeighbors | null,
  ): TemplateResult {
    const scroll = (direction: 'previous' | 'next'): void => {
      if (!neighbors || !this._media) {
        return;
      }
      const newIndex =
        (direction === 'previous' ? neighbors.previous?.index : neighbors.next?.index) ??
        null;
      if (newIndex !== null) {
        this._setViewSelectedIndex(newIndex);
      }
    };

    const textDirection = getTextDirection(this);
    const scrollDirection =
      (textDirection === 'ltr' && side === 'left') ||
      (textDirection === 'rtl' && side === 'right')
        ? 'previous'
        : 'next';

    return html` <advanced-camera-card-next-previous-control
      slot=${side}
      .hass=${this.hass}
      .side=${side}
      .controlConfig=${this.viewerConfig?.controls.next_previous}
      .thumbnail=${neighbors?.[scrollDirection]?.media.getThumbnail() ?? undefined}
      .label=${neighbors?.[scrollDirection]?.media.getTitle() ?? ''}
      ?disabled=${!neighbors?.[scrollDirection]}
      @click=${(ev: Event) => {
        scroll(scrollDirection);
        stopEventFromActivatingCardWideActions(ev);
      }}
    ></advanced-camera-card-next-previous-control>`;
  }

  protected render(): TemplateResult | void {
    const mediaCount = this._media?.length ?? 0;
    if (!this._media || !mediaCount) {
      return renderMessage({
        message: localize('common.no_media'),
        type: 'info',
        icon: 'mdi:multimedia',
        ...(this.viewFilterCameraID && {
          context: {
            camera_id: this.viewFilterCameraID,
          },
        }),
      });
    }

    if (!this.hass || !this.cameraManager || this._selected === null) {
      return;
    }

    const neighbors = this._getMediaNeighbors();
    const view = this.viewManagerEpoch?.manager.getView();

    return html`
      <advanced-camera-card-carousel
        ${ref(this._refCarousel)}
        .dragEnabled=${this.viewerConfig?.draggable ?? true}
        .plugins=${guard([this.viewerConfig, this._media], this._getPlugins.bind(this))}
        .selected=${this._selected}
        transitionEffect=${this._getTransitionEffect()}
        @advanced-camera-card:carousel:select=${(ev: CustomEvent<CarouselSelected>) => {
          this._setViewSelectedIndex(ev.detail.index);
        }}
        @advanced-camera-card:media:loaded=${(ev: CustomEvent<MediaLoadedInfo>) => {
          this._loadedMediaPlayerController = ev.detail.mediaPlayerController ?? null;
          this._seekHandler();
        }}
        @advanced-camera-card:media:unloaded=${() => {
          this._loadedMediaPlayerController = null;
        }}
      >
        ${this.showControls ? this._renderNextPrevious('left', neighbors) : ''}
        ${guard([this._media, view], () => this._getSlides())}
        ${this.showControls ? this._renderNextPrevious('right', neighbors) : ''}
      </advanced-camera-card-carousel>
      ${view
        ? html` <advanced-camera-card-ptz
            .hass=${this.hass}
            .config=${this.viewerConfig?.controls.ptz}
            .forceVisibility=${view?.context?.ptzControls?.enabled}
          >
          </advanced-camera-card-ptz>`
        : ''}
      <div class="seek-warning">
        <advanced-camera-card-icon
          title="${localize('media_viewer.unseekable')}"
          .icon=${{ icon: 'mdi:clock-remove' }}
        >
        </advanced-camera-card-icon>
      </div>
    `;
  }

  updated(changedProperties: PropertyValues): void {
    super.updated(changedProperties);

    const rootChanged = this._refCarousel.value
      ? this._mediaActionsController.setRoot(this._refCarousel.value)
      : false;

    // If the view has changed, or if the media actions controller has just been
    // initialized, then call the necessary media action.
    // See: https://github.com/dermotduffy/advanced-camera-card/issues/1626
    if (rootChanged || changedProperties.has('viewManagerEpoch')) {
      this._setMediaTarget();
    }

    if (changedProperties.has('viewManagerEpoch')) {
      // Seek into the video if the seek time has changed (this is also called
      // on media load, since the media may or may not have been loaded at
      // this point).
      if (
        this.viewManagerEpoch?.manager.getView()?.context?.mediaViewer !==
        this.viewManagerEpoch?.oldView?.context?.mediaViewer
      ) {
        this._seekHandler();
      }
    }
  }

  protected _setMediaTarget(): void {
    if (!this._media?.length || this._selected === null) {
      this._mediaActionsController.unsetTarget();
    } else {
      this._mediaActionsController.setTarget(
        this._selected,
        // Camera in this carousel is only selected if the camera from the view
        // matches the filtered camera.
        this.viewFilterCameraID
          ? this.viewManagerEpoch?.manager.getView()?.camera === this.viewFilterCameraID
          : true,
      );
      this._mediaHeightController.setSelected(this._selected);
    }
  }

  /**
   * Fire a media show event when a slide is selected.
   */
  protected async _seekHandler(): Promise<void> {
    const view = this.viewManagerEpoch?.manager.getView();
    const seek = view?.context?.mediaViewer?.seek;
    if (
      !this.hass ||
      !seek ||
      !this._media ||
      !this._loadedMediaPlayerController ||
      this._selected === null
    ) {
      return;
    }
    const selectedMedia = this._media[this._selected];
    if (!selectedMedia) {
      return;
    }

    const seekTimeInMedia = selectedMedia.includesTime(seek);
    setOrRemoveAttribute(this, !seekTimeInMedia, 'unseekable');
    if (!seekTimeInMedia && !this._loadedMediaPlayerController.isPaused()) {
      this._loadedMediaPlayerController.pause();
    } else if (seekTimeInMedia && this._loadedMediaPlayerController.isPaused()) {
      this._loadedMediaPlayerController.play();
    }

    const seekTime =
      (await this.cameraManager?.getMediaSeekTime(selectedMedia, seek)) ?? null;

    if (seekTime !== null) {
      this._loadedMediaPlayerController.seek(seekTime);
    }
  }

  protected _renderMediaItem(media: ViewMedia): TemplateResult | null {
    const view = this.viewManagerEpoch?.manager.getView();
    if (!this.hass || !view || !this.viewerConfig) {
      return null;
    }

    return html` <div class="embla__slide">
      <advanced-camera-card-viewer-provider
        .hass=${this.hass}
        .viewManagerEpoch=${this.viewManagerEpoch}
        .media=${media}
        .viewerConfig=${this.viewerConfig}
        .resolvedMediaCache=${this.resolvedMediaCache}
        .cameraManager=${this.cameraManager}
        .cardWideConfig=${this.cardWideConfig}
      ></advanced-camera-card-viewer-provider>
    </div>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(viewerCarouselStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-viewer-carousel': AdvancedCameraCardViewerCarousel;
  }
}



================================================
FILE: src/components/viewer/grid.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { MediaGridSelected } from '../../components-lib/media-grid-controller.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { ViewerConfig } from '../../config/schema/viewer.js';
import { HomeAssistant } from '../../ha/types.js';
import { ResolvedMediaCache } from '../../ha/resolved-media.js';
import '../../patches/ha-hls-player.js';
import basicBlockStyle from '../../scss/basic-block.scss';
import './carousel';

@customElement('advanced-camera-card-viewer-grid')
export class AdvancedCameraCardViewerGrid extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public viewerConfig?: ViewerConfig;

  @property({ attribute: false })
  public resolvedMediaCache?: ResolvedMediaCache;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  protected _renderCarousel(filterCamera?: string): TemplateResult {
    const selectedCameraID = this.viewManagerEpoch?.manager.getView()?.camera;
    return html`
      <advanced-camera-card-viewer-carousel
        grid-id=${ifDefined(filterCamera)}
        .hass=${this.hass}
        .viewManagerEpoch=${this.viewManagerEpoch}
        .viewFilterCameraID=${filterCamera}
        .viewerConfig=${this.viewerConfig}
        .resolvedMediaCache=${this.resolvedMediaCache}
        .cameraManager=${this.cameraManager}
        .cardWideConfig=${this.cardWideConfig}
        .showControls=${!filterCamera || selectedCameraID === filterCamera}
      >
      </advanced-camera-card-viewer-carousel>
    `;
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (changedProps.has('viewManagerEpoch') && this._needsGrid()) {
      import('../media-grid.js');
    }
  }

  protected _needsGrid(): boolean {
    const view = this.viewManagerEpoch?.manager.getView();
    const cameraIDs = view?.queryResults?.getCameraIDs();
    return (
      !!view?.isGrid() &&
      !!view?.supportsMultipleDisplayModes() &&
      (cameraIDs?.size ?? 0) > 1
    );
  }

  protected _gridSelectCamera(cameraID: string): void {
    const view = this.viewManagerEpoch?.manager.getView();
    this.viewManagerEpoch?.manager.setViewByParameters({
      params: {
        camera: cameraID,
        queryResults: view?.queryResults
          ?.clone()
          .promoteCameraSelectionToMainSelection(cameraID),
      },
    });
  }

  protected render(): TemplateResult {
    const view = this.viewManagerEpoch?.manager.getView();
    const cameraIDs = view?.queryResults?.getCameraIDs();
    if (!cameraIDs || !this._needsGrid()) {
      return this._renderCarousel();
    }

    return html`
      <advanced-camera-card-media-grid
        .selected=${view?.camera}
        .displayConfig=${this.viewerConfig?.display}
        @advanced-camera-card:media-grid:selected=${(
          ev: CustomEvent<MediaGridSelected>,
        ) => this._gridSelectCamera(ev.detail.selected)}
      >
        ${[...cameraIDs].map((cameraID) => this._renderCarousel(cameraID))}
      </advanced-camera-card-media-grid>
    `;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(basicBlockStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-viewer-grid': AdvancedCameraCardViewerGrid;
  }
}



================================================
FILE: src/components/viewer/index.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { ViewerConfig } from '../../config/schema/viewer.js';
import { ResolvedMediaCache } from '../../ha/resolved-media.js';
import { HomeAssistant } from '../../ha/types.js';
import { localize } from '../../localize/localize.js';
import '../../patches/ha-hls-player.js';
import viewerStyle from '../../scss/viewer.scss';
import { ViewItemClassifier } from '../../view/item-classifier.js';
import { renderMessage } from '../message.js';
import './grid';

export interface MediaViewerViewContext {
  seek?: Date;
}

declare module 'view' {
  interface ViewContext {
    mediaViewer?: MediaViewerViewContext;
  }
}

@customElement('advanced-camera-card-viewer')
export class AdvancedCameraCardViewer extends LitElement {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public viewerConfig?: ViewerConfig;

  @property({ attribute: false })
  public resolvedMediaCache?: ResolvedMediaCache;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  @property({ attribute: 'empty', reflect: true, type: Boolean })
  public isEmpty = false;

  protected willUpdate(changedProperties: PropertyValues): void {
    if (changedProperties.has('viewManagerEpoch')) {
      const view = this.viewManagerEpoch?.manager.getView();
      this.isEmpty = !view?.queryResults
        ?.getResults()
        ?.filter((result) => ViewItemClassifier.isMedia(result)).length;
    }
  }

  protected render(): TemplateResult | void {
    if (
      !this.hass ||
      !this.viewManagerEpoch ||
      !this.viewerConfig ||
      !this.cameraManager ||
      !this.cardWideConfig
    ) {
      return;
    }

    if (this.isEmpty) {
      // Directly render an error message (instead of dispatching it upwards)
      // to preserve the mini-timeline if the user pans into an area with no
      // media.
      const loadingMedia =
        !!this.viewManagerEpoch.manager.getView()?.context?.loading?.query;
      return renderMessage({
        type: 'info',
        message: loadingMedia
          ? localize('error.awaiting_media')
          : localize('common.no_media'),
        icon: 'mdi:multimedia',
        dotdotdot: loadingMedia,
      });
    }

    return html` <advanced-camera-card-viewer-grid
      .hass=${this.hass}
      .viewManagerEpoch=${this.viewManagerEpoch}
      .viewerConfig=${this.viewerConfig}
      .resolvedMediaCache=${this.resolvedMediaCache}
      .cameraManager=${this.cameraManager}
      .cardWideConfig=${this.cardWideConfig}
    >
    </advanced-camera-card-viewer-grid>`;
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(viewerStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-viewer': AdvancedCameraCardViewer;
  }
}



================================================
FILE: src/components/viewer/provider.ts
================================================
import {
  CSSResultGroup,
  html,
  LitElement,
  PropertyValues,
  TemplateResult,
  unsafeCSS,
} from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { guard } from 'lit/directives/guard.js';
import { createRef, Ref, ref } from 'lit/directives/ref.js';
import { CameraManager } from '../../camera-manager/manager.js';
import { ViewManagerEpoch } from '../../card-controller/view/types.js';
import { LazyLoadController } from '../../components-lib/lazy-load-controller.js';
import { ZoomSettingsObserved } from '../../components-lib/zoom/types.js';
import { handleZoomSettingsObservedEvent } from '../../components-lib/zoom/zoom-view-context.js';
import { CardWideConfig } from '../../config/schema/types.js';
import { ViewerConfig } from '../../config/schema/viewer.js';
import { canonicalizeHAURL } from '../../ha/canonical-url.js';
import { isHARelativeURL } from '../../ha/is-ha-relative-url.js';
import { ResolvedMediaCache, resolveMedia } from '../../ha/resolved-media.js';
import { homeAssistantSignPath } from '../../ha/sign-path.js';
import { HomeAssistant, ResolvedMedia } from '../../ha/types.js';
import {
  addDynamicProxyURL,
  getWebProxiedURL,
  shouldUseWebProxy,
} from '../../ha/web-proxy.js';
import '../../patches/ha-hls-player.js';
import viewerProviderStyle from '../../scss/viewer-provider.scss';
import { MediaPlayer, MediaPlayerController, MediaPlayerElement } from '../../types.js';
import { aspectRatioToString, errorToConsole } from '../../utils/basic.js';
import { updateElementStyleFromMediaLayoutConfig } from '../../utils/media-layout.js';
import { ViewItemClassifier } from '../../view/item-classifier.js';
import { VideoContentType, ViewMedia } from '../../view/item.js';
import { QueryClassifier } from '../../view/query-classifier.js';
import '../image-player.js';
import { renderProgressIndicator } from '../progress-indicator.js';
import '../video-player.js';

@customElement('advanced-camera-card-viewer-provider')
export class AdvancedCameraCardViewerProvider extends LitElement implements MediaPlayer {
  @property({ attribute: false })
  public hass?: HomeAssistant;

  @property({ attribute: false })
  public viewManagerEpoch?: ViewManagerEpoch;

  @property({ attribute: false })
  public media?: ViewMedia;

  @property({ attribute: false })
  public viewerConfig?: ViewerConfig;

  @property({ attribute: false })
  public resolvedMediaCache?: ResolvedMediaCache;

  @property({ attribute: false })
  public cameraManager?: CameraManager;

  @property({ attribute: false })
  public cardWideConfig?: CardWideConfig;

  protected _refProvider: Ref<MediaPlayerElement> = createRef();
  protected _lazyLoadController: LazyLoadController = new LazyLoadController(this);

  @state()
  protected _url: string | null = null;

  constructor() {
    super();
    this._lazyLoadController.addListener((loaded) => loaded && this._setURL());
  }

  public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
    await this.updateComplete;
    return (await this._refProvider.value?.getMediaPlayerController()) ?? null;
  }

  protected async _switchToRelatedClipView(): Promise<void> {
    const view = this.viewManagerEpoch?.manager.getView();
    if (
      !this.hass ||
      !view ||
      !this.cameraManager ||
      !this.media ||
      // If this specific media item has no clip, then do nothing (even if all
      // the other media items do).
      !ViewItemClassifier.isEvent(this.media) ||
      !QueryClassifier.isEventQuery(view.query)
    ) {
      return;
    }

    // Convert the query to a clips equivalent.
    const clipQuery = view.query.clone();
    clipQuery.convertToClipsQueries();

    const queries = clipQuery.getQuery();
    if (!queries) {
      return;
    }

    await this.viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
      params: {
        view: 'media',
        query: clipQuery,
      },
      queryExecutorOptions: {
        selectResult: {
          id: this.media.getID() ?? undefined,
        },
        rejectResults: (results) => !results.hasSelectedResult(),
      },
    });
  }

  protected async _setURL(): Promise<void> {
    const mediaContentID = this.media?.getContentID();
    if (
      !this.media ||
      !mediaContentID ||
      !this.hass ||
      !this._lazyLoadController?.isLoaded()
    ) {
      return;
    }

    let resolvedMedia: ResolvedMedia | null =
      this.resolvedMediaCache?.get(mediaContentID) ?? null;
    if (!resolvedMedia) {
      resolvedMedia = await resolveMedia(
        this.hass,
        mediaContentID,
        this.resolvedMediaCache,
      );
    }

    if (!resolvedMedia) {
      return;
    }

    const unsignedURL = resolvedMedia.url;
    if (isHARelativeURL(unsignedURL)) {
      // No need to proxy or sign local resolved URLs.
      this._url = canonicalizeHAURL(this.hass, unsignedURL);
      return;
    }

    const cameraID = this.media.getCameraID();
    const camera = cameraID ? this.cameraManager?.getStore().getCamera(cameraID) : null;
    const proxyConfig = camera?.getProxyConfig();

    if (proxyConfig && shouldUseWebProxy(this.hass, proxyConfig, 'media')) {
      if (proxyConfig.dynamic) {
        // Don't use URL() parsing, since that will strip the port number if
        // it's the default, just need to strip any hash part of the URL.
        const urlWithoutQSorHash = unsignedURL.split(/#/)[0];
        await addDynamicProxyURL(this.hass, urlWithoutQSorHash, {
          sslVerification: proxyConfig.ssl_verification,
          sslCiphers: proxyConfig.ssl_ciphers,

          // The link may need to be opened multiple times.
          openLimit: 0,
        });
      }

      try {
        this._url = await homeAssistantSignPath(
          this.hass,
          getWebProxiedURL(unsignedURL),
        );
      } catch (e) {
        errorToConsole(e as Error);
      }
    } else {
      this._url = unsignedURL;
    }
  }

  protected willUpdate(changedProps: PropertyValues): void {
    if (
      changedProps.has('viewerConfig') ||
      (!this._lazyLoadController && this.viewerConfig)
    ) {
      this._lazyLoadController.setConfiguration(this.viewerConfig?.lazy_load);
    }

    if (
      changedProps.has('media') ||
      changedProps.has('viewerConfig') ||
      changedProps.has('resolvedMediaCache') ||
      changedProps.has('hass')
    ) {
      this._setURL();
    }

    if (changedProps.has('viewerConfig') && this.viewerConfig?.zoomable) {
      import('../zoomer.js');
    }

    if (changedProps.has('media') || changedProps.has('cameraManager')) {
      const cameraID = this.media?.getCameraID();
      const cameraConfig = cameraID
        ? this.cameraManager?.getStore().getCameraConfig(cameraID)
        : null;
      updateElementStyleFromMediaLayoutConfig(this, cameraConfig?.dimensions?.layout);

      this.style.aspectRatio = aspectRatioToString({
        ratio: cameraConfig?.dimensions?.aspect_ratio,
      });
    }
  }

  protected _useZoomIfRequired(template: TemplateResult): TemplateResult {
    if (!this.media) {
      return template;
    }
    const cameraID = this.media.getCameraID();
    const mediaID = this.media.getID() ?? undefined;
    const cameraConfig = cameraID
      ? this.cameraManager?.getStore().getCameraConfig(cameraID) ?? null
      : null;
    const view = this.viewManagerEpoch?.manager.getView();

    return this.viewerConfig?.zoomable
      ? html` <advanced-camera-card-zoomer
          .defaultSettings=${guard([cameraConfig?.dimensions?.layout], () =>
            cameraConfig?.dimensions?.layout
              ? {
                  pan: cameraConfig.dimensions.layout.pan,
                  zoom: cameraConfig.dimensions.layout.zoom,
                }
              : undefined,
          )}
          .settings=${mediaID ? view?.context?.zoom?.[mediaID]?.requested : undefined}
          @advanced-camera-card:zoom:zoomed=${async () =>
            (await this.getMediaPlayerController())?.setControls(false)}
          @advanced-camera-card:zoom:unzoomed=${async () =>
            (await this.getMediaPlayerController())?.setControls()}
          @advanced-camera-card:zoom:change=${(ev: CustomEvent<ZoomSettingsObserved>) =>
            handleZoomSettingsObservedEvent(ev, this.viewManagerEpoch?.manager, mediaID)}
        >
          ${template}
        </advanced-camera-card-zoomer>`
      : template;
  }

  protected render(): TemplateResult | void {
    if (
      !this._lazyLoadController?.isLoaded() ||
      !this.media ||
      !this.hass ||
      !this.viewerConfig
    ) {
      return;
    }

    if (!this._url) {
      return renderProgressIndicator({
        cardWideConfig: this.cardWideConfig,
      });
    }

    // Note: crossorigin="anonymous" is required on <video> below in order to
    // allow screenshot of motionEye videos which currently go cross-origin.
    return this._useZoomIfRequired(html`
      ${ViewItemClassifier.isVideo(this.media)
        ? this.media.getVideoContentType() === VideoContentType.HLS
          ? html`<advanced-camera-card-ha-hls-player
              ${ref(this._refProvider)}
              allow-exoplayer
              aria-label="${this.media.getTitle() ?? ''}"
              ?autoplay=${false}
              controls
              muted
              playsinline
              title="${this.media.getTitle() ?? ''}"
              url=${this._url}
              .hass=${this.hass}
              ?controls=${this.viewerConfig.controls.builtin}
            >
            </advanced-camera-card-ha-hls-player>`
          : html`
              <advanced-camera-card-video-player
                ${ref(this._refProvider)}
                url=${this._url}
                aria-label="${this.media.getTitle() ?? ''}"
                title="${this.media.getTitle() ?? ''}"
                ?controls=${this.viewerConfig.controls.builtin}
              >
              </advanced-camera-card-video-player>
            `
        : html`<advanced-camera-card-image-player
            ${ref(this._refProvider)}
            url="${this._url}"
            aria-label="${this.media.getTitle() ?? ''}"
            title="${this.media.getTitle() ?? ''}"
            @click=${() => {
              if (this.viewerConfig?.snapshot_click_plays_clip) {
                this._switchToRelatedClipView();
              }
            }}
          ></advanced-camera-card-image-player>`}
    `);
  }

  static get styles(): CSSResultGroup {
    return unsafeCSS(viewerProviderStyle);
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-viewer-provider': AdvancedCameraCardViewerProvider;
  }
}



================================================
FILE: src/components-lib/cached-value-controller.ts
================================================
import { ReactiveController, ReactiveControllerHost } from 'lit';
import { Timer } from '../utils/timer';

export class CachedValueController<T> implements ReactiveController {
  protected _value?: T;
  protected _host: ReactiveControllerHost;
  protected _timerSeconds: number;
  protected _callback: () => T;
  protected _timerStartCallback?: () => void;
  protected _timerStopCallback?: () => void;
  protected _timer = new Timer();

  constructor(
    host: ReactiveControllerHost,
    timerSeconds: number,
    callback: () => T,
    timerStartCallback?: () => void,
    timerStopCallback?: () => void,
  ) {
    this._timerSeconds = timerSeconds;
    this._callback = callback;
    this._timerStartCallback = timerStartCallback;
    this._timerStopCallback = timerStopCallback;
    (this._host = host).addController(this);
  }

  /**
   * Remove the controller for the host.
   */
  public removeController(): void {
    this.stopTimer();
    this._host.removeController(this);
  }

  /**
   * Get the value.
   */
  get value(): T | undefined {
    return this._value;
  }

  /**
   * Update the cached value.
   */
  public updateValue(): void {
    this._value = this._callback();
  }

  /**
   * Clear the cached value.
   */
  public clearValue(): void {
    this._value = undefined;
  }

  /**
   * Disable the timer.
   */
  public stopTimer(): void {
    if (this._timer.isRunning()) {
      this._timer.stop();
      this._timerStopCallback?.();
    }
  }

  /**
   * Enable the timer. Repeated calls will have no effect.
   */
  public startTimer(): void {
    this.stopTimer();

    this._timerStartCallback?.();
    this._timer.startRepeated(this._timerSeconds, () => {
      this.updateValue();
      this._host.requestUpdate();
    });
  }

  public hasTimer(): boolean {
    return this._timer.isRunning();
  }

  /**
   * Host has connected to the cache.
   */
  hostConnected(): void {
    this.updateValue();
    this.startTimer();
    this._host.requestUpdate();
  }

  /**
   * Host has disconnected from the cache.
   */
  hostDisconnected(): void {
    this.clearValue();
    this.stopTimer();
  }
}



================================================
FILE: src/components-lib/icon-controller.ts
================================================
import { HassEntity } from 'home-assistant-js-websocket';
import frigateSVG from '../camera-manager/frigate/assets/frigate.svg';
import motioneyeSVG from '../camera-manager/motioneye/assets/motioneye.svg';
import reolinkSVG from '../camera-manager/reolink/assets/reolink.svg';
import { HomeAssistant } from '../ha/types';
import irisSVG from '../images/iris.svg';
import { Icon } from '../types';

export class IconController {
  public getCustomIcon(icon?: Icon): string | null {
    switch (icon?.icon) {
      case 'frigate':
        return frigateSVG;
      case 'motioneye':
        return motioneyeSVG;
      case 'reolink':
        return reolinkSVG;
      case 'iris':
        return irisSVG;
      default:
        return null;
    }
  }

  public createStateObjectForStateBadge(
    hass: HomeAssistant,
    entityID: string,
  ): HassEntity | null {
    if (!hass.states[entityID]) {
      return null;
    }
    return {
      ...hass.states[entityID],
      attributes: {
        ...hass.states[entityID].attributes,

        // State badge is the only available component that will allow the
        // Home Assistant frontend to correctly color based on the state, but
        // it also will render an image (instead of an icon) if one is present
        // in the attributes. By overriding the below attributes, we avoid
        // that behavior.
        entity_picture: undefined,
        entity_picture_local: undefined,
      },
    };
  }
}



================================================
FILE: src/components-lib/key-assigner-controller.ts
================================================
import { LitElement, ReactiveController } from 'lit';
import { isEqual } from 'lodash-es';
import { KeyboardShortcut } from '../config/schema/view';
import { setOrRemoveAttribute } from '../utils/basic';

export class KeyAssignerController implements ReactiveController {
  protected _host: LitElement;
  protected _assigning = false;
  protected _value: KeyboardShortcut | null = null;

  constructor(host: LitElement) {
    this._host = host;
    this._host.addController(this);
  }

  public setValue(value: KeyboardShortcut | null): void {
    if (!isEqual(value, this._value)) {
      this._value = value;
      this._host.requestUpdate();

      this._host.dispatchEvent(
        new CustomEvent('value-changed', {
          detail: {
            value: this._value,
          },
        }),
      );
    }
  }
  public getValue(): KeyboardShortcut | null {
    return this._value;
  }
  public hasValue(): boolean {
    return !!this._value;
  }

  public isAssigning(): boolean {
    return this._assigning;
  }
  public toggleAssigning(): void {
    this._setAssigning(!this._assigning);
  }
  protected _setAssigning(assigning: boolean): void {
    this._assigning = assigning;
    setOrRemoveAttribute(this._host, this._assigning, 'assigning');

    if (this._assigning) {
      this._host.addEventListener('keydown', this._keydownEventHandler);
    } else {
      this._host.removeEventListener('keydown', this._keydownEventHandler);
    }

    this._host.requestUpdate();
  }

  protected _blurEventHandler = (): void => {
    this._setAssigning(false);
  };

  protected _keydownEventHandler = (ev: KeyboardEvent): void => {
    // Don't allow _only_ a modifier.
    if (!ev.key || ['Control', 'Alt', 'Shift', 'Meta'].includes(ev.key)) {
      return;
    }

    this.setValue({
      key: ev.key,
      ctrl: ev.ctrlKey,
      alt: ev.altKey,
      shift: ev.shiftKey,
      meta: ev.metaKey,
    });
    this._setAssigning(false);
  };

  public hostConnected(): void {
    this._host.addEventListener('blur', this._blurEventHandler);
  }

  public hostDisconnected(): void {
    this._host.removeEventListener('blur', this._blurEventHandler);
  }
}



================================================
FILE: src/components-lib/lazy-load-controller.ts
================================================
import { ReactiveController, ReactiveControllerHost } from 'lit';
import { LazyUnloadCondition } from '../config/schema/common/media-actions';

type LazyLoadListener = (loaded: boolean) => void;

export class LazyLoadController implements ReactiveController {
  private _host: ReactiveControllerHost & HTMLElement;
  private _documentVisible = true;
  private _intersects = false;
  private _loaded = false;
  private _unloadConditions: LazyUnloadCondition[] | null = null;
  private _intersectionObserver = new IntersectionObserver(
    this._intersectionHandler.bind(this),
  );
  private _listeners: LazyLoadListener[] = [];

  constructor(host: ReactiveControllerHost & HTMLElement) {
    this._host = host;
    this._host.addController(this);
  }

  public setConfiguration(
    lazyLoad?: boolean,
    lazyUnloadConditions?: LazyUnloadCondition[],
  ) {
    if (!lazyLoad && !this._loaded) {
      this._setLoaded(true);
    }
    this._unloadConditions = lazyUnloadConditions ?? null;
  }

  public destroy(): void {
    this._removeEventHandlers();
    this._listeners = [];
  }

  public isLoaded(): boolean {
    return this._loaded;
  }

  public addListener(listener: LazyLoadListener): void {
    this._listeners.push(listener);
  }

  public removeListener(listener: LazyLoadListener): void {
    this._listeners = this._listeners.filter((l) => l !== listener);
  }

  public removeController(): void {
    this._host.removeController(this);
  }

  public hostConnected(): void {
    this._addEventHandlers();
  }

  public hostDisconnected(): void {
    this._removeEventHandlers();
    this._setLoaded(false);
  }

  private _addEventHandlers(): void {
    document.addEventListener('visibilitychange', this._visibilityHandler);
    this._intersectionObserver.observe(this._host);
  }

  private _removeEventHandlers(): void {
    document.removeEventListener('visibilitychange', this._visibilityHandler);
    this._intersectionObserver.disconnect();
  }

  private _lazyLoadOrUnloadIfNecessary(): void {
    const shouldBeLoaded = !this._loaded && this._documentVisible && this._intersects;
    const shouldBeUnloaded =
      this._loaded &&
      ((this._unloadConditions?.includes('hidden') && !this._documentVisible) ||
        (this._unloadConditions?.includes('unselected') && !this._intersects));

    if (shouldBeLoaded) {
      this._setLoaded(true);
    } else if (shouldBeUnloaded) {
      this._setLoaded(false);
    }
  }

  private _setLoaded(loaded: boolean): void {
    this._loaded = loaded;
    this._notifyListeners();
    this._host.requestUpdate();
  }

  private _notifyListeners(): void {
    this._listeners.forEach((listener) => listener(this._loaded));
  }

  private _intersectionHandler(entries: IntersectionObserverEntry[]): void {
    this._intersects = entries.some((entry) => entry.isIntersecting);
    this._lazyLoadOrUnloadIfNecessary();
  }

  private _visibilityHandler = (): void => {
    this._documentVisible = document.visibilityState === 'visible';
    this._lazyLoadOrUnloadIfNecessary();
  };
}



================================================
FILE: src/components-lib/media-actions-controller.ts
================================================
import { MicrophoneState } from '../card-controller/types.js';
import {
  AutoMuteCondition,
  AutoPauseCondition,
  AutoPlayCondition,
  AutoUnmuteCondition,
} from '../config/schema/common/media-actions.js';
import { MediaPlayerElement } from '../types.js';
import { AdvancedCameraCardMediaLoadedEventTarget } from '../utils/media-info.js';
import { Timer } from '../utils/timer.js';

export interface MediaActionsControllerOptions {
  playerSelector: string;

  autoPlayConditions?: readonly AutoPlayCondition[];
  autoUnmuteConditions?: readonly AutoUnmuteCondition[];
  autoPauseConditions?: readonly AutoPauseCondition[];
  autoMuteConditions?: readonly AutoMuteCondition[];

  microphoneState?: MicrophoneState;
  microphoneMuteSeconds?: number;
}

type RenderRoot = HTMLElement & AdvancedCameraCardMediaLoadedEventTarget;

/**
 * General note: Always unmute before playing, since Chrome may pause a piece of
 * media if the page hasn't been interacted with first, after unmute. By unmuting
 * first, even if the unmute call fails a subsequent call to play will still
 * start the video.
 */

type MediaActionsTarget = {
  selected: boolean;
  index: number;
};

export class MediaActionsController {
  protected _options: MediaActionsControllerOptions | null = null;
  protected _viewportIntersecting: boolean | null = null;
  protected _microphoneMuteTimer = new Timer();
  protected _root: RenderRoot | null = null;

  protected _eventListeners = new Map<HTMLElement, () => void>();
  protected _children: MediaPlayerElement[] = [];
  protected _target: MediaActionsTarget | null = null;
  protected _mutationObserver = new MutationObserver(this._mutationHandler.bind(this));
  protected _intersectionObserver = new IntersectionObserver(
    this._intersectionHandler.bind(this),
  );

  constructor() {
    document.addEventListener('visibilitychange', this._visibilityHandler);
  }

  public setOptions(options: MediaActionsControllerOptions): void {
    if (this._options?.microphoneState !== options.microphoneState) {
      this._microphoneStateChangeHandler(
        this._options?.microphoneState,
        options.microphoneState,
      );
    }

    this._options = options;
  }

  public hasRoot(): boolean {
    return !!this._root;
  }

  public destroy(): void {
    this._viewportIntersecting = null;
    this._microphoneMuteTimer.stop();
    this._root = null;
    this._removeChildHandlers();
    this._children = [];
    this._target = null;
    this._mutationObserver.disconnect();
    this._intersectionObserver.disconnect();
    document.removeEventListener('visibilitychange', this._visibilityHandler);
  }

  public async setTarget(index: number, selected: boolean): Promise<void> {
    if (this._target?.index === index && this._target?.selected === selected) {
      return;
    }

    // If there's already a selected target, unselect it.
    if (!!this._target?.selected) {
      await this._pauseTargetIfConfigured('unselected');
      await this._muteTargetIfConfigured('unselected');
      this._microphoneMuteTimer.stop();
    }

    this._target = {
      selected,
      index,
    };

    if (selected) {
      await this._unmuteTargetIfConfigured('selected');
      await this._playTargetIfConfigured('selected');
    } else {
      await this._unmuteTargetIfConfigured('visible');
      await this._playTargetIfConfigured('visible');
    }
  }

  public unsetTarget(): void {
    this._target = null;
  }

  protected async _playTargetIfConfigured(condition: AutoPlayCondition): Promise<void> {
    if (
      this._target !== null &&
      this._options?.autoPlayConditions?.includes(condition)
    ) {
      await this._play(this._target.index);
    }
  }
  protected async _play(index: number): Promise<void> {
    await (await this._children[index]?.getMediaPlayerController())?.play();
  }
  protected async _unmuteTargetIfConfigured(
    condition: AutoUnmuteCondition,
  ): Promise<void> {
    if (
      this._target !== null &&
      this._options?.autoUnmuteConditions?.includes(condition)
    ) {
      await this._unmute(this._target.index);
    }
  }
  protected async _unmute(index: number): Promise<void> {
    await (await this._children[index]?.getMediaPlayerController())?.unmute();
  }

  protected async _pauseAllIfConfigured(condition: AutoPauseCondition): Promise<void> {
    if (this._options?.autoPauseConditions?.includes(condition)) {
      for (const index of this._children.keys()) {
        await this._pause(index);
      }
    }
  }
  protected async _pauseTargetIfConfigured(
    condition: AutoPauseCondition,
  ): Promise<void> {
    if (
      this._target !== null &&
      this._options?.autoPauseConditions?.includes(condition)
    ) {
      await this._pause(this._target.index);
    }
  }
  protected async _pause(index: number): Promise<void> {
    await (await this._children[index]?.getMediaPlayerController())?.pause();
  }

  protected async _muteAllIfConfigured(condition: AutoMuteCondition): Promise<void> {
    if (this._options?.autoMuteConditions?.includes(condition)) {
      for (const index of this._children.keys()) {
        await this._mute(index);
      }
    }
  }
  protected async _muteTargetIfConfigured(condition: AutoMuteCondition): Promise<void> {
    if (
      this._target !== null &&
      this._options?.autoMuteConditions?.includes(condition)
    ) {
      await this._mute(this._target.index);
    }
  }
  protected async _mute(index: number): Promise<void> {
    await (await this._children[index]?.getMediaPlayerController())?.mute();
  }

  protected _mutationHandler(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mutations: MutationRecord[],
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _observer: MutationObserver,
  ): void {
    this._initializeRoot();
  }

  protected _mediaLoadedHandler = async (index: number): Promise<void> => {
    if (this._target?.index !== index) {
      return;
    }
    await this._unmuteTargetIfConfigured(this._target.selected ? 'selected' : 'visible');
    await this._playTargetIfConfigured(this._target.selected ? 'selected' : 'visible');
  };

  protected _removeChildHandlers(): void {
    for (const [child, callback] of this._eventListeners.entries()) {
      child.removeEventListener('advanced-camera-card:media:loaded', callback);
    }
    this._eventListeners.clear();
  }

  public setRoot(root: RenderRoot): boolean {
    if (root === this._root) {
      return false;
    }

    this._target = null;
    this._root = root;
    this._initializeRoot();

    this._intersectionObserver.disconnect();
    this._intersectionObserver.observe(this._root);

    this._mutationObserver.disconnect();
    this._mutationObserver.observe(this._root, { childList: true, subtree: true });
    return true;
  }

  protected _initializeRoot(): void {
    if (!this._options || !this._root) {
      return;
    }

    this._removeChildHandlers();

    this._children = [
      ...this._root.querySelectorAll<MediaPlayerElement>(this._options.playerSelector),
    ];

    for (const [index, child] of this._children.entries()) {
      const eventListener = () => this._mediaLoadedHandler(index);
      this._eventListeners.set(child, eventListener);
      child.addEventListener('advanced-camera-card:media:loaded', eventListener);
    }
  }

  protected async _intersectionHandler(
    entries: IntersectionObserverEntry[],
  ): Promise<void> {
    const wasIntersecting = this._viewportIntersecting;
    this._viewportIntersecting = entries.some((entry) => entry.isIntersecting);

    if (wasIntersecting !== null && wasIntersecting !== this._viewportIntersecting) {
      // If the live view is preloaded (i.e. in the background) we may need to
      // take media actions, e.g. muting a live stream that is now running in
      // the background, so we act even if the new state is hidden.
      await this._changeVisibility(this._viewportIntersecting);
    }
  }

  protected _visibilityHandler = async (): Promise<void> => {
    await this._changeVisibility(document.visibilityState === 'visible');
  };

  protected _changeVisibility = async (visible: boolean): Promise<void> => {
    if (visible) {
      await this._unmuteTargetIfConfigured('visible');
      await this._playTargetIfConfigured('visible');
    } else {
      await this._pauseAllIfConfigured('hidden');
      await this._muteAllIfConfigured('hidden');
    }
  };

  protected async _microphoneStateChangeHandler(
    oldState?: MicrophoneState,
    newState?: MicrophoneState,
  ): Promise<void> {
    if (!oldState || !newState) {
      return;
    }

    if (oldState.muted && !newState.muted) {
      await this._unmuteTargetIfConfigured('microphone');
    } else if (
      !oldState.muted &&
      newState.muted &&
      this._options?.autoMuteConditions?.includes('microphone')
    ) {
      this._microphoneMuteTimer.start(
        this._options.microphoneMuteSeconds ?? 60,
        async () => {
          await this._muteTargetIfConfigured('microphone');
        },
      );
    }
  }
}



================================================
FILE: src/components-lib/media-filter-controller.ts
================================================
import {
  endOfDay,
  endOfMonth,
  endOfToday,
  endOfYesterday,
  format,
  parse,
  startOfDay,
  startOfToday,
  startOfYesterday,
  sub,
} from 'date-fns';
import { LitElement } from 'lit';
import { isEqual, orderBy, uniqWith } from 'lodash-es';
import { CameraManager } from '../camera-manager/manager';
import { DateRange, PartialDateRange } from '../camera-manager/range';
import { CameraQuery, MediaMetadata, QueryType } from '../camera-manager/types';
import { ViewManagerInterface } from '../card-controller/view/types';
import { SelectOption, SelectValues } from '../components/select';
import { CardWideConfig } from '../config/schema/types';
import { localize } from '../localize/localize';
import { errorToConsole, formatDate, prettifyTitle } from '../utils/basic';
import { EventMediaQuery, RecordingMediaQuery } from '../view/query';
import { QueryClassifier } from '../view/query-classifier';

interface MediaFilterControls {
  events: boolean;
  recordings: boolean;
  favorites: boolean;
}

export interface MediaFilterCoreDefaults {
  cameraIDs?: string[];
  favorite?: MediaFilterCoreFavoriteSelection;
  mediaType?: MediaFilterMediaType;
  what?: string[];
  when?: string;
  where?: string[];
  tags?: string[];
}

export enum MediaFilterCoreFavoriteSelection {
  Favorite = 'favorite',
  NotFavorite = 'not-favorite',
}

export enum MediaFilterCoreWhen {
  Today = 'today',
  Yesterday = 'yesterday',
  PastWeek = 'past-week',
  PastMonth = 'past-month',
  Custom = 'custom',
}

export enum MediaFilterMediaType {
  Clips = 'clips',
  Snapshots = 'snapshots',
  Recordings = 'recordings',
}

export class MediaFilterController {
  protected _host: LitElement;

  protected _mediaTypeOptions: SelectOption[];
  protected _cameraOptions: SelectOption[] = [];

  protected _whenOptions: SelectOption[] = [];
  protected _staticWhenOptions: SelectOption[];
  protected _metaDataWhenOptions: SelectOption[] = [];

  protected _whatOptions: SelectOption[] = [];
  protected _whereOptions: SelectOption[] = [];
  protected _tagsOptions: SelectOption[] = [];
  protected _favoriteOptions: SelectOption[];

  protected _defaults: MediaFilterCoreDefaults | null = null;
  protected _viewManager: ViewManagerInterface | null = null;

  constructor(host: LitElement) {
    this._host = host;

    this._favoriteOptions = [
      {
        value: MediaFilterCoreFavoriteSelection.Favorite,
        label: localize('media_filter.favorite'),
      },
      {
        value: MediaFilterCoreFavoriteSelection.NotFavorite,
        label: localize('media_filter.not_favorite'),
      },
    ];
    this._mediaTypeOptions = [
      {
        value: MediaFilterMediaType.Clips,
        label: localize('media_filter.media_types.clips'),
      },
      {
        value: MediaFilterMediaType.Snapshots,
        label: localize('media_filter.media_types.snapshots'),
      },
      {
        value: MediaFilterMediaType.Recordings,
        label: localize('media_filter.media_types.recordings'),
      },
    ];
    this._staticWhenOptions = [
      {
        value: MediaFilterCoreWhen.Today,
        label: localize('media_filter.whens.today'),
      },
      {
        value: MediaFilterCoreWhen.Yesterday,
        label: localize('media_filter.whens.yesterday'),
      },
      {
        value: MediaFilterCoreWhen.PastWeek,
        label: localize('media_filter.whens.past_week'),
      },
      {
        value: MediaFilterCoreWhen.PastMonth,
        label: localize('media_filter.whens.past_month'),
      },
      {
        value: MediaFilterCoreWhen.Custom,
        label: localize('media_filter.whens.custom'),
      },
    ];
    this._computeWhenOptions();
  }

  public getMediaTypeOptions(): SelectOption[] {
    return this._mediaTypeOptions;
  }
  public getCameraOptions(): SelectOption[] {
    return this._cameraOptions;
  }
  public getWhenOptions(): SelectOption[] {
    return this._whenOptions;
  }
  public getWhatOptions(): SelectOption[] {
    return this._whatOptions;
  }
  public getWhereOptions(): SelectOption[] {
    return this._whereOptions;
  }
  public getTagsOptions(): SelectOption[] {
    return this._tagsOptions;
  }
  public getFavoriteOptions(): SelectOption[] {
    return this._favoriteOptions;
  }
  public getDefaults(): MediaFilterCoreDefaults | null {
    return this._defaults;
  }
  public setViewManager(viewManager: ViewManagerInterface | null): void {
    this._viewManager = viewManager;
  }

  public async valueChangeHandler(
    cameraManager: CameraManager,
    cardWideConfig: CardWideConfig,
    values: {
      camera?: string | string[];
      mediaType?: MediaFilterMediaType;
      when: {
        selected?: string | string[];
        from?: Date | null;
        to?: Date | null;
      };
      favorite?: MediaFilterCoreFavoriteSelection;
      where?: string | string[];
      what?: string | string[];
      tags?: string | string[];
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _ev?: unknown,
  ): Promise<void> {
    const getArrayValueAsSet = (val?: SelectValues): Set<string> | null => {
      // The reported value may be '' if the field is clearable (i.e. the user
      // can click 'x').
      if (val && Array.isArray(val) && val.length && !val.includes('')) {
        return new Set([...val]);
      }
      return null;
    };

    const cameraIDs =
      getArrayValueAsSet(values.camera) ?? this._getAllCameraIDs(cameraManager);
    if (!cameraIDs.size || !values.mediaType) {
      return;
    }

    const when = this._getWhen(values.when);
    const favorite = values.favorite
      ? values.favorite === MediaFilterCoreFavoriteSelection.Favorite
      : null;

    // A note on views:
    // - In the below, if the user selects a camera to view media for, the main
    //   view camera is also set to that value (e.g. a user browsing the
    //   gallery, chooses a different camera in the media filter, then
    //   subsequently chooses the live button -- they would expect the live view
    //   for that filtered camera not the prior camera).
    // - Similarly, if the user chooses clips or snapshots, set the actual view
    //   to 'clips' or 'snapshots' in order to ensure the right icon is shown as
    //   selected in the menu.
    const limit = cardWideConfig.performance?.features.media_chunk_size;

    if (
      values.mediaType === MediaFilterMediaType.Clips ||
      values.mediaType === MediaFilterMediaType.Snapshots
    ) {
      const where = getArrayValueAsSet(values.where);
      const what = getArrayValueAsSet(values.what);
      const tags = getArrayValueAsSet(values.tags);

      const queries = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: cameraIDs,
          ...(tags && { tags: tags }),
          ...(what && { what: what }),
          ...(where && { where: where }),
          ...(favorite !== null && { favorite: favorite }),
          ...(when && {
            ...(when.start && { start: when.start }),
            ...(when.end && { end: when.end }),
          }),
          ...(limit && { limit: limit }),
          ...(values.mediaType === MediaFilterMediaType.Clips && { hasClip: true }),
          ...(values.mediaType === MediaFilterMediaType.Snapshots && {
            hasSnapshot: true,
          }),
        },
      ]);

      this._viewManager?.setViewByParametersWithExistingQuery({
        params: {
          query: queries,

          // See 'A note on views' above for these two arguments
          ...(cameraIDs.size === 1 && { camera: [...cameraIDs][0] }),
          view: values.mediaType === MediaFilterMediaType.Clips ? 'clips' : 'snapshots',
        },
      });
    } else {
      const queries = new RecordingMediaQuery([
        {
          type: QueryType.Recording,
          cameraIDs: cameraIDs,
          ...(limit && { limit: limit }),
          ...(when && {
            ...(when.start && { start: when.start }),
            ...(when.end && { end: when.end }),
          }),
          ...(favorite !== null && { favorite: favorite }),
        },
      ]);

      this._viewManager?.setViewByParametersWithExistingQuery({
        params: {
          query: queries,

          // See 'A note on views' above for these two arguments
          ...(cameraIDs.size === 1 && { camera: [...cameraIDs][0] }),
          view: 'recordings',
        },
      });
    }

    // Need to ensure we update the element as the date-picker selections may
    // have changed, and we need to un/set the selected class.
    this._host.requestUpdate();
  }

  protected _getAllCameraIDs(cameraManager: CameraManager): Set<string> {
    return cameraManager.getStore().getCameraIDsWithCapability({
      anyCapabilities: ['clips', 'snapshots', 'recordings'],
    });
  }

  public computeInitialDefaultsFromView(cameraManager: CameraManager): void {
    const view = this._viewManager?.getView();
    const query = view?.query;
    const allCameraIDs = this._getAllCameraIDs(cameraManager);
    if (!view || !QueryClassifier.isMediaQuery(query) || !allCameraIDs.size) {
      return;
    }

    const queries = query.getQuery();
    if (!queries) {
      return;
    }

    let mediaType: MediaFilterMediaType | undefined;
    let cameraIDs: string[] | undefined;
    let what: string[] | undefined;
    let where: string[] | undefined;
    let favorite: MediaFilterCoreFavoriteSelection | undefined;
    let tags: string[] | undefined;

    const cameraIDSets = uniqWith(
      queries.map((query: CameraQuery) => query.cameraIDs),
      isEqual,
    );
    // Special note: If all visible cameras are selected, this is the same as no
    // selector at all.
    if (cameraIDSets.length === 1 && !isEqual(queries[0].cameraIDs, allCameraIDs)) {
      cameraIDs = [...queries[0].cameraIDs];
    }

    const favoriteValues = uniqWith(
      queries.map((query) => query.favorite),
      isEqual,
    );
    if (favoriteValues.length === 1 && queries[0].favorite !== undefined) {
      favorite = queries[0].favorite
        ? MediaFilterCoreFavoriteSelection.Favorite
        : MediaFilterCoreFavoriteSelection.NotFavorite;
    }

    /* istanbul ignore else: the else path cannot be reached -- @preserve */
    if (QueryClassifier.isEventQuery(view.query)) {
      const queries = view.query.getQuery();

      /* istanbul ignore if: the if path cannot be reached -- @preserve */
      if (!queries) {
        return;
      }

      const hasClips = uniqWith(
        queries.map((query) => query.hasClip),
        isEqual,
      );
      const hasSnapshots = uniqWith(
        queries.map((query) => query.hasSnapshot),
        isEqual,
      );
      if (hasClips.length === 1 && hasSnapshots.length === 1) {
        mediaType = !!hasClips[0]
          ? MediaFilterMediaType.Clips
          : !!hasSnapshots[0]
            ? MediaFilterMediaType.Snapshots
            : undefined;
      }

      const whatSets = uniqWith(
        queries.map((query) => query.what),
        isEqual,
      );
      if (whatSets.length === 1 && queries[0].what?.size) {
        what = [...queries[0].what];
      }
      const whereSets = uniqWith(
        queries.map((query) => query.where),
        isEqual,
      );
      if (whereSets.length === 1 && queries[0].where?.size) {
        where = [...queries[0].where];
      }
      const tagsSets = uniqWith(
        queries.map((query) => query.tags),
        isEqual,
      );
      if (tagsSets.length === 1 && queries[0].tags?.size) {
        tags = [...queries[0].tags];
      }
    } else if (QueryClassifier.isRecordingQuery(view.query)) {
      mediaType = MediaFilterMediaType.Recordings;
    }

    this._defaults = {
      ...(mediaType && { mediaType: mediaType }),
      ...(cameraIDs && { cameraIDs: cameraIDs }),
      ...(what && { what: what }),
      ...(where && { where: where }),
      ...(favorite !== undefined && { favorite: favorite }),
      ...(tags && { tags: tags }),
    };
  }

  public computeCameraOptions(cameraManager: CameraManager): void {
    this._cameraOptions = [...this._getAllCameraIDs(cameraManager)].map((cameraID) => ({
      value: cameraID,
      label: cameraManager.getCameraMetadata(cameraID)?.title ?? cameraID,
    }));
  }

  public async computeMetadataOptions(cameraManager: CameraManager): Promise<void> {
    let metadata: MediaMetadata | null = null;
    try {
      metadata = await cameraManager.getMediaMetadata();
    } catch (e) {
      errorToConsole(e as Error);
    }
    if (!metadata) {
      return;
    }

    if (metadata.what) {
      this._whatOptions = [...metadata.what]
        .sort()
        .map((what) => ({ value: what, label: prettifyTitle(what) }));
    }
    if (metadata.where) {
      this._whereOptions = [...metadata.where]
        .sort()
        .map((where) => ({ value: where, label: prettifyTitle(where) }));
    }
    if (metadata.tags) {
      this._tagsOptions = [...metadata.tags]
        .sort()
        .map((tag) => ({ value: tag, label: prettifyTitle(tag) }));
    }
    if (metadata.days) {
      const yearMonths: Set<string> = new Set();
      [...metadata.days].forEach((day) => {
        // An efficient conversion: "2023-01-26" -> "2023-01"
        yearMonths.add(day.substring(0, 7));
      });

      const monthStarts: Date[] = [];
      yearMonths.forEach((yearMonth) => {
        monthStarts.push(parse(yearMonth, 'yyyy-MM', new Date()));
      });

      this._metaDataWhenOptions = orderBy(
        monthStarts,
        (date) => date.getTime(),
        'desc',
      ).map((monthStart) => ({
        label: format(monthStart, 'MMMM yyyy'),
        value: this._dateRangeToString({
          start: monthStart,
          end: endOfMonth(monthStart),
        }),
      }));
      this._computeWhenOptions();
    }

    this._host.requestUpdate();
  }

  public getControlsToShow(cameraManager: CameraManager): MediaFilterControls {
    const view = this._viewManager?.getView();
    const events = QueryClassifier.isEventQuery(view?.query);
    const recordings = QueryClassifier.isRecordingQuery(view?.query);
    const managerCapabilities = cameraManager.getAggregateCameraCapabilities();

    return {
      events: events,
      recordings: recordings,
      favorites: events
        ? managerCapabilities?.has('favorite-events')
        : recordings
          ? managerCapabilities?.has('favorite-recordings')
          : false,
    };
  }

  protected _computeWhenOptions(): void {
    this._whenOptions = [...this._staticWhenOptions, ...this._metaDataWhenOptions];
  }

  protected _dateRangeToString(when: DateRange): string {
    return `${formatDate(when.start)},${formatDate(when.end)}`;
  }

  protected _stringToDateRange(input: string): DateRange {
    const dates = input.split(',');
    return {
      start: parse(dates[0], 'yyyy-MM-dd', new Date()),
      end: endOfDay(parse(dates[1], 'yyyy-MM-dd', new Date())),
    };
  }

  protected _getWhen(values: {
    selected?: string | string[];
    from?: Date | null;
    to?: Date | null;
  }): PartialDateRange | null {
    if (values.from || values.to) {
      return {
        ...(values.from && { start: values.from }),
        ...(values.to && { end: values.to }),
      };
    }

    if (!values.selected || Array.isArray(values.selected)) {
      return null;
    }

    const now = new Date();
    switch (values.selected) {
      case MediaFilterCoreWhen.Custom:
        return null;
      case MediaFilterCoreWhen.Today:
        return { start: startOfToday(), end: endOfToday() };
      case MediaFilterCoreWhen.Yesterday:
        return { start: startOfYesterday(), end: endOfYesterday() };
      case MediaFilterCoreWhen.PastWeek:
        return { start: startOfDay(sub(now, { days: 7 })), end: endOfDay(now) };
      case MediaFilterCoreWhen.PastMonth:
        return { start: startOfDay(sub(now, { months: 1 })), end: endOfDay(now) };
      default:
        return this._stringToDateRange(values.selected);
    }
  }
}



================================================
FILE: src/components-lib/media-grid-controller.ts
================================================
import { isEqual, throttle } from 'lodash-es';
import Masonry from 'masonry-layout';
import { ViewDisplayConfig } from '../config/schema/common/display';
import { MediaLoadedInfo } from '../types';
import { getChildrenFromElement, setOrRemoveAttribute } from '../utils/basic';
import { fireAdvancedCameraCardEvent } from '../utils/fire-advanced-camera-card-event';
import {
  AdvancedCameraCardMediaLoadedEventTarget,
  dispatchExistingMediaLoadedInfoAsEvent,
  dispatchMediaUnloadedEvent,
} from '../utils/media-info';

// The default minimum cell width: if the columns are not specified this value
// is used to compute the number of columns, always trying to keep each cell as
// at least this width. On Android, a card in portrait mode is 396 pixels, and
// we'd like to support two cells wide in that configuration.
const MEDIA_GRID_DEFAULT_MIN_CELL_WIDTH = 190;
const MEDIA_GRID_DEFAULT_IDEAL_CELL_WIDTH = 600;
const MEDIA_GRID_DEFAULT_SELECTED_WIDTH_FACTOR = 2.0;
const MEDIA_GRID_HORIZONTAL_GUTTER_WIDTH = 1;

type GridID = string;
type MediaGridChild = HTMLElement & AdvancedCameraCardMediaLoadedEventTarget;
type MediaGridContents = Map<GridID, MediaGridChild>;

export interface MediaGridSelected {
  selected: GridID;
}

export interface MediaGridConstructorOptions {
  selected?: GridID;
  idAttribute?: string;
  displayConfig?: ViewDisplayConfig;
}

export interface ExtendedMasonry extends Masonry {
  // Expose the items array to allow for custom ordering (used for the
  // `grid_selected_position` parameter).
  items: {
    element: MediaGridChild;
  }[];
}

export class MediaGridController {
  protected _host: HTMLElement;

  protected _selected: GridID | null;
  protected _mediaLoadedInfoMap: Map<GridID, MediaLoadedInfo> = new Map();
  protected _gridContents: MediaGridContents = new Map();
  protected _masonry: ExtendedMasonry | null = null;
  protected _displayConfig: ViewDisplayConfig | null = null;
  protected _hostWidth: number;
  protected _idAttribute: string;

  protected _throttledLayout = throttle(
    () => this._masonry?.layout?.(),
    // Throttle layout calls to larger than the masonry.js transitionDuration
    // value specified below.
    300,
    { trailing: true, leading: false },
  );

  // If the order in which the observers are declared changes, the unittest must
  // be updated in triggerResizeObserver and triggerMutationObserver.
  protected _hostMutationObserver = new MutationObserver(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (_mutations: MutationRecord[], _observer: MutationObserver) =>
      this._calculateGridContentsFromHost(),
  );
  protected _cellMutationObserver = new MutationObserver(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (_mutations: MutationRecord[], _observer: MutationObserver) =>
      this._calculateGridContentsFromHost(),
  );
  protected _hostResizeObserver = new ResizeObserver(this._hostResizeHandler.bind(this));
  protected _cellResizeObserver = new ResizeObserver(this._cellResizeHandler.bind(this));

  constructor(host: HTMLElement, options?: MediaGridConstructorOptions) {
    this._host = host;
    this._selected = options?.selected ?? null;
    this._idAttribute = options?.idAttribute ?? 'grid-id';
    this._hostWidth = this._host.getBoundingClientRect().width;
    this._hostResizeObserver.observe(host);
    this._displayConfig = options?.displayConfig ?? null;

    this._hostMutationObserver.observe(host, {
      childList: true,
    });

    // Need to separately listen for slotchanges since mutation observer will
    // not be called for shadom DOM slotted changes.
    if (host instanceof HTMLSlotElement) {
      host.addEventListener('slotchange', this._calculateGridContentsFromHost);
    }
    this._calculateGridContentsFromHost();
  }

  public destroy(): void {
    this._hostResizeObserver.disconnect();
    this._cellResizeObserver.disconnect();

    this._hostMutationObserver.disconnect();
    this._cellMutationObserver.disconnect();

    if (this._host instanceof HTMLSlotElement) {
      this._host.removeEventListener('slotchange', this._calculateGridContentsFromHost);
    }

    this._mediaLoadedInfoMap.clear();
    this._masonry?.destroy?.();
    this._masonry = null;

    for (const child of this._gridContents.values()) {
      this._removeChildEventListeners(child);
    }
    this._gridContents.clear();
  }

  public setDisplayConfig(displayConfig: ViewDisplayConfig | null): void {
    if (!isEqual(displayConfig, this._displayConfig)) {
      this._displayConfig = displayConfig;
      this._calculateGridContentsFromHost();
    }
  }

  public getGridContents(): MediaGridContents {
    return this._gridContents;
  }

  public getGridSize(): number {
    return this._gridContents.size;
  }

  public getSelected(): GridID | null {
    return this._selected;
  }

  protected _sortItemsInGrid(): void {
    const existingItems = this._masonry?.items;
    const selectedItem = existingItems?.find(
      (item) => item.element.getAttribute(this._idAttribute) === this._selected,
    );

    // If `grid_selected_position` is set to 'first' or 'last', move the
    // selected item to the start or end of the list respectively.
    if (
      !!this._displayConfig?.grid_selected_position &&
      ['first', 'last'].includes(this._displayConfig.grid_selected_position) &&
      existingItems &&
      selectedItem &&
      this._masonry
    ) {
      // Implementation note: With the latest version of the Masonry library
      // (4.2.2) using the prepended() and appended() methods in quick sucession
      // causes the layout to not show the newly added items. Instead, access
      // the items in place and swap them around.
      const otherItems = existingItems?.filter((item) => item !== selectedItem);
      const newItems =
        this._displayConfig.grid_selected_position === 'first'
          ? [selectedItem, ...otherItems]
          : [...otherItems, selectedItem];
      this._masonry.items = newItems;
    }
  }

  public selectCell(id: GridID) {
    if (this._selected === id) {
      return;
    }

    this._selected = id;
    fireAdvancedCameraCardEvent(this._host, 'media-grid:selected', { selected: id });

    const mediaLoadedInfo = this._mediaLoadedInfoMap.get(id);
    if (mediaLoadedInfo) {
      dispatchExistingMediaLoadedInfoAsEvent(this._host, mediaLoadedInfo);
    }

    this._sortItemsInGrid();
    this._updateSelectedStylesOnElements();

    // Sizes and positions may change when an element is selected, so re-do the
    // layout (must come after the call to _updateStylesOnElements in order to
    // ensure the right styles are applied first).
    this._throttledLayout();
  }

  public unselectAll() {
    if (this._selected !== null) {
      dispatchMediaUnloadedEvent(this._host);
      fireAdvancedCameraCardEvent(this._host, 'media-grid:unselected');
    }
    this._selected = null;
    this._updateSelectedStylesOnElements();
  }

  protected _calculateGridContentsFromHost = (): void => {
    const children = getChildrenFromElement(this._host);
    const gridContents: MediaGridContents = new Map();
    for (const child of children) {
      const id = child.getAttribute(this._idAttribute) || String(gridContents.size);
      gridContents.set(id, child);
    }

    this._setGridContents(gridContents);
  };

  protected _setGridContents(gridContents: MediaGridContents): void {
    this._gridContents = gridContents;

    // Remove media loaded info objects that belong to objects no longer in the
    // grid.
    for (const key of this._mediaLoadedInfoMap.keys()) {
      if (!gridContents.has(key)) {
        this._mediaLoadedInfoMap.delete(key);
      }
    }

    if (this._selected !== null && !this._gridContents.has(this._selected)) {
      this.unselectAll();
    }

    for (const element of gridContents.values()) {
      this._removeChildEventListeners(element);
      this._addChildEventListeners(element);
    }

    this._setColumnSizeStyles();
    this._createMasonry();

    // Observe grid elements for size or id changes.
    this._cellMutationObserver.disconnect();
    this._cellResizeObserver.disconnect();
    for (const child of gridContents.values()) {
      this._cellMutationObserver.observe(child, {
        attributeFilter: [this._idAttribute],
        attributes: true,
      });
      this._cellResizeObserver.observe(child);
    }

    this._sortItemsInGrid();
    this._updateSelectedStylesOnElements();
    this._setColumnSizeStyles();
  }

  protected _handleMediaLoadedInfoEvent = (ev: CustomEvent<MediaLoadedInfo>): void => {
    const eventPath = ev.composedPath();

    for (const [id, element] of this._gridContents.entries()) {
      /* istanbul ignore else: the else path cannot be reached -- @preserve */
      if (eventPath.includes(element)) {
        this._mediaLoadedInfoMap.set(id, ev.detail);
        if (id !== this._selected) {
          ev.stopPropagation();
        }
        break;
      }
    }
  };

  protected _hostResizeHandler(): void {
    const dimensions = this._host.getBoundingClientRect();

    // Only resize things if the width has changed. It is expected that the
    // height may change during the layout.
    if (dimensions.width !== this._hostWidth) {
      this._hostWidth = dimensions.width;

      // Reset the column CSS sizes first.
      this._setColumnSizeStyles();

      // Need to recreate the masonry layout since the column width will differ.
      this._createMasonry();
    }
  }

  protected _cellResizeHandler(): void {
    this._throttledLayout();
  }

  protected _addChildEventListeners(child: MediaGridChild): void {
    child.addEventListener('click', this._handleSelectGridCellEvent, {
      capture: true,
    });

    child.addEventListener(
      'advanced-camera-card:media:loaded',
      this._handleMediaLoadedInfoEvent,
    );
  }

  protected _removeChildEventListeners(child: MediaGridChild): void {
    child.removeEventListener('click', this._handleSelectGridCellEvent, {
      capture: true,
    });

    child.removeEventListener(
      'advanced-camera-card:media:loaded',
      this._handleMediaLoadedInfoEvent,
    );
  }

  protected _createMasonry(): void {
    if (this._masonry) {
      this._masonry.destroy?.();
    }

    this._masonry = new Masonry(this._host, {
      columnWidth: this._getColumnSize(),
      initLayout: false,
      percentPosition: true,
      transitionDuration: '0.2s',
      gutter: MEDIA_GRID_HORIZONTAL_GUTTER_WIDTH,
    }) as ExtendedMasonry;
    this._masonry.addItems?.([...this._gridContents.values()]);
    this._throttledLayout();
  }

  protected _handleSelectGridCellEvent = (ev: Event): void => {
    const eventPath = ev.composedPath();

    for (const [id, element] of this._gridContents.entries()) {
      /* istanbul ignore else: the else path cannot be reached -- @preserve */
      if (eventPath.includes(element)) {
        if (this._selected !== id) {
          this.selectCell(id);
          ev.stopPropagation();
        }
        break;
      }
    }
  };

  protected _updateSelectedStylesOnElements(): void {
    for (const [id, element] of this._gridContents.entries()) {
      setOrRemoveAttribute(element, id === this._selected, 'selected');

      // Explicitly use an 'unselected' attribute vs a :not(selected) such that
      // a carousel with neither selected nor unselected will behave normally.
      // This matches a css selector in viewer-carousel.scss .
      setOrRemoveAttribute(element, id !== this._selected, 'unselected');
    }
  }

  protected _getColumnSize(): number {
    const columns = this._getColumns();
    if (columns === 1) {
      return this._hostWidth;
    }

    return Math.max(0, this._hostWidth / columns - MEDIA_GRID_HORIZONTAL_GUTTER_WIDTH);
  }

  protected _getColumns(): number {
    if (this._displayConfig?.grid_columns) {
      return this._displayConfig?.grid_columns;
    }

    const maxColumns = this._displayConfig?.grid_max_columns ?? Infinity;

    // See if we can get a multi-column layout using the ideal cell width.
    const idealColumns = Math.min(
      maxColumns,
      Math.floor(this._hostWidth / MEDIA_GRID_DEFAULT_IDEAL_CELL_WIDTH),
    );
    if (idealColumns > 1) {
      return idealColumns;
    }

    // If not, get a multi-column view using the minimum cell width.
    const minColumns = Math.floor(
      Math.min(maxColumns, this._hostWidth / MEDIA_GRID_DEFAULT_MIN_CELL_WIDTH),
    );

    // Last result use at least 1 column.
    return Math.max(1, minColumns);
  }

  protected _setColumnSizeStyles(): void {
    this._host.style.setProperty(
      '--advanced-camera-card-grid-column-size',
      `${this._getColumnSize()}px`,
    );

    this._host.style.setProperty(
      '--advanced-camera-card-grid-selected-width-factor',
      `${
        this._displayConfig?.grid_selected_width_factor ??
        MEDIA_GRID_DEFAULT_SELECTED_WIDTH_FACTOR
      }`,
    );
  }
}



================================================
FILE: src/components-lib/media-height-controller.ts
================================================
import { debounce, isEqual } from 'lodash-es';

export class MediaHeightController {
  private _host: HTMLElement;
  private _selector: string;

  private _root: HTMLElement | DocumentFragment | null = null;
  private _children: HTMLElement[] = [];
  private _selectedChild: HTMLElement | null = null;

  private _mutationObserver = new MutationObserver(() => this._initializeRoot());
  private _resizeObserver = new ResizeObserver(() => this._debouncedSetHeight());

  private _debouncedSetHeight = debounce(
    () => this._setHeight(),
    // Balancing act: Debounce to avoid excessive calls to setHeight, when new
    // media is loading the player may be a much smaller height momentarily.
    300,
    {
      trailing: true,
      leading: false,
    },
  );

  constructor(host: HTMLElement, selector: string) {
    this._host = host;
    this._selector = selector;
  }

  public setRoot(root: HTMLElement | DocumentFragment): void {
    if (root === this._root) {
      return;
    }

    this._root = root;
    this._mutationObserver.disconnect();
    this._mutationObserver.observe(this._root, {
      childList: true,
    });
    this._initializeRoot();
  }

  public setSelected(selectedIndex: number): void {
    const selectedChild: HTMLElement | undefined = this._children[selectedIndex];
    if (!selectedChild || selectedChild === this._selectedChild) {
      return;
    }
    this._selectedChild = selectedChild;

    this._resizeObserver.disconnect();
    this._resizeObserver.observe(selectedChild);

    this._debouncedSetHeight();
  }

  public destroy(): void {
    this._mutationObserver.disconnect();
    this._resizeObserver.disconnect();

    this._root = null;
    this._children = [];
    this._selectedChild = null;
  }

  private _setHeight(): void {
    if (!this._selectedChild) {
      return;
    }

    const originalHeight = this._host.style.maxHeight;

    // Remove the height restriction to ensure the full max height. Example of
    // behavior without this: Chrome on Android will not correctly size if the
    // card is in fullscreen mode.
    this._host.style.maxHeight = '';

    // Calculate the true height.
    const selectedHeight = this._selectedChild.getBoundingClientRect().height;

    // Reset the original height so that browser transition animation can be
    // applied from the current to the target.
    this._host.style.maxHeight = originalHeight;

    // Force the browser to reflow.
    this._selectedChild.getBoundingClientRect();

    if (selectedHeight && !isNaN(selectedHeight) && selectedHeight > 0) {
      this._host.style.maxHeight = `${selectedHeight}px`;
    }
  }

  private _initializeRoot(): void {
    const children = [
      ...(this._root?.querySelectorAll<HTMLElement>(this._selector) ??
        /* istanbul ignore next: this path cannot be reached as root will always
        exist by the time the mutation observer is observing -- @preserve */
        []),
    ];
    if (isEqual(children, this._children)) {
      return;
    }

    this._children = children;
    this._selectedChild = null;
  }
}



================================================
FILE: src/components-lib/menu-button-controller.ts
================================================
import { StyleInfo } from 'lit/directives/style-map';
import { CameraManager } from '../camera-manager/manager';
import { FoldersManager } from '../card-controller/folders/manager';
import { FullscreenManager } from '../card-controller/fullscreen/fullscreen-manager';
import { MediaPlayerManager } from '../card-controller/media-player-manager';
import { MicrophoneManager } from '../card-controller/microphone-manager';
import { ViewManager } from '../card-controller/view/view-manager';
import { VIEWS_USER_SPECIFIED } from '../config/schema/common/const';
import { MenuItem } from '../config/schema/elements/custom/menu/types';
import { AdvancedCameraCardConfig } from '../config/schema/types';
import { getEntityTitle } from '../ha/get-entity-title';
import { HomeAssistant } from '../ha/types';
import { localize } from '../localize/localize.js';
import { MediaLoadedInfo } from '../types';
import {
  createCameraAction,
  createDisplayModeAction,
  createFoldersViewAction,
  createGeneralAction,
  createMediaPlayerAction,
  createPTZControlsAction,
  createPTZMultiAction,
  createViewAction,
  isAdvancedCameraCardCustomAction,
} from '../utils/action';
import { arrayify, isTruthy } from '../utils/basic';
import { isBeingCasted } from '../utils/casting';
import { getPTZTarget } from '../utils/ptz';
import { getStreamCameraID, hasSubstream } from '../utils/substream';
import { ViewItemClassifier } from '../view/item-classifier';
import { QueryClassifier } from '../view/query-classifier';
import { View } from '../view/view';
import { getCameraIDsForViewName } from '../view/view-to-cameras';

export interface MenuButtonControllerOptions {
  currentMediaLoadedInfo?: MediaLoadedInfo | null;
  showCameraUIButton?: boolean;
  foldersManager?: FoldersManager | null;
  fullscreenManager?: FullscreenManager | null;
  inExpandedMode?: boolean;
  microphoneManager?: MicrophoneManager | null;
  mediaPlayerController?: MediaPlayerManager | null;
  viewManager?: ViewManager | null;
  view?: View | null;
}

export class MenuButtonController {
  // Array of dynamic menu buttons to be added to menu.
  protected _dynamicMenuButtons: MenuItem[] = [];

  public addDynamicMenuButton(button: MenuItem): void {
    if (!this._dynamicMenuButtons.includes(button)) {
      this._dynamicMenuButtons.push(button);
    }
  }

  public removeDynamicMenuButton(button: MenuItem): void {
    this._dynamicMenuButtons = this._dynamicMenuButtons.filter(
      (existingButton) => existingButton != button,
    );
  }

  /**
   * Get the menu buttons to display.
   * @returns An array of menu buttons.
   */
  public calculateButtons(
    hass: HomeAssistant,
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    options?: MenuButtonControllerOptions,
  ): MenuItem[] {
    return [
      this._getIrisButton(config),
      this._getCamerasButton(config, cameraManager, options?.view),
      this._getSubstreamsButton(config, cameraManager, options?.view),
      this._getLiveButton(config, options?.view, options?.viewManager),
      this._getClipsButton(config, options?.view, options?.viewManager),
      this._getSnapshotsButton(config, options?.view, options?.viewManager),
      this._getRecordingsButton(config, options?.view, options?.viewManager),
      this._getImageButton(config, options?.view, options?.viewManager),
      this._getTimelineButton(config, options?.view, options?.viewManager),
      this._getDownloadButton(config, cameraManager, options?.view),
      this._getCameraUIButton(config, options?.showCameraUIButton),
      this._getMicrophoneButton(
        config,
        options?.microphoneManager,
        options?.currentMediaLoadedInfo,
      ),
      this._getExpandButton(config, options?.inExpandedMode),
      this._getFullscreenButton(config, options?.fullscreenManager),
      this._getCastButton(
        hass,
        config,
        cameraManager,
        options?.view,
        options?.mediaPlayerController,
      ),
      this._getPlayPauseButton(config, options?.currentMediaLoadedInfo),
      this._getMuteUnmuteButton(config, options?.currentMediaLoadedInfo),
      this._getScreenshotButton(config, options?.currentMediaLoadedInfo),
      this._getDisplayModeButton(config, cameraManager, options?.view),
      this._getPTZControlsButton(config, cameraManager, options?.view),
      this._getPTZHomeButton(config, cameraManager, options?.view),
      this._getFoldersButton(config, options?.foldersManager, options?.view),

      ...this._dynamicMenuButtons.map((button) => ({
        style: this._getStyleFromActions(config, button, options),
        ...button,
      })),
    ].filter(isTruthy);
  }

  protected _getIrisButton(config: AdvancedCameraCardConfig): MenuItem {
    return {
      icon: 'iris',
      ...config.menu.buttons.iris,
      type: 'custom:advanced-camera-card-menu-icon',
      title: localize('config.menu.buttons.iris'),
      // The default button always shows regardless of whether the menu is
      // hidden or not.
      permanent: true,
      tap_action:
        config.menu?.style === 'hidden'
          ? createGeneralAction('menu_toggle')
          : createGeneralAction('default'),
      hold_action: createViewAction('diagnostics'),
    };
  }

  protected _getCamerasButton(
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
  ): MenuItem | null {
    // Show all cameras in the menu rather than just cameras that support the
    // current view for a less surprising UX.
    const menuCameraIDs = cameraManager.getStore().getCameraIDsWithCapability('menu');
    if (menuCameraIDs.size > 1) {
      const submenuItems = Array.from(menuCameraIDs, (cameraID) => {
        const action = createCameraAction('camera_select', cameraID);
        const metadata = cameraManager.getCameraMetadata(cameraID);

        return {
          enabled: true,
          icon: metadata?.icon.icon,
          entity: metadata?.icon.entity,
          state_color: true,
          title: metadata?.title,
          selected: view?.camera === cameraID,
          ...(action && { tap_action: action }),
        };
      });

      return {
        icon: 'mdi:video-switch',
        ...config.menu.buttons.cameras,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: localize('config.menu.buttons.cameras'),
        items: submenuItems,
      };
    }
    return null;
  }

  protected _getSubstreamsButton(
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
  ): MenuItem | null {
    if (!view) {
      return null;
    }

    const substreamCameraIDs = cameraManager
      .getStore()
      .getAllDependentCameras(view.camera, 'substream');

    if (substreamCameraIDs.size && view.is('live')) {
      const substreams = [...substreamCameraIDs].filter(
        (cameraID) => cameraID !== view.camera,
      );
      const streams = [view.camera, ...substreams];
      const substreamAwareCameraID = getStreamCameraID(view);

      if (streams.length === 2) {
        // If there are only two dependencies (the main camera, and 1 other)
        // then use a button not a menu to toggle.
        return {
          icon: 'mdi:video-input-component',
          style:
            substreamAwareCameraID !== view.camera ? this._getEmphasizedStyle() : {},
          title: localize('config.menu.buttons.substreams'),
          ...config.menu.buttons.substreams,
          type: 'custom:advanced-camera-card-menu-icon',
          tap_action: createGeneralAction(
            hasSubstream(view) ? 'live_substream_off' : 'live_substream_on',
          ),
        };
      } else if (streams.length > 2) {
        const menuItems = Array.from(streams, (streamID) => {
          const action = createCameraAction('live_substream_select', streamID);
          const metadata = cameraManager.getCameraMetadata(streamID) ?? undefined;
          return {
            enabled: true,
            icon: metadata?.icon.icon,
            entity: metadata?.icon.entity,
            state_color: true,
            title: metadata?.title,
            selected: substreamAwareCameraID === streamID,
            ...(action && { tap_action: action }),
          };
        });

        return {
          icon: 'mdi:video-input-component',
          title: localize('config.menu.buttons.substreams'),
          style:
            substreamAwareCameraID !== view.camera ? this._getEmphasizedStyle() : {},
          ...config.menu.buttons.substreams,
          type: 'custom:advanced-camera-card-menu-submenu',
          items: menuItems,
        };
      }
    }
    return null;
  }

  protected _getLiveButton(
    config: AdvancedCameraCardConfig,
    view?: View | null,
    viewManager?: ViewManager | null,
  ): MenuItem | null {
    return view && viewManager?.isViewSupportedByCamera(view.camera, 'live')
      ? {
          icon: 'mdi:cctv',
          ...config.menu.buttons.live,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.view.views.live'),
          style: view.is('live') ? this._getEmphasizedStyle() : {},
          tap_action: createViewAction('live'),
        }
      : null;
  }

  protected _getClipsButton(
    config: AdvancedCameraCardConfig,
    view?: View | null,
    viewManager?: ViewManager | null,
  ): MenuItem | null {
    return view && viewManager?.isViewSupportedByCamera(view.camera, 'clips')
      ? {
          icon: 'mdi:filmstrip',
          ...config.menu.buttons.clips,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.view.views.clips'),
          style: view?.is('clips') ? this._getEmphasizedStyle() : {},
          tap_action: createViewAction('clips'),
          hold_action: createViewAction('clip'),
        }
      : null;
  }

  protected _getSnapshotsButton(
    config: AdvancedCameraCardConfig,
    view?: View | null,
    viewManager?: ViewManager | null,
  ): MenuItem | null {
    return view && viewManager?.isViewSupportedByCamera(view.camera, 'snapshots')
      ? {
          icon: 'mdi:camera',
          ...config.menu.buttons.snapshots,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.view.views.snapshots'),
          style: view?.is('snapshots') ? this._getEmphasizedStyle() : {},
          tap_action: createViewAction('snapshots'),
          hold_action: createViewAction('snapshot'),
        }
      : null;
  }

  protected _getRecordingsButton(
    config: AdvancedCameraCardConfig,
    view?: View | null,
    viewManager?: ViewManager | null,
  ): MenuItem | null {
    return view && viewManager?.isViewSupportedByCamera(view.camera, 'recordings')
      ? {
          icon: 'mdi:album',
          ...config.menu.buttons.recordings,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.view.views.recordings'),
          style: view.is('recordings') ? this._getEmphasizedStyle() : {},
          tap_action: createViewAction('recordings'),
          hold_action: createViewAction('recording'),
        }
      : null;
  }

  protected _getImageButton(
    config: AdvancedCameraCardConfig,
    view?: View | null,
    viewManager?: ViewManager | null,
  ): MenuItem | null {
    return view && viewManager?.isViewSupportedByCamera(view.camera, 'image')
      ? {
          icon: 'mdi:image',
          ...config.menu.buttons.image,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.view.views.image'),
          style: view?.is('image') ? this._getEmphasizedStyle() : {},
          tap_action: createViewAction('image'),
        }
      : null;
  }

  protected _getTimelineButton(
    config: AdvancedCameraCardConfig,
    view?: View | null,
    viewManager?: ViewManager | null,
  ): MenuItem | null {
    return view && viewManager?.isViewSupportedByCamera(view.camera, 'timeline')
      ? {
          icon: 'mdi:chart-gantt',
          ...config.menu.buttons.timeline,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.view.views.timeline'),
          style: view.is('timeline') ? this._getEmphasizedStyle() : {},
          tap_action: createViewAction('timeline'),
        }
      : null;
  }

  protected _getDownloadButton(
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
  ): MenuItem | null {
    const selectedItem = view?.queryResults?.getSelectedResult();
    const mediaCapabilities =
      selectedItem && ViewItemClassifier.isMedia(selectedItem)
        ? cameraManager?.getMediaCapabilities(selectedItem)
        : null;
    if (view?.isViewerView() && mediaCapabilities?.canDownload && !isBeingCasted()) {
      return {
        icon: 'mdi:download',
        ...config.menu.buttons.download,
        type: 'custom:advanced-camera-card-menu-icon',
        title: localize('config.menu.buttons.download'),
        tap_action: createGeneralAction('download'),
      };
    }
    return null;
  }

  protected _getCameraUIButton(
    config: AdvancedCameraCardConfig,
    showCameraUIButton?: boolean,
  ): MenuItem | null {
    return showCameraUIButton
      ? {
          icon: 'mdi:web',
          ...config.menu.buttons.camera_ui,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.menu.buttons.camera_ui'),
          tap_action: createGeneralAction('camera_ui'),
        }
      : null;
  }

  protected _getMicrophoneButton(
    config: AdvancedCameraCardConfig,
    microphoneManager?: MicrophoneManager | null,
    currentMediaLoadedInfo?: MediaLoadedInfo | null,
  ): MenuItem | null {
    if (microphoneManager && currentMediaLoadedInfo?.capabilities?.supports2WayAudio) {
      const unavailable =
        microphoneManager.isForbidden() || !microphoneManager.isSupported();
      const muted = microphoneManager.isMuted();
      const buttonType = config.menu.buttons.microphone.type;
      return {
        icon: unavailable
          ? 'mdi:microphone-message-off'
          : muted
            ? 'mdi:microphone-off'
            : 'mdi:microphone',
        ...config.menu.buttons.microphone,
        type: 'custom:advanced-camera-card-menu-icon',
        title: localize('config.menu.buttons.microphone'),
        style: unavailable || muted ? {} : this._getEmphasizedStyle(true),
        ...(!unavailable &&
          buttonType === 'momentary' && {
            start_tap_action: createGeneralAction('microphone_unmute'),
            end_tap_action: createGeneralAction('microphone_mute'),
          }),
        ...(!unavailable &&
          buttonType === 'toggle' && {
            tap_action: createGeneralAction(
              muted ? 'microphone_unmute' : 'microphone_mute',
            ),
          }),
      };
    }
    return null;
  }

  protected _getExpandButton(
    config: AdvancedCameraCardConfig,
    inExpandedMode?: boolean,
  ): MenuItem {
    return {
      icon: inExpandedMode ? 'mdi:arrow-collapse-all' : 'mdi:arrow-expand-all',
      ...config.menu.buttons.expand,
      type: 'custom:advanced-camera-card-menu-icon',
      title: localize('config.menu.buttons.expand'),
      tap_action: createGeneralAction('expand'),
      style: inExpandedMode ? this._getEmphasizedStyle() : {},
    };
  }

  protected _getFullscreenButton(
    config: AdvancedCameraCardConfig,
    fullscreenManager?: FullscreenManager | null,
  ): MenuItem | null {
    const inFullscreen = fullscreenManager?.isInFullscreen();
    return fullscreenManager?.isSupported()
      ? {
          icon: inFullscreen ? 'mdi:fullscreen-exit' : 'mdi:fullscreen',
          ...config.menu.buttons.fullscreen,
          type: 'custom:advanced-camera-card-menu-icon',
          title: localize('config.menu.buttons.fullscreen'),
          tap_action: createGeneralAction('fullscreen'),
          style: inFullscreen ? this._getEmphasizedStyle() : {},
        }
      : null;
  }

  protected _getCastButton(
    hass: HomeAssistant,
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
    mediaPlayerController?: MediaPlayerManager | null,
  ): MenuItem | null {
    if (!view) {
      return null;
    }
    const selectedCameraConfig = cameraManager.getStore().getCameraConfig(view.camera);
    if (
      mediaPlayerController?.hasMediaPlayers() &&
      (view.isViewerView() || (view.is('live') && selectedCameraConfig?.camera_entity))
    ) {
      const mediaPlayerItems = mediaPlayerController
        .getMediaPlayers()
        .map((playerEntityID) => {
          const title = getEntityTitle(hass, playerEntityID) || playerEntityID;
          const state = hass.states[playerEntityID];
          const playAction = createMediaPlayerAction(playerEntityID, 'play');
          const stopAction = createMediaPlayerAction(playerEntityID, 'stop');
          const disabled = !state || state.state === 'unavailable';

          return {
            enabled: true,
            selected: false,
            entity: playerEntityID,
            state_color: false,
            title: title,
            disabled: disabled,
            ...(!disabled && playAction && { tap_action: playAction }),
            ...(!disabled && stopAction && { hold_action: stopAction }),
          };
        });

      return {
        icon: 'mdi:cast',
        ...config.menu.buttons.media_player,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: localize('config.menu.buttons.media_player'),
        items: mediaPlayerItems,
      };
    }
    return null;
  }

  protected _getPlayPauseButton(
    config: AdvancedCameraCardConfig,
    currentMediaLoadedInfo?: MediaLoadedInfo | null,
  ): MenuItem | null {
    if (
      currentMediaLoadedInfo &&
      currentMediaLoadedInfo.mediaPlayerController &&
      currentMediaLoadedInfo.capabilities?.supportsPause
    ) {
      const paused = currentMediaLoadedInfo.mediaPlayerController?.isPaused();
      return {
        icon: paused ? 'mdi:play' : 'mdi:pause',
        ...config.menu.buttons.play,
        type: 'custom:advanced-camera-card-menu-icon',
        title: localize('config.menu.buttons.play'),
        tap_action: createGeneralAction(paused ? 'play' : 'pause'),
      };
    }
    return null;
  }

  protected _getMuteUnmuteButton(
    config: AdvancedCameraCardConfig,
    currentMediaLoadedInfo?: MediaLoadedInfo | null,
  ): MenuItem | null {
    if (
      currentMediaLoadedInfo &&
      currentMediaLoadedInfo.mediaPlayerController &&
      currentMediaLoadedInfo?.capabilities?.hasAudio
    ) {
      const muted = currentMediaLoadedInfo.mediaPlayerController?.isMuted();
      return {
        icon: muted ? 'mdi:volume-off' : 'mdi:volume-high',
        ...config.menu.buttons.mute,
        type: 'custom:advanced-camera-card-menu-icon',
        title: localize('config.menu.buttons.mute'),
        tap_action: createGeneralAction(muted ? 'unmute' : 'mute'),
      };
    }
    return null;
  }

  protected _getScreenshotButton(
    config: AdvancedCameraCardConfig,
    currentMediaLoadedInfo?: MediaLoadedInfo | null,
  ): MenuItem | null {
    if (currentMediaLoadedInfo && currentMediaLoadedInfo.mediaPlayerController) {
      return {
        icon: 'mdi:monitor-screenshot',
        ...config.menu.buttons.screenshot,
        type: 'custom:advanced-camera-card-menu-icon',
        title: localize('config.menu.buttons.screenshot'),
        tap_action: createGeneralAction('screenshot'),
      };
    }
    return null;
  }

  protected _getDisplayModeButton(
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
  ): MenuItem | null {
    const viewCameraIDs = view
      ? getCameraIDsForViewName(cameraManager, view.view)
      : null;
    if (
      view?.supportsMultipleDisplayModes() &&
      viewCameraIDs &&
      viewCameraIDs.size > 1
    ) {
      const isGrid = view.isGrid();
      return {
        icon: isGrid ? 'mdi:grid-off' : 'mdi:grid',
        ...config.menu.buttons.display_mode,
        style: isGrid ? this._getEmphasizedStyle() : {},
        type: 'custom:advanced-camera-card-menu-icon',
        title: isGrid
          ? localize('display_modes.single')
          : localize('display_modes.grid'),
        tap_action: createDisplayModeAction(isGrid ? 'single' : 'grid'),
      };
    }
    return null;
  }

  protected _getPTZControlsButton(
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
  ): MenuItem | null {
    const ptzConfig = view?.is('live')
      ? config.live.controls.ptz
      : view?.isViewerView()
        ? config.media_viewer.controls.ptz
        : null;

    if (!view || !ptzConfig) {
      return null;
    }

    const ptzTarget = getPTZTarget(view, {
      cameraManager: cameraManager,
    });

    if (ptzTarget) {
      const isOn =
        view.context?.ptzControls?.enabled !== undefined
          ? view.context.ptzControls.enabled
          : ptzConfig.mode === 'on' ||
            (ptzConfig.mode === 'auto' && ptzTarget.type === 'ptz');
      return {
        icon: 'mdi:pan',
        ...config.menu.buttons.ptz_controls,
        style: isOn ? this._getEmphasizedStyle() : {},
        type: 'custom:advanced-camera-card-menu-icon',
        title: localize('config.menu.buttons.ptz_controls'),
        tap_action: createPTZControlsAction(!isOn),
      };
    }
    return null;
  }

  protected _getPTZHomeButton(
    config: AdvancedCameraCardConfig,
    cameraManager: CameraManager,
    view?: View | null,
  ): MenuItem | null {
    const target = view
      ? getPTZTarget(view, {
          cameraManager: cameraManager,
        })
      : null;

    if (
      !target ||
      ((target.type === 'digital' &&
        view?.context?.zoom?.[target.targetID]?.observed?.isDefault) ??
        true)
    ) {
      return null;
    }

    return {
      icon: 'mdi:home',
      ...config.menu.buttons.ptz_home,
      type: 'custom:advanced-camera-card-menu-icon',
      title: localize('config.menu.buttons.ptz_home'),
      tap_action: createPTZMultiAction({
        targetID: target.targetID,
      }),
    };
  }

  protected _getFoldersButton(
    config: AdvancedCameraCardConfig,
    foldersManager?: FoldersManager | null,
    view?: View | null,
  ): MenuItem | null {
    const folders = [...(foldersManager?.getFolders() ?? [])];
    if (!folders?.length) {
      return null;
    }

    if (folders.length === 1) {
      const isSelected =
        QueryClassifier.isFolderQuery(view?.query) &&
        view.query.getQuery()?.folder.id === folders[0][0];
      const folder = folders[0][1];

      return {
        icon: folder.icon ?? 'mdi:folder',
        ...config.menu.buttons.folders,
        type: 'custom:advanced-camera-card-menu-icon',
        title: folder.title ?? localize('config.menu.buttons.folders'),
        style: isSelected ? this._getEmphasizedStyle() : {},
        tap_action: createFoldersViewAction('folders'),
        hold_action: createFoldersViewAction('folder'),
      };
    }

    const submenuItems = folders.map(([id, folder]) => {
      const isSelected =
        QueryClassifier.isFolderQuery(view?.query) &&
        view.query.getQuery()?.folder.id === id;

      return {
        enabled: true,
        title: folder.title ?? folder.id,
        icon: folder.icon ?? 'mdi:folder',
        selected: isSelected,
        style: isSelected ? this._getEmphasizedStyle() : {},
        tap_action: createFoldersViewAction('folders', { folderID: id }),
        hold_action: createFoldersViewAction('folder', { folderID: id }),
      };
    });

    return {
      icon: 'mdi:folder-multiple',
      ...config.menu.buttons.folders,
      type: 'custom:advanced-camera-card-menu-submenu',
      title: localize('config.menu.buttons.folders'),
      items: submenuItems,
      style: view?.isAnyFolderView() ? this._getEmphasizedStyle() : {},
    };
  }

  /**
   * Get the style of emphasized menu items.
   * @returns A StyleInfo.
   */
  protected _getEmphasizedStyle(critical?: boolean): StyleInfo {
    if (critical) {
      return {
        animation: 'pulse 3s infinite',
        color: 'var(--advanced-camera-card-menu-button-critical-color)',
      };
    }
    return {
      color: 'var(--advanced-camera-card-menu-button-active-color)',
    };
  }

  /**
   * Given a button determine if the style should be emphasized by examining all
   * of the actions sequentially.
   * @param button The button to examine.
   * @returns A StyleInfo object.
   */
  protected _getStyleFromActions(
    config: AdvancedCameraCardConfig,
    button: MenuItem,
    options?: MenuButtonControllerOptions,
  ): StyleInfo {
    for (const actionSet of [
      button.tap_action,
      button.double_tap_action,
      button.hold_action,
      button.start_tap_action,
      button.end_tap_action,
    ]) {
      for (const action of arrayify(actionSet)) {
        if (!isAdvancedCameraCardCustomAction(action)) {
          continue;
        }

        if (
          VIEWS_USER_SPECIFIED.some(
            (viewName) =>
              viewName === action.advanced_camera_card_action &&
              options?.view?.is(action.advanced_camera_card_action),
          ) ||
          (action.advanced_camera_card_action === 'default' &&
            options?.view?.is(config.view.default)) ||
          (action.advanced_camera_card_action === 'fullscreen' &&
            !!options?.fullscreenManager?.isInFullscreen()) ||
          (action.advanced_camera_card_action === 'camera_select' &&
            options?.view?.camera === action.camera)
        ) {
          return this._getEmphasizedStyle();
        }
      }
    }
    return {};
  }
}



================================================
FILE: src/components-lib/menu-controller.ts
================================================
import { LitElement } from 'lit';
import { orderBy } from 'lodash-es';
import { dispatchActionExecutionRequest } from '../card-controller/actions/utils/execution-request.js';
import { SubmenuInteraction } from '../components/submenu/types.js';
import { ActionConfig, ActionsConfig } from '../config/schema/actions/types.js';
import { MENU_PRIORITY_MAX } from '../config/schema/common/const.js';
import { MenuItem } from '../config/schema/elements/custom/menu/types.js';
import { MenuConfig } from '../config/schema/menu.js';
import { Interaction } from '../types.js';
import { getActionConfigGivenAction } from '../utils/action';
import { arrayify, isTruthy, setOrRemoveAttribute } from '../utils/basic.js';

export class MenuController {
  protected _host: LitElement;
  protected _config: MenuConfig | null = null;
  protected _buttons: MenuItem[] = [];
  protected _expanded = false;

  constructor(host: LitElement) {
    this._host = host;
  }

  public setMenuConfig(config: MenuConfig): void {
    this._config = config;
    this._host.style.setProperty(
      '--advanced-camera-card-menu-button-size',
      `${config.button_size}px`,
    );

    // Store the menu style, position and alignment as attributes (used for
    // styling).
    this._host.setAttribute('data-style', config.style);
    this._host.setAttribute('data-position', config.position);
    this._host.setAttribute('data-alignment', config.alignment);

    this._sortButtons();
    this._host.requestUpdate();
  }

  public getMenuConfig(): MenuConfig | null {
    return this._config;
  }

  public isExpanded(): boolean {
    return this._expanded;
  }

  public setButtons(buttons: MenuItem[]): void {
    this._buttons = buttons;
    this._sortButtons();
    this._host.requestUpdate();
  }

  public getButtons(alignment: 'matching' | 'opposing'): MenuItem[] {
    const aligned = (button: MenuItem): boolean => {
      return (
        button.alignment === alignment || (alignment === 'matching' && !button.alignment)
      );
    };

    const enabled = (button: MenuItem): boolean => {
      return button.enabled !== false;
    };

    const show = (button: MenuItem): boolean => {
      return !this._isHidingMenu() || this._expanded || !!button.permanent;
    };

    return this._buttons.filter(
      (button) => enabled(button) && aligned(button) && show(button),
    );
  }

  public setExpanded(expanded: boolean): void {
    this._expanded = expanded;
    setOrRemoveAttribute(this._host, expanded, 'expanded');
    this._host.requestUpdate();
  }

  public toggleExpanded(): void {
    this.setExpanded(!this._expanded);
  }

  public handleAction(
    ev: CustomEvent<Interaction & Partial<SubmenuInteraction>>,
    buttonConfig?: ActionsConfig,
  ): void {
    // These interactions should only be handled by the menu, as nothing
    // upstream has the user-provided configuration.
    ev.stopPropagation();

    // If the action is from a submenu, use the attached action config.
    const config: ActionsConfig | null = buttonConfig ?? ev.detail.item ?? null;
    if (!config) {
      return;
    }

    const interaction: string = ev.detail.action;
    const action = getActionConfigGivenAction(interaction, config);
    if (!action) {
      return;
    }
    const actions = arrayify(action);

    // A note on the complexity below: By default the menu should close when a
    // user takes an action, an exception is if the user is specifically
    // manipulating the menu in the actions themselves.
    let menuToggle = false;

    const toggleLessActions = actions.filter(
      (item) => isTruthy(item) && !this._isMenuToggleAction(item),
    );
    if (toggleLessActions.length != actions.length) {
      menuToggle = true;
    }

    if (toggleLessActions.length) {
      dispatchActionExecutionRequest(this._host, {
        actions: actions,
        config: config,
      });
    }

    if (this._isHidingMenu()) {
      if (menuToggle) {
        this.setExpanded(!this._expanded);
      } else {
        // Don't close the menu if there is another action to come.
        const holdAction = getActionConfigGivenAction('hold', config);
        const doubleTapAction = getActionConfigGivenAction('double_tap', config);
        const tapAction = getActionConfigGivenAction('tap', config);
        const endTapAction = getActionConfigGivenAction('end_tap', config);

        if (
          interaction === 'end_tap' ||
          (interaction === 'start_tap' &&
            !holdAction &&
            !doubleTapAction &&
            !tapAction &&
            !endTapAction) ||
          (interaction !== 'end_tap' && !endTapAction)
        ) {
          this.setExpanded(false);
        }
      }
    }
  }

  protected _sortButtons(): void {
    this._buttons = orderBy(
      this._buttons,
      (button) => {
        const priority = button.priority ?? 0;
        // If the menu is hidden, the buttons that toggle the menu must come
        // first.
        return (
          priority + (this._isHidingMenu() && button.permanent ? MENU_PRIORITY_MAX : 0)
        );
      },
      ['desc'],
    );
  }

  protected _isHidingMenu(): boolean {
    return this._config?.style === 'hidden';
  }

  protected _isMenuToggleAction(action: ActionConfig): boolean {
    return (
      action.action === 'fire-dom-event' &&
      action.advanced_camera_card_action === 'menu_toggle'
    );
  }
}



================================================
FILE: src/components-lib/status-bar-controller.ts
================================================
import { LitElement } from 'lit';
import { isEqual, orderBy } from 'lodash-es';
import { dispatchActionExecutionRequest } from '../card-controller/actions/utils/execution-request';
import { ActionsConfig, StatusBarItem } from '../config/schema/actions/types';
import { STATUS_BAR_PRIORITY_DEFAULT } from '../config/schema/common/const';
import { StatusBarConfig } from '../config/schema/status-bar';
import { getActionConfigGivenAction } from '../utils/action';
import { arrayify, setOrRemoveAttribute } from '../utils/basic';
import { Timer } from '../utils/timer';

export class StatusBarController {
  protected _host: LitElement;
  protected _config: StatusBarConfig | null = null;

  protected _popupTimer = new Timer();
  protected _items: StatusBarItem[] = [];

  constructor(host: LitElement) {
    this._host = host;
  }

  public getRenderItems(): StatusBarItem[] {
    return this._items;
  }

  public setItems(items: StatusBarItem[]): void {
    const exclusiveItems = items.filter((item) => !!item.exclusive);

    const newItems = orderBy(
      exclusiveItems.length ? exclusiveItems : items,
      (item) => item.priority ?? STATUS_BAR_PRIORITY_DEFAULT,
      'desc',
    );

    const sufficientBefore = this._getSufficientValues(this._items);
    const sufficientAfter = this._getSufficientValues(newItems);

    this._items = newItems;

    if (this._config?.style === 'popup' && !isEqual(sufficientBefore, sufficientAfter)) {
      this._show();
      this._popupTimer.start(this._config.popup_seconds, () => this._hide());
    }

    this._host.requestUpdate();
  }

  public setConfig(config: StatusBarConfig): void {
    this._config = config;
    this._host.style.setProperty(
      '--advanced-camera-card-status-bar-height',
      `${config.height}px`,
    );

    this._host.setAttribute('data-style', config.style);
    this._host.setAttribute('data-position', config.position);

    if (this._config?.style !== 'popup') {
      this._show();
    }

    this._host.requestUpdate();
  }

  public getConfig(): StatusBarConfig | null {
    return this._config;
  }

  public shouldRender(): boolean {
    return this._items.some((item) => item.enabled !== false && item.sufficient);
  }

  public actionHandler(
    ev: CustomEvent<{ action: string; config?: ActionsConfig }>,
    config?: ActionsConfig,
  ): void {
    // These interactions should only be handled by the status bar, as nothing
    // upstream has the user-provided configuration.
    ev.stopPropagation();

    const interaction: string = ev.detail.action;
    const action = getActionConfigGivenAction(interaction, config);
    if (!action) {
      return;
    }

    dispatchActionExecutionRequest(this._host, {
      actions: arrayify(action),
      config: config,
    });
  }

  protected _getSufficientValue(item: StatusBarItem): string | null {
    /* istanbul ignore else: cannot happen -- @preserve */
    if (item.type === 'custom:advanced-camera-card-status-bar-icon') {
      return item.icon;
    } else if (item.type === 'custom:advanced-camera-card-status-bar-string') {
      return item.string;
    } else if (item.type === 'custom:advanced-camera-card-status-bar-image') {
      return item.image;
    } else {
      return null;
    }
  }

  protected _getSufficientValues(items: StatusBarItem[]): (string | null)[] {
    return items
      .filter((item) => item.enabled !== false && item.sufficient)
      .map((item) => this._getSufficientValue(item));
  }

  protected _show(): void {
    setOrRemoveAttribute(this._host, false, 'hide');
  }

  protected _hide(): void {
    setOrRemoveAttribute(this._host, true, 'hide');
  }
}



================================================
FILE: src/components-lib/timeline-source.ts
================================================
import { add, sub } from 'date-fns';
import { DataSet } from 'vis-data';
import { IdType, TimelineItem, TimelineWindow } from 'vis-timeline/esnext';
import { CameraManager } from '../camera-manager/manager';
import {
  compressRanges,
  ExpiringMemoryRangeSet,
  MemoryRangeSet,
} from '../camera-manager/range';
import { EventQuery, RecordingQuery, RecordingSegment } from '../camera-manager/types';
import { capEndDate } from '../camera-manager/utils/cap-end-date';
import { convertRangeToCacheFriendlyTimes } from '../camera-manager/utils/range-to-cache-friendly';
import { ClipsOrSnapshotsOrAll } from '../types';
import { errorToConsole, ModifyInterface } from '../utils/basic.js';
import { ViewMedia } from '../view/item';

// Allow timeline freshness to be at least this number of seconds out of date
// (caching times in the data-engine may increase the effective delay).
const TIMELINE_FRESHNESS_TOLERANCE_SECONDS = 30;

// Number of seconds gap allowable in order to consider two recording segments
// to be consecutive. Some low performance cameras have trouble and without a
// generous allowance here the timeline may be littered with individual segments
// instead of clean recording blocks.
const TIMELINE_RECORDING_SEGMENT_CONSECUTIVE_TOLERANCE_SECONDS = 60;

export interface AdvancedCameraCardTimelineItem extends TimelineItem {
  // Use numbers to avoid significant volumes of Date object construction (for
  // high-quantity recording segments).
  start: number;
  end?: number;

  // DataSet requires string (not HTMLElement) content.
  content: string;

  media?: ViewMedia;
}

export class TimelineDataSource {
  protected _cameraManager: CameraManager;
  protected _dataset: DataSet<AdvancedCameraCardTimelineItem> = new DataSet();

  // The ranges in which recordings have been calculated and added for.
  // Calculating recordings is a very expensive process since it is based on
  // segments (not just the fetch is expensive, but the JS to dedup and turn the
  // high-N segments into a smaller number of consecutive recording blocks).
  protected _recordingRanges = new MemoryRangeSet();

  // Cache event ranges since re-adding the same events is a timeline
  // performance killer (even if the request results are cached).
  protected _eventRanges = new ExpiringMemoryRangeSet();

  protected _cameraIDs: Set<string>;
  protected _eventsMediaType: ClipsOrSnapshotsOrAll;
  protected _showRecordings: boolean;

  constructor(
    cameraManager: CameraManager,
    cameraIDs: Set<string>,
    eventsMediaType: ClipsOrSnapshotsOrAll,
    showRecordings: boolean,
  ) {
    this._cameraManager = cameraManager;
    this._cameraIDs = cameraIDs;
    this._eventsMediaType = eventsMediaType;
    this._showRecordings = showRecordings;
  }

  get dataset(): DataSet<AdvancedCameraCardTimelineItem> {
    return this._dataset;
  }

  public rewriteEvent(id: IdType): void {
    // Hack: For timeline uses of the event dataset clustering may not update
    // unless the dataset changes, artifically update the dataset to ensure the
    // newly selected item cannot be included in a cluster.

    // Hack2: Cannot use `updateOnly` here, as vis-data loses the object
    // prototype, see: https://github.com/visjs/vis-data/issues/997 . Instead,
    // remove then add.
    const item = this._dataset.get(id);
    if (item) {
      this._dataset.remove(id);
      this._dataset.add(item);
    }
  }

  public async refresh(window: TimelineWindow): Promise<void> {
    try {
      await Promise.all([
        this._refreshEvents(window),
        ...(this._showRecordings ? [this._refreshRecordings(window)] : []),
      ]);
    } catch (e) {
      errorToConsole(e as Error);

      // Intentionally ignore errors here, since it is likely the user will
      // change the range again and a subsequent call may work. To do otherwise
      // would be jarring to the timeline experience in the case of transient
      // errors from the backend.
    }
  }

  public getTimelineEventQueries(window: TimelineWindow): EventQuery[] | null {
    return this._cameraManager.generateDefaultEventQueries(this._cameraIDs, {
      start: window.start,
      end: window.end,
      ...(this._eventsMediaType === 'clips' && { hasClip: true }),
      ...(this._eventsMediaType === 'snapshots' && { hasSnapshot: true }),
    });
  }

  public getTimelineRecordingQueries(window: TimelineWindow): RecordingQuery[] | null {
    return this._cameraManager.generateDefaultRecordingQueries(this._cameraIDs, {
      start: window.start,
      end: window.end,
    });
  }

  protected async _refreshEvents(window: TimelineWindow): Promise<void> {
    if (
      this._eventRanges.hasCoverage({
        start: window.start,
        end: sub(capEndDate(window.end), {
          seconds: TIMELINE_FRESHNESS_TOLERANCE_SECONDS,
        }),
      })
    ) {
      return;
    }
    const cacheFriendlyWindow = convertRangeToCacheFriendlyTimes(window);
    const eventQueries = this.getTimelineEventQueries(cacheFriendlyWindow);
    if (!eventQueries) {
      return;
    }

    const mediaArray = await this._cameraManager.executeMediaQueries(eventQueries);
    const data: AdvancedCameraCardTimelineItem[] = [];
    for (const media of mediaArray ?? []) {
      const startTime = media.getStartTime();
      const id = media.getID();
      const cameraID = media.getCameraID();
      if (id && startTime && cameraID) {
        data.push({
          id: id,
          group: cameraID,
          content: '',
          media: media,
          start: startTime.getTime(),
          type: 'range',
          end: media.getUsableEndTime()?.getTime() ?? startTime.getTime(),
        });
      }
    }
    this._dataset.update(data);

    this._eventRanges.add({
      ...cacheFriendlyWindow,
      expires: add(new Date(), { seconds: TIMELINE_FRESHNESS_TOLERANCE_SECONDS }),
    });
  }

  protected async _refreshRecordings(window: TimelineWindow): Promise<void> {
    type AdvancedCameraCardTimelineItemWithEnd = ModifyInterface<
      AdvancedCameraCardTimelineItem,
      { end: number }
    >;

    const convertSegmentToRecording = (
      cameraID: string,
      segment: RecordingSegment,
    ): AdvancedCameraCardTimelineItemWithEnd => {
      return {
        id: `recording-${cameraID}-${segment.id}`,
        group: cameraID,
        start: segment.start_time * 1000,
        end: segment.end_time * 1000,
        content: '',
        type: 'background',
      };
    };

    const getExistingRecordingsForCameraID = (
      cameraID: string,
    ): AdvancedCameraCardTimelineItemWithEnd[] => {
      return this._dataset.get({
        filter: (item) =>
          item.type == 'background' && item.group === cameraID && item.end !== undefined,
      }) as AdvancedCameraCardTimelineItemWithEnd[];
    };

    const deleteRecordingsForCameraID = (cameraID: string): void => {
      this._dataset.remove(
        this._dataset.get({
          filter: (item) => item.type === 'background' && item.group === cameraID,
        }),
      );
    };

    const addRecordings = (
      recordings: AdvancedCameraCardTimelineItemWithEnd[],
    ): void => {
      this._dataset.add(recordings);
    };

    // Calculate an end date that's slightly short of the current time to allow
    // for caching up to the freshness tolerance.
    if (
      this._recordingRanges.hasCoverage({
        start: window.start,
        end: sub(capEndDate(window.end), {
          seconds: TIMELINE_FRESHNESS_TOLERANCE_SECONDS,
        }),
      })
    ) {
      return;
    }

    const cacheFriendlyWindow = convertRangeToCacheFriendlyTimes(window);
    const recordingQueries = this._cameraManager.generateDefaultRecordingSegmentsQueries(
      this._cameraIDs,
      {
        start: cacheFriendlyWindow.start,
        end: cacheFriendlyWindow.end,
      },
    );

    if (!recordingQueries) {
      return;
    }
    const results = await this._cameraManager.getRecordingSegments(recordingQueries);

    const newSegments: Map<string, RecordingSegment[]> = new Map();
    for (const [query, result] of results) {
      for (const cameraID of query.cameraIDs) {
        let destination: RecordingSegment[] | undefined = newSegments.get(cameraID);
        if (!destination) {
          destination = [];
          newSegments.set(cameraID, destination);
        }
        result.segments.forEach((segment) => destination?.push(segment));
      }
    }

    for (const [cameraID, segments] of newSegments.entries()) {
      const existingRecordings = getExistingRecordingsForCameraID(cameraID);
      const mergedRecordings = existingRecordings.concat(
        segments.map((segment) => convertSegmentToRecording(cameraID, segment)),
      );
      const compressedRecordings = compressRanges(
        mergedRecordings,
        TIMELINE_RECORDING_SEGMENT_CONSECUTIVE_TOLERANCE_SECONDS,
      ) as AdvancedCameraCardTimelineItemWithEnd[];

      deleteRecordingsForCameraID(cameraID);
      addRecordings(compressedRecordings);
    }

    this._recordingRanges.add({
      start: cacheFriendlyWindow.start,
      end: cacheFriendlyWindow.end,
    });
  }
}



================================================
FILE: src/components-lib/folder/up-folder.ts
================================================
import { ViewManagerEpoch } from '../../card-controller/view/types';
import { stopEventFromActivatingCardWideActions } from '../../utils/action';
import { ViewFolder, ViewItem } from '../../view/item';
import { QueryClassifier } from '../../view/query-classifier';
import { View } from '../../view/view';

export const upFolderClickHandler = (
  _item: ViewItem,
  ev: Event,
  viewManagerEpoch?: ViewManagerEpoch,
): void => {
  stopEventFromActivatingCardWideActions(ev);

  const query = viewManagerEpoch?.manager.getView()?.query;
  if (!query || !QueryClassifier.isFolderQuery(query)) {
    return;
  }
  const rawQuery = query?.getQuery();
  if (!rawQuery?.path || rawQuery?.path.length <= 1) {
    return;
  }

  const path = rawQuery.path.slice(0, -1);

  viewManagerEpoch?.manager.setViewByParametersWithExistingQuery({
    params: {
      query: query.clone().setQuery({
        folder: rawQuery.folder,
        path: [path[0], ...path.slice(1)],
      }),
    },
  });
};

export const getUpFolderMediaItem = (view?: View | null): ViewFolder | null => {
  const query = view?.query;
  if (!query || !QueryClassifier.isFolderQuery(query)) {
    return null;
  }

  const rawQuery = query.getQuery();
  if (!rawQuery?.folder || !rawQuery?.path || rawQuery.path.length <= 1) {
    return null;
  }

  return new ViewFolder(rawQuery.folder, {
    icon: 'mdi:arrow-up-left',
  });
};



================================================
FILE: src/components-lib/gallery/folder-gallery-controller.ts
================================================
import { ViewManagerInterface } from '../../card-controller/view/types';
import { THUMBNAIL_WIDTH_DEFAULT } from '../../config/schema/common/controls/thumbnails';
import { MediaGalleryThumbnailsConfig } from '../../config/schema/media-gallery';
import { stopEventFromActivatingCardWideActions } from '../../utils/action';
import { ViewItem } from '../../view/item';
import { ViewItemClassifier } from '../../view/item-classifier';
import { QueryClassifier } from '../../view/query-classifier';
import { GalleryColumnCountRoundMethod } from './gallery-core-controller';

// The minimum width of a (folder) thumbnail with details enabled. This is
// shorter than for regular camera media as this will consist of just a name.
export const FOLDER_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN = 200;

export class FolderGalleryController {
  private _host: HTMLElement;

  public constructor(host: HTMLElement) {
    this._host = host;
  }

  public setThumbnailSize(size?: number): void {
    this._host.style.setProperty(
      '--advanced-camera-card-thumbnail-size',
      `${size ?? THUMBNAIL_WIDTH_DEFAULT}px`,
    );
  }

  public getColumnWidth(thumbnailConfig?: MediaGalleryThumbnailsConfig): number {
    return !thumbnailConfig
      ? THUMBNAIL_WIDTH_DEFAULT
      : thumbnailConfig.show_details
        ? FOLDER_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN
        : thumbnailConfig.size;
  }

  public getColumnCountRoundMethod(
    thumbnailConfig?: MediaGalleryThumbnailsConfig,
  ): GalleryColumnCountRoundMethod {
    return thumbnailConfig?.show_details ? 'floor' : 'ceil';
  }

  public itemClickHandler(
    viewManager: ViewManagerInterface,
    item: ViewItem,
    ev: Event,
  ): void {
    stopEventFromActivatingCardWideActions(ev);

    const view = viewManager.getView();
    if (!view) {
      return;
    }
    if (ViewItemClassifier.isMedia(item)) {
      viewManager.setViewByParameters({
        params: {
          view: 'media',
          queryResults: view.queryResults
            ?.clone()
            .selectResultIfFound((result) => result === item),
        },
      });
    } else if (
      ViewItemClassifier.isFolder(item) &&
      QueryClassifier.isFolderQuery(view.query)
    ) {
      const rawQuery = view.query.getQuery();
      const id = item.getID();
      if (!rawQuery || !id) {
        return;
      }
      viewManager.setViewByParametersWithExistingQuery({
        params: {
          query: view.query.clone().setQuery({
            folder: rawQuery.folder,
            path: [...rawQuery.path, { folder: item }],
          }),
        },
      });
    }
  }
}



================================================
FILE: src/components-lib/gallery/gallery-core-controller.ts
================================================
import { LitElement, ReactiveController } from 'lit';
import { throttle } from 'lodash-es';
import { GalleryExtendEvent } from '../../components/gallery/types';
import { fireAdvancedCameraCardEvent } from '../../utils/fire-advanced-camera-card-event';
import { scrollIntoView } from '../../utils/scroll';
import { sleep } from '../../utils/sleep';

const GALLERY_MIN_EXTENSION_SECONDS = 0.5;

export type GalleryColumnCountRoundMethod = 'ceil' | 'floor';

interface GalleryCoreOptions {
  columnWidth?: number;
  columnCountRoundMethod?: GalleryColumnCountRoundMethod;
  extendUp?: boolean;
  extendDown?: boolean;
}

export class GalleryCoreController implements ReactiveController {
  private _host: LitElement;
  private _intersectionObserver: IntersectionObserver;
  private _resizeObserver: ResizeObserver;

  private _options: GalleryCoreOptions | null = null;
  private _touchScrollYPosition: number | null = null;

  // Wheel / touch events may be voluminous, throttle extension calls.
  private _throttledExtendUp = throttle(
    this._extendUp.bind(this),
    GALLERY_MIN_EXTENSION_SECONDS * 1000,
    {
      leading: true,
      trailing: false,
    },
  );

  private _getSlot: () => HTMLSlotElement | null;
  private _getSentintelBottom: () => HTMLElement | null;
  private _showLoaderTop: (show: boolean) => void;
  private _showSentinelBottom: (show: boolean) => void;

  private _wasEverNonEmpty = false;

  constructor(
    host: LitElement,
    getSlot: () => HTMLSlotElement | null,
    getSentinelBottom: () => HTMLElement | null,
    showLoaderTopCallback: (show: boolean) => void,
    showSentinelBottomCallback: (show: boolean) => void,
  ) {
    this._host = host;
    this._host.addController(this);

    this._getSlot = getSlot;
    this._getSentintelBottom = getSentinelBottom;
    this._showLoaderTop = showLoaderTopCallback;
    this._showSentinelBottom = showSentinelBottomCallback;

    this._resizeObserver = new ResizeObserver(() => this._setColumnCount());
    this._intersectionObserver = new IntersectionObserver(
      async (entries: IntersectionObserverEntry[]): Promise<void> => {
        if (entries.some((entry) => entry.isIntersecting)) {
          await this._extendDown();
        }
      },
    );
  }

  public removeController(): void {
    this._host.removeController(this);
  }

  public setOptions(options: GalleryCoreOptions): void {
    this._options = options;
    this._setColumnCount();
  }

  public hostConnected(): void {
    this._resizeObserver.observe(this._host);

    // Since the scroll event does not fire if the user is already at the top of
    // the container, instead we manually use the wheel and touchstart/end
    // events to detect "top upwards scrolling" (to trigger an extension of the
    // gallery).
    this._host.addEventListener('wheel', this._wheelHandler, { passive: true });
    this._host.addEventListener('touchstart', this._touchStartHandler, {
      passive: true,
    });
    this._host.addEventListener('touchend', this._touchEndHandler);

    // Request update in order to ensure the intersection observer reconnects
    // with the loader sentinel.
    this._host.requestUpdate();
  }

  public hostDisconnected(): void {
    this._host.removeEventListener('wheel', this._wheelHandler);
    this._host.removeEventListener('touchstart', this._touchStartHandler);
    this._host.removeEventListener('touchend', this._touchEndHandler);
    this._resizeObserver.disconnect();
    this._intersectionObserver.disconnect();
  }

  public hostUpdated(): void {
    const sentinel = this._getSentintelBottom();
    this._intersectionObserver.disconnect();

    if (sentinel) {
      this._intersectionObserver.observe(sentinel);
    }
  }

  private _setColumnCount(): void {
    if (!this._options?.columnWidth) {
      return;
    }
    const roundFunc =
      this._options.columnCountRoundMethod === 'ceil' ? Math.ceil : Math.floor;

    const columns = Math.max(
      1,
      roundFunc(this._host.clientWidth / this._options.columnWidth),
    );
    this._host.style.setProperty(
      '--advanced-camera-card-gallery-columns',
      String(columns),
    );
  }

  private _touchStartHandler = (ev: TouchEvent): void => {
    // Remember the Y touch position on touch start, so that we can calculate if
    // the user gestured upwards or downards on touchend.
    if (ev.touches.length === 1) {
      this._touchScrollYPosition = ev.touches[0].screenY;
    } else {
      this._touchScrollYPosition = null;
    }
  };

  private _touchEndHandler = async (ev: TouchEvent): Promise<void> => {
    if (
      !this._host.scrollTop &&
      ev.changedTouches.length === 1 &&
      this._touchScrollYPosition !== null
    ) {
      if (ev.changedTouches[0].screenY > this._touchScrollYPosition) {
        await this._throttledExtendUp();
      }
    }
    this._touchScrollYPosition = null;
  };

  private _wheelHandler = async (ev: WheelEvent): Promise<void> => {
    if (!this._host.scrollTop && ev.deltaY < 0) {
      await this._throttledExtendUp();
    }
  };

  private async _extendUp(): Promise<void> {
    if (!this._options?.extendUp) {
      return;
    }

    this._showLoaderTop(true);

    const start = new Date();
    await this._waitForExtend('up');
    const delta = new Date().getTime() - start.getTime();

    if (delta < GALLERY_MIN_EXTENSION_SECONDS * 1000) {
      // Hidden gem: "legitimate" (?!) use of sleep() :-) These calls can return
      // very quickly even with caching disabled since the time window
      // constraints on the query will usually be very narrow and the backend
      // can thus very quickly reply. It's often so fast it actually looks like
      // a rendering issue where the progress indictor barely registers before
      // it's gone again. This optional pause ensures there is at least some
      // visual feedback to the user that lasts long enough they can 'feel' the
      // fetch has happened.
      //
      // This is only applied on the 'up' extend since the 'down' extend may be
      // called multiple times for large card sizes (e.g. fullscreen) where a
      // delay is not desirable.
      await sleep(GALLERY_MIN_EXTENSION_SECONDS - delta / 1000);
    }
    this._showLoaderTop(false);
  }

  private async _extendDown(): Promise<void> {
    if (!this._options?.extendDown) {
      return;
    }

    this._showSentinelBottom(false);

    await this._waitForExtend('down');

    // Sentinel will be re-shown next time the contents changes, see:
    // updateContents() .
  }

  private async _waitForExtend(direction: 'up' | 'down'): Promise<void> {
    await new Promise<void>((resolve) => {
      fireAdvancedCameraCardEvent<GalleryExtendEvent>(
        this._host,
        `gallery:extend:${direction}`,
        { resolve },
        {
          bubbles: false,
          composed: false,
        },
      );
    });
  }

  public updateContents(): void {
    const slot = this._getSlot();

    if (!slot) {
      return;
    }

    const contents = slot
      .assignedElements()
      .filter((element) => element instanceof HTMLElement);

    const firstSelected = contents.find(
      (element) => element.getAttribute('selected') !== null,
    );
    if (contents.length) {
      if (!this._wasEverNonEmpty && firstSelected) {
        // As a special case, if this is the first setting of the slot contents,
        // the gallery is scrolled to the selected element (if any). This is
        // only done on the first setting, as subsequent gallery extensions
        // should not cause the gallery to rescroll to the item that happens to
        // be selected.
        // See: https://github.com/dermotduffy/advanced-camera-card/issues/885
        scrollIntoView(firstSelected, {
          boundary: this._host,
          block: 'center',
        });
      }

      this._wasEverNonEmpty = true;
    }

    // Always render the bottom sentinel when the contents changes, in order to allow
    // the gallery to be extended downwards.
    this._showSentinelBottom(true);
  }
}



================================================
FILE: src/components-lib/gallery/media-gallery-controller.ts
================================================
import { CameraManager, ExtendedMediaQueryResult } from '../../camera-manager/manager';
import { EventQuery, MediaQuery, RecordingQuery } from '../../camera-manager/types';
import {
  ViewManagerEpoch,
  ViewManagerInterface,
} from '../../card-controller/view/types';
import { THUMBNAIL_WIDTH_DEFAULT } from '../../config/schema/common/controls/thumbnails';
import { MediaGalleryThumbnailsConfig } from '../../config/schema/media-gallery';
import { stopEventFromActivatingCardWideActions } from '../../utils/action';
import { errorToConsole } from '../../utils/basic';
import { ViewItem } from '../../view/item';
import { EventMediaQuery, RecordingMediaQuery } from '../../view/query';
import { QueryClassifier } from '../../view/query-classifier';
import { QueryResults } from '../../view/query-results';
import { View } from '../../view/view';
import { GalleryColumnCountRoundMethod } from './gallery-core-controller';

// The minimum width of a thumbnail with details enabled.
export const MEDIA_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN = 300;

export class MediaGalleryController {
  private _host: HTMLElement;
  private _media: ViewItem[] | null = null;

  public constructor(host: HTMLElement) {
    this._host = host;
  }

  public getMedia(): ViewItem[] | null {
    return this._media;
  }

  public setMediaFromView(newView?: View | null, oldView?: View | null): void {
    const newResults = newView?.queryResults?.getResults() ?? null;
    if (newResults === null) {
      this._media = null;
      return;
    }

    if (!this._media || oldView?.queryResults?.getResults() !== newResults) {
      // Media gallery places the most recent media at the top (the query
      // results place the most recent media at the end for use in the viewer).
      // This is copied to a new array to avoid reversing the query results in
      // place.
      this._media = [...newResults].reverse();
    }
  }

  public setThumbnailSize(size?: number): void {
    this._host.style.setProperty(
      '--advanced-camera-card-thumbnail-size',
      `${size ?? THUMBNAIL_WIDTH_DEFAULT}px`,
    );
  }

  public getColumnWidth(thumbnailConfig?: MediaGalleryThumbnailsConfig): number {
    return !thumbnailConfig
      ? THUMBNAIL_WIDTH_DEFAULT
      : thumbnailConfig.show_details
        ? MEDIA_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN
        : thumbnailConfig.size;
  }

  public getColumnCountRoundMethod(
    thumbnailConfig?: MediaGalleryThumbnailsConfig,
  ): GalleryColumnCountRoundMethod {
    return thumbnailConfig?.show_details ? 'floor' : 'ceil';
  }

  public async extendMediaGallery(
    cameraManager: CameraManager,
    viewManagerEpoch: ViewManagerEpoch,
    direction: 'earlier' | 'later',
    useCache = true,
  ): Promise<void> {
    const view = viewManagerEpoch.manager.getView();
    if (!view) {
      return;
    }

    const query = view.query;
    const existingMedia = view.queryResults?.getResults();
    if (!existingMedia || !query || !QueryClassifier.isMediaQuery(query)) {
      return;
    }

    const rawQueries = query.getQuery() ?? null;
    if (!rawQueries) {
      return;
    }

    let extension: ExtendedMediaQueryResult<MediaQuery> | null;
    try {
      extension = await cameraManager.extendMediaQueries<MediaQuery>(
        rawQueries,
        existingMedia,
        direction,
        {
          useCache: useCache,
        },
      );
    } catch (e) {
      errorToConsole(e as Error);
      return;
    }

    if (extension) {
      const newMediaQueries = QueryClassifier.isEventQuery(query)
        ? new EventMediaQuery(extension.queries as EventQuery[])
        : QueryClassifier.isRecordingQuery(query)
          ? new RecordingMediaQuery(extension.queries as RecordingQuery[])
          : /* istanbul ignore next: this path cannot be reached -- @preserve */
            null;

      /* istanbul ignore else: this path cannot be reached, as we explicitly
         check for media queries above -- @preserve */
      if (newMediaQueries) {
        viewManagerEpoch.manager.setViewByParameters({
          baseView: view,
          params: {
            query: newMediaQueries,
            queryResults: new QueryResults({
              results: extension.results,
            }).selectResultIfFound(
              (media) => media === view.queryResults?.getSelectedResult(),
            ),
          },
        });
      }
    }
  }

  public itemClickHandler(
    viewManager: ViewManagerInterface,
    reversedIndex: number,
    ev: Event,
  ): void {
    stopEventFromActivatingCardWideActions(ev);

    const view = viewManager.getView();
    if (!view || !this._media?.length) {
      return;
    }

    viewManager.setViewByParameters({
      params: {
        view: 'media',
        queryResults: view.queryResults?.clone().selectIndex(
          // Media in the gallery is reversed vs the queryResults (see
          // note above).
          this._media.length - reversedIndex - 1,
        ),
      },
    });
  }
}



================================================
FILE: src/components-lib/live/live-controller.ts
================================================
import { LitElement, ReactiveController } from 'lit';
import { MediaLoadedInfo } from '../../types.js';
import {
  AdvancedCameraCardMediaLoadedEventTarget,
  dispatchExistingMediaLoadedInfoAsEvent,
} from '../../utils/media-info.js';
import { AdvancedCameraCardMessageEventTarget } from '../message/dispatch.js';

interface LiveViewContext {
  // A cameraID override (used for dependencies/substreams to force a different
  // camera to be live rather than the camera selected in the view).
  overrides?: Map<string, string>;
}

declare module 'view' {
  interface ViewContext {
    live?: LiveViewContext;
  }
}

interface LastMediaLoadedInfo {
  mediaLoadedInfo: MediaLoadedInfo;
  source: EventTarget;
}

type LiveControllerHost = LitElement &
  AdvancedCameraCardMediaLoadedEventTarget &
  AdvancedCameraCardMessageEventTarget;

export class LiveController implements ReactiveController {
  protected _host: LiveControllerHost;

  // Whether or not the live view is currently in the background (i.e. preloaded
  // but not visible).
  protected _inBackground = false;

  // Intersection handler is used to detect when the live view flips between
  // foreground and background (in preload mode).
  protected _intersectionObserver: IntersectionObserver;

  // MediaLoadedInfo object and target from the underlying live media. In the
  // case of pre-loading these may be propagated later (from the original
  // source).
  protected _lastMediaLoadedInfo: LastMediaLoadedInfo | null = null;

  constructor(host: LiveControllerHost) {
    this._host = host;

    host.addController(this);

    this._intersectionObserver = new IntersectionObserver(
      this._intersectionHandler.bind(this),
    );
  }

  public hostConnected(): void {
    this._intersectionObserver.observe(this._host);

    this._host.addEventListener(
      'advanced-camera-card:media:loaded',
      this._handleMediaLoaded,
    );
  }

  public hostDisconnected(): void {
    this._intersectionObserver.disconnect();

    this._host.removeEventListener(
      'advanced-camera-card:media:loaded',
      this._handleMediaLoaded,
    );
  }

  public isInBackground(): boolean {
    return this._inBackground;
  }

  protected _handleMediaLoaded = (ev: CustomEvent<MediaLoadedInfo>): void => {
    this._lastMediaLoadedInfo = {
      source: ev.composedPath()[0],
      mediaLoadedInfo: ev.detail,
    };

    if (this._inBackground) {
      ev.stopPropagation();
    }
  };

  protected _intersectionHandler(entries: IntersectionObserverEntry[]): void {
    const wasInBackground = this._inBackground;
    this._inBackground = !entries.some((entry) => entry.isIntersecting);

    if (!this._inBackground && this._lastMediaLoadedInfo) {
      // If this isn't being rendered in the background, the last render did not
      // generate a message and there's a saved MediaInfo, dispatch it upwards.
      dispatchExistingMediaLoadedInfoAsEvent(
        // Specifically dispatch the event "where it came from", as otherwise
        // the intermediate layers (e.g. media-carousel which controls the title
        // popups) will not re-receive the events.
        this._lastMediaLoadedInfo.source,
        this._lastMediaLoadedInfo.mediaLoadedInfo,
      );
    }

    if (wasInBackground !== this._inBackground) {
      this._host.requestUpdate();
    }
  }
}



================================================
FILE: src/components-lib/live/utils/dispatch-live-error.ts
================================================
import { fireAdvancedCameraCardEvent } from '../../../utils/fire-advanced-camera-card-event';

export function dispatchLiveErrorEvent(element: EventTarget): void {
  fireAdvancedCameraCardEvent(element, 'live:error');
}



================================================
FILE: src/components-lib/live/utils/get-technology-for-video-rtc.ts
================================================
import { VideoRTC } from '../../../components/live/providers/go2rtc/video-rtc';
import { MediaTechnology } from '../../../types';

export const getTechnologyForVideoRTC = (
  element: VideoRTC,
): MediaTechnology[] | undefined => {
  const tech = [
    ...(!!element.pc ? ['webrtc' as const] : []),
    ...(!element.pc && element.mseCodecs ? ['mse' as const, 'hls' as const] : []),
  ];
  return tech.length ? tech : undefined;
};



================================================
FILE: src/components-lib/media-player/image.ts
================================================
import { LitElement } from 'lit';
import { FullscreenElement, MediaPlayerController } from '../../types';
import { screenshotImage } from '../../utils/screenshot';

export class ImageMediaPlayerController implements MediaPlayerController {
  private _host: LitElement;
  private _getImageCallback: () => HTMLImageElement | null;

  constructor(host: LitElement, getImageCallback: () => HTMLImageElement | null) {
    this._host = host;
    this._getImageCallback = getImageCallback;
  }

  public async play(): Promise<void> {
    // Not implemented.
  }

  public async pause(): Promise<void> {
    // Not implemented.
  }

  public async mute(): Promise<void> {
    // Not implemented.
  }

  public async unmute(): Promise<void> {
    // Not implemented.
  }

  public isMuted(): boolean {
    return true;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async seek(_seconds: number): Promise<void> {
    // Not implemented.
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async setControls(_controls: boolean): Promise<void> {
    // Not implemented.
  }

  public isPaused(): boolean {
    // The image could be an MJPEG, so it is always reported unpaused.
    return false;
  }

  public async getScreenshotURL(): Promise<string | null> {
    await this._host.updateComplete;

    const image = this._getImageCallback();

    // It might an MJPEG so still need to screenshot it.
    return image ? screenshotImage(image) : null;
  }

  public getFullscreenElement(): FullscreenElement | null {
    return this._getImageCallback() ?? null;
  }
}



================================================
FILE: src/components-lib/media-player/jsmpeg.ts
================================================
import JSMpeg from '@cycjimmy/jsmpeg-player';
import { LitElement } from 'lit';
import { FullscreenElement, MediaPlayerController } from '../../types';

export class JSMPEGMediaPlayerController implements MediaPlayerController {
  private _host: LitElement;
  private _getJSMPEGVideoElementCallback: () => JSMpeg.VideoElement | null;
  private _getCanvasElementCallback: () => HTMLCanvasElement | null;

  constructor(
    host: LitElement,
    _getJSMPEGVideoElementCallback: () => JSMpeg.VideoElement | null,
    _getCanvasElementCallback: () => HTMLCanvasElement | null,
  ) {
    this._host = host;
    this._getJSMPEGVideoElementCallback = _getJSMPEGVideoElementCallback;
    this._getCanvasElementCallback = _getCanvasElementCallback;
  }

  public async play(): Promise<void> {
    await this._host.updateComplete;
    return this._getJSMPEGVideoElementCallback()?.play();
  }

  public async pause(): Promise<void> {
    await this._host.updateComplete;
    return this._getJSMPEGVideoElementCallback()?.stop();
  }

  public async mute(): Promise<void> {
    await this._host.updateComplete;
    const player = this._getJSMPEGVideoElementCallback()?.player;
    if (player) {
      player.volume = 0;
    }
  }

  public async unmute(): Promise<void> {
    await this._host.updateComplete;
    const player = this._getJSMPEGVideoElementCallback()?.player;
    if (player) {
      player.volume = 1;
    }
  }

  public isMuted(): boolean {
    const player = this._getJSMPEGVideoElementCallback()?.player;
    return player ? player.volume === 0 : true;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async seek(_seconds: number): Promise<void> {
    // JSMPEG does not support seeking.
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async setControls(_controls: boolean): Promise<void> {
    // Not implemented.
  }

  public isPaused(): boolean {
    return this._getJSMPEGVideoElementCallback()?.player?.paused ?? true;
  }

  public async getScreenshotURL(): Promise<string | null> {
    await this._host.updateComplete;
    return this._getCanvasElementCallback()?.toDataURL('image/jpeg') ?? null;
  }

  public getFullscreenElement(): FullscreenElement | null {
    return this._getCanvasElementCallback() ?? null;
  }
}



================================================
FILE: src/components-lib/media-player/updating-image.ts
================================================
import { LitElement } from 'lit';
import { FullscreenElement, MediaPlayerController } from '../../types';
import { CachedValueController } from '../cached-value-controller';

export class UpdatingImageMediaPlayerController implements MediaPlayerController {
  private _host: LitElement;
  private _getImageCallback: () => HTMLImageElement | null;
  private _getCachedValueController: () => CachedValueController<string> | null;

  constructor(
    host: LitElement,
    getImageCallback: () => HTMLImageElement | null,
    getCachedValueController: () => CachedValueController<string> | null,
  ) {
    this._host = host;
    this._getImageCallback = getImageCallback;
    this._getCachedValueController = getCachedValueController;
  }

  public async play(): Promise<void> {
    await this._host.updateComplete;
    this._getCachedValueController()?.startTimer();
  }

  public async pause(): Promise<void> {
    await this._host.updateComplete;
    this._getCachedValueController()?.stopTimer();
  }

  public async mute(): Promise<void> {
    // Not implemented.
  }

  public async unmute(): Promise<void> {
    // Not implemented.
  }

  public isMuted(): boolean {
    return true;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async seek(_seconds: number): Promise<void> {
    // Not implemented.
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async setControls(_controls: boolean): Promise<void> {
    // Not implemented.
  }

  public isPaused(): boolean {
    return !this._getCachedValueController()?.hasTimer();
  }

  public async getScreenshotURL(): Promise<string | null> {
    await this._host.updateComplete;
    return this._getCachedValueController()?.value ?? null;
  }

  public getFullscreenElement(): FullscreenElement | null {
    return this._getImageCallback() ?? null;
  }
}



================================================
FILE: src/components-lib/media-player/video.ts
================================================
import { LitElement } from 'lit';
import { FullscreenElement, MediaPlayerController } from '../../types';
import { hideMediaControlsTemporarily, setControlsOnVideo } from '../../utils/controls';
import { screenshotVideo } from '../../utils/screenshot';

export class VideoMediaPlayerController implements MediaPlayerController {
  private _host: LitElement;
  private _getVideoCallback: () => HTMLVideoElement | null;
  private _getControlsDefaultCallback: (() => boolean) | null;

  constructor(
    host: LitElement,
    getVideoCallback: () => HTMLVideoElement | null,
    getControlsDefaultCallback?: () => boolean,
  ) {
    this._host = host;
    this._getVideoCallback = getVideoCallback;
    this._getControlsDefaultCallback = getControlsDefaultCallback ?? null;
  }

  public async play(): Promise<void> {
    await this._host.updateComplete;

    const video = this._getVideoCallback();
    if (!video?.play) {
      return;
    }

    // If the play call fails, and the media is not already muted, mute it first
    // and then try again. This works around some browsers that prevent
    // auto-play unless the video is muted.
    try {
      await video.play();
    } catch (err: unknown) {
      if ((err as Error).name === 'NotAllowedError' && !this.isMuted()) {
        await this.mute();
        try {
          await video.play();
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (e) {
          // Pass.
        }
      }
    }
  }

  public async pause(): Promise<void> {
    await this._host.updateComplete;
    this._getVideoCallback()?.pause();
  }

  public async mute(): Promise<void> {
    await this._host.updateComplete;

    // The muted property is only for the initial muted state. Must explicitly
    // set the muted on the video player to make the change dynamic.
    const video = this._getVideoCallback();
    if (video) {
      video.muted = true;
    }
  }

  public async unmute(): Promise<void> {
    await this._host.updateComplete;

    const video = this._getVideoCallback();
    if (video) {
      video.muted = false;
    }
  }

  public isMuted(): boolean {
    return this._getVideoCallback()?.muted ?? true;
  }

  public async seek(seconds: number): Promise<void> {
    await this._host.updateComplete;

    const video = this._getVideoCallback();
    if (video) {
      hideMediaControlsTemporarily(video);
      video.currentTime = seconds;
    }
  }

  public async setControls(controls?: boolean): Promise<void> {
    await this._host.updateComplete;

    const video = this._getVideoCallback();
    const value = controls ?? this._getControlsDefaultCallback?.();
    if (video && value !== undefined) {
      setControlsOnVideo(video, value);
    }
  }

  public isPaused(): boolean {
    return this._getVideoCallback()?.paused ?? true;
  }

  public async getScreenshotURL(): Promise<string | null> {
    await this._host.updateComplete;

    const video = this._getVideoCallback();
    return video ? screenshotVideo(video) : null;
  }

  public getFullscreenElement(): FullscreenElement | null {
    return this._getVideoCallback() ?? null;
  }
}



================================================
FILE: src/components-lib/message/controller.ts
================================================
import yaml from 'js-yaml';
import { TROUBLESHOOTING_URL } from '../../const';
import { localize } from '../../localize/localize.js';
import { Message, MessageURL } from '../../types';

export class MessageController {
  public getMessageString(message: Message): string {
    return (
      message.message +
      (message.context && typeof message.context === 'string'
        ? ': ' + message.context
        : '')
    );
  }

  public getIcon(message: Message): string {
    return message.icon
      ? message.icon
      : message.type === 'error'
        ? 'mdi:alert-circle'
        : 'mdi:information-outline';
  }

  public getURL(message: Message): MessageURL | null {
    return message.url
      ? message.url
      : message.type === 'error'
        ? { link: TROUBLESHOOTING_URL, title: localize('error.troubleshooting') }
        : null;
  }

  public getContextStrings(message: Message): string[] {
    if (Array.isArray(message.context)) {
      return message.context.map((contextItem) => yaml.dump(contextItem));
    }
    if (typeof message.context === 'object') {
      return [yaml.dump(message.context)];
    }
    if (typeof message.context === 'string') {
      return [message.context];
    }
    return [];
  }
}



================================================
FILE: src/components-lib/message/dispatch.ts
================================================
import { AdvancedCameraCardError, Message } from '../../types';
import { fireAdvancedCameraCardEvent } from '../../utils/fire-advanced-camera-card-event';

// Facilitates correct typing of event handlers.
export interface AdvancedCameraCardMessageEventTarget extends EventTarget {
  addEventListener(
    event: 'advanced-camera-card:message',
    listener: (
      this: AdvancedCameraCardMessageEventTarget,
      ev: CustomEvent<Message>,
    ) => void,
    options?: AddEventListenerOptions | boolean,
  ): void;
  addEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: AddEventListenerOptions | boolean,
  ): void;
  removeEventListener(
    event: 'advanced-camera-card:message',
    listener: (
      this: AdvancedCameraCardMessageEventTarget,
      ev: CustomEvent<Message>,
    ) => void,
    options?: boolean | EventListenerOptions,
  ): void;
  removeEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions,
  ): void;
}

/**
 * Dispatch an event with an error message to show to the user. Calling this
 * method will grind the card to a halt, so should only be used for "global" /
 * critical errors (i.e. not for individual errors with a given camera, since
 * there may be multiple correctly functioning cameras in a grid).
 * @param element The element to send the event.
 * @param message The message to show.
 */
export const dispatchAdvancedCameraCardErrorEvent = (
  element: EventTarget,
  error: unknown,
): void => {
  if (error instanceof Error) {
    fireAdvancedCameraCardEvent<Message>(element, 'message', {
      message: error.message,
      type: 'error',
      ...(error instanceof AdvancedCameraCardError && { context: error.context }),
    });
  }
};



================================================
FILE: src/components-lib/ptz/ptz-controller.ts
================================================
import { CameraManager } from '../../camera-manager/manager.js';
import { dispatchActionExecutionRequest } from '../../card-controller/actions/utils/execution-request.js';
import { SubmenuInteraction } from '../../components/submenu/types.js';
import { PTZAction } from '../../config/schema/actions/custom/ptz.js';
import { Actions, ActionsConfig } from '../../config/schema/actions/types.js';
import { PTZControlsConfig } from '../../config/schema/common/controls/ptz.js';
import { HomeAssistant } from '../../ha/types.js';
import { Interaction } from '../../types.js';
import { createPTZMultiAction, getActionConfigGivenAction } from '../../utils/action.js';
import { PTZControllerActions } from './types';

export class PTZController {
  private _host: HTMLElement;

  private _config: PTZControlsConfig | null = null;
  private _hass: HomeAssistant | null = null;
  private _cameraManager: CameraManager | null = null;
  private _cameraID: string | null = null;

  private _forceVisibility?: boolean;

  constructor(host: HTMLElement) {
    this._host = host;
  }

  public setConfig(config?: PTZControlsConfig) {
    this._config = config ?? null;

    this._host.setAttribute('data-orientation', config?.orientation ?? 'horizontal');
    this._host.setAttribute('data-position', config?.position ?? 'bottom-right');
    this._host.setAttribute(
      'style',
      Object.entries(config?.style ?? {})
        .map(([k, v]) => `${k}:${v}`)
        .join(';'),
    );
  }

  public getConfig(): PTZControlsConfig | null {
    return this._config;
  }

  public setCamera(cameraManager?: CameraManager, cameraID?: string): void {
    this._cameraManager = cameraManager ?? null;
    this._cameraID = cameraID ?? null;
  }

  public setForceVisibility(forceVisibility?: boolean): void {
    this._forceVisibility = forceVisibility;
  }

  public handleAction(
    ev: CustomEvent<Interaction & Partial<SubmenuInteraction>>,
    buttonConfig?: ActionsConfig | null,
  ): void {
    const config: ActionsConfig | null = buttonConfig ?? ev.detail.item ?? null;

    // Nothing else has the configuration for this action, so don't let it
    // propagate further.
    ev.stopPropagation();

    const interaction: string = ev.detail.action;
    const action = getActionConfigGivenAction(interaction, config);
    if (action) {
      dispatchActionExecutionRequest(this._host, {
        actions: action,
        ...(config && { config: config }),
      });
    }
  }

  public shouldDisplay(): boolean {
    return this._forceVisibility !== undefined
      ? this._forceVisibility
      : this._config?.mode === 'auto'
        ? !!this._cameraID &&
          !!this._cameraManager
            ?.getCameraCapabilities(this._cameraID)
            ?.hasPTZCapability()
        : this._config?.mode === 'on';
  }

  public getPTZActions(): PTZControllerActions {
    const cameraCapabilities = this._cameraID
      ? this._cameraManager?.getCameraCapabilities(this._cameraID)
      : null;
    const hasRealPTZCapability =
      cameraCapabilities && cameraCapabilities.hasPTZCapability();
    const ptzCapabilities = cameraCapabilities?.getPTZCapabilities();

    const getContinuousActions = (options?: {
      ptzAction?: PTZAction;
      preset?: string;
    }): Actions => ({
      start_tap_action: createPTZMultiAction({
        ptzAction: options?.ptzAction,
        ptzPhase: 'start',
        ptzPreset: options?.preset,
      }),
      end_tap_action: createPTZMultiAction({
        ptzAction: options?.ptzAction,
        ptzPhase: 'stop',
        ptzPreset: options?.preset,
      }),
    });

    const getDiscreteAction = (options?: {
      ptzAction?: PTZAction;
      preset?: string;
    }): Actions => ({
      tap_action: createPTZMultiAction({
        ptzAction: options?.ptzAction,
        ptzPreset: options?.preset,
      }),
    });

    const actions: PTZControllerActions = {};
    if (!hasRealPTZCapability || ptzCapabilities?.up) {
      actions.up = getContinuousActions({
        ptzAction: 'up',
      });
    }
    if (!hasRealPTZCapability || ptzCapabilities?.down) {
      actions.down = getContinuousActions({
        ptzAction: 'down',
      });
    }
    if (!hasRealPTZCapability || ptzCapabilities?.left) {
      actions.left = getContinuousActions({
        ptzAction: 'left',
      });
    }
    if (!hasRealPTZCapability || ptzCapabilities?.right) {
      actions.right = getContinuousActions({
        ptzAction: 'right',
      });
    }
    if (!hasRealPTZCapability || ptzCapabilities?.zoomIn) {
      actions.zoom_in = getContinuousActions({
        ptzAction: 'zoom_in',
      });
    }
    if (!hasRealPTZCapability || ptzCapabilities?.zoomOut) {
      actions.zoom_out = getContinuousActions({
        ptzAction: 'zoom_out',
      });
    }
    if (!hasRealPTZCapability || ptzCapabilities?.presets?.length) {
      actions.home = getDiscreteAction();
    }
    for (const preset of ptzCapabilities?.presets ?? []) {
      actions.presets ??= [];
      actions.presets.push({
        preset: preset,
        actions: getDiscreteAction({
          preset: preset,
          ptzAction: 'preset',
        }),
      });
    }

    return actions;
  }
}



================================================
FILE: src/components-lib/ptz/types.ts
================================================
import { PTZControlAction } from '../../config/schema/actions/custom/ptz';
import { Actions } from '../../config/schema/actions/types';

interface PTZControlsViewContext {
  enabled?: boolean;
}
declare module 'view' {
  interface ViewContext {
    ptzControls?: PTZControlsViewContext;
  }
}

interface PTZPresetAction {
  preset: string;
  actions: Actions;
}

export type PTZControllerActions = {
  [K in PTZControlAction]?: Actions;
} & {
  presets?: PTZPresetAction[];
};



================================================
FILE: src/components-lib/thumbnail/details-controller.ts
================================================
import { format } from 'date-fns';
import { CameraManager } from '../../camera-manager/manager';
import { CameraManagerCameraMetadata } from '../../camera-manager/types';
import { localize } from '../../localize/localize';
import { Icon } from '../../types';
import { getDurationString, prettifyTitle } from '../../utils/basic';
import { ViewItem } from '../../view/item';
import { ViewItemClassifier } from '../../view/item-classifier';

interface Detail {
  icon?: Icon;
  hint?: string;
  title: string;
}

export class ThumbnailDetailsController {
  private _details: Detail[] = [];
  private _heading: string | null = null;

  public calculate(
    cameraManager?: CameraManager | null,
    item?: ViewItem,
    seek?: Date,
  ): void {
    const cameraID = ViewItemClassifier.isMedia(item) ? item.getCameraID() : null;
    const cameraMetadata = cameraID
      ? cameraManager?.getCameraMetadata(cameraID) ?? null
      : null;

    this._calculateHeading(cameraMetadata, item);
    this._calculateDetails(cameraMetadata, item, seek);
  }

  private _calculateHeading(
    cameraMetadata: CameraManagerCameraMetadata | null,
    item?: ViewItem,
  ): void {
    if (ViewItemClassifier.isEvent(item)) {
      const what = prettifyTitle(item.getWhat()?.join(', ')) ?? null;
      const tags = prettifyTitle(item.getTags()?.join(', ')) ?? null;
      const whatWithTags =
        what || tags ? (what ?? '') + (what && tags ? ': ' : '') + (tags ?? '') : null;
      const rawScore = item.getScore();
      const score = rawScore ? (rawScore * 100).toFixed(2) + '%' : null;

      this._heading = whatWithTags ? `${whatWithTags}${score ? ` ${score}` : ''}` : null;
      return;
    }

    if (cameraMetadata?.title) {
      this._heading = cameraMetadata.title;
      return;
    }

    this._heading = null;
  }

  private _calculateDetails(
    cameraMetadata: CameraManagerCameraMetadata | null,
    item?: ViewItem,
    seek?: Date,
  ): void {
    const itemTitle = item?.getTitle() ?? null;

    const startTime = ViewItemClassifier.isMedia(item) ? item.getStartTime() : null;
    const endTime = ViewItemClassifier.isMedia(item) ? item.getEndTime() : null;
    const duration = startTime && endTime ? getDurationString(startTime, endTime) : null;
    const inProgress = ViewItemClassifier.isMedia(item)
      ? item.inProgress()
        ? localize('thumbnail.in_progress')
        : null
      : null;
    const where = ViewItemClassifier.isMedia(item)
      ? prettifyTitle(item?.getWhere()?.join(', ')) ?? null
      : null;
    const tags = ViewItemClassifier.isEvent(item)
      ? prettifyTitle(item?.getTags()?.join(', ')) ?? null
      : null;
    const seekString = seek ? format(seek, 'HH:mm:ss') : null;

    const details = [
      ...(startTime
        ? [
            {
              hint: localize('thumbnail.start'),
              icon: { icon: 'mdi:calendar-clock-outline' },
              title: format(startTime, 'yyyy-MM-dd HH:mm:ss'),
            },
          ]
        : []),
      ...(duration || inProgress
        ? [
            {
              hint: localize('thumbnail.duration'),
              icon: { icon: 'mdi:clock-outline' },
              title: `${duration ?? ''}${duration && inProgress ? ' ' : ''}${inProgress ?? ''}`,
            },
          ]
        : []),
      ...(cameraMetadata?.title
        ? [
            {
              hint: localize('thumbnail.camera'),
              title: cameraMetadata.title,
              icon: { icon: 'mdi:cctv' },
            },
          ]
        : []),
      ...(where
        ? [
            {
              hint: localize('thumbnail.where'),
              title: where,
              icon: { icon: 'mdi:map-marker-outline' },
            },
          ]
        : []),
      ...(tags
        ? [
            {
              hint: localize('thumbnail.tag'),
              title: tags,
              icon: { icon: 'mdi:tag' },
            },
          ]
        : []),
      ...(seekString
        ? [
            {
              hint: localize('thumbnail.seek'),
              title: seekString,
              icon: { icon: 'mdi:clock-fast' },
            },
          ]
        : []),
    ];

    // To avoid duplication, if the event has a starttime, the title is omitted
    // from the details.
    const includeTitle = !ViewItemClassifier.isEvent(item) || !startTime;
    this._details = [
      ...(includeTitle && itemTitle
        ? [
            {
              title: itemTitle,
              ...(details.length > 0 && {
                icon: { icon: 'mdi:rename' },
                hint: localize('thumbnail.title'),
              }),
            },
          ]
        : []),
      ...details,
    ];
  }

  public getHeading(): string | null {
    return this._heading;
  }

  public getDetails(): Detail[] {
    return this._details;
  }
}



================================================
FILE: src/components-lib/thumbnail/feature/controller.ts
================================================
import { format } from 'date-fns';
import { CameraManager } from '../../../camera-manager/manager';
import { CameraManagerCameraMetadata } from '../../../camera-manager/types';
import {
  brandsUrl,
  extractDomainFromBrandUrl,
  isBrandUrl,
} from '../../../ha/brands-url';
import { ViewItem } from '../../../view/item';
import { ViewItemClassifier } from '../../../view/item-classifier';

export class ThumbnailFeatureController {
  private _title: string | null = null;
  private _subtitles: string[] = [];
  private _icon: string | null = null;
  private _thumbnail: string | null = null;
  private _thumbnailClass: string | null = null;

  public calculate(
    cameraManager?: CameraManager | null,
    item?: ViewItem,
    hasDetails?: boolean,
  ): void {
    const cameraID = ViewItemClassifier.isMedia(item) ? item.getCameraID() : null;
    const cameraMetadata = cameraID
      ? cameraManager?.getCameraMetadata(cameraID) ?? null
      : null;

    this._calculateVisuals(cameraMetadata, item);
    this._calculateTitles(cameraMetadata, item, hasDetails);
  }

  private _calculateTitles(
    cameraMetadata?: CameraManagerCameraMetadata | null,
    item?: ViewItem,
    hasDetails?: boolean,
  ) {
    if (hasDetails) {
      return;
    }

    if (this._thumbnail && ViewItemClassifier.isMedia(item)) {
      this._title = null;
      this._subtitles = [];
      return;
    }

    const startTime =
      ViewItemClassifier.isEvent(item) || ViewItemClassifier.isRecording(item)
        ? item.getStartTime()
        : null;

    this._title = startTime ? format(startTime, 'HH:mm') : null;

    const day = startTime ? format(startTime, 'MMM do') : null;
    const itemTitle = item?.getTitle() ?? null;
    const src = cameraMetadata?.title ?? itemTitle ?? null;

    this._subtitles = [...(day ? [day] : []), ...(src ? [src] : [])];
  }

  private _calculateVisuals(
    cameraMetadata?: CameraManagerCameraMetadata | null,
    item?: ViewItem,
  ) {
    let thumbnail: string | null = item?.getThumbnail() ?? null;
    if (thumbnail && isBrandUrl(thumbnail)) {
      thumbnail = brandsUrl({
        domain: extractDomainFromBrandUrl(thumbnail),
        type: 'icon',
        useFallback: true,
        brand: true,
      });
    }

    if (thumbnail) {
      this._thumbnail = thumbnail;
      this._icon = null;
      this._thumbnailClass = isBrandUrl(thumbnail) ? 'brand' : null;
    } else {
      this._thumbnail = null;
      this._thumbnailClass = null;
      this._icon = item?.getIcon() ?? cameraMetadata?.engineIcon ?? null;
    }
  }

  public getTitle(): string | null {
    return this._title;
  }

  public getSubtitles(): string[] {
    return this._subtitles;
  }

  public getIcon(): string | null {
    return this._icon;
  }

  public getThumbnail(): string | null {
    return this._thumbnail;
  }

  public getThumbnailClass(): string | null {
    return this._thumbnailClass;
  }
}



================================================
FILE: src/components-lib/zoom/types.ts
================================================
import { PartialDeep } from 'type-fest';

export const ZOOM_DEFAULT_PAN_X = 50;
export const ZOOM_DEFAULT_PAN_Y = 50;
export const ZOOM_DEFAULT_SCALE = 1;
export const ZOOM_PRECISION = 4;

export interface ZoomSettingsBase {
  pan: {
    x: number;
    y: number;
  };
  zoom: number;
}

export type PartialZoomSettings = PartialDeep<ZoomSettingsBase>;

export interface ZoomSettingsObserved extends ZoomSettingsBase {
  isDefault: boolean;
  unzoomed: boolean;
}

export const isZoomEmpty = (settings?: PartialZoomSettings | null): boolean => {
  return (
    settings?.pan?.x === undefined &&
    settings?.pan?.y === undefined &&
    settings?.zoom === undefined
  );
};



================================================
FILE: src/components-lib/zoom/zoom-controller.ts
================================================
import Panzoom, { PanzoomEventDetail, PanzoomObject } from '@dermotduffy/panzoom';
import { round, throttle } from 'lodash-es';
import { arefloatsApproximatelyEqual, isHoverableDevice } from '../../utils/basic';
import { fireAdvancedCameraCardEvent } from '../../utils/fire-advanced-camera-card-event';
import {
  PartialZoomSettings,
  ZOOM_DEFAULT_PAN_X,
  ZOOM_DEFAULT_PAN_Y,
  ZOOM_DEFAULT_SCALE,
  ZOOM_PRECISION,
  ZoomSettingsObserved,
  isZoomEmpty,
} from './types';

export class ZoomController {
  protected _element: HTMLElement;
  protected _panzoom?: PanzoomObject;

  // Is the controller zoomed in at all?
  protected _zoomed = false;

  // Is the controller set to the default zoom/pan settings?
  protected _default = true;

  // Should clicks be allowed to propagate, or consumed as a pan/zoom action?
  protected _allowClick = true;

  protected _defaultSettings: PartialZoomSettings | null;
  protected _settings: PartialZoomSettings | null;

  // These values should be suitably less than the value of STEP_DELAY_SECONDS
  // in the ptz_digital action, in order to ensure smooth movements of the
  // digital PTZ actions.
  protected _debouncedChangeHandler = throttle(this._changeHandler.bind(this), 50);
  protected _debouncedUpdater = throttle(this._updateBasedOnConfig.bind(this), 50);

  protected _resizeObserver = new ResizeObserver(this._debouncedUpdater);

  protected _events = isHoverableDevice()
    ? {
        down: ['pointerdown'],
        move: ['pointermove'],
        up: ['pointerup', 'pointerleave', 'pointercancel'],
      }
    : {
        down: ['touchstart'],
        move: ['touchmove'],
        up: ['touchend', 'touchcancel'],
      };

  protected _downHandler = (ev: Event) => {
    if (this._shouldZoomOrPan(ev)) {
      this._panzoom?.handleDown(ev as PointerEvent);
      ev.stopPropagation();

      // If we do not prevent default here, the media carousels scroll.
      ev.preventDefault();
      this._allowClick = false;
    } else {
      this._allowClick = true;
    }
  };

  protected _clickHandler = (ev: Event) => {
    // When mouse clicking is used to pan, need to avoid that causing a click
    // handler elsewhere in the card being called. Example: Viewing a snapshot,
    // and panning within it should not cause a related clip to play (the click
    // handler in the viewer).
    if (!this._allowClick) {
      ev.stopPropagation();

      // Even though the click is stopped,the card still needs to gain focus so
      // that keyboard shortcuts will work immediately after the card is clicked
      // upon.
      fireAdvancedCameraCardEvent(this._element, 'focus');
    }
    this._allowClick = true;
  };

  protected _moveHandler = (ev: Event) => {
    if (this._shouldZoomOrPan(ev)) {
      this._panzoom?.handleMove(ev as PointerEvent);
      ev.stopPropagation();
    }
  };

  protected _upHandler = (ev: Event) => {
    if (this._shouldZoomOrPan(ev)) {
      this._panzoom?.handleUp(ev as PointerEvent);
      ev.stopPropagation();
    }
  };

  protected _wheelHandler = (ev: Event) => {
    if (ev instanceof WheelEvent && this._shouldZoomOrPan(ev)) {
      this._panzoom?.zoomWithWheel(ev);
      ev.stopPropagation();
    }
  };

  constructor(
    element: HTMLElement,
    options?: {
      config?: PartialZoomSettings | null;
      defaultConfig?: PartialZoomSettings | null;
    },
  ) {
    this._element = element;
    this._settings = options?.config ?? null;
    this._defaultSettings = options?.defaultConfig ?? null;
  }

  public activate(): void {
    const config = this._getConfigToUse();
    const converted = this._convertPercentToXYPan(
      config?.pan?.x ?? ZOOM_DEFAULT_PAN_X,
      config?.pan?.y ?? ZOOM_DEFAULT_PAN_Y,
      config?.zoom ?? ZOOM_DEFAULT_SCALE,
    );

    this._panzoom = Panzoom(this._element, {
      contain: 'outside',
      maxScale: 10,
      minScale: 1,
      noBind: true,
      // Do not force the cursor style (by default it will always show the
      // 'move' type cursor whether or not it is zoomed in).
      cursor: undefined,

      // Disable automatic touchAction setting from Panzoom() as otherwise it
      // effectively disables dashboard scrolling. See:
      // https://github.com/dermotduffy/advanced-camera-card/issues/1181
      touchAction: '',

      // Set the initial pan/zoom values to avoid an initial unzoomed view.
      ...(config && converted && { startX: converted.x }),
      ...(config && converted && { startY: converted.y }),
      ...(config &&
        converted && {
          startScale:
            config.zoom ??
            // This is not reachable as without a zoom value, a default of 1 is
            // assumed in _convertPercentToXYPan, which will return null @
            // default zoom, and so this cannot be reached in practice.
            /* istanbul ignore next @preserve */
            ZOOM_DEFAULT_SCALE,
        }),
    });

    const registerListeners = (
      events: string[],
      func: (ev: Event) => void,
      options?: AddEventListenerOptions,
    ) => {
      events.forEach((eventName) => {
        this._element.addEventListener(eventName, func, options);
      });
    };

    registerListeners(this._events['down'], this._downHandler, { capture: true });
    registerListeners(this._events['move'], this._moveHandler, { capture: true });
    registerListeners(this._events['up'], this._upHandler, { capture: true });
    registerListeners(['wheel'], this._wheelHandler);
    registerListeners(['click'], this._clickHandler, { capture: true });

    this._resizeObserver.observe(this._element);
    this._element.addEventListener('panzoomchange', this._debouncedChangeHandler);
  }

  public deactivate(): void {
    const unregisterListener = (
      events: string[],
      func: (ev: Event) => void,
      options?: EventListenerOptions,
    ) => {
      events.forEach((eventName) => {
        this._element.removeEventListener(eventName, func, options);
      });
    };

    unregisterListener(this._events['down'], this._downHandler, { capture: true });
    unregisterListener(this._events['move'], this._moveHandler, { capture: true });
    unregisterListener(this._events['up'], this._upHandler, { capture: true });
    unregisterListener(['wheel'], this._wheelHandler);
    unregisterListener(['click'], this._clickHandler, { capture: true });

    this._resizeObserver.disconnect();
    this._element.removeEventListener('panzoomchange', this._debouncedChangeHandler);
  }

  public setDefaultSettings(config: PartialZoomSettings | null): void {
    this._defaultSettings = config;
    this._debouncedUpdater();
  }

  public setSettings(config: PartialZoomSettings | null): void {
    this._settings = config;
    this._debouncedUpdater();
  }

  protected _changeHandler(ev: Event): void {
    const pz = (<CustomEvent<PanzoomEventDetail>>ev).detail;
    const unzoomed = this._isUnzoomed(pz.scale);

    // Take care here to only dispatch the zoomed/unzoomed events when the
    // absolute state changes (rather than on every single zoom adjustment).
    if (unzoomed && this._zoomed) {
      this._zoomed = false;
      this._setTouchAction(true);
      fireAdvancedCameraCardEvent(this._element, 'zoom:unzoomed');
    } else if (!unzoomed && !this._zoomed) {
      this._zoomed = true;
      this._setTouchAction(false);
      fireAdvancedCameraCardEvent(this._element, 'zoom:zoomed');
    }

    const converted = this._convertXYPanToPercent(pz.x, pz.y, pz.scale);
    const observed: ZoomSettingsObserved = {
      pan: {
        x: converted?.x ?? ZOOM_DEFAULT_PAN_X,
        y: converted?.y ?? ZOOM_DEFAULT_PAN_Y,
      },
      zoom: pz.scale,
      isDefault: this._isAtDefaultZoomAndPan(pz.x, pz.y, pz.scale),
      unzoomed: unzoomed,
    };

    fireAdvancedCameraCardEvent(this._element, 'zoom:change', observed);
  }

  protected _isZoomEqual(a: PartialZoomSettings, b: PartialZoomSettings): boolean {
    // The ?? clauses below cannot be reached since this function is only ever
    // used fully specified by this object. It's kept as-is for completeness.
    return (
      arefloatsApproximatelyEqual(
        /* istanbul ignore next @preserve */
        a.zoom ?? ZOOM_DEFAULT_SCALE,
        /* istanbul ignore next @preserve */
        b.zoom ?? ZOOM_DEFAULT_SCALE,
        ZOOM_PRECISION,
      ) &&
      arefloatsApproximatelyEqual(
        /* istanbul ignore next @preserve */
        a.pan?.x ?? ZOOM_DEFAULT_PAN_X,
        /* istanbul ignore next @preserve */
        b.pan?.x ?? ZOOM_DEFAULT_PAN_X,
        ZOOM_PRECISION,
      ) &&
      arefloatsApproximatelyEqual(
        /* istanbul ignore next @preserve */
        a.pan?.y ?? ZOOM_DEFAULT_PAN_Y,
        /* istanbul ignore next @preserve */
        b.pan?.y ?? ZOOM_DEFAULT_PAN_Y,
        ZOOM_PRECISION,
      )
    );
  }

  protected _getConfigToUse(): PartialZoomSettings | null {
    return isZoomEmpty(this._settings) ? this._defaultSettings : this._settings;
  }

  protected _updateBasedOnConfig(): void {
    if (!this._panzoom) {
      return;
    }

    const config = this._getConfigToUse();
    const desiredScale = config?.zoom ?? ZOOM_DEFAULT_SCALE;

    // Transform won't exist (will be null) if the element has no dimensions, or
    // if the desired scale has no zoom (i.e. is 1).
    const converted = this._convertPercentToXYPan(
      config?.pan?.x ?? ZOOM_DEFAULT_PAN_X,
      config?.pan?.y ?? ZOOM_DEFAULT_PAN_Y,
      desiredScale,
    );

    const x = converted?.x ?? 0;
    const y = converted?.y ?? 0;

    // Verify there is a material change in the pan/zoom settings before acting.
    if (
      this._isZoomEqual(
        { zoom: desiredScale, pan: { x: x, y: y } },
        {
          zoom: this._panzoom.getScale(),
          pan: this._panzoom.getPan(),
        },
      )
    ) {
      return;
    }

    this._panzoom.zoom(desiredScale, {
      // Zoom is stepped, not animated. If it is animated, there is interaction
      // between the zoom and the pan below, and the pan would need to be
      // delayed until after the zoom is complete.
      animate: false,
    });

    // Panzoom must allow the browser to paint the zoomed image in order to
    // "contain" the pan within the parent, this creates somewhat of an async
    // situation where we need to ensure the zoom completes first. Using
    // `requestAnimationFrame` appears to reliably allow the zoom to finish
    // rendering first, before the pain is applied.
    //
    // See: https://github.com/timmywil/panzoom?tab=readme-ov-file#a-note-on-the-async-nature-of-panzoom
    window.requestAnimationFrame(() => {
      this._panzoom?.pan(x, y, {
        animate: true,
        duration: 100,
      });
    });
  }

  /**
   * Convert from Advanced Camera Card pan % values to Panzoom X/Y transformation
   * coordinates.
   * @param x The x translation value.
   * @param y The y translation value.
   * @param scale The desired (not current) scale.
   * @returns An object with x/y pan % values or null on error.
   */
  protected _convertPercentToXYPan(
    x: number,
    y: number,
    scale: number,
  ): { x: number; y: number } | null {
    const minMax = this._getTransformMinMax(scale, this._panzoom?.getScale());
    if (minMax === null) {
      return null;
    }

    return {
      x: minMax.minX + (minMax.maxX - minMax.minX) * (x / 100),
      y: minMax.minY + (minMax.maxY - minMax.minY) * (y / 100),
    };
  }

  protected _convertXYPanToPercent(
    x: number,
    y: number,
    scale: number,
  ): { x: number; y: number } | null {
    const minMax = this._getTransformMinMax(scale, this._panzoom?.getScale());
    if (minMax === null) {
      return null;
    }

    return {
      x:
        ((-x + Math.abs(minMax.minX)) /
          (Math.abs(minMax.maxX) + Math.abs(minMax.minX))) *
        100,
      y:
        ((-y + Math.abs(minMax.minY)) /
          (Math.abs(minMax.maxY) + Math.abs(minMax.minY))) *
        100,
    };
  }

  protected _getTransformMinMax(
    desiredScale: number,
    currentScale?: number,
  ): {
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
  } | null {
    const rendered = this._getRenderedSize(currentScale);

    if (!rendered.width || !rendered.height) {
      return null;
    }

    const minX = (rendered.width * (desiredScale - 1)) / desiredScale / 2;
    const minY = (rendered.height * (desiredScale - 1)) / desiredScale / 2;

    if (arefloatsApproximatelyEqual(minX, 0) || arefloatsApproximatelyEqual(minY, 0)) {
      return null;
    }

    return {
      minX: minX,
      maxX: -minX,
      minY: minY,
      maxY: -minY,
    };
  }

  protected _getRenderedSize(scale?: number): { width: number; height: number } {
    const rect = this._element.getBoundingClientRect();
    return {
      width: rect.width / (scale ?? ZOOM_DEFAULT_SCALE),
      height: rect.height / (scale ?? ZOOM_DEFAULT_SCALE),
    };
  }

  protected _isUnzoomed(scale?: number): boolean {
    return scale !== undefined && round(scale, ZOOM_PRECISION) <= 1;
  }

  protected _isAtDefaultZoomAndPan(x: number, y: number, scale: number): boolean {
    if (!this._defaultSettings) {
      return this._isUnzoomed(scale);
    }

    const convertedDefault = this._convertPercentToXYPan(
      this._defaultSettings.pan?.x ?? ZOOM_DEFAULT_PAN_X,
      this._defaultSettings.pan?.y ?? ZOOM_DEFAULT_PAN_Y,
      this._defaultSettings.zoom ?? ZOOM_DEFAULT_SCALE,
    );
    if (!convertedDefault) {
      return true;
    }

    return (
      arefloatsApproximatelyEqual(x, convertedDefault.x) &&
      arefloatsApproximatelyEqual(y, convertedDefault.y) &&
      arefloatsApproximatelyEqual(
        scale,
        this._defaultSettings.zoom ??
          // The ZOOM_DEFAULT_SCALE clause below cannot be reached since when
          // this._defaultConfig.zoom is undefined, convertedDefault will end up
          // null above and this function will have already returned.
          /* istanbul ignore next @preserve */
          ZOOM_DEFAULT_SCALE,
      )
    );
  }

  protected _shouldZoomOrPan(ev: Event): boolean {
    return (
      !this._isUnzoomed(this._panzoom?.getScale()) ||
      // TouchEvent does not exist on Firefox on non-touch events. See:
      // https://github.com/dermotduffy/advanced-camera-card/issues/1174
      (window.TouchEvent && ev instanceof TouchEvent && ev.touches.length > 1) ||
      (ev instanceof WheelEvent && ev.ctrlKey)
    );
  }

  protected _setTouchAction(touchEnabled: boolean): void {
    this._element.style.touchAction = touchEnabled ? '' : 'none';
  }
}



================================================
FILE: src/components-lib/zoom/zoom-view-context.ts
================================================
import { ViewContext } from 'view';
import { MergeContextViewModifier } from '../../card-controller/view/modifiers/merge-context.js';
import { ViewManagerInterface } from '../../card-controller/view/types.js';
import { PartialZoomSettings, ZoomSettingsObserved } from './types.js';

interface ZoomViewContext {
  observed?: ZoomSettingsObserved;

  // Populate this to request zoom to a particular scale/x/y. An empty object
  // will reset to default, null will make no change.
  requested?: PartialZoomSettings | null;
}

interface ZoomsViewContext {
  [targetID: string]: ZoomViewContext;
}

declare module 'view' {
  interface ViewContext {
    zoom?: ZoomsViewContext;
  }
}

export const generateViewContextForZoom = (
  targetID: string,
  options?: {
    observed?: ZoomSettingsObserved;
    requested?: PartialZoomSettings | null;
  },
): ViewContext | null => {
  return {
    zoom: {
      [targetID]: {
        observed: options?.observed ?? undefined,
        requested: options?.requested ?? null,
      },
    },
  };
};

/**
 * Convenience wrapper to convert zoom settings into a view change
 */
export const handleZoomSettingsObservedEvent = (
  ev: CustomEvent<ZoomSettingsObserved>,
  viewManager?: ViewManagerInterface,
  targetID?: string,
): void => {
  if (!viewManager || !targetID) {
    return;
  }

  viewManager.setViewByParameters({
    modifiers: [
      new MergeContextViewModifier(
        generateViewContextForZoom(targetID, {
          observed: ev.detail,
        }),
      ),
    ],
  });
};



================================================
FILE: src/conditions/conditions-manager.ts
================================================
import { TemplateRenderer } from '../card-controller/templates';
import { getConfigValue } from '../config/management';
import { AdvancedCameraCardCondition } from '../config/schema/conditions/types';
import { isCompanionApp } from '../utils/companion';
import {
  ConditionsEvaluationResult,
  ConditionsListener,
  ConditionsManagerReadonlyInterface,
  ConditionState,
  ConditionStateChange,
  ConditionStateManagerReadonlyInterface,
  ConditionsTriggerData,
} from './types';

/**
 * A class to evaluate an array of conditions, and notify listeners when the
 * evaluation changes (a change is either the result changing, or the data
 * associated with a result).
 */
export class ConditionsManager implements ConditionsManagerReadonlyInterface {
  protected _conditions: AdvancedCameraCardCondition[];
  protected _stateManager: ConditionStateManagerReadonlyInterface | null;

  protected _listeners: ConditionsListener[] = [];
  protected _mediaQueries: MediaQueryList[] = [];
  protected _evaluation: ConditionsEvaluationResult = { result: false };
  protected _templateRenderer: TemplateRenderer = new TemplateRenderer();

  constructor(
    conditions: AdvancedCameraCardCondition[],
    stateManager?: ConditionStateManagerReadonlyInterface | null,
  ) {
    this._conditions = conditions;
    conditions.forEach((condition) => {
      if (condition.condition === 'screen') {
        const mql = window.matchMedia(condition.media_query);
        mql.addEventListener('change', this._mediaQueryHandler);
        this._mediaQueries.push(mql);
      }
    });

    this._stateManager = stateManager ?? null;

    // Do an initial condition evaluation, but without calling listeners.
    this._evaluate({ callListeners: false });

    this._stateManager?.addListener(this._stateManagerHandler);
  }

  public destroy(): void {
    this._stateManager?.removeListener(this._stateManagerHandler);

    this._listeners.forEach((l) => this.removeListener(l));

    this._mediaQueries.forEach((mql) =>
      mql.removeEventListener('change', this._mediaQueryHandler),
    );
    this._mediaQueries = [];
    this._conditions = [];
  }

  public addListener(listener: ConditionsListener): void {
    if (!this._listeners.includes(listener)) {
      this._listeners.push(listener);
    }
  }

  public removeListener(listener: ConditionsListener): void {
    this._listeners = this._listeners.filter((l) => l !== listener);
  }

  public getEvaluation(): ConditionsEvaluationResult {
    return this._evaluation;
  }

  protected _mediaQueryHandler = () => this._evaluate();

  protected _stateManagerHandler = (stateChange: ConditionStateChange): void => {
    this._evaluate({ stateChange });
  };

  protected _evaluate(options?: {
    stateChange?: ConditionStateChange;
    callListeners?: boolean;
  }): void {
    const state = options?.stateChange?.new ?? this._stateManager?.getState();

    let result = true;
    let triggerData: ConditionsTriggerData = {};

    for (const condition of this._conditions) {
      const evaluation = this._evaluateCondition(
        condition,
        state,
        options?.stateChange?.old,
      );
      if (!evaluation.result) {
        result = false;
        break;
      }
      triggerData = {
        ...triggerData,
        ...evaluation.triggerData,
      };
    }

    const evaluation: ConditionsEvaluationResult = result
      ? { result, triggerData }
      : { result };

    if (
      evaluation.result !== this._evaluation.result ||
      (evaluation.triggerData && Object.keys(evaluation.triggerData).length)
    ) {
      this._evaluation = evaluation;
      if (options?.callListeners ?? true) {
        this._listeners.forEach(
          (listener) => this._evaluation && listener(this._evaluation),
        );
      }
    }
  }

  protected _evaluateCondition(
    condition: AdvancedCameraCardCondition,
    newState?: ConditionState,
    oldState?: ConditionState,
  ): ConditionsEvaluationResult {
    switch (condition.condition) {
      case undefined:
      case 'state': {
        const fromState = oldState?.hass?.states?.[condition.entity]?.state;
        const toState = newState?.hass?.states?.[condition.entity]?.state;

        return {
          result:
            (!condition.state && !condition.state_not && toState !== fromState) ||
            ((!!condition.state || !!condition.state_not) &&
              !!toState &&
              (!condition.state ||
                (Array.isArray(condition.state)
                  ? condition.state.includes(toState)
                  : condition.state === toState)) &&
              (!condition.state_not ||
                (Array.isArray(condition.state_not)
                  ? !condition.state_not.includes(toState)
                  : condition.state_not !== toState))),
          ...(fromState !== toState && {
            triggerData: {
              state: {
                entity: condition.entity,
                ...(fromState && { from: fromState }),
                ...(toState && { to: toState }),
              },
            },
          }),
        };
      }
      case 'view': {
        const oldView = oldState?.view;
        const newView = newState?.view;

        return {
          result:
            (!!newView && condition.views?.includes(newView)) ||
            (newView !== oldView && !condition.views?.length),
          ...(oldView !== newView && {
            triggerData: {
              ...((oldState?.view || newState?.view) && {
                view: {
                  ...(oldState?.view && { from: oldState.view }),
                  ...(newState?.view && { to: newState.view }),
                },
              }),
            },
          }),
        };
      }
      case 'fullscreen':
        return {
          result:
            newState?.fullscreen !== undefined &&
            condition.fullscreen === newState.fullscreen,
        };
      case 'expand':
        return {
          result: newState?.expand !== undefined && condition.expand === newState.expand,
        };
      case 'camera': {
        const oldCamera = oldState?.camera;
        const newCamera = newState?.camera;

        return {
          result:
            (!!newCamera && !!condition.cameras?.includes(newCamera)) ||
            (newCamera !== oldCamera && !condition.cameras?.length),
          ...(newCamera !== oldCamera && {
            triggerData: {
              ...((oldState?.camera || newState?.camera) && {
                camera: {
                  ...(oldState?.camera && { from: oldState?.camera }),
                  ...(newState?.camera && { to: newState?.camera }),
                },
              }),
            },
          }),
        };
      }
      case 'numeric_state':
        return {
          result:
            !!newState?.hass?.states &&
            condition.entity in newState.hass?.states &&
            newState.hass.states[condition.entity].state !== undefined &&
            (condition.above === undefined ||
              Number(newState.hass.states[condition.entity].state) > condition.above) &&
            (condition.below === undefined ||
              Number(newState.hass.states[condition.entity].state) < condition.below),
        };
      case 'user':
        return {
          result:
            !!newState?.hass?.user && condition.users.includes(newState.hass.user.id),
        };
      case 'media_loaded':
        return {
          result:
            newState?.mediaLoadedInfo !== undefined &&
            condition.media_loaded === !!newState.mediaLoadedInfo,
        };
      case 'screen':
        return { result: window.matchMedia(condition.media_query).matches };
      case 'display_mode':
        return {
          result:
            !!newState?.displayMode && condition.display_mode === newState.displayMode,
        };
      case 'triggered':
        return {
          result: condition.triggered.some((triggeredCameraID) =>
            newState?.triggered?.has(triggeredCameraID),
          ),
        };
      case 'interaction':
        return {
          result:
            newState?.interaction !== undefined &&
            condition.interaction === newState.interaction,
        };
      case 'microphone':
        return {
          result:
            (condition.connected === undefined ||
              newState?.microphone?.connected === condition.connected) &&
            (condition.muted === undefined ||
              newState?.microphone?.muted === condition.muted),
        };
      case 'key':
        return {
          result:
            !!newState?.keys &&
            condition.key in newState.keys &&
            (condition.state ?? 'down') === newState.keys[condition.key].state &&
            (condition.ctrl === undefined ||
              condition.ctrl === !!newState.keys[condition.key].ctrl) &&
            (condition.alt === undefined ||
              condition.alt === !!newState.keys[condition.key].alt) &&
            (condition.meta === undefined ||
              condition.meta === !!newState.keys[condition.key].meta) &&
            (condition.shift === undefined ||
              condition.shift === !!newState.keys[condition.key].shift),
        };
      case 'user_agent':
        return {
          result:
            !!newState?.userAgent &&
            (!condition.user_agent || condition.user_agent === newState.userAgent) &&
            (condition.companion === undefined ||
              condition.companion === isCompanionApp(newState.userAgent)) &&
            (condition.user_agent_re === undefined ||
              new RegExp(condition.user_agent_re).test(newState.userAgent)),
        };
      case 'config': {
        const newConfig = newState?.config;
        const oldConfig = oldState?.config;

        return {
          result:
            !!newConfig &&
            newConfig !== oldConfig &&
            (!condition.paths?.length ||
              condition.paths.some(
                (key) =>
                  getConfigValue(newConfig, key) !==
                  (oldConfig ? getConfigValue(oldConfig, key) : undefined),
              )),
          ...(newConfig !== oldConfig && {
            triggerData: {
              config: {
                ...((oldState?.config || newState?.config) && {
                  ...(oldState?.config && { from: oldState?.config }),
                  ...(newState?.config && { to: newState?.config }),
                }),
              },
            },
          }),
        };
      }
      case 'initialized':
        return { result: !!newState?.initialized };
      case 'or':
        for (const subCondition of condition.conditions) {
          const evaluation = this._evaluateCondition(subCondition, newState, oldState);
          if (evaluation.result) {
            return evaluation;
          }
        }
        return { result: false };
      case 'and': {
        let triggerData: ConditionsTriggerData = {};
        for (const subCondition of condition.conditions) {
          const evaluation = this._evaluateCondition(subCondition, newState, oldState);
          if (!evaluation.result) {
            return { result: false };
          }
          triggerData = {
            ...triggerData,
            ...evaluation.triggerData,
          };
        }
        return { result: true, triggerData };
      }
      case 'not': {
        // "Not" is just an inversed `and`. There is no trigger data for "not
        // triggering".
        return {
          result: !this._evaluateCondition(
            {
              ...condition,
              condition: 'and',
            },
            newState,
            oldState,
          ).result,
        };
      }
      case 'template':
        return {
          result:
            !!newState?.hass &&
            this._templateRenderer.renderRecursively(
              newState.hass,
              condition.value_template,
              { conditionState: newState },
            ) === true,
        };
    }
  }
}



================================================
FILE: src/conditions/state-manager-via-event.ts
================================================
import { ConditionStateManager } from './state-manager';

export class ConditionStateManagerGetEvent extends Event {
  public conditionStateManager?: ConditionStateManager;

  constructor(eventInitDict?: EventInit) {
    super('advanced-camera-card:condition-state-manager:get', eventInitDict);
  }
}

/**
 * Fetch the main ConditionStateManager via an event.
 * @returns The ConditionStateManager or null if not found.
 */

export function getConditionStateManagerViaEvent(
  element: HTMLElement,
): ConditionStateManager | null {
  const getEvent = new ConditionStateManagerGetEvent({
    bubbles: true,
    composed: true,
  });

  /* Special note on what's going on here:
   *
   * Some parts of the card (e.g. <advanced-camera-card-elements>) may have arbitrary
   * complexity and layers (that this card doesn't control) between that master
   * element and the element that needs to evaluate the condition. In these
   * cases there's no clean way to pass state from the rest of card down through
   * these layers. Instead, an event is dispatched as a "request for evaluation"
   * (ConditionEvaluateRequestEvent) upwards which is caught by the outer card
   * and the evaluation result is added to the event object. Because event
   * propagation is handled synchronously, the result will be added to the event
   * before the flow proceeds.
   */
  element.dispatchEvent(getEvent);
  return getEvent.conditionStateManager ?? null;
}



================================================
FILE: src/conditions/state-manager.ts
================================================
import { isEqual } from 'lodash-es';
import {
  ConditionState,
  ConditionStateChange,
  ConditionStateListener,
  ConditionStateManagerReadonlyInterface,
} from './types';

/**
 * A class to manage state used in the evaluation of conditions.
 */
export class ConditionStateManager implements ConditionStateManagerReadonlyInterface {
  protected _listeners: ConditionStateListener[] = [];
  protected _state: ConditionState = {};

  public addListener(listener: ConditionStateListener): void {
    this._listeners.push(listener);
  }

  public removeListener(listener: ConditionStateListener): void {
    this._listeners = this._listeners.filter((l) => l !== listener);
  }

  public getState(): ConditionState {
    return this._state;
  }

  public setState(state: ConditionState): void {
    this._processStateChange(this._calculateTrueChange(state));
  }

  protected _processStateChange(changeState: ConditionState): void {
    if (!Object.keys(changeState).length) {
      return;
    }

    const oldState = this._state;
    this._state = {
      ...oldState,
      ...changeState,
    };
    this._callListeners({ old: oldState, change: changeState, new: this._state });
  }

  protected _calculateTrueChange(change: ConditionState): ConditionState {
    const changeState: ConditionState = {};

    for (const key of Object.keys(change)) {
      if (!isEqual(change[key], this._state[key])) {
        changeState[key] = change[key];
      }
    }

    return changeState;
  }

  protected _callListeners = (stateChange: ConditionStateChange): void => {
    this._listeners.forEach((listener) => listener(stateChange));
  };
}



================================================
FILE: src/conditions/types.ts
================================================
import { KeysState, MicrophoneState } from '../card-controller/types';
import { ViewDisplayMode } from '../config/schema/common/display';
import { AdvancedCameraCardConfig } from '../config/schema/types';
import { HomeAssistant } from '../ha/types';
import { MediaLoadedInfo } from '../types';

export interface ConditionState {
  camera?: string;
  config?: AdvancedCameraCardConfig;
  displayMode?: ViewDisplayMode;
  expand?: boolean;
  fullscreen?: boolean;
  initialized?: boolean;
  interaction?: boolean;
  keys?: KeysState;
  mediaLoadedInfo?: MediaLoadedInfo | null;
  microphone?: MicrophoneState;
  hass?: HomeAssistant;
  triggered?: Set<string>;
  userAgent?: string;
  view?: string;
}

export interface ConditionStateChange {
  old: ConditionState;
  change: ConditionState;
  new: ConditionState;
}

export type ConditionStateListener = (change: ConditionStateChange) => void;

export interface ConditionStateManagerReadonlyInterface {
  addListener(listener: ConditionStateListener): void;
  removeListener(listener: ConditionStateListener): void;
  getState(): ConditionState;
}

interface ConditionsTriggerDataFromTo {
  from?: string;
  to?: string;
}

interface ConditionsTriggerDataState extends ConditionsTriggerDataFromTo {
  entity: string;
}

interface ConditionsTriggerDataConfig {
  from?: AdvancedCameraCardConfig;
  to?: AdvancedCameraCardConfig;
}

export interface ConditionsTriggerData {
  camera?: ConditionsTriggerDataFromTo;
  view?: ConditionsTriggerDataFromTo;
  state?: ConditionsTriggerDataState;
  config?: ConditionsTriggerDataConfig;
}
export interface ConditionsEvaluationResult {
  result: boolean;

  // Trigger data is only provided if there was a real change of state (For
  // example: if a state condition that matches 'on' previously evaluated to
  // true, and a call from the state manager arrives for an unrelated hass state
  // update, the condition will still evaluate true, but there won't be any
  // trigger data provided since the state relevant to the condition did not
  // change).
  triggerData?: ConditionsTriggerData;
}

export type ConditionsListener = (result: ConditionsEvaluationResult) => void;

export interface ConditionsManagerReadonlyInterface {
  addListener(listener: ConditionsListener): void;
  removeListener(listener: ConditionsListener): void;
  getEvaluation(): ConditionsEvaluationResult | null;
}



================================================
FILE: src/config/management.ts
================================================
import { cloneDeep, get, isEqual, set, unset } from 'lodash-es';
import {
  CONF_AUTOMATIONS,
  CONF_CAMERAS,
  CONF_CAMERAS_GLOBAL_DIMENSIONS_LAYOUT,
  CONF_CAMERAS_GLOBAL_PTZ,
  CONF_DIMENSIONS_HEIGHT,
  CONF_ELEMENTS,
  CONF_LIVE_CONTROLS_THUMBNAILS_EVENTS_MEDIA_TYPE,
  CONF_LIVE_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
  CONF_OVERRIDES,
  CONF_PROFILES,
  CONF_STATUS_BAR,
  CONF_TIMELINE_EVENTS_MEDIA_TYPE,
  CONF_VIEW_DEFAULT_CYCLE_CAMERA,
  CONF_VIEW_DEFAULT_RESET_ENTITIES,
  CONF_VIEW_DEFAULT_RESET_EVERY_SECONDS,
  CONF_VIEW_DEFAULT_RESET_INTERACTION_MODE,
  CONF_VIEW_DIM,
  CONF_VIEW_INTERACTION_SECONDS,
  CONF_VIEW_TRIGGERS,
  CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER,
  CONF_VIEW_TRIGGERS_ACTIONS_UNTRIGGER,
  CONF_VIEW_TRIGGERS_FILTER_SELECTED_CAMERA,
} from '../const';
import { arrayify } from '../utils/basic';
import { AdvancedCameraCardCondition } from './schema/conditions/types';
import { RawAdvancedCameraCardConfig, RawAdvancedCameraCardConfigArray } from './types';

// *************************************************************************
//                  General Config Management Functions
// *************************************************************************

/**
 * Set a configuration value.
 * @param obj The configuration.
 * @param keys The key to the property to set.
 * @param value The value to set.
 */
export const setConfigValue = (
  obj: RawAdvancedCameraCardConfig,
  keys: string | (string | number)[],
  value: unknown,
): void => {
  set(obj, keys, value);
};

/**
 * Get a configuration value.
 * @param obj The configuration.
 * @param keys The key to the property to retrieve.
 * @param def Default if key not found.
 * @returns The property or undefined if not found.
 */
export const getConfigValue = (
  obj: RawAdvancedCameraCardConfig,
  keys: string | (string | number)[],
  def?: unknown,
): unknown => {
  return get(obj, keys, def);
};

/**
 * Delete a configuration value.
 * @param obj The configuration.
 * @param key The key to the property to delete.
 */
export const deleteConfigValue = (
  obj: RawAdvancedCameraCardConfig,
  path: string,
): void => {
  unset(obj, path);
};

/**
 * Copy a configuration.
 * @param obj Configuration to copy.
 * @returns A new deeply-copied configuration.
 */
export const copyConfig = <T>(obj: T): T => {
  return cloneDeep(obj);
};

/**
 * Given an array path, return a true path.
 * @param path The array path (should have a '#').
 * @param index The numeric array index to use.
 * @returns The true config path.
 */
export const getArrayConfigPath = (path: string, index: number): string => {
  return path.replace('#', `[${index.toString()}]`);
};

// *************************************************************************
//                  Upgrade Related Functions
// *************************************************************************

/**
 * Upgrade a configuration.
 * @param obj The configuration to upgrade.
 * @returns `true` if the configuration is modified.
 */
export const upgradeConfig = function (obj: RawAdvancedCameraCardConfig): boolean {
  let upgraded = false;
  for (let i = 0; i < UPGRADES.length; i++) {
    upgraded = UPGRADES[i](obj) || upgraded;
  }
  return upgraded;
};

/**
 * Determine if a configuration is automatically upgradeable.
 * @param obj The configuration. It is not modified.
 * @returns `true` if the configuration is upgradeable.
 */
export const isConfigUpgradeable = function (obj: RawAdvancedCameraCardConfig): boolean {
  return upgradeConfig(copyConfig(obj));
};

/**
 * Move a property from one location to another.
 * @param obj The configuration object in which the property resides.
 * @param oldPath The old property path.
 * @param newPath The new property path.
 * @param transform An optional transform for the value.
 * @returns `true` if the configuration was modified.
 */
export const moveConfigValue = (
  obj: RawAdvancedCameraCardConfig,
  oldPath: string,
  newPath: string,
  options?: {
    transform?: (valueIn: unknown) => unknown;
    keepOriginal?: boolean;
  },
): boolean => {
  const inValue = getConfigValue(obj, oldPath);
  if (inValue === undefined) {
    return false;
  }
  const outValue = options?.transform ? options.transform(inValue) : inValue;
  if (oldPath === newPath && isEqual(inValue, outValue)) {
    return false;
  }
  if (outValue === null) {
    if (!options?.keepOriginal) {
      deleteConfigValue(obj, oldPath);
      return true;
    }
    return false;
  }
  if (outValue !== undefined) {
    if (!options?.keepOriginal) {
      deleteConfigValue(obj, oldPath);
    }
    setConfigValue(obj, newPath, outValue);
    return true;
  }
  return false;
};

/**
 * Upgrade by moving a property from one location to another.
 * @param oldPath The old property path.
 * @param newPath The new property path.
 * @param transform An optional transform for the value.
 * @returns `true` if the configuration was modified.
 */
export const upgradeMoveTo = function (
  oldPath: string,
  newPath: string,
  options?: {
    transform?: (valueIn: unknown) => unknown;
    keepOriginal?: boolean;
  },
): (obj: RawAdvancedCameraCardConfig) => boolean {
  return function (obj: RawAdvancedCameraCardConfig): boolean {
    return moveConfigValue(obj, oldPath, newPath, options);
  };
};

/**
 * Upgrade by moving a property from one location to another, and moving a
 * property specified in a top-level overrides object.
 * @param oldPath The old property path.
 * @param newPath The new property path.
 * @param transform An optional transform for the value.
 * @returns A function that returns `true` if the configuration was modified.
 */
export const upgradeMoveToWithOverrides = function (
  oldPath: string,
  newPath: string,
  options?: {
    transform?: (valueIn: unknown) => unknown;
    keepOriginal?: boolean;
  },
): (obj: RawAdvancedCameraCardConfig) => boolean {
  return function (obj: RawAdvancedCameraCardConfig): boolean {
    let modified = upgradeMoveTo(oldPath, newPath, options)(obj);
    modified =
      upgradeArrayOfObjects(
        CONF_OVERRIDES,
        upgradeMoveTo(oldPath, newPath, options),
        (obj) =>
          obj.merge && typeof obj.merge === 'object'
            ? (obj.merge as RawAdvancedCameraCardConfig | undefined)
            : undefined,
      )(obj) || modified;
    modified =
      upgradeArrayOfObjects(
        CONF_OVERRIDES,
        upgradeMoveTo(oldPath, newPath, options),
        (obj) =>
          obj.set && typeof obj.set === 'object'
            ? (obj.set as RawAdvancedCameraCardConfig | undefined)
            : undefined,
      )(obj) || modified;
    return modified;
  };
};

/**
 * Upgrade a property in place with overrides.
 * @param path The old property path.
 * @param transform An optional transform for the value.
 * @returns A function that returns `true` if the configuration was modified.
 */
export const upgradeWithOverrides = function (
  path: string,
  transform: (valueIn: unknown) => unknown,
): (obj: RawAdvancedCameraCardConfig) => boolean {
  return upgradeMoveToWithOverrides(path, path, { transform: transform });
};

/**
 * Delete a property in place with overrides.
 * @param path The property path.
 * @returns A function that returns `true` if the configuration was modified.
 */
export const deleteWithOverrides = function (
  path: string,
): (obj: RawAdvancedCameraCardConfig) => boolean {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return upgradeMoveToWithOverrides(path, path, { transform: (_) => null });
};

/**
 * Given a path to an array, apply an upgrade to each object in the array.
 * @param arrayPath The path to the array to upgrade.
 * @param upgrade A function that applies an upgrade to an object.
 * @param getObject A optional function that takes an item in the array and
 * returns the object to modify within it.
 * @returns A function that returns `true` if the configuration was modified.
 */
export const upgradeArrayOfObjects = function (
  arrayPath: string,
  upgrade: (obj: RawAdvancedCameraCardConfig) => boolean,
  getObject?: (
    obj: RawAdvancedCameraCardConfig,
  ) => RawAdvancedCameraCardConfig | undefined,
): (obj: RawAdvancedCameraCardConfig) => boolean {
  return function (obj: RawAdvancedCameraCardConfig): boolean {
    let modified = false;
    const array = getConfigValue(obj, arrayPath);
    if (Array.isArray(array)) {
      array.forEach((item) => {
        const object = getObject ? getObject(item) : item;
        if (object && typeof object === 'object') {
          modified = upgrade(object) || modified;
        }
      });
    }
    return modified;
  };
};

/**
 * Recursively upgrade an object.
 * @param transform A transform applied to each object recursively.
 * @param getObject A function to get the object to be upgraded.
 * @returns An upgrade function.
 */
export const upgradeObjectRecursively = (
  transform: (data: RawAdvancedCameraCardConfig) => boolean,
  getObject?: (
    data: RawAdvancedCameraCardConfig,
  ) => RawAdvancedCameraCardConfig | undefined | null,
): ((data: RawAdvancedCameraCardConfig) => boolean) => {
  const recurse = (data: RawAdvancedCameraCardConfig): boolean => {
    let result = false;
    if (data && typeof data === 'object') {
      const object = getObject ? getObject(data) : data;
      if (object) {
        result = transform(object) || result;
      }
      if (Array.isArray(data)) {
        data.forEach((item: RawAdvancedCameraCardConfig) => {
          result = recurse(item) || result;
        });
      } else {
        Object.keys(data).forEach((key) => {
          result = recurse(data[key] as RawAdvancedCameraCardConfig) || result;
        });
      }
    }
    return result;
  };
  return recurse;
};

// *************************************************************************
//              Upgrade Related Functions: Generic Transforms
// *************************************************************************

/**
 * Create a transform that will cap a numeric value.
 * @param value The value.
 * @returns A number or null.
 */
export const createRangedTransform = function (
  transform: (value: unknown) => unknown,
  min?: number,
  max?: number,
): (valueIn: unknown) => unknown {
  return (value: unknown): unknown => {
    let transformed = transform(value);
    if (typeof transformed !== 'number') {
      return transformed;
    }
    transformed = min !== undefined ? Math.max(min, transformed as number) : transformed;
    transformed = max !== undefined ? Math.min(max, transformed as number) : transformed;
    return transformed;
  };
};

/**
 * Request a property be deleted.
 * @param _value Inbound value (not required).
 * @returns `null` to request the property be deleted.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const deleteTransform = function (_value: unknown): number | null | undefined {
  return null;
};

// *************************************************************************
//        Upgrade Related Functions: Specific Transforms / Upgraders
// *************************************************************************

/**
 * Transform a single object with multiple conditions to multiple objects with
 * single conditions
 * @param data Input data.
 * @returns `true` if the configuration was modified.
 */
const conditionToConditionsTransform = (data: unknown): boolean => {
  if (
    typeof data !== 'object' ||
    !data ||
    typeof data['conditions'] !== 'object' ||
    !data['conditions']
  ) {
    return false;
  }

  const oldConditions = data['conditions'];
  const newConditions: AdvancedCameraCardCondition[] = [];

  if (oldConditions['view'] !== undefined) {
    newConditions.push({
      condition: 'view' as const,
      views: oldConditions['view'],
    });
  }
  if (oldConditions['fullscreen'] !== undefined) {
    newConditions.push({
      condition: 'fullscreen' as const,
      fullscreen: oldConditions['fullscreen'],
    });
  }
  if (oldConditions['expand'] !== undefined) {
    newConditions.push({
      condition: 'expand' as const,
      expand: oldConditions['expand'],
    });
  }
  if (oldConditions['camera'] !== undefined) {
    newConditions.push({
      condition: 'camera' as const,
      cameras: oldConditions['camera'],
    });
  }
  if (oldConditions['media_loaded'] !== undefined) {
    newConditions.push({
      condition: 'media_loaded' as const,
      media_loaded: oldConditions['media_loaded'],
    });
  }
  if (oldConditions['state'] !== undefined && Array.isArray(oldConditions['state'])) {
    for (const stateCondition of oldConditions['state']) {
      if (
        typeof stateCondition === 'object' &&
        stateCondition &&
        (stateCondition['state'] !== undefined ||
          stateCondition['state_not'] !== undefined ||
          stateCondition['entity'] !== undefined)
      ) {
        newConditions.push({
          condition: 'state' as const,
          ...(stateCondition['state'] && {
            state: stateCondition['state'],
          }),
          ...(stateCondition['state_not'] && {
            state_not: stateCondition['state_not'],
          }),
          ...(stateCondition['entity'] && {
            entity: stateCondition['entity'],
          }),
        });
      }
    }
  }
  if (oldConditions['media_query'] !== undefined) {
    newConditions.push({
      condition: 'screen' as const,
      media_query: oldConditions['media_query'],
    });
  }

  // These conditions did not exist prior to v6.0.0 and so are not converted:
  // - display_mode
  // - triggered
  // - interaction
  // - microphone

  if (newConditions.length) {
    data['conditions'] = newConditions;
    return true;
  }
  return false;
};

const callServiceToPerformActionTransform = (data: unknown): boolean => {
  if (
    typeof data !== 'object' ||
    !data ||
    data['action'] !== 'call-service' ||
    typeof data['service'] !== 'string'
  ) {
    return false;
  }
  data['action'] = 'perform-action';
  data['perform_action'] = data['service'];
  delete data['service'];
  return true;
};

/**
 * Transform service_data -> data
 * See: https://github.com/dermotduffy/advanced-camera-card/issues/1103
 * @param data Input data.
 * @returns `true` if the configuration was modified.
 */
const serviceDataToDataTransform = (data: unknown): boolean => {
  if (
    typeof data === 'object' &&
    data &&
    data['action'] === 'call-service' &&
    data['service'] !== undefined &&
    data['service_data'] !== undefined &&
    data['data'] === undefined
  ) {
    data['data'] = data['service_data'];
    delete data['service_data'];
    return true;
  }
  return false;
};

/**
 * Transform element PTZ to native live PTZ.
 * @param data Input data.
 * @returns `true` if the configuration was modified.
 */
const upgradePTZElementsToLive = function (): (data: unknown) => boolean {
  return function (data: unknown): boolean {
    if (
      typeof data !== 'object' ||
      !data ||
      !(CONF_ELEMENTS in data) ||
      !Array.isArray(data[CONF_ELEMENTS])
    ) {
      return false;
    }

    let foundPTZ = false;
    const movePTZ = (element: RawAdvancedCameraCardConfig): void => {
      if (!foundPTZ) {
        if (!get(data, 'live.controls.ptz')) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const { type: _, ...newPTZ } = element;
          set(data, 'live.controls.ptz', newPTZ);
        }
        foundPTZ = true;
      }
    };

    const processElements = (
      elements: RawAdvancedCameraCardConfigArray,
    ): RawAdvancedCameraCardConfigArray => {
      const newElements: RawAdvancedCameraCardConfigArray = [];
      for (const element of elements) {
        if (element['type'] === 'custom:advanced-camera-card-ptz') {
          movePTZ(element);
        } else if (
          (element['type'] === 'conditional' ||
            element['type'] === 'custom:advanced-camera-card-conditional') &&
          Array.isArray(element['elements'])
        ) {
          const newConditionalElements = processElements(element['elements']);
          if (newConditionalElements.length) {
            element['elements'] = newConditionalElements;
            newElements.push(element);
          }
        } else {
          newElements.push(element);
        }
      }
      return newElements;
    };

    const newElements = processElements(data[CONF_ELEMENTS]);

    if (foundPTZ) {
      if (newElements.length) {
        data[CONF_ELEMENTS] = newElements;
      } else {
        delete data[CONF_ELEMENTS];
      }
    }
    return foundPTZ;
  };
};

const ptzActionsToCamerasGlobalTransform = (data: unknown): unknown => {
  if (typeof data !== 'object' || !data) {
    return undefined;
  }

  const NON_PRESET_DATA_KEYS = [
    'data_left',
    'data_right',
    'data_up',
    'data_down',
    'data_zoom_in',
    'data_zoom_out',
    'service',
  ];

  const NON_PRESET_ACTION_KEYS = [
    // 'actions_' will overwrite 'data_*' if there's duplication.
    'actions_left',
    'actions_right',
    'actions_up',
    'actions_down',
    'actions_zoom_in',
    'actions_zoom_out',
  ];

  const PRESET_TRANSFORM_KEYS = ['data_home', 'actions_home'];
  const TRANSFORM_KEYS = [
    ...NON_PRESET_DATA_KEYS,
    ...NON_PRESET_ACTION_KEYS,
    ...PRESET_TRANSFORM_KEYS,
  ];

  const keys = Object.keys(data);
  const hasTransformable = keys.some((key) => TRANSFORM_KEYS.includes(key));
  if (!hasTransformable) {
    return undefined;
  }

  const output = {};

  NON_PRESET_DATA_KEYS.filter((key) => key in data).reduce((obj, key) => {
    obj[key] = data[key];
    return obj;
  }, output);

  NON_PRESET_ACTION_KEYS.filter((key) => key in data).reduce((obj, key) => {
    if (typeof data[key] === 'object' && 'tap_action' in data[key]) {
      obj[key] = data[key]['tap_action'];
    }
    return obj;
  }, output);

  const createPresets = () => {
    output['presets'] =
      'presets' in data && typeof data['presets'] === 'object' && !!data['presets']
        ? data['presets']
        : {};
  };

  if (
    'actions_home' in data &&
    typeof data['actions_home'] === 'object' &&
    data['actions_home'] &&
    'tap_action' in data['actions_home']
  ) {
    createPresets();
    output['presets']['home'] = data['actions_home']['tap_action'];
  } else if (
    'data_home' in data &&
    typeof data['data_home'] === 'object' &&
    data['data_home'] &&
    typeof data['service'] === 'string'
  ) {
    createPresets();
    output['presets']['service'] = data['service'];
    output['presets']['data_home'] = data['data_home'];
  }

  return output;
};

const ptzControlSettingsTransform = (data: unknown): unknown => {
  if (typeof data !== 'object' || !data) {
    return data;
  }

  const TRANSFORM_KEYS = [
    'mode',
    'position',
    'orientation',
    'hide_pan_tilt',
    'hide_zoom',
    'hide_home',
    'style',
  ];

  const keys = Object.keys(data);
  const hasSomethingToFilter = keys.some((key) => !TRANSFORM_KEYS.includes(key));
  if (!hasSomethingToFilter) {
    return undefined;
  }

  return keys
    .filter((key) => TRANSFORM_KEYS.includes(key))
    .reduce((obj, key) => {
      obj[key] = data[key];
      return obj;
    }, {});
};

const titleControlTransform = (data: unknown): unknown => {
  if (typeof data !== 'object' || !data || typeof data['mode'] !== 'string') {
    return null;
  }
  if (data['mode'] === 'none') {
    return {
      style: 'none',
    };
  }
  if (data['mode'].includes('bottom')) {
    return {
      position: 'bottom',
    };
  } else if (data['mode'].includes('top')) {
    return {
      position: 'top',
    };
  }
  return null;
};

const frigateCardToAdvancedCameraCardTransform = (
  data: RawAdvancedCameraCardConfig,
): boolean => {
  interface Substitution {
    oldKey: string;
    oldValue?: string;
    newKey?: string;
    newValue?: string;
  }

  const substitutions: Substitution[] = [
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card',
      newValue: 'custom:advanced-camera-card',
    },
    {
      oldKey: 'action',
      oldValue: 'custom:frigate-card-action',
      newValue: 'custom:advanced-camera-card-action',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-menu-icon',
      newValue: 'custom:advanced-camera-card-menu-icon',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-menu-state-icon',
      newValue: 'custom:advanced-camera-card-menu-state-icon',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-menu-submenu',
      newValue: 'custom:advanced-camera-card-menu-submenu',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-menu-submenu-select',
      newValue: 'custom:advanced-camera-card-menu-submenu-select',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-status-bar-icon',
      newValue: 'custom:advanced-camera-card-status-bar-icon',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-status-bar-image',
      newValue: 'custom:advanced-camera-card-status-bar-image',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-status-bar-string',
      newValue: 'custom:advanced-camera-card-status-bar-string',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-conditional',
      newValue: 'custom:advanced-camera-card-conditional',
    },
    {
      oldKey: 'type',
      oldValue: 'custom:frigate-card-conditional',
      newValue: 'custom:advanced-camera-card-conditional',
    },
    {
      oldKey: 'frigate_card_action',
      newKey: 'advanced_camera_card_action',
    },
  ];

  let modified = false;
  for (const substitution of substitutions) {
    if (
      substitution.oldValue &&
      substitution.newValue &&
      data[substitution.oldKey] === substitution.oldValue
    ) {
      data[substitution.newKey ?? substitution.oldKey] = substitution.newValue;
      modified = true;
    }
    if (substitution.oldKey in data && substitution.newKey) {
      data[substitution.newKey] = data[substitution.oldKey];
      delete data[substitution.oldKey];
      modified = true;
    }
  }
  return modified;
};

const frigateCardToAdvancedCameraCardStyleTransform = (data: unknown): unknown => {
  if (typeof data !== 'object' || !data || Array.isArray(data)) {
    return data;
  }

  const newStyleOverrides = { ...data };
  const frigateCardStyleRegexp = new RegExp(/^--frigate-card-/);

  for (const key of Object.keys(data)) {
    if (key.match(frigateCardStyleRegexp)) {
      const newKey = key.replace(frigateCardStyleRegexp, '--advanced-camera-card-');

      newStyleOverrides[newKey] = data[key];
      delete newStyleOverrides[key];
    }
  }

  return newStyleOverrides;
};

const UPGRADES = [
  // v5.2.0 -> v6.0.0
  (data: unknown): boolean => {
    return upgradeObjectRecursively(serviceDataToDataTransform)(
      typeof data === 'object' && data ? <RawAdvancedCameraCardConfig>data : {},
    );
  },
  upgradePTZElementsToLive(),
  upgradeMoveToWithOverrides('view.timeout_seconds', CONF_VIEW_INTERACTION_SECONDS),
  upgradeWithOverrides('live.lazy_unload', (data) =>
    data === 'all' ? ['unselected', 'hidden'] : data === 'never' ? null : arrayify(data),
  ),
  upgradeWithOverrides('live.auto_play', (data) =>
    data === 'all' ? null : data === 'never' ? [] : arrayify(data),
  ),
  upgradeWithOverrides('live.auto_pause', (data) =>
    data === 'all' ? ['unselected', 'hidden'] : data === 'never' ? null : arrayify(data),
  ),
  upgradeWithOverrides('live.auto_mute', (data) =>
    data === 'all' ? null : data === 'never' ? [] : arrayify(data),
  ),
  upgradeWithOverrides('live.auto_unmute', (data) =>
    data === 'all'
      ? ['selected', 'visible', 'microphone']
      : data === 'never'
        ? null
        : arrayify(data),
  ),
  upgradeWithOverrides('media_viewer.auto_play', (data) =>
    data === 'all' ? null : data === 'never' ? [] : arrayify(data),
  ),
  upgradeWithOverrides('media_viewer.auto_pause', (data) =>
    data === 'all' ? null : data === 'never' ? [] : arrayify(data),
  ),
  upgradeWithOverrides('media_viewer.auto_mute', (data) =>
    data === 'all' ? null : data === 'never' ? [] : arrayify(data),
  ),
  upgradeWithOverrides('media_viewer.auto_unmute', (data) =>
    data === 'all' ? ['selected', 'visible'] : data === 'never' ? null : arrayify(data),
  ),
  upgradeMoveToWithOverrides(
    'live.controls.thumbnails.media',
    CONF_LIVE_CONTROLS_THUMBNAILS_EVENTS_MEDIA_TYPE,
  ),
  upgradeMoveToWithOverrides('timeline.media', CONF_TIMELINE_EVENTS_MEDIA_TYPE),
  upgradeMoveToWithOverrides(
    'live.controls.timeline.media',
    CONF_LIVE_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
  ),
  upgradeMoveToWithOverrides(
    'media_viewer.controls.timeline.media',
    CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_EVENTS_MEDIA_TYPE,
  ),
  upgradeMoveToWithOverrides('view.scan', CONF_VIEW_TRIGGERS),
  upgradeMoveToWithOverrides(
    'view.triggers.enabled',
    CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER,
    {
      transform: (data) => (data === true ? 'live' : null),
      // Keep it around, for the following transform.
      keepOriginal: true,
    },
  ),
  upgradeMoveToWithOverrides(
    'view.triggers.enabled',
    CONF_VIEW_TRIGGERS_FILTER_SELECTED_CAMERA,
    {
      transform: (data) => (data === true ? false : null),
    },
  ),
  upgradeMoveToWithOverrides(
    'view.triggers.untrigger_reset',
    CONF_VIEW_TRIGGERS_ACTIONS_UNTRIGGER,
    {
      // Delete the value if it's set to the default.
      transform: (val) => (val ? 'default' : null),
    },
  ),
  upgradeMoveToWithOverrides('live.layout', CONF_CAMERAS_GLOBAL_DIMENSIONS_LAYOUT),
  deleteWithOverrides('media_viewer.layout'),
  deleteWithOverrides('image.layout'),
  upgradeArrayOfObjects(CONF_OVERRIDES, conditionToConditionsTransform),
  (data: unknown): boolean => {
    return upgradeObjectRecursively(conditionToConditionsTransform)(
      typeof data === 'object' && data ? data[CONF_ELEMENTS] : {},
    );
  },
  (data: unknown): boolean => {
    return upgradeObjectRecursively(conditionToConditionsTransform)(
      typeof data === 'object' && data ? data[CONF_AUTOMATIONS] : {},
    );
  },
  upgradeArrayOfObjects(
    CONF_CAMERAS,
    upgradeMoveToWithOverrides('hide', 'capabilities', {
      transform: (val) => (val === true ? { disable_except: ['substream'] } : null),
    }),
  ),
  upgradeMoveToWithOverrides('performance.profile', CONF_PROFILES, {
    // Delete the value if it's set to the default.
    transform: (val) => (val === 'low' ? ['low-performance'] : null),
  }),
  upgradeArrayOfObjects(CONF_OVERRIDES, upgradeMoveTo('overrides', 'merge')),
  upgradeMoveToWithOverrides('live.controls.ptz', CONF_CAMERAS_GLOBAL_PTZ, {
    transform: ptzActionsToCamerasGlobalTransform,
    keepOriginal: true,
  }),
  upgradeWithOverrides('live.controls.ptz', ptzControlSettingsTransform),
  upgradeMoveToWithOverrides('view.update_cycle_camera', CONF_VIEW_DEFAULT_CYCLE_CAMERA),
  upgradeMoveToWithOverrides(
    'view.update_force',
    CONF_VIEW_DEFAULT_RESET_INTERACTION_MODE,
    {
      transform: (val) => (val === true ? 'all' : null),
    },
  ),
  upgradeMoveToWithOverrides(
    'view.update_seconds',
    CONF_VIEW_DEFAULT_RESET_EVERY_SECONDS,
  ),
  upgradeMoveToWithOverrides('view.update_entities', CONF_VIEW_DEFAULT_RESET_ENTITIES),
  upgradeMoveTo('live.controls.title', CONF_STATUS_BAR, {
    transform: titleControlTransform,
  }),
  deleteWithOverrides('live.controls.title'),
  deleteWithOverrides('media_viewer.controls.title'),

  // Upgrade call-service calls throughout the card config. They could show up
  // attached to any element, any automation, or any card/view action (i.e. very
  // broadly across the config), so it's challenging to better target this
  // upgrade. As written, this will convert things that look like call-service
  // calls recurseively throughout the whole card config, but this could
  // conceivably be an overreach if (e.g.) some totally unrelated object has {
  // action: 'call-service', service: '<any string>' } that means something
  // different.
  (data: unknown): boolean => {
    return upgradeObjectRecursively(callServiceToPerformActionTransform)(
      typeof data === 'object' && data ? (data as RawAdvancedCameraCardConfig) : {},
    );
  },
  upgradeMoveToWithOverrides('dimensions.max_height', CONF_DIMENSIONS_HEIGHT),
  deleteWithOverrides('dimensions.min_height'),

  // v6.1.2+
  upgradeMoveToWithOverrides('view.dark_mode', CONF_VIEW_DIM, {
    transform: (val) => val === 'on',
  }),

  // v7.0.0+
  (data: unknown): boolean => {
    return upgradeObjectRecursively(frigateCardToAdvancedCameraCardTransform)(
      typeof data === 'object' && data ? (data as RawAdvancedCameraCardConfig) : {},
    );
  },
  upgradeWithOverrides(
    'view.theme.overrides',
    frigateCardToAdvancedCameraCardStyleTransform,
  ),
  upgradeMoveToWithOverrides('menu.buttons.frigate', 'menu.buttons.iris'),
];



================================================
FILE: src/config/types.ts
================================================
export type RawAdvancedCameraCardConfig = Record<string, unknown>;
export type RawAdvancedCameraCardConfigArray = RawAdvancedCameraCardConfig[];



================================================
FILE: src/config/profiles/casting.ts
================================================
import {
  CONF_CAMERAS_GLOBAL_IMAGE_REFRESH_SECONDS,
  CONF_DIMENSIONS_ASPECT_RATIO,
  CONF_DIMENSIONS_ASPECT_RATIO_MODE,
  CONF_LIVE_AUTO_UNMUTE,
  CONF_LIVE_CONTROLS_BUILTIN,
  CONF_LIVE_SHOW_IMAGE_DURING_LOAD,
  CONF_MEDIA_VIEWER_CONTROLS_BUILTIN,
  CONF_MENU_BUTTONS_FULLSCREEN,
  CONF_MENU_BUTTONS_MEDIA_PLAYER,
  CONF_MENU_BUTTONS_MUTE,
  CONF_MENU_BUTTONS_PLAY,
  CONF_MENU_STYLE,
} from '../../const.js';

export const CASTING_PROFILE = {
  [CONF_LIVE_CONTROLS_BUILTIN]: false,
  [CONF_MEDIA_VIEWER_CONTROLS_BUILTIN]: false,

  // TVs are generally not touch-enabled, so we don't want to show the menu
  [CONF_MENU_STYLE]: 'none',

  // But in case the user enables the menu, let's make sure to enable the
  // buttons that make sense and disable the ones that don't
  [`${CONF_MENU_BUTTONS_PLAY}.enabled`]: true,
  [`${CONF_MENU_BUTTONS_MUTE}.enabled`]: true,
  [`${CONF_MENU_BUTTONS_FULLSCREEN}.enabled`]: false,
  [`${CONF_MENU_BUTTONS_MEDIA_PLAYER}.enabled`]: false,

  [CONF_LIVE_AUTO_UNMUTE]: ['selected', 'visible'],

  [CONF_DIMENSIONS_ASPECT_RATIO_MODE]: 'static',
  [CONF_DIMENSIONS_ASPECT_RATIO]: '16:9',

  // These values are defaults anyway unless another profile (e.g.
  // low-performance) is also selected, but at pretty important to a good
  // experience so are reset here.
  [CONF_CAMERAS_GLOBAL_IMAGE_REFRESH_SECONDS]: 1,
  [CONF_LIVE_SHOW_IMAGE_DURING_LOAD]: true,
};



================================================
FILE: src/config/profiles/low-performance.ts
================================================
import {
  CONF_CAMERAS_GLOBAL_IMAGE_REFRESH_SECONDS,
  CONF_CAMERAS_GLOBAL_LIVE_PROVIDER,
  CONF_CAMERAS_GLOBAL_TRIGGERS_OCCUPANCY,
  CONF_LIVE_AUTO_MUTE,
  CONF_LIVE_CONTROLS_THUMBNAILS_MODE,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_LIVE_CONTROLS_TIMELINE_SHOW_RECORDINGS,
  CONF_LIVE_DRAGGABLE,
  CONF_LIVE_LAZY_UNLOAD,
  CONF_LIVE_SHOW_IMAGE_DURING_LOAD,
  CONF_LIVE_TRANSITION_EFFECT,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_MEDIA_VIEWER_AUTO_MUTE,
  CONF_MEDIA_VIEWER_AUTO_PAUSE,
  CONF_MEDIA_VIEWER_AUTO_PLAY,
  CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_STYLE,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_MODE,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_SHOW_RECORDINGS,
  CONF_MEDIA_VIEWER_DRAGGABLE,
  CONF_MEDIA_VIEWER_SNAPSHOT_CLICK_PLAYS_CLIP,
  CONF_MEDIA_VIEWER_TRANSITION_EFFECT,
  CONF_MENU_BUTTONS_IRIS,
  CONF_MENU_BUTTONS_MEDIA_PLAYER,
  CONF_MENU_BUTTONS_TIMELINE,
  CONF_MENU_STYLE,
  CONF_PERFORMANCE_FEATURES_ANIMATED_PROGRESS_INDICATOR,
  CONF_PERFORMANCE_FEATURES_CARD_LOADING_INDICATOR,
  CONF_PERFORMANCE_FEATURES_MAX_SIMULTANEOUS_ENGINE_REQUESTS,
  CONF_PERFORMANCE_FEATURES_MEDIA_CHUNK_SIZE,
  CONF_PERFORMANCE_STYLE_BORDER_RADIUS,
  CONF_PERFORMANCE_STYLE_BOX_SHADOW,
  CONF_STATUS_BAR_STYLE,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_MODE,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DETAILS,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL,
  CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL,
  CONF_TIMELINE_SHOW_RECORDINGS,
  CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER,
} from '../../const.js';

export const LOW_PERFORMANCE_PROFILE = {
  // Disable thumbnail carousels.
  [CONF_LIVE_CONTROLS_THUMBNAILS_MODE]: 'none' as const,
  [CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_MODE]: 'none' as const,
  [CONF_TIMELINE_CONTROLS_THUMBNAILS_MODE]: 'none' as const,

  // Do not show recordings on timelines.
  [CONF_LIVE_CONTROLS_TIMELINE_SHOW_RECORDINGS]: false,
  [CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_SHOW_RECORDINGS]: false,
  [CONF_TIMELINE_SHOW_RECORDINGS]: false,

  // Take no automatic media actions.
  [CONF_LIVE_AUTO_MUTE]: [],
  [CONF_MEDIA_VIEWER_AUTO_PLAY]: [],
  [CONF_MEDIA_VIEWER_AUTO_PAUSE]: [],
  [CONF_MEDIA_VIEWER_AUTO_MUTE]: [],

  // Always unload resources that are lazily loaded.
  [CONF_LIVE_LAZY_UNLOAD]: ['unselected', 'hidden'],

  // Media carousels do not drag.
  [CONF_LIVE_DRAGGABLE]: false,
  [CONF_MEDIA_VIEWER_DRAGGABLE]: false,

  // Media carousels have no effects.
  [CONF_LIVE_TRANSITION_EFFECT]: 'none' as const,
  [CONF_MEDIA_VIEWER_TRANSITION_EFFECT]: 'none' as const,

  // Do not show image during load.
  [CONF_LIVE_SHOW_IMAGE_DURING_LOAD]: false,

  // Media player next/previous are chevrons.
  [CONF_MEDIA_VIEWER_CONTROLS_NEXT_PREVIOUS_STYLE]: 'chevrons' as const,

  // Disable the status bar.
  [CONF_STATUS_BAR_STYLE]: 'none' as const,

  // Move the menu to outside to remove the need to interact with it with open.
  [CONF_MENU_STYLE]: 'outside',

  // Hide several buttons that are otherwise visible by default.
  [`${CONF_MENU_BUTTONS_IRIS}.enabled`]: false,
  [`${CONF_MENU_BUTTONS_TIMELINE}.enabled`]: false,
  [`${CONF_MENU_BUTTONS_TIMELINE}.enabled`]: false,

  // If the media player button is present media player entity fetches are
  // required on initialization.
  [`${CONF_MENU_BUTTONS_MEDIA_PLAYER}.enabled`]: false,

  // Disable all options in thumbnails.
  [CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL]: false,
  [CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL]: false,
  [CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL]: false,
  [CONF_MEDIA_GALLERY_CONTROLS_THUMBNAILS_SHOW_DETAILS]: false,
  [CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL]: false,
  [CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL]: false,
  [CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL]: false,
  [CONF_LIVE_CONTROLS_THUMBNAILS_SHOW_DETAILS]: false,
  [CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL]: false,
  [CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL]: false,
  [CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL]: false,
  [CONF_MEDIA_VIEWER_CONTROLS_THUMBNAILS_SHOW_DETAILS]: false,
  [CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DOWNLOAD_CONTROL]: false,
  [CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_FAVORITE_CONTROL]: false,
  [CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_TIMELINE_CONTROL]: false,
  [CONF_TIMELINE_CONTROLS_THUMBNAILS_SHOW_DETAILS]: false,

  // Disable all optional performance related features.
  [CONF_PERFORMANCE_FEATURES_ANIMATED_PROGRESS_INDICATOR]: false,
  [CONF_PERFORMANCE_FEATURES_CARD_LOADING_INDICATOR]: false,

  // Load fewer media items by default.
  [CONF_PERFORMANCE_FEATURES_MEDIA_CHUNK_SIZE]: 10,

  // Disable all expensive CSS features.
  [CONF_PERFORMANCE_STYLE_BORDER_RADIUS]: false,
  [CONF_PERFORMANCE_STYLE_BOX_SHADOW]: false,

  // Clicking on a snapshot should not play a clip.
  [CONF_MEDIA_VIEWER_SNAPSHOT_CLICK_PLAYS_CLIP]: false,

  [CONF_CAMERAS_GLOBAL_TRIGGERS_OCCUPANCY]: false,
  [CONF_CAMERAS_GLOBAL_LIVE_PROVIDER]: 'image',

  // Refresh the live camera image every 10 seconds (same as stock Home
  // Assistant Picture Glance).
  [CONF_CAMERAS_GLOBAL_IMAGE_REFRESH_SECONDS]: 10,

  // No trigger actions.
  [CONF_VIEW_TRIGGERS_ACTIONS_TRIGGER]: 'none',

  // One engine request at a time.
  [CONF_PERFORMANCE_FEATURES_MAX_SIMULTANEOUS_ENGINE_REQUESTS]: 1,
};



================================================
FILE: src/config/profiles/scrubbing.ts
================================================
import {
  CONF_LIVE_CONTROLS_TIMELINE_MODE,
  CONF_LIVE_CONTROLS_TIMELINE_PAN_MODE,
  CONF_LIVE_CONTROLS_TIMELINE_STYLE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_MODE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_PAN_MODE,
  CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_STYLE,
} from '../../const.js';

export const SCRUBBING_PROFILE = {
  [CONF_LIVE_CONTROLS_TIMELINE_MODE]: 'below' as const,
  [CONF_LIVE_CONTROLS_TIMELINE_STYLE]: 'ribbon' as const,
  [CONF_LIVE_CONTROLS_TIMELINE_PAN_MODE]: 'seek' as const,

  [CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_MODE]: 'below' as const,
  [CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_STYLE]: 'ribbon' as const,
  [CONF_MEDIA_VIEWER_CONTROLS_TIMELINE_PAN_MODE]: 'seek' as const,
};



================================================
FILE: src/config/profiles/set-profiles.ts
================================================
import { deepRemoveDefaults } from '../../utils/zod.js';
import { getConfigValue, setConfigValue } from '../management.js';
import { ProfileType } from '../schema/profiles.js';
import { advancedCameraCardConfigSchema } from '../schema/types.js';
import { RawAdvancedCameraCardConfig } from '../types.js';
import { CASTING_PROFILE } from './casting.js';
import { LOW_PERFORMANCE_PROFILE } from './low-performance.js';
import { SCRUBBING_PROFILE } from './scrubbing.js';

const PROFILES = {
  casting: CASTING_PROFILE,
  'low-performance': LOW_PERFORMANCE_PROFILE,
  scrubbing: SCRUBBING_PROFILE,
};

/**
 * Set a profile. Sets flags as defined in the relevant profile unless they are
 * explicitly overriden in the configuration.
 * @param inputConfig The raw unparsed input configuration.
 * @param outputConfig The output config to write to.
 * @returns A changed (in-place) parsed input configuration.
 */
export const setProfiles = <T extends RawAdvancedCameraCardConfig>(
  inputConfig: RawAdvancedCameraCardConfig,
  outputConfig: T,
  profiles?: ProfileType[],
): T => {
  const defaultLessParseResult = deepRemoveDefaults(
    advancedCameraCardConfigSchema,
  ).safeParse(inputConfig);
  if (!defaultLessParseResult.success) {
    return outputConfig;
  }
  const defaultLessConfig = defaultLessParseResult.data;

  const setIfNotSpecified = (key: string, value: unknown) => {
    if (getConfigValue(defaultLessConfig, key) === undefined) {
      setConfigValue(outputConfig, key, value);
    }
  };

  for (const profile of profiles ?? []) {
    if (profile in PROFILES) {
      Object.entries(PROFILES[profile]).forEach(([k, v]: [string, unknown]) =>
        setIfNotSpecified(k, v),
      );
    }
  }

  return outputConfig;
};



================================================
FILE: src/config/schema/automations.ts
================================================
import { z } from 'zod';
import { actionConfigSchema } from './actions/types';
import { advancedCameraCardConditionSchema } from './conditions/types';

const automationActionsSchema = actionConfigSchema.array();
export type AutomationActions = z.infer<typeof automationActionsSchema>;

const automationSchema = z
  .object({
    conditions: advancedCameraCardConditionSchema.array(),
    actions: automationActionsSchema.optional(),
    actions_not: automationActionsSchema.optional(),
  })
  .refine(
    (data) => data.actions?.length || data.actions_not?.length,
    'Automations must include at least one action',
  );
export type Automation = z.infer<typeof automationSchema>;

export const automationsSchema = automationSchema.array();



================================================
FILE: src/config/schema/cameras.ts
================================================
import { z } from 'zod';
import { capabilityKeys } from '../../types';
import { mediaLayoutConfigSchema } from './camera/media-layout';
import { ptzCameraConfigDefaults, ptzCameraConfigSchema } from './camera/ptz';
import { aspectRatioSchema } from './common/aspect-ratio';
import { imageBaseConfigSchema, imageConfigDefault } from './common/image';

const CAMERA_TRIGGER_EVENT_TYPES = [
  // An event whether or not it has any media yet associated with it.
  'events',

  // Specific media availability.
  'clips',
  'snapshots',
] as const;
export type CameraTriggerEventType = (typeof CAMERA_TRIGGER_EVENT_TYPES)[number];

// *************************************************************************
//                       Live Provider Configuration
// *************************************************************************

const LIVE_PROVIDERS = [
  'auto',
  'image',
  'ha',
  'jsmpeg',
  'go2rtc',
  'webrtc-card',
] as const;
export type LiveProvider = (typeof LIVE_PROVIDERS)[number];

const go2rtcConfigSchema = z.object({
  url: z
    .string()
    .transform((input) => input.replace(/\/+$/, ''))
    .optional(),
  host: z.string().optional(),
  modes: z.enum(['webrtc', 'mse', 'mp4', 'mjpeg']).array().optional(),
  stream: z.string().optional(),
});

const webrtcCardConfigSchema = z
  .object({
    entity: z.string().optional(),
    url: z.string().optional(),
  })
  .passthrough();

const jsmpegConfigSchema = z.object({
  options: z
    .object({
      // https://github.com/phoboslab/jsmpeg#usage
      audio: z.boolean().optional(),
      video: z.boolean().optional(),
      pauseWhenHidden: z.boolean().optional(),
      disableGl: z.boolean().optional(),
      disableWebAssembly: z.boolean().optional(),
      preserveDrawingBuffer: z.boolean().optional(),
      progressive: z.boolean().optional(),
      throttled: z.boolean().optional(),
      chunkSize: z.number().optional(),
      maxAudioLag: z.number().optional(),
      videoBufferSize: z.number().optional(),
      audioBufferSize: z.number().optional(),
    })
    .optional(),
});

// *************************************************************************
//                       Cast Configuration
// *************************************************************************

const castConfigDefault = {
  method: 'standard' as const,
};

const castSchema = z.object({
  method: z.enum(['standard', 'dashboard']).default(castConfigDefault.method).optional(),
  dashboard: z
    .object({
      dashboard_path: z.string().optional(),
      view_path: z.string().optional(),
    })
    .optional(),
});

// *************************************************************************
//                     Camera Configuration
// *************************************************************************

const ENGINES = ['auto', 'frigate', 'generic', 'motioneye', 'reolink'] as const;

export const cameraConfigDefault = {
  dependencies: {
    all_cameras: false,
    cameras: [],
  },
  engine: 'auto' as const,
  frigate: {
    client_id: 'frigate' as const,
  },
  live_provider: 'auto' as const,
  motioneye: {
    images: {
      directory_pattern: '%Y-%m-%d' as const,
      file_pattern: '%H-%M-%S' as const,
    },
    movies: {
      directory_pattern: '%Y-%m-%d' as const,
      file_pattern: '%H-%M-%S' as const,
    },
  },
  reolink: {
    media_resolution: 'low' as const,
  },
  ptz: ptzCameraConfigDefaults,
  triggers: {
    motion: false,
    occupancy: false,
    events: [...CAMERA_TRIGGER_EVENT_TYPES],
    entities: [],
  },
  proxy: {
    media: 'auto' as const,
    dynamic: true,
    ssl_verification: 'auto' as const,
    ssl_ciphers: 'auto' as const,
  },
  always_error_if_entity_unavailable: false,
};

const SSL_CIPHERS = ['default', 'insecure', 'intermediate', 'modern'] as const;
export type SSLCiphers = (typeof SSL_CIPHERS)[number];

const proxyConfigSchema = z.object({
  media: z.boolean().or(z.literal('auto')).default(cameraConfigDefault.proxy.media),
  dynamic: z.boolean().default(cameraConfigDefault.proxy.dynamic),
  ssl_verification: z
    .boolean()
    .or(z.literal('auto'))
    .default(cameraConfigDefault.proxy.ssl_verification),
  ssl_ciphers: z
    .enum(SSL_CIPHERS)
    .or(z.literal('auto'))
    .default(cameraConfigDefault.proxy.ssl_ciphers),
});
export type ProxyConfig = z.infer<typeof proxyConfigSchema>;

export const cameraConfigSchema = z
  .object({
    camera_entity: z.string().optional(),

    // Used for presentation in the UI (autodetected from the entity if
    // specified).
    icon: z.string().optional(),
    title: z.string().optional(),

    capabilities: z
      .object({
        disable: z.enum(capabilityKeys).array().optional(),
        disable_except: z.enum(capabilityKeys).array().optional(),
      })
      .optional(),

    // Optional identifier to separate different camera configurations used in
    // this card.
    id: z.string().optional(),

    dependencies: z
      .object({
        all_cameras: z.boolean().default(cameraConfigDefault.dependencies.all_cameras),
        cameras: z.string().array().default(cameraConfigDefault.dependencies.cameras),
      })
      .default(cameraConfigDefault.dependencies),

    triggers: z
      .object({
        motion: z.boolean().default(cameraConfigDefault.triggers.motion),
        occupancy: z.boolean().default(cameraConfigDefault.triggers.occupancy),
        entities: z.string().array().default(cameraConfigDefault.triggers.entities),
        events: z
          .enum(CAMERA_TRIGGER_EVENT_TYPES)
          .array()
          .default(cameraConfigDefault.triggers.events),
      })
      .default(cameraConfigDefault.triggers),

    // Engine options.
    engine: z.enum(ENGINES).default('auto'),
    frigate: z
      .object({
        url: z.string().optional(),
        client_id: z.string().default(cameraConfigDefault.frigate.client_id),
        camera_name: z.string().optional(),
        labels: z.string().array().optional(),
        zones: z.string().array().optional(),
      })
      .default(cameraConfigDefault.frigate),
    motioneye: z
      .object({
        url: z.string().optional(),
        images: z
          .object({
            directory_pattern: z
              .string()
              .includes('%')
              .default(cameraConfigDefault.motioneye.images.directory_pattern),
            file_pattern: z
              .string()
              .includes('%')
              .default(cameraConfigDefault.motioneye.images.file_pattern),
          })
          .default(cameraConfigDefault.motioneye.images),
        movies: z
          .object({
            directory_pattern: z
              .string()
              .includes('%')
              .default(cameraConfigDefault.motioneye.movies.directory_pattern),
            file_pattern: z
              .string()
              .includes('%')
              .default(cameraConfigDefault.motioneye.movies.file_pattern),
          })
          .default(cameraConfigDefault.motioneye.movies),
      })
      .default(cameraConfigDefault.motioneye),
    reolink: z
      .object({
        url: z.string().optional(),
        channel: z.number().optional(),
        media_resolution: z
          .enum(['high', 'low'])
          .default(cameraConfigDefault.reolink.media_resolution),
      })
      .default(cameraConfigDefault.reolink),

    // Live provider options.
    live_provider: z.enum(LIVE_PROVIDERS).default(cameraConfigDefault.live_provider),
    go2rtc: go2rtcConfigSchema.optional(),
    image: imageBaseConfigSchema.optional().default(imageConfigDefault),
    jsmpeg: jsmpegConfigSchema.optional(),
    webrtc_card: webrtcCardConfigSchema.optional(),

    cast: castSchema.optional(),

    ptz: ptzCameraConfigSchema.default(cameraConfigDefault.ptz),

    dimensions: z
      .object({
        aspect_ratio: aspectRatioSchema.optional(),
        layout: mediaLayoutConfigSchema.optional(),
      })
      .optional(),

    proxy: proxyConfigSchema.default(cameraConfigDefault.proxy),

    // See: https://github.com/dermotduffy/advanced-camera-card/issues/1650
    always_error_if_entity_unavailable: z
      .boolean()
      .default(cameraConfigDefault.always_error_if_entity_unavailable),
  })
  .default(cameraConfigDefault);
export type CameraConfig = z.infer<typeof cameraConfigSchema>;

// Avoid using .nonempty() to avoid changing the inferred type
// (https://github.com/colinhacks/zod#minmaxlength).
export const camerasConfigSchema = cameraConfigSchema.array().min(1);
export type CamerasConfig = z.infer<typeof camerasConfigSchema>;



================================================
FILE: src/config/schema/debug.ts
================================================
import { z } from 'zod';

export const debugConfigDefault = {
  logging: false,
};

export const debugConfigSchema = z
  .object({
    logging: z.boolean().default(debugConfigDefault.logging),
  })
  .default(debugConfigDefault);
export type DebugConfig = z.infer<typeof debugConfigSchema>;



================================================
FILE: src/config/schema/dimensions.ts
================================================
import { z } from 'zod';
import { aspectRatioSchema } from './common/aspect-ratio';

const dimensionsConfigDefault = {
  aspect_ratio_mode: 'dynamic' as const,
  aspect_ratio: [16, 9],
  height: 'auto',
};

export const dimensionsConfigSchema = z
  .object({
    aspect_ratio_mode: z
      .enum(['dynamic', 'static', 'unconstrained'])
      .default(dimensionsConfigDefault.aspect_ratio_mode),
    aspect_ratio: aspectRatioSchema.default(dimensionsConfigDefault.aspect_ratio),
    height: z.string().default(dimensionsConfigDefault.height),
  })
  .default(dimensionsConfigDefault);



================================================
FILE: src/config/schema/folders.ts
================================================
import { NonEmptyTuple } from 'type-fest';
import { z } from 'zod';
import { AdvancedCameraCardError } from '../../types';
import { isTruthy } from '../../utils/basic';
import { regexSchema } from './common/regex';

export const HA_MEDIA_SOURCE_ROOT = 'media-source://';

export const folderTypeSchema = z.enum(['ha']);
export type FolderType = z.infer<typeof folderTypeSchema>;

const folderConfigDefault = {
  type: 'ha' as const,
  ha: {},
};

const startdateParserSchema = z.object({
  type: z.literal('startdate'),
  format: z.string().optional(),
  regexp: regexSchema.optional(),
});
// Simple alias date -> startdate.
const dateParserSchema = startdateParserSchema.extend({
  type: z.literal('date'),
});
const parserSchema = z.discriminatedUnion('type', [
  dateParserSchema,
  startdateParserSchema,
]);
export type Parser = z.infer<typeof parserSchema>;

const startDateMatcherSchema = z.object({
  type: z.literal('startdate'),
  since: z.object({
    years: z.number().int().min(0).optional(),
    months: z.number().int().min(0).optional(),
    days: z.number().int().min(0).optional(),
    hours: z.number().int().min(0).optional(),
    minutes: z.number().int().min(0).optional(),
  }),
});
export type StartDateMatcher = z.infer<typeof startDateMatcherSchema>;

// Simple alias date -> startdate.
const dateMatcherSchema = startDateMatcherSchema.extend({
  type: z.literal('date'),
});
export type DateMatcher = z.infer<typeof dateMatcherSchema>;

const templateMatcherSchema = z.object({
  type: z.literal('template'),
  value_template: z.string(),
});
export type TemplateMatcher = z.infer<typeof templateMatcherSchema>;

const titleMatcherSchema = z.object({
  type: z.literal('title'),
  regexp: regexSchema.optional(),
  title: z.string().optional(),
});
export type TitleMatcher = z.infer<typeof titleMatcherSchema>;

type OrMatcher = {
  type: 'or';
  matchers: Matcher[];
};
const orMatcherSchema: z.ZodSchema<OrMatcher, z.ZodTypeDef> = z.object({
  type: z.literal('or'),
  matchers: z.array(z.lazy(() => matcherSchema)),
});
export const matcherSchema = z.union([
  dateMatcherSchema,
  orMatcherSchema,
  startDateMatcherSchema,
  templateMatcherSchema,
  titleMatcherSchema,
]);
export type Matcher = z.infer<typeof matcherSchema>;

const haFolderPathComponentSchema = z.object({
  id: z.string().optional(),
  parsers: parserSchema.array().optional(),
  matchers: matcherSchema.array().optional(),
});
export type HAFolderPathComponent = z.infer<typeof haFolderPathComponentSchema>;

export const transformPathURLToPathArray = (
  url: string,
): NonEmptyTuple<HAFolderPathComponent> => {
  let urlPath = url;
  try {
    const urlObj = new URL(url);
    urlPath = urlObj.pathname;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (e) {}

  const splitPath = decodeURIComponent(urlPath).split(',').filter(isTruthy).slice(1);

  // HA uses a pretty odd URL protocol for media-browser URLs:
  //  - The URL is an encoded comma-separated value representing the folder
  //    hierarchy
  //  - The first component will be `media-browser/browser` representing the
  //    root
  //  - Each subsequent component will start with `media-source://<path>`
  //  - All components except the last will additionally include
  //    '/<media-class>'.
  const folderPath: NonEmptyTuple<HAFolderPathComponent> = [
    { id: HA_MEDIA_SOURCE_ROOT },
    ...splitPath.slice(0, -1).map((split) => ({ id: split.replace(/\/[^/]+$/, '') })),
    ...splitPath.slice(-1).map((split) => ({ id: split })),
  ];

  for (const component of folderPath) {
    if (component.id && !component.id.startsWith(HA_MEDIA_SOURCE_ROOT)) {
      throw new AdvancedCameraCardError(`Could not parse media source URL: ${url}`);
    }
  }
  return folderPath;
};

const haFolderConfigSchema = z.object({
  url: z.string().transform(transformPathURLToPathArray).optional(),
  path: haFolderPathComponentSchema.array().nonempty().optional(),
});
export type HAFolderConfig = z.infer<typeof haFolderConfigSchema>;

const folderConfigSchema = z.object({
  type: folderTypeSchema.default(folderConfigDefault.type),
  id: z.string().optional(),
  ha: haFolderConfigSchema.default(folderConfigDefault.ha).optional(),
  title: z.string().optional(),
  icon: z.string().optional(),
});
export type FolderConfig = z.infer<typeof folderConfigSchema>;

export const foldersConfigSchema = folderConfigSchema.array();



================================================
FILE: src/config/schema/image.ts
================================================
import { z } from 'zod';
import { actionsSchema } from './actions/types';
import { imageBaseConfigSchema, imageConfigDefault } from './common/image';

export const imageConfigSchema = imageBaseConfigSchema
  .extend({
    zoomable: z.boolean().default(imageConfigDefault.zoomable),
  })
  .merge(actionsSchema)
  .default(imageConfigDefault);

export type ImageViewConfig = z.infer<typeof imageConfigSchema>;



================================================
FILE: src/config/schema/live.ts
================================================
import { z } from 'zod';
import { actionsSchema } from './actions/types';
import { nextPreviousControlConfigSchema } from './common/controls/next-previous';
import { ptzControlsConfigSchema, ptzControlsDefaults } from './common/controls/ptz';
import {
  thumbnailControlsDefaults,
  thumbnailsControlSchema,
} from './common/controls/thumbnails';
import {
  miniTimelineConfigDefault,
  miniTimelineConfigSchema,
} from './common/controls/timeline';
import { viewDisplaySchema } from './common/display';
import { eventsMediaTypeSchema } from './common/events-media';
import {
  MEDIA_ACTION_NEGATIVE_CONDITIONS,
  MEDIA_ACTION_POSITIVE_CONDITIONS,
  MEDIA_MUTE_CONDITIONS,
  MEDIA_UNMUTE_CONDITIONS,
} from './common/media-actions';
import { transitionEffectConfigSchema } from './common/transition-effect';

const microphoneConfigDefault = {
  always_connected: false,
  disconnect_seconds: 90,
  mute_after_microphone_mute_seconds: 60,
};

const microphoneConfigSchema = z
  .object({
    always_connected: z.boolean().default(microphoneConfigDefault.always_connected),
    disconnect_seconds: z
      .number()
      .min(0)
      .default(microphoneConfigDefault.disconnect_seconds),
    mute_after_microphone_mute_seconds: z
      .number()
      .min(0)
      .default(microphoneConfigDefault.mute_after_microphone_mute_seconds),
  })
  .default(microphoneConfigDefault);
export type MicrophoneConfig = z.infer<typeof microphoneConfigSchema>;

const liveThumbnailControlsDefaults = {
  ...thumbnailControlsDefaults,
  media_type: 'events' as const,
  events_media_type: 'all' as const,
};

export const liveConfigDefault = {
  auto_play: [...MEDIA_ACTION_POSITIVE_CONDITIONS],
  auto_pause: [],
  auto_mute: [...MEDIA_MUTE_CONDITIONS],
  auto_unmute: ['microphone' as const],
  preload: false,
  lazy_load: true,
  lazy_unload: [],
  draggable: true,
  zoomable: true,
  transition_effect: 'slide' as const,
  show_image_during_load: true,
  mode: 'single' as const,
  controls: {
    builtin: true,
    next_previous: {
      size: 48,
      style: 'chevrons' as const,
    },
    ptz: ptzControlsDefaults,
    thumbnails: liveThumbnailControlsDefaults,
    timeline: miniTimelineConfigDefault,
  },
  microphone: {
    ...microphoneConfigDefault,
  },
};

const livethumbnailsControlSchema = thumbnailsControlSchema.extend({
  media_type: z
    .enum(['events', 'recordings'])
    .default(liveConfigDefault.controls.thumbnails.media_type),
  events_media_type: eventsMediaTypeSchema.default(
    liveConfigDefault.controls.thumbnails.events_media_type,
  ),
});

export const liveConfigSchema = z
  .object({
    auto_pause: z
      .enum(MEDIA_ACTION_NEGATIVE_CONDITIONS)
      .array()
      .default(liveConfigDefault.auto_pause),
    auto_play: z
      .enum(MEDIA_ACTION_POSITIVE_CONDITIONS)
      .array()
      .default(liveConfigDefault.auto_play),
    auto_mute: z
      .enum(MEDIA_MUTE_CONDITIONS)
      .array()
      .default(liveConfigDefault.auto_mute),
    auto_unmute: z
      .enum(MEDIA_UNMUTE_CONDITIONS)
      .array()
      .default(liveConfigDefault.auto_unmute),
    controls: z
      .object({
        builtin: z.boolean().default(liveConfigDefault.controls.builtin),
        next_previous: nextPreviousControlConfigSchema
          .extend({
            // Live cannot show thumbnails, remove that option.
            style: z
              .enum(['none', 'chevrons', 'icons'])
              .default(liveConfigDefault.controls.next_previous.style),
            size: nextPreviousControlConfigSchema.shape.size.default(
              liveConfigDefault.controls.next_previous.size,
            ),
          })
          .default(liveConfigDefault.controls.next_previous),
        ptz: ptzControlsConfigSchema.default(liveConfigDefault.controls.ptz),
        thumbnails: livethumbnailsControlSchema.default(
          liveConfigDefault.controls.thumbnails,
        ),
        timeline: miniTimelineConfigSchema.default(liveConfigDefault.controls.timeline),
      })
      .default(liveConfigDefault.controls),
    display: viewDisplaySchema,
    draggable: z.boolean().default(liveConfigDefault.draggable),
    lazy_load: z.boolean().default(liveConfigDefault.lazy_load),
    lazy_unload: z
      .enum(MEDIA_ACTION_NEGATIVE_CONDITIONS)
      .array()
      .default(liveConfigDefault.lazy_unload),
    microphone: microphoneConfigSchema.default(liveConfigDefault.microphone),
    preload: z.boolean().default(liveConfigDefault.preload),
    show_image_during_load: z
      .boolean()
      .default(liveConfigDefault.show_image_during_load),
    transition_effect: transitionEffectConfigSchema.default(
      liveConfigDefault.transition_effect,
    ),
    zoomable: z.boolean().default(liveConfigDefault.zoomable),
  })
  .merge(actionsSchema)
  .default(liveConfigDefault);
export type LiveConfig = z.infer<typeof liveConfigSchema>;



================================================
FILE: src/config/schema/media-gallery.ts
================================================
import { z } from 'zod';
import { actionsSchema } from './actions/types';
import {
  thumbnailControlsDefaults,
  thumbnailsControlBaseSchema,
} from './common/controls/thumbnails';

const mediaGalleryThumbnailControlsDefaults = {
  ...thumbnailControlsDefaults,
  show_details: false,
};

export const mediaGalleryConfigDefault = {
  controls: {
    thumbnails: mediaGalleryThumbnailControlsDefaults,
    filter: {
      mode: 'right' as const,
    },
  },
};

const mediaGallerythumbnailsControlSchema = thumbnailsControlBaseSchema.extend({
  show_details: z.boolean().default(mediaGalleryThumbnailControlsDefaults.show_details),
});
export type MediaGalleryThumbnailsConfig = z.infer<
  typeof mediaGallerythumbnailsControlSchema
>;

export const mediaGalleryConfigSchema = z
  .object({
    controls: z
      .object({
        thumbnails: mediaGallerythumbnailsControlSchema.default(
          mediaGalleryConfigDefault.controls.thumbnails,
        ),
        filter: z
          .object({
            mode: z
              .enum(['none', 'left', 'right'])
              .default(mediaGalleryConfigDefault.controls.filter.mode),
          })
          .default(mediaGalleryConfigDefault.controls.filter),
      })
      .default(mediaGalleryConfigDefault.controls),
  })
  .merge(actionsSchema)
  .default(mediaGalleryConfigDefault);
export type MediaGalleryConfig = z.infer<typeof mediaGalleryConfigSchema>;



================================================
FILE: src/config/schema/menu.ts
================================================
import { z } from 'zod';
import { BUTTON_SIZE_MIN, MENU_PRIORITY_DEFAULT } from './common/const';
import { menuBaseSchema } from './elements/custom/menu/base';

const MENU_STYLES = [
  'none',
  'hidden',
  'overlay',
  'hover',
  'hover-card',
  'outside',
] as const;
const MENU_POSITIONS = ['left', 'right', 'top', 'bottom'] as const;
const MENU_ALIGNMENTS = MENU_POSITIONS;

const visibleButtonDefault = {
  priority: MENU_PRIORITY_DEFAULT,
  enabled: true,
};

const hiddenButtonDefault = {
  priority: MENU_PRIORITY_DEFAULT,
  enabled: false,
};

export const menuConfigDefault = {
  alignment: 'left' as const,
  button_size: 40,
  buttons: {
    camera_ui: visibleButtonDefault,
    cameras: visibleButtonDefault,
    clips: visibleButtonDefault,
    ptz_home: hiddenButtonDefault,
    display_mode: visibleButtonDefault,
    download: visibleButtonDefault,
    expand: hiddenButtonDefault,
    folders: visibleButtonDefault,
    iris: visibleButtonDefault,
    fullscreen: visibleButtonDefault,
    image: hiddenButtonDefault,
    live: visibleButtonDefault,
    media_player: visibleButtonDefault,
    microphone: {
      ...hiddenButtonDefault,
      type: 'momentary' as const,
    },
    mute: hiddenButtonDefault,
    play: hiddenButtonDefault,
    ptz_controls: hiddenButtonDefault,
    recordings: hiddenButtonDefault,
    screenshot: hiddenButtonDefault,
    snapshots: visibleButtonDefault,
    substreams: visibleButtonDefault,
    timeline: visibleButtonDefault,
  },
  position: 'top' as const,
  style: 'hidden' as const,
};

const visibleButtonSchema = menuBaseSchema.extend({
  enabled: menuBaseSchema.shape.enabled.default(visibleButtonDefault.enabled),
  priority: menuBaseSchema.shape.priority.default(visibleButtonDefault.priority),
});

const hiddenButtonSchema = menuBaseSchema.extend({
  enabled: menuBaseSchema.shape.enabled.default(hiddenButtonDefault.enabled),
  priority: menuBaseSchema.shape.priority.default(hiddenButtonDefault.priority),
});

export const menuConfigSchema = z
  .object({
    style: z.enum(MENU_STYLES).default(menuConfigDefault.style),
    position: z.enum(MENU_POSITIONS).default(menuConfigDefault.position),
    alignment: z.enum(MENU_ALIGNMENTS).default(menuConfigDefault.alignment),
    buttons: z
      .object({
        camera_ui: visibleButtonSchema.default(menuConfigDefault.buttons.camera_ui),
        cameras: visibleButtonSchema.default(menuConfigDefault.buttons.cameras),
        clips: visibleButtonSchema.default(menuConfigDefault.buttons.clips),
        ptz_home: hiddenButtonSchema.default(menuConfigDefault.buttons.ptz_home),
        display_mode: visibleButtonSchema.default(
          menuConfigDefault.buttons.display_mode,
        ),
        download: visibleButtonSchema.default(menuConfigDefault.buttons.download),
        expand: hiddenButtonSchema.default(menuConfigDefault.buttons.expand),
        folders: visibleButtonSchema.default(menuConfigDefault.buttons.folders),
        iris: visibleButtonSchema.default(menuConfigDefault.buttons.iris),
        fullscreen: visibleButtonSchema.default(menuConfigDefault.buttons.fullscreen),
        image: hiddenButtonSchema.default(menuConfigDefault.buttons.image),
        live: visibleButtonSchema.default(menuConfigDefault.buttons.live),
        media_player: visibleButtonSchema.default(
          menuConfigDefault.buttons.media_player,
        ),
        microphone: hiddenButtonSchema
          .extend({
            type: z
              .enum(['momentary', 'toggle'])
              .default(menuConfigDefault.buttons.microphone.type),
          })
          .default(menuConfigDefault.buttons.microphone),
        mute: hiddenButtonSchema.default(menuConfigDefault.buttons.mute),
        play: hiddenButtonSchema.default(menuConfigDefault.buttons.play),
        ptz_controls: hiddenButtonSchema.default(menuConfigDefault.buttons.ptz_controls),
        recordings: hiddenButtonSchema.default(menuConfigDefault.buttons.recordings),
        screenshot: hiddenButtonSchema.default(menuConfigDefault.buttons.screenshot),
        snapshots: visibleButtonSchema.default(menuConfigDefault.buttons.snapshots),
        substreams: visibleButtonSchema.default(menuConfigDefault.buttons.substreams),
        timeline: visibleButtonSchema.default(menuConfigDefault.buttons.timeline),
      })
      .default(menuConfigDefault.buttons),
    button_size: z.number().min(BUTTON_SIZE_MIN).default(menuConfigDefault.button_size),
  })
  .default(menuConfigDefault);
export type MenuConfig = z.infer<typeof menuConfigSchema>;



================================================
FILE: src/config/schema/overrides.ts
================================================
import { z } from 'zod';
import { advancedCameraCardConditionSchema } from './conditions/types';

const overrideSchema = z.object({
  conditions: advancedCameraCardConditionSchema.array(),
  merge: z.object({}).passthrough().optional(),
  set: z.object({}).passthrough().optional(),
  delete: z.string().array().optional(),
});
export type Override = z.infer<typeof overrideSchema>;

export const overridesSchema = overrideSchema.array().optional();



================================================
FILE: src/config/schema/performance.ts
================================================
import { z } from 'zod';
import { MEDIA_CHUNK_SIZE_DEFAULT, MEDIA_CHUNK_SIZE_MAX } from '../../const';

export const performanceConfigDefault = {
  features: {
    animated_progress_indicator: true,
    card_loading_indicator: true,
    media_chunk_size: MEDIA_CHUNK_SIZE_DEFAULT,
  },
  style: {
    border_radius: true,
    box_shadow: true,
  },
};

export const performanceConfigSchema = z
  .object({
    features: z
      .object({
        animated_progress_indicator: z
          .boolean()
          .default(performanceConfigDefault.features.animated_progress_indicator),
        card_loading_indicator: z
          .boolean()
          .default(performanceConfigDefault.features.card_loading_indicator),
        media_chunk_size: z
          .number()
          .min(0)
          .max(MEDIA_CHUNK_SIZE_MAX)
          .default(performanceConfigDefault.features.media_chunk_size),
        max_simultaneous_engine_requests: z.number().min(1).optional(),
      })
      .default(performanceConfigDefault.features),
    style: z
      .object({
        border_radius: z.boolean().default(performanceConfigDefault.style.border_radius),
        box_shadow: z.boolean().default(performanceConfigDefault.style.box_shadow),
      })
      .default(performanceConfigDefault.style),
  })
  .default(performanceConfigDefault);
export type PerformanceConfig = z.infer<typeof performanceConfigSchema>;



================================================
FILE: src/config/schema/profiles.ts
================================================
import { z } from 'zod';

const PROFILES = ['casting', 'low-performance', 'scrubbing'] as const;
export type ProfileType = (typeof PROFILES)[number];
export const profilesSchema = z.enum(PROFILES).array().optional();



================================================
FILE: src/config/schema/remote-control.ts
================================================
import { z } from 'zod';

export const remoteControlConfigDefault = {
  entities: {
    camera_priority: 'card' as const,
  },
};

const entityPrioritySchema = z.enum(['card', 'entity']);
export type RemoteControlEntityPriority = z.infer<typeof entityPrioritySchema>;

export const remoteControlConfigSchema = z
  .object({
    entities: z
      .object({
        camera: z.string().startsWith('input_select.').optional(),
        camera_priority: entityPrioritySchema.default(
          remoteControlConfigDefault.entities.camera_priority,
        ),
      })
      .default(remoteControlConfigDefault.entities),
  })
  .default(remoteControlConfigDefault);



================================================
FILE: src/config/schema/status-bar.ts
================================================
import { z } from 'zod';
import { BUTTON_SIZE_MIN, STATUS_BAR_PRIORITY_DEFAULT } from './common/const';
import { statusBarItemBaseSchema } from './common/status-bar';

export const STATUS_BAR_HEIGHT_MIN = BUTTON_SIZE_MIN;
const STATUS_BAR_STYLES = [
  'none',
  'overlay',
  'hover',
  'hover-card',
  'outside',
  'popup',
] as const;
const STATUS_BAR_POSITIONS = ['top', 'bottom'] as const;

const statusBarItemDefault = {
  priority: STATUS_BAR_PRIORITY_DEFAULT,
  enabled: true,
};

export const statusBarConfigDefault = {
  height: 40,
  items: {
    engine: statusBarItemDefault,
    resolution: statusBarItemDefault,
    technology: statusBarItemDefault,
    title: statusBarItemDefault,
  },
  position: 'bottom' as const,
  style: 'popup' as const,
  popup_seconds: 3,
};

export const statusBarConfigSchema = z
  .object({
    position: z.enum(STATUS_BAR_POSITIONS).default(statusBarConfigDefault.position),
    style: z.enum(STATUS_BAR_STYLES).default(statusBarConfigDefault.style),
    popup_seconds: z
      .number()
      .min(0)
      .max(60)
      .default(statusBarConfigDefault.popup_seconds),
    height: z.number().min(STATUS_BAR_HEIGHT_MIN).default(statusBarConfigDefault.height),
    items: z
      .object({
        engine: statusBarItemBaseSchema.default(statusBarConfigDefault.items.engine),
        technology: statusBarItemBaseSchema.default(
          statusBarConfigDefault.items.technology,
        ),
        resolution: statusBarItemBaseSchema.default(
          statusBarConfigDefault.items.resolution,
        ),
        title: statusBarItemBaseSchema.default(statusBarConfigDefault.items.title),
      })
      .default(statusBarConfigDefault.items),
  })
  .default(statusBarConfigDefault);
export type StatusBarConfig = z.infer<typeof statusBarConfigSchema>;



================================================
FILE: src/config/schema/timeline.ts
================================================
import { z } from 'zod';
import { thumbnailsControlSchema } from './common/controls/thumbnails';
import {
  timelineConfigDefault,
  timelineCoreConfigSchema,
} from './common/controls/timeline';

export const timelineConfigSchema = timelineCoreConfigSchema
  .extend({
    controls: z
      .object({
        thumbnails: thumbnailsControlSchema.default(
          timelineConfigDefault.controls.thumbnails,
        ),
      })
      .default(timelineConfigDefault.controls),
  })
  .default(timelineConfigDefault);
export type TimelineConfig = z.infer<typeof timelineConfigSchema>;



================================================
FILE: src/config/schema/types.ts
================================================
import { z } from 'zod';
import { deepRemoveDefaults } from '../../utils/zod';
import { automationsSchema } from './automations';
import { cameraConfigDefault, cameraConfigSchema, camerasConfigSchema } from './cameras';
import { cardIDRegex } from './common/const';
import { timelineConfigDefault } from './common/controls/timeline';
import { imageConfigDefault } from './common/image';
import { DebugConfig, debugConfigDefault, debugConfigSchema } from './debug';
import { dimensionsConfigSchema } from './dimensions';
import { pictureElementsSchema } from './elements/types';
import { foldersConfigSchema } from './folders';
import { imageConfigSchema } from './image';
import { liveConfigDefault, liveConfigSchema } from './live';
import { mediaGalleryConfigDefault, mediaGalleryConfigSchema } from './media-gallery';
import { menuConfigDefault, menuConfigSchema } from './menu';
import { overridesSchema } from './overrides';
import {
  PerformanceConfig,
  performanceConfigDefault,
  performanceConfigSchema,
} from './performance';
import { profilesSchema } from './profiles';
import { remoteControlConfigDefault, remoteControlConfigSchema } from './remote-control';
import { statusBarConfigDefault, statusBarConfigSchema } from './status-bar';
import { timelineConfigSchema } from './timeline';
import { viewConfigDefault, viewConfigSchema } from './view';
import { viewerConfigDefault, viewerConfigSchema } from './viewer';

export interface CardWideConfig {
  performance?: PerformanceConfig;
  debug?: DebugConfig;
}

export const advancedCameraCardConfigSchema = z.object({
  // Defaults are stripped out of the individual cameras, since each camera will
  // be merged with `cameras_global` which *does* have defaults. If we didn't do
  // this, the default values of each individual camera would override the
  // intentionally specified values in `cameras_global` during camera
  // initialization when the two configs are merged.
  cameras: deepRemoveDefaults(camerasConfigSchema),
  cameras_global: cameraConfigSchema,

  view: viewConfigSchema,
  menu: menuConfigSchema,
  status_bar: statusBarConfigSchema,
  live: liveConfigSchema,
  media_gallery: mediaGalleryConfigSchema,
  media_viewer: viewerConfigSchema,
  image: imageConfigSchema,
  elements: pictureElementsSchema,
  dimensions: dimensionsConfigSchema,
  timeline: timelineConfigSchema,
  performance: performanceConfigSchema,
  debug: debugConfigSchema,
  automations: automationsSchema.optional(),

  profiles: profilesSchema,

  folders: foldersConfigSchema.optional(),

  // Configuration overrides.
  overrides: overridesSchema,

  // Support for card_mod (https://github.com/thomasloven/lovelace-card-mod).
  card_mod: z.unknown(),

  // Card ID (used for query string commands). Restrict contents to only values
  // that be easily used in a URL.
  card_id: z.string().regex(cardIDRegex).optional(),

  remote_control: remoteControlConfigSchema,

  // Stock lovelace card config.
  type: z.string(),
});
export type AdvancedCameraCardConfig = z.infer<typeof advancedCameraCardConfigSchema>;

export const configDefaults = {
  cameras: cameraConfigDefault,
  view: viewConfigDefault,
  menu: menuConfigDefault,
  status_bar: statusBarConfigDefault,
  live: liveConfigDefault,
  media_gallery: mediaGalleryConfigDefault,
  media_viewer: viewerConfigDefault,
  image: imageConfigDefault,
  timeline: timelineConfigDefault,
  performance: performanceConfigDefault,
  debug: debugConfigDefault,
  remote_control: remoteControlConfigDefault,
};



================================================
FILE: src/config/schema/view.ts
================================================
import { z } from 'zod';
import { actionsSchema } from './actions/types';
import { VIEW_DEFAULT, VIEWS_USER_SPECIFIED } from './common/const';

const keyboardShortcut = z.object({
  key: z.string(),
  ctrl: z.boolean().optional(),
  shift: z.boolean().optional(),
  alt: z.boolean().optional(),
  meta: z.boolean().optional(),
});
export type KeyboardShortcut = z.infer<typeof keyboardShortcut>;

const keyboardShortcutsDefault = {
  enabled: true,
  ptz_left: { key: 'ArrowLeft' },
  ptz_right: { key: 'ArrowRight' },
  ptz_up: { key: 'ArrowUp' },
  ptz_down: { key: 'ArrowDown' },
  ptz_zoom_in: { key: '+' },
  ptz_zoom_out: { key: '-' },
  ptz_home: { key: 'h' },
};

const keyboardShortcutsSchema = z.object({
  enabled: z.boolean().default(keyboardShortcutsDefault.enabled),
  ptz_left: keyboardShortcut.nullable().default(keyboardShortcutsDefault.ptz_left),
  ptz_right: keyboardShortcut.nullable().default(keyboardShortcutsDefault.ptz_right),
  ptz_up: keyboardShortcut.nullable().default(keyboardShortcutsDefault.ptz_up),
  ptz_down: keyboardShortcut.nullable().default(keyboardShortcutsDefault.ptz_down),
  ptz_zoom_in: keyboardShortcut.nullable().default(keyboardShortcutsDefault.ptz_zoom_in),
  ptz_zoom_out: keyboardShortcut
    .nullable()
    .default(keyboardShortcutsDefault.ptz_zoom_out),
  ptz_home: keyboardShortcut.nullable().default(keyboardShortcutsDefault.ptz_home),
});
export type KeyboardShortcuts = z.infer<typeof keyboardShortcutsSchema>;

export type PTZKeyboardShortcutName =
  | 'ptz_down'
  | 'ptz_home'
  | 'ptz_left'
  | 'ptz_right'
  | 'ptz_up'
  | 'ptz_zoom_in'
  | 'ptz_zoom_out';

export const viewConfigDefault = {
  default: VIEW_DEFAULT,
  camera_select: 'current' as const,
  interaction_seconds: 300,
  default_reset: {
    every_seconds: 0,
    after_interaction: false,
    entities: [],
    interaction_mode: 'inactive' as const,
  },
  default_cycle_camera: false,
  dim: false,
  theme: {
    themes: ['traditional' as const],
  },
  triggers: {
    show_trigger_status: false,
    filter_selected_camera: true,
    actions: {
      trigger: 'update' as const,
      untrigger: 'none' as const,
    },
    untrigger_seconds: 0,
  },
  keyboard_shortcuts: keyboardShortcutsDefault,
};

const interactionModeSchema = z.enum(['all', 'inactive', 'active']).default('inactive');
export type InteractionMode = z.infer<typeof interactionModeSchema>;

export const triggersSchema = z.object({
  actions: z
    .object({
      interaction_mode: interactionModeSchema,
      trigger: z
        .enum(['default', 'live', 'media', 'none', 'update'])
        .default(viewConfigDefault.triggers.actions.trigger),
      untrigger: z
        .enum(['default', 'none'])
        .default(viewConfigDefault.triggers.actions.untrigger),
    })
    .default(viewConfigDefault.triggers.actions),
  filter_selected_camera: z
    .boolean()
    .default(viewConfigDefault.triggers.filter_selected_camera),
  show_trigger_status: z
    .boolean()
    .default(viewConfigDefault.triggers.show_trigger_status),
  untrigger_seconds: z.number().default(viewConfigDefault.triggers.untrigger_seconds),
});
export type TriggersOptions = z.infer<typeof triggersSchema>;

const themeName = z.enum(['ha', 'dark', 'light', 'traditional']);
export type ThemeName = z.infer<typeof themeName>;

const themeConfigSchema = z.object({
  themes: themeName.array().default(viewConfigDefault.theme.themes),
  overrides: z.record(z.string()).optional(),
});
export type ThemeConfig = z.infer<typeof themeConfigSchema>;

export const viewConfigSchema = z
  .object({
    default: z.enum(VIEWS_USER_SPECIFIED).default(viewConfigDefault.default),
    camera_select: z
      .enum([...VIEWS_USER_SPECIFIED, 'current'])
      .default(viewConfigDefault.camera_select),
    interaction_seconds: z.number().default(viewConfigDefault.interaction_seconds),
    default_cycle_camera: z.boolean().default(viewConfigDefault.default_cycle_camera),

    default_reset: z
      .object({
        after_interaction: z
          .boolean()
          .default(viewConfigDefault.default_reset.after_interaction),
        every_seconds: z.number().default(viewConfigDefault.default_reset.every_seconds),
        entities: z.string().array().default(viewConfigDefault.default_reset.entities),
        interaction_mode: interactionModeSchema.default(
          viewConfigDefault.default_reset.interaction_mode,
        ),
      })
      .default(viewConfigDefault.default_reset),

    render_entities: z.string().array().optional(),

    theme: themeConfigSchema.default(viewConfigDefault.theme),

    dim: z.boolean().default(viewConfigDefault.dim),
    triggers: triggersSchema.default(viewConfigDefault.triggers),
    keyboard_shortcuts: keyboardShortcutsSchema.default(
      viewConfigDefault.keyboard_shortcuts,
    ),
  })
  .merge(actionsSchema)
  .default(viewConfigDefault);



================================================
FILE: src/config/schema/viewer.ts
================================================
import { z } from 'zod';
import { actionsSchema } from './actions/types';
import { nextPreviousControlConfigSchema } from './common/controls/next-previous';
import { ptzControlsConfigSchema, ptzControlsDefaults } from './common/controls/ptz';
import {
  thumbnailControlsDefaults,
  thumbnailsControlSchema,
} from './common/controls/thumbnails';
import {
  miniTimelineConfigDefault,
  miniTimelineConfigSchema,
} from './common/controls/timeline';
import { viewDisplaySchema } from './common/display';
import {
  MEDIA_ACTION_NEGATIVE_CONDITIONS,
  MEDIA_ACTION_POSITIVE_CONDITIONS,
} from './common/media-actions';
import { transitionEffectConfigSchema } from './common/transition-effect';

export const viewerConfigDefault = {
  auto_play: [...MEDIA_ACTION_POSITIVE_CONDITIONS],
  auto_pause: [...MEDIA_ACTION_NEGATIVE_CONDITIONS],
  auto_mute: [...MEDIA_ACTION_NEGATIVE_CONDITIONS],
  auto_unmute: [],
  lazy_load: true,
  draggable: true,
  zoomable: true,
  transition_effect: 'slide' as const,
  snapshot_click_plays_clip: true,
  display_mode: 'single' as const,
  controls: {
    builtin: true,
    next_previous: {
      size: 48,
      style: 'thumbnails' as const,
    },
    thumbnails: thumbnailControlsDefaults,
    timeline: miniTimelineConfigDefault,
    ptz: {
      ...ptzControlsDefaults,
      mode: 'off' as const,
    },
  },
};

const viewerNextPreviousControlConfigSchema = nextPreviousControlConfigSchema.extend({
  style: z
    .enum(['none', 'thumbnails', 'chevrons'])
    .default(viewerConfigDefault.controls.next_previous.style),
  size: nextPreviousControlConfigSchema.shape.size.default(
    viewerConfigDefault.controls.next_previous.size,
  ),
});

export const viewerConfigSchema = z
  .object({
    auto_play: z
      .enum(MEDIA_ACTION_POSITIVE_CONDITIONS)
      .array()
      .default(viewerConfigDefault.auto_play),
    auto_pause: z
      .enum(MEDIA_ACTION_NEGATIVE_CONDITIONS)
      .array()
      .default(viewerConfigDefault.auto_pause),

    // Don't use MEDIA_UNMUTE_CONDITIONS and MEDIA_MUTE_CONDITIONS here, since
    // it includes 'microphone' which doesn't make sense for viewer media.
    auto_mute: z
      .enum(MEDIA_ACTION_NEGATIVE_CONDITIONS)
      .array()
      .default(viewerConfigDefault.auto_mute),
    auto_unmute: z
      .enum(MEDIA_ACTION_POSITIVE_CONDITIONS)
      .array()
      .default(viewerConfigDefault.auto_unmute),
    lazy_load: z.boolean().default(viewerConfigDefault.lazy_load),
    draggable: z.boolean().default(viewerConfigDefault.draggable),
    zoomable: z.boolean().default(viewerConfigDefault.zoomable),
    transition_effect: transitionEffectConfigSchema.default(
      viewerConfigDefault.transition_effect,
    ),
    snapshot_click_plays_clip: z
      .boolean()
      .default(viewerConfigDefault.snapshot_click_plays_clip),
    display: viewDisplaySchema,
    controls: z
      .object({
        builtin: z.boolean().default(viewerConfigDefault.controls.builtin),
        next_previous: viewerNextPreviousControlConfigSchema.default(
          viewerConfigDefault.controls.next_previous,
        ),
        ptz: ptzControlsConfigSchema
          .extend({
            // The media_viewer ptz has no 'auto' mode.
            mode: z.enum(['off', 'on']).default(viewerConfigDefault.controls.ptz.mode),
          })
          .default(viewerConfigDefault.controls.ptz),
        thumbnails: thumbnailsControlSchema.default(
          viewerConfigDefault.controls.thumbnails,
        ),
        timeline: miniTimelineConfigSchema.default(
          viewerConfigDefault.controls.timeline,
        ),
      })
      .default(viewerConfigDefault.controls),
  })
  .merge(actionsSchema)
  .default(viewerConfigDefault);
export type ViewerConfig = z.infer<typeof viewerConfigSchema>;



================================================
FILE: src/config/schema/actions/base.ts
================================================
import { z } from 'zod';
import { cardIDRegex } from '../common/const';

// https://www.home-assistant.io/dashboards/actions/#options-for-confirmation
export const actionBaseSchema = z.object({
  confirmation: z
    .boolean()
    .or(
      z.object({
        text: z.string().optional(),
        exemptions: z
          .object({
            user: z.string(),
          })
          .array()
          .optional(),
      }),
    )
    .optional(),

  card_id: z
    .string()
    .regex(cardIDRegex, 'card_id parameter can only contain [a-z][A-Z][0-9_]-')
    .optional(),
});



================================================
FILE: src/config/schema/actions/types.ts
================================================
import { z } from 'zod';
import { statusBarItemBaseSchema } from '../common/status-bar';
import { advancedCameraCardCustomActionsBaseSchema } from './custom/base';
import { cameraSelectActionConfigSchema } from './custom/camera-select';
import { viewDisplayModeActionConfigSchema } from './custom/display-mode';
import { foldersViewActionConfigSchema } from './custom/folders-view';
import { generalActionConfigSchema } from './custom/general';
import { internalCallbackActionConfigSchema } from './custom/internal';
import { logActionConfigSchema } from './custom/log';
import { mediaPlayerActionConfigSchema } from './custom/media-player';
import { ptzActionConfigSchema } from './custom/ptz';
import { ptzControlsActionConfigSchema } from './custom/ptz-controls';
import { ptzDigitalActionConfigSchema } from './custom/ptz-digital';
import { ptzMultiActionSchema } from './custom/ptz-multi';
import { sleepActionConfigSchema } from './custom/sleep';
import { substreamSelectActionConfigSchema } from './custom/substream-select';
import { viewActionConfigSchema } from './custom/view';
import { stockActionSchema } from './stock/types';

// Provide a manual type definition to avoid the `any` that would be created by
// the lazy() evaluation below.
// See: https://zod.dev/?id=recursive-types
export type StatusBarActionConfig = z.infer<
  typeof advancedCameraCardCustomActionsBaseSchema
> & {
  advanced_camera_card_action: 'status_bar';
  status_bar_action: 'add' | 'remove' | 'reset';
  items?: StatusBarItem[];
};
export const statusBarActionConfigSchema: z.ZodSchema<
  StatusBarActionConfig,
  z.ZodTypeDef,
  unknown
> = advancedCameraCardCustomActionsBaseSchema.extend({
  advanced_camera_card_action: z.literal('status_bar'),
  status_bar_action: z.enum(['add', 'remove', 'reset']),
  items: z
    .lazy(() => statusBarItemSchema)
    .array()
    .optional(),
});

const advancedCameraCardCustomActionSchema = z.union([
  cameraSelectActionConfigSchema,
  foldersViewActionConfigSchema,
  generalActionConfigSchema,
  internalCallbackActionConfigSchema,
  logActionConfigSchema,
  mediaPlayerActionConfigSchema,
  ptzActionConfigSchema,
  ptzControlsActionConfigSchema,
  ptzDigitalActionConfigSchema,
  ptzMultiActionSchema,
  sleepActionConfigSchema,
  statusBarActionConfigSchema,
  substreamSelectActionConfigSchema,
  viewActionConfigSchema,
  viewDisplayModeActionConfigSchema,
]);
export type AdvancedCameraCardCustomActionConfig = z.infer<
  typeof advancedCameraCardCustomActionSchema
>;

export const actionConfigSchema = z.union([
  stockActionSchema,
  advancedCameraCardCustomActionSchema,
]);
export type ActionConfig = z.infer<typeof actionConfigSchema>;

export const actionsBaseSchema = z
  .object({
    tap_action: actionConfigSchema.or(actionConfigSchema.array()).optional(),
    hold_action: actionConfigSchema.or(actionConfigSchema.array()).optional(),
    double_tap_action: actionConfigSchema.or(actionConfigSchema.array()).optional(),
    start_tap_action: actionConfigSchema.or(actionConfigSchema.array()).optional(),
    end_tap_action: actionConfigSchema.or(actionConfigSchema.array()).optional(),
  })
  // Passthrough to allow (at least) entity/camera_image to go through. This
  // card doesn't need these attributes, but handleAction() in
  // custom_card_helpers may depending on how the action is configured.
  .passthrough();
export type Actions = z.infer<typeof actionsBaseSchema>;

export interface AuxillaryActionConfig {
  entity?: string;
}

export type ActionsConfig = Actions & AuxillaryActionConfig;

export const actionsSchema = z.object({
  actions: actionsBaseSchema.optional(),
});

// ============================================================================
//                         Status Bar Elements
//
// Note: Status Bar action & elements are included in this file, since this is
// the only action that may include content that refers to *other* actions (e.g.
// a status bar action, compromises of status bar items, which themselves may
// have actions). This circular relationship means the components must be
// together in a file, or they will generate typescript circular dependency
// errors.
// ============================================================================

const statusBarItemElementsBaseSchema = statusBarItemBaseSchema.extend({
  sufficient: z.boolean().default(false).optional(),
  exclusive: z.boolean().default(false).optional(),
  expand: z.boolean().default(false).optional(),
  actions: actionsBaseSchema.optional(),
});

export const statusBarIconItemSchema = statusBarItemElementsBaseSchema.extend({
  type: z.literal('custom:advanced-camera-card-status-bar-icon'),
  icon: z.string(),
});
export type StatusBarIcon = z.infer<typeof statusBarIconItemSchema>;

export const statusBarImageItemSchema = statusBarItemElementsBaseSchema.extend({
  type: z.literal('custom:advanced-camera-card-status-bar-image'),
  image: z.string(),
});
export type StatusBarImage = z.infer<typeof statusBarImageItemSchema>;

export const statusBarStringItemSchema = statusBarItemElementsBaseSchema.extend({
  type: z.literal('custom:advanced-camera-card-status-bar-string'),
  string: z.string(),
});
export type StatusBarString = z.infer<typeof statusBarStringItemSchema>;

const statusBarItemSchema = z.union([
  statusBarIconItemSchema,
  statusBarImageItemSchema,
  statusBarStringItemSchema,
]);
export type StatusBarItem = z.infer<typeof statusBarItemSchema>;



================================================
FILE: src/config/schema/actions/custom/base.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const advancedCameraCardCustomActionsBaseSchema = actionBaseSchema.extend({
  action: z
    .literal('fire-dom-event')
    .or(
      z
        .literal('custom:advanced-camera-card-action')
        .transform((): 'fire-dom-event' => 'fire-dom-event'),
    ),
});



================================================
FILE: src/config/schema/actions/custom/camera-select.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

export const cameraSelectActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('camera_select'),
    camera: z.string().optional(),
    triggered: z.boolean().optional(),
  });
export type CameraSelectActionConfig = z.infer<typeof cameraSelectActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/display-mode.ts
================================================
import { z } from 'zod';
import { viewDisplayModeSchema } from '../../common/display';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

export const viewDisplayModeActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('display_mode_select'),
    display_mode: viewDisplayModeSchema,
  });
export type DisplayModeActionConfig = z.infer<typeof viewDisplayModeActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/folders-view.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

export const foldersViewActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('folders').or(z.literal('folder')),
    folder: z.string().optional(),
  });
export type FoldersViewActionConfig = z.infer<typeof foldersViewActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/general.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

const GENERAL_ACTIONS = [
  'camera_ui',
  'default',
  'download',
  'expand',
  'fullscreen',
  'live_substream_off',
  'live_substream_on',
  'menu_toggle',
  'microphone_connect',
  'microphone_disconnect',
  'microphone_mute',
  'microphone_unmute',
  'mute',
  'pause',
  'play',
  'screenshot',
  'unmute',
] as const;
export type AdvancedCameraCardGeneralAction = (typeof GENERAL_ACTIONS)[number];

export const generalActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.enum(GENERAL_ACTIONS),
  });
export type GeneralActionConfig = z.infer<typeof generalActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/internal.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

// An action that can be used internally to call a callback (it is not possible
// for the user to pass this through via the configuration).
export const INTERNAL_CALLBACK_ACTION = '__INTERNAL_CALLBACK_ACTION__';
export const internalCallbackActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal(INTERNAL_CALLBACK_ACTION),

    // The callback is expected to be called with a CardController API object.
    callback: z.function().args(z.any()).returns(z.promise(z.void())),
  });
export type InternalCallbackActionConfig = z.infer<
  typeof internalCallbackActionConfigSchema
>;



================================================
FILE: src/config/schema/actions/custom/log.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

const LOG_ACTIONS_LEVELS = ['debug', 'info', 'warn', 'error'] as const;
export type LogActionLevel = (typeof LOG_ACTIONS_LEVELS)[number];

export const logActionConfigSchema = advancedCameraCardCustomActionsBaseSchema.extend({
  advanced_camera_card_action: z.literal('log'),
  message: z.string(),
  level: z.enum(LOG_ACTIONS_LEVELS).default('info'),
});
export type LogActionConfig = z.infer<typeof logActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/media-player.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

export const mediaPlayerActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('media_player'),
    media_player: z.string(),
    media_player_action: z.enum(['play', 'stop']),
  });
export type MediaPlayerActionConfig = z.infer<typeof mediaPlayerActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/ptz-controls.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

export const ptzControlsActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('ptz_controls'),
    enabled: z.boolean(),
  });
export type PTZControlsActionConfig = z.infer<typeof ptzControlsActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/ptz-digital.ts
================================================
import { z } from 'zod';
import { panSchema } from '../../common/pan';
import { zoomSchema } from '../../common/zoom';
import { advancedCameraCardCustomActionsBaseSchema } from './base';
import { PTZ_ACTION_PHASES, PTZ_ACTIONS } from './ptz';

export const ptzDigitalActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('ptz_digital'),
    target_id: z.string().optional(),
    absolute: z
      .object({
        zoom: zoomSchema.optional(),
        pan: panSchema.optional(),
      })
      .optional(),
    ptz_action: z.enum(PTZ_ACTIONS).optional(),
    ptz_phase: z.enum(PTZ_ACTION_PHASES).optional(),
  });
export type PTZDigitialActionConfig = z.infer<typeof ptzDigitalActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/ptz-multi.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';
import { PTZ_ACTION_PHASES, PTZ_ACTIONS } from './ptz';

export const ptzMultiActionSchema = advancedCameraCardCustomActionsBaseSchema.extend({
  advanced_camera_card_action: z.literal('ptz_multi'),
  target_id: z.string().optional(),

  ptz_action: z.enum(PTZ_ACTIONS).optional(),
  ptz_phase: z.enum(PTZ_ACTION_PHASES).optional(),
  ptz_preset: z.string().optional(),
});
export type PTZMultiActionConfig = z.infer<typeof ptzMultiActionSchema>;



================================================
FILE: src/config/schema/actions/custom/ptz.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

const PTZ_PAN_TILT_ACTIONS = ['left', 'right', 'up', 'down'] as const;
const PTZ_ZOOM_ACTIONS = ['zoom_in', 'zoom_out'] as const;
const PTZ_BASE_ACTIONS = [...PTZ_PAN_TILT_ACTIONS, ...PTZ_ZOOM_ACTIONS] as const;
export type PTZBaseAction = (typeof PTZ_BASE_ACTIONS)[number];

// PTZ actions as used by the PTZ control (includes a 'home' button).
export type PTZControlAction = PTZBaseAction | 'home';

// PTZ actions as used by the camera manager (includes generic presets).
export const PTZ_ACTIONS = [...PTZ_BASE_ACTIONS, 'preset'] as const;
export type PTZAction = (typeof PTZ_ACTIONS)[number];

export const PTZ_ACTION_PHASES = ['start', 'stop'] as const;
export type PTZActionPhase = (typeof PTZ_ACTION_PHASES)[number];

export const ptzActionConfigSchema = advancedCameraCardCustomActionsBaseSchema.extend({
  advanced_camera_card_action: z.literal('ptz'),
  camera: z.string().optional(),
  ptz_action: z.enum(PTZ_ACTIONS).optional(),
  ptz_phase: z.enum(PTZ_ACTION_PHASES).optional(),
  ptz_preset: z.string().optional(),
});
export type PTZActionConfig = z.infer<typeof ptzActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/sleep.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

const timeDeltaSchema = z.object({
  ms: z.number().optional(),
  s: z.number().optional(),
  m: z.number().optional(),
  h: z.number().optional(),
});
export type TimeDelta = z.infer<typeof timeDeltaSchema>;

export const sleepActionConfigSchema = advancedCameraCardCustomActionsBaseSchema.extend({
  advanced_camera_card_action: z.literal('sleep'),
  duration: timeDeltaSchema.optional().default({ s: 1 }),
});
export type SleepActionConfig = z.infer<typeof sleepActionConfigSchema>;



================================================
FILE: src/config/schema/actions/custom/substream-select.ts
================================================
import { z } from 'zod';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

export const substreamSelectActionConfigSchema =
  advancedCameraCardCustomActionsBaseSchema.extend({
    advanced_camera_card_action: z.literal('live_substream_select'),
    camera: z.string(),
  });
export type SubstreamSelectActionConfig = z.infer<
  typeof substreamSelectActionConfigSchema
>;



================================================
FILE: src/config/schema/actions/custom/view.ts
================================================
import { z } from 'zod';
import {
  AdvancedCameraCardUserSpecifiedView,
  VIEWS_USER_SPECIFIED,
} from '../../common/const';
import { advancedCameraCardCustomActionsBaseSchema } from './base';

type AdvancedCameraCardUserSpecifiedViewWithoutFolder = Exclude<
  AdvancedCameraCardUserSpecifiedView,
  'folder' | 'folders'
>;

export const viewActionConfigSchema = advancedCameraCardCustomActionsBaseSchema.extend({
  advanced_camera_card_action: z.enum(
    // The folder/folders views are handled separately as they accept an
    // optional folder ID.
    VIEWS_USER_SPECIFIED.filter((view) => view !== 'folder' && view !== 'folders') as [
      AdvancedCameraCardUserSpecifiedViewWithoutFolder,
      ...AdvancedCameraCardUserSpecifiedViewWithoutFolder[],
    ],
  ),
});
export type ViewActionConfig = z.infer<typeof viewActionConfigSchema>;



================================================
FILE: src/config/schema/actions/stock/call-service.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';
import { targetSchema } from './target';

// Note: call-service is deprecated and will eventually go away. Please use
// perform-action instead.
// See: https://www.home-assistant.io/blog/2024/08/07/release-20248/#goodbye-service-calls-hello-actions-

export const callServiceActionSchema = actionBaseSchema.extend({
  action: z.literal('call-service'),
  service: z.string(),
  data: z.object({}).passthrough().optional(),
  target: targetSchema.optional(),
});
export type CallServiceActionConfig = z.infer<typeof callServiceActionSchema>;



================================================
FILE: src/config/schema/actions/stock/custom.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const customActionSchema = actionBaseSchema
  .extend({
    action: z.literal('fire-dom-event'),
  })
  .passthrough();
export type CustomActionConfig = z.infer<typeof customActionSchema>;



================================================
FILE: src/config/schema/actions/stock/more-info.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const moreInfoActionSchema = actionBaseSchema.extend({
  action: z.literal('more-info'),
  entity: z.string().optional(),
});
export type MoreInfoActionConfig = z.infer<typeof moreInfoActionSchema>;



================================================
FILE: src/config/schema/actions/stock/navigate.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const navigateActionSchema = actionBaseSchema.extend({
  action: z.literal('navigate'),
  navigation_path: z.string(),
  navigation_replace: z.boolean().optional(),
});
export type NavigateActionConfig = z.infer<typeof navigateActionSchema>;



================================================
FILE: src/config/schema/actions/stock/none.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const noneActionSchema = actionBaseSchema.extend({
  action: z.literal('none'),
});
export type NoneActionConfig = z.infer<typeof noneActionSchema>;



================================================
FILE: src/config/schema/actions/stock/perform-action.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';
import { targetSchema } from './target';

export const performActionActionSchema = actionBaseSchema.extend({
  action: z.literal('perform-action'),
  perform_action: z.string(),
  data: z.object({}).passthrough().optional(),
  target: targetSchema.optional(),
});
export type PerformActionActionConfig = z.infer<typeof performActionActionSchema>;



================================================
FILE: src/config/schema/actions/stock/target.ts
================================================
import { HassServiceTarget } from 'home-assistant-js-websocket';
import { z } from 'zod';

export const targetSchema: z.ZodSchema<HassServiceTarget, z.ZodTypeDef> = z.object({
  entity_id: z.string().or(z.string().array()).optional(),
  device_id: z.string().or(z.string().array()).optional(),
  area_id: z.string().or(z.string().array()).optional(),
  floor_id: z.string().or(z.string().array()).optional(),
  label_id: z.string().or(z.string().array()).optional(),
});



================================================
FILE: src/config/schema/actions/stock/toggle.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const toggleActionSchema = actionBaseSchema.extend({
  action: z.literal('toggle'),
});
export type ToggleActionConfig = z.infer<typeof toggleActionSchema>;



================================================
FILE: src/config/schema/actions/stock/types.ts
================================================
import { z } from 'zod';
import { callServiceActionSchema } from './call-service';
import { customActionSchema } from './custom';
import { moreInfoActionSchema } from './more-info';
import { navigateActionSchema } from './navigate';
import { noneActionSchema } from './none';
import { performActionActionSchema } from './perform-action';
import { toggleActionSchema } from './toggle';
import { urlActionSchema } from './url';

export const stockActionSchema = z.union([
  callServiceActionSchema,
  customActionSchema,
  moreInfoActionSchema,
  navigateActionSchema,
  noneActionSchema,
  performActionActionSchema,
  toggleActionSchema,
  urlActionSchema,
]);



================================================
FILE: src/config/schema/actions/stock/url.ts
================================================
import { z } from 'zod';
import { actionBaseSchema } from '../base';

export const urlActionSchema = actionBaseSchema.extend({
  action: z.literal('url'),
  url_path: z.string(),
});
export type URLActionConfig = z.infer<typeof urlActionSchema>;



================================================
FILE: src/config/schema/camera/media-layout.ts
================================================
import { z } from 'zod';
import { panSchema } from '../common/pan';
import { zoomSchema } from '../common/zoom';

export const mediaLayoutConfigSchema = z.object({
  fit: z.enum(['contain', 'cover', 'fill']).optional(),
  position: z
    .object({
      x: z.number().min(0).max(100).optional(),
      y: z.number().min(0).max(100).optional(),
    })
    .optional(),
  view_box: z
    .object({
      bottom: z.number().min(0).max(100).optional().default(0),
      left: z.number().min(0).max(100).optional().default(0),
      right: z.number().min(0).max(100).optional().default(0),
      top: z.number().min(0).max(100).optional().default(0),
    })
    .optional(),
  pan: panSchema.optional(),
  zoom: zoomSchema.optional(),
});
export type MediaLayoutConfig = z.infer<typeof mediaLayoutConfigSchema>;



================================================
FILE: src/config/schema/camera/ptz.ts
================================================
import { z } from 'zod';
import { performActionActionSchema } from '../actions/stock/perform-action';

export const ptzCameraConfigDefaults = {
  r2c_delay_between_calls_seconds: 0.5,
  c2r_delay_between_calls_seconds: 0.2,
};

// To avoid lots of YAML duplication, provide an easy way to just specify the
// service data as actions for each PTZ action, and it will be preprocessed
// into the full form. This also provides compatability with the AlexIT/WebRTC
// PTZ configuration.
const dataPTZFormatToFullFormat = function (suffix: string): (data: unknown) => unknown {
  return (data) => {
    if (!data || typeof data !== 'object' || !data['service']) {
      return data;
    }
    const out = { ...data };
    Object.keys(data).forEach((key) => {
      const match = key.match(/^data_(.+)$/);
      const name = match?.[1];
      if (name && !(`${suffix}${name}` in data)) {
        out[`${suffix}${name}`] = {
          action: 'perform-action',
          perform_action: data['service'],
          data: data[key],
        };
        delete out[key];
        delete out['service'];
      }
    });
    return out;
  };
};

export const ptzCameraConfigSchema = z.preprocess(
  dataPTZFormatToFullFormat('actions_'),
  z
    .object({
      actions_left: performActionActionSchema.optional(),
      actions_left_start: performActionActionSchema.optional(),
      actions_left_stop: performActionActionSchema.optional(),

      actions_right: performActionActionSchema.optional(),
      actions_right_start: performActionActionSchema.optional(),
      actions_right_stop: performActionActionSchema.optional(),

      actions_up: performActionActionSchema.optional(),
      actions_up_start: performActionActionSchema.optional(),
      actions_up_stop: performActionActionSchema.optional(),

      actions_down: performActionActionSchema.optional(),
      actions_down_start: performActionActionSchema.optional(),
      actions_down_stop: performActionActionSchema.optional(),

      actions_zoom_in: performActionActionSchema.optional(),
      actions_zoom_in_start: performActionActionSchema.optional(),
      actions_zoom_in_stop: performActionActionSchema.optional(),

      actions_zoom_out: performActionActionSchema.optional(),
      actions_zoom_out_start: performActionActionSchema.optional(),
      actions_zoom_out_stop: performActionActionSchema.optional(),

      // The number of seconds between subsequent relative calls when converting a
      // relative request into a continuous request.
      r2c_delay_between_calls_seconds: z
        .number()
        .default(ptzCameraConfigDefaults.r2c_delay_between_calls_seconds),

      // The number of seconds between the start/stop call when converting a
      // continuous request into a relative request.
      c2r_delay_between_calls_seconds: z
        .number()
        .default(ptzCameraConfigDefaults.c2r_delay_between_calls_seconds),

      presets: z
        .preprocess(
          dataPTZFormatToFullFormat(''),
          z.union([
            z.record(performActionActionSchema),

            // This is used by the data_ style of action.
            z.object({ service: z.string().optional() }),
          ]),
        )
        .optional(),

      // This is used by the data_ style of action.
      service: z.string().optional(),
    })
    // We allow passthrough as there may be user-configured presets as "actions_<preset>" .
    .passthrough(),
);



================================================
FILE: src/config/schema/common/aspect-ratio.ts
================================================
import { z } from 'zod';

export const aspectRatioSchema = z
  .number()
  .array()
  .length(2)
  .or(
    z
      .string()
      .regex(/^\s*\d+\.?\d*\s*[:/]\s*\d+\.?\d*\s*$/)
      .transform((input) => input.split(/[:\/]/).map((d) => Number(d))),
  );



================================================
FILE: src/config/schema/common/const.ts
================================================
export const cardIDRegex = /^[-\w]+$/;

export const MENU_PRIORITY_DEFAULT = 50;
export const MENU_PRIORITY_MAX = 100;

export const STATUS_BAR_PRIORITY_DEFAULT = 50;
export const STATUS_BAR_PRIORITY_MAX = 100;

export const BUTTON_SIZE_MIN = 20;

// The default view (may not be supported on all cameras).
export const VIEW_DEFAULT = 'live' as const;

export const VIEWS_USER_SPECIFIED = [
  'diagnostics',
  'live',
  'clip',
  'clips',
  'folder',
  'folders',
  'snapshot',
  'snapshots',
  'recording',
  'recordings',
  'image',
  'timeline',
] as const;
export type AdvancedCameraCardUserSpecifiedView = (typeof VIEWS_USER_SPECIFIED)[number];
export type AdvancedCameraCardView =
  | AdvancedCameraCardUserSpecifiedView
  | 'media'
  | 'diagnostics';



================================================
FILE: src/config/schema/common/display.ts
================================================
import { z } from 'zod';

export const viewDisplayModeSchema = z.enum(['single', 'grid']);
export type ViewDisplayMode = z.infer<typeof viewDisplayModeSchema>;

const gridSelectedPositionSchema = z.enum(['default', 'first', 'last']);

export const viewDisplaySchema = z
  .object({
    mode: viewDisplayModeSchema.optional(),
    grid_selected_position: gridSelectedPositionSchema.optional(),
    grid_selected_width_factor: z.number().min(0).optional(),
    grid_max_columns: z.number().min(0).optional(),
    grid_columns: z.number().min(0).optional(),
  })
  .optional();
export type ViewDisplayConfig = z.infer<typeof viewDisplaySchema>;



================================================
FILE: src/config/schema/common/events-media.ts
================================================
import { z } from 'zod';

export const eventsMediaTypeSchema = z.enum(['all', 'clips', 'snapshots']);



================================================
FILE: src/config/schema/common/image.ts
================================================
import { z } from 'zod';

export const imageConfigDefault = {
  mode: 'auto' as const,
  refresh_seconds: 1,
  zoomable: true,
};

const IMAGE_MODES = ['auto', 'camera', 'entity', 'screensaver', 'url'] as const;
export type ImageMode = (typeof IMAGE_MODES)[number];

export const imageBaseConfigSchema = z.object({
  mode: z.enum(IMAGE_MODES).default(imageConfigDefault.mode),

  refresh_seconds: z.number().min(0).default(imageConfigDefault.refresh_seconds),

  url: z.string().optional(),
  entity: z.string().optional(),
  entity_parameters: z.string().optional(),
});



================================================
FILE: src/config/schema/common/media-actions.ts
================================================
export const MEDIA_ACTION_POSITIVE_CONDITIONS = ['selected', 'visible'] as const;
export const MEDIA_ACTION_NEGATIVE_CONDITIONS = ['unselected', 'hidden'] as const;

export const MEDIA_MUTE_CONDITIONS = [
  ...MEDIA_ACTION_NEGATIVE_CONDITIONS,
  'microphone',
] as const;

export const MEDIA_UNMUTE_CONDITIONS = [
  ...MEDIA_ACTION_POSITIVE_CONDITIONS,
  'microphone',
] as const;

export type AutoPlayCondition = (typeof MEDIA_ACTION_POSITIVE_CONDITIONS)[number];
export type AutoPauseCondition = (typeof MEDIA_ACTION_NEGATIVE_CONDITIONS)[number];
export type AutoMuteCondition = (typeof MEDIA_MUTE_CONDITIONS)[number];
export type AutoUnmuteCondition = (typeof MEDIA_UNMUTE_CONDITIONS)[number];

export type LazyUnloadCondition = (typeof MEDIA_ACTION_NEGATIVE_CONDITIONS)[number];



================================================
FILE: src/config/schema/common/pan.ts
================================================
import { z } from 'zod';

export const panSchema = z.object({
  x: z.number().min(0).max(100).optional(),
  y: z.number().min(0).max(100).optional(),
});



================================================
FILE: src/config/schema/common/regex.ts
================================================
import { z } from 'zod';

export const regexSchema = z.string().refine(
  (val) => {
    try {
      new RegExp(val);
    } catch {
      return false;
    }
    return true;
  },
  { message: 'Invalid regular expression' },
);



================================================
FILE: src/config/schema/common/status-bar.ts
================================================
import { z } from 'zod';
import { STATUS_BAR_PRIORITY_DEFAULT, STATUS_BAR_PRIORITY_MAX } from './const';

export const statusBarItemBaseSchema = z.object({
  enabled: z.boolean().default(true).optional(),
  priority: z
    .number()
    .min(0)
    .max(STATUS_BAR_PRIORITY_MAX)
    .default(STATUS_BAR_PRIORITY_DEFAULT)
    .optional(),
});



================================================
FILE: src/config/schema/common/transition-effect.ts
================================================
import { z } from 'zod';

export const transitionEffectConfigSchema = z.enum(['none', 'slide']);
export type TransitionEffect = z.infer<typeof transitionEffectConfigSchema>;



================================================
FILE: src/config/schema/common/zoom.ts
================================================
import { z } from 'zod';

export const ZOOM_MIN = 1;
export const ZOOM_MAX = 10;

export const zoomSchema = z.number().min(ZOOM_MIN).max(ZOOM_MAX);



================================================
FILE: src/config/schema/common/controls/next-previous.ts
================================================
import { z } from 'zod';
import { BUTTON_SIZE_MIN } from '../const';

export const nextPreviousControlConfigSchema = z.object({
  style: z.enum(['none', 'chevrons', 'icons', 'thumbnails']),
  size: z.number().min(BUTTON_SIZE_MIN),
});
export type NextPreviousControlConfig = z.infer<typeof nextPreviousControlConfigSchema>;



================================================
FILE: src/config/schema/common/controls/ptz.ts
================================================
import { z } from 'zod';

export const ptzControlsDefaults = {
  orientation: 'horizontal' as const,
  mode: 'auto' as const,
  hide_pan_tilt: false,
  hide_zoom: false,
  hide_home: false,
  position: 'bottom-right' as const,
};

export const ptzControlsConfigSchema = z.object({
  mode: z.enum(['off', 'auto', 'on']).default(ptzControlsDefaults.mode),
  position: z
    .enum(['top-left', 'top-right', 'bottom-left', 'bottom-right'])
    .default(ptzControlsDefaults.position),
  orientation: z
    .enum(['vertical', 'horizontal'])
    .default(ptzControlsDefaults.orientation),

  hide_pan_tilt: z.boolean().default(ptzControlsDefaults.hide_pan_tilt),
  hide_zoom: z.boolean().default(ptzControlsDefaults.hide_zoom),
  hide_home: z.boolean().default(ptzControlsDefaults.hide_home),

  style: z.object({}).passthrough().optional(),
});
export type PTZControlsConfig = z.infer<typeof ptzControlsConfigSchema>;



================================================
FILE: src/config/schema/common/controls/thumbnails.ts
================================================
import { z } from 'zod';

// The min/max width thumbnail.
export const THUMBNAIL_WIDTH_MIN = 75;
export const THUMBNAIL_WIDTH_DEFAULT = 100;
export const THUMBNAIL_WIDTH_MAX = 300;

const thumbnailControlsBaseDefaults = {
  size: THUMBNAIL_WIDTH_DEFAULT,
  show_details: true,
  show_favorite_control: true,
  show_timeline_control: true,
  show_download_control: true,
};

// Configuration for the actual rendered thumbnail.
export const thumbnailsControlBaseSchema = z.object({
  size: z
    .number()
    .min(THUMBNAIL_WIDTH_MIN)
    .max(THUMBNAIL_WIDTH_MAX)
    .default(thumbnailControlsBaseDefaults.size),
  show_details: z.boolean().default(thumbnailControlsBaseDefaults.show_details),
  show_favorite_control: z
    .boolean()
    .default(thumbnailControlsBaseDefaults.show_favorite_control),
  show_timeline_control: z
    .boolean()
    .default(thumbnailControlsBaseDefaults.show_timeline_control),
  show_download_control: z
    .boolean()
    .default(thumbnailControlsBaseDefaults.show_download_control),
});
export type ThumbnailsControlBaseConfig = z.infer<typeof thumbnailsControlBaseSchema>;

export const thumbnailControlsDefaults = {
  ...thumbnailControlsBaseDefaults,
  mode: 'right' as const,
};

export const thumbnailsControlSchema = thumbnailsControlBaseSchema.extend({
  mode: z
    .enum(['none', 'above', 'below', 'left', 'right'])
    .default(thumbnailControlsDefaults.mode),
});
export type ThumbnailsControlConfig = z.infer<typeof thumbnailsControlSchema>;



================================================
FILE: src/config/schema/common/controls/timeline.ts
================================================
import { z } from 'zod';
import { eventsMediaTypeSchema } from '../events-media';
import { thumbnailControlsDefaults } from './thumbnails';

const timelineCoreConfigDefault = {
  clustering_threshold: 3,
  events_media_type: 'all' as const,
  window_seconds: 60 * 60,
  show_recordings: true,
  style: 'stack' as const,
  pan_mode: 'pan' as const,
  format: {
    '24h': true,
  },
};

const timelinePanModeSchema = z.enum(['pan', 'seek', 'seek-in-media', 'seek-in-camera']);
export type TimelinePanMode = z.infer<typeof timelinePanModeSchema>;

const timelineFormatSchema = z.object({
  '24h': z.boolean().optional().default(timelineCoreConfigDefault.format['24h']),
});

export const timelineCoreConfigSchema = z.object({
  clustering_threshold: z
    .number()
    .optional()
    .default(timelineCoreConfigDefault.clustering_threshold),
  events_media_type: eventsMediaTypeSchema
    .optional()
    .default(timelineCoreConfigDefault.events_media_type),
  window_seconds: z
    .number()
    .min(1 * 60)
    .max(24 * 60 * 60)
    .optional()
    .default(timelineCoreConfigDefault.window_seconds),
  show_recordings: z
    .boolean()
    .optional()
    .default(timelineCoreConfigDefault.show_recordings),
  style: z.enum(['stack', 'ribbon']).optional().default(timelineCoreConfigDefault.style),
  pan_mode: timelinePanModeSchema.optional().default(timelineCoreConfigDefault.pan_mode),
  format: timelineFormatSchema.optional().default(timelineCoreConfigDefault.format),
});
export type TimelineCoreConfig = z.infer<typeof timelineCoreConfigSchema>;

export const miniTimelineConfigDefault = {
  ...timelineCoreConfigDefault,
  mode: 'none' as const,

  // Mini-timeline defaults to ribbon style.
  style: 'ribbon' as const,
};

export const miniTimelineConfigSchema = timelineCoreConfigSchema.extend({
  mode: z.enum(['none', 'above', 'below']).default(miniTimelineConfigDefault.mode),
  style: timelineCoreConfigSchema.shape.style.default(miniTimelineConfigDefault.style),
});
export type MiniTimelineControlConfig = z.infer<typeof miniTimelineConfigSchema>;

export const timelineConfigDefault = {
  ...timelineCoreConfigDefault,
  controls: {
    thumbnails: thumbnailControlsDefaults,
  },
};



================================================
FILE: src/config/schema/conditions/types.ts
================================================
import { z } from 'zod';
import { cameraConditionSchema } from './custom/camera';
import { configConditionSchema } from './custom/config';
import { displayModeConditionSchema } from './custom/display-mode';
import { expandConditionSchema } from './custom/expand';
import { fullscreenConditionSchema } from './custom/fullscreen';
import { initializedConditionSchema } from './custom/initialized';
import { interactionConditionSchema } from './custom/interaction';
import { keyConditionSchema } from './custom/key';
import { mediaLoadedConditionSchema } from './custom/media-loaded';
import { microphoneConditionSchema } from './custom/microphone';
import { triggeredConditionSchema } from './custom/triggered';
import { userAgentConditionSchema } from './custom/user-agent';
import { viewConditionSchema } from './custom/view';
import { numericStateConditionSchema } from './stock/numeric';
import { screenConditionSchema } from './stock/screen';
import { stateConditionSchema } from './stock/state';
import { templateConditionSchema } from './stock/template';
import { usersConditionSchema } from './stock/users';

// https://www.home-assistant.io/docs/scripts/conditions/#or-condition
type OrCondition = {
  condition: 'or';
  conditions: AdvancedCameraCardCondition[];
};
const orConditionSchema: z.ZodSchema<OrCondition> = z.object({
  condition: z.literal('or'),
  conditions: z
    .lazy(() => advancedCameraCardConditionSchema)
    .array()
    .min(1),
});

// https://www.home-assistant.io/docs/scripts/conditions/#and-condition
type AndCondition = {
  condition: 'and';
  conditions: AdvancedCameraCardCondition[];
};
const andConditionSchema: z.ZodSchema<AndCondition> = z.object({
  condition: z.literal('and'),
  conditions: z
    .lazy(() => advancedCameraCardConditionSchema)
    .array()
    .min(1),
});

// https://www.home-assistant.io/docs/scripts/conditions/#not-condition
type NotCondition = {
  condition: 'not';
  conditions: AdvancedCameraCardCondition[];
};
const notConditionSchema: z.ZodSchema<NotCondition> = z.object({
  condition: z.literal('not'),
  conditions: z
    .lazy(() => advancedCameraCardConditionSchema)
    .array()
    .min(1),
});

export const advancedCameraCardConditionSchema = z.union([
  // Stock conditions:
  numericStateConditionSchema,
  screenConditionSchema,
  stateConditionSchema,
  usersConditionSchema,
  orConditionSchema,
  andConditionSchema,
  notConditionSchema,
  templateConditionSchema,

  // Custom conditions:
  cameraConditionSchema,
  configConditionSchema,
  displayModeConditionSchema,
  expandConditionSchema,
  fullscreenConditionSchema,
  initializedConditionSchema,
  interactionConditionSchema,
  keyConditionSchema,
  mediaLoadedConditionSchema,
  microphoneConditionSchema,
  triggeredConditionSchema,
  userAgentConditionSchema,
  viewConditionSchema,
]);
export type AdvancedCameraCardCondition = z.infer<
  typeof advancedCameraCardConditionSchema
>;



================================================
FILE: src/config/schema/conditions/custom/camera.ts
================================================
import { z } from 'zod';

export const cameraConditionSchema = z.object({
  condition: z.literal('camera'),
  cameras: z.string().array().optional(),
});



================================================
FILE: src/config/schema/conditions/custom/config.ts
================================================
import { z } from 'zod';

export const configConditionSchema = z.object({
  condition: z.literal('config'),
  paths: z.string().array().optional(),
});



================================================
FILE: src/config/schema/conditions/custom/display-mode.ts
================================================
import { z } from 'zod';
import { viewDisplayModeSchema } from '../../common/display';

export const displayModeConditionSchema = z.object({
  condition: z.literal('display_mode'),
  display_mode: viewDisplayModeSchema,
});



================================================
FILE: src/config/schema/conditions/custom/expand.ts
================================================
import { z } from 'zod';

export const expandConditionSchema = z.object({
  condition: z.literal('expand'),
  expand: z.boolean(),
});



================================================
FILE: src/config/schema/conditions/custom/fullscreen.ts
================================================
import { z } from 'zod';

export const fullscreenConditionSchema = z.object({
  condition: z.literal('fullscreen'),
  fullscreen: z.boolean(),
});



================================================
FILE: src/config/schema/conditions/custom/initialized.ts
================================================
import { z } from 'zod';

export const initializedConditionSchema = z.object({
  condition: z.literal('initialized'),
});



================================================
FILE: src/config/schema/conditions/custom/interaction.ts
================================================
import { z } from 'zod';

export const interactionConditionSchema = z.object({
  condition: z.literal('interaction'),
  interaction: z.boolean(),
});



================================================
FILE: src/config/schema/conditions/custom/key.ts
================================================
import { z } from 'zod';

export const keyConditionSchema = z.object({
  condition: z.literal('key'),
  key: z.string(),
  state: z.enum(['down', 'up']).optional(),
  ctrl: z.boolean().optional(),
  shift: z.boolean().optional(),
  alt: z.boolean().optional(),
  meta: z.boolean().optional(),
});



================================================
FILE: src/config/schema/conditions/custom/media-loaded.ts
================================================
import { z } from 'zod';

export const mediaLoadedConditionSchema = z.object({
  condition: z.literal('media_loaded'),
  media_loaded: z.boolean(),
});



================================================
FILE: src/config/schema/conditions/custom/microphone.ts
================================================
import { z } from 'zod';

export const microphoneConditionSchema = z.object({
  condition: z.literal('microphone'),
  connected: z.boolean().optional(),
  muted: z.boolean().optional(),
});



================================================
FILE: src/config/schema/conditions/custom/triggered.ts
================================================
import { z } from 'zod';

export const triggeredConditionSchema = z.object({
  condition: z.literal('triggered'),
  triggered: z.string().array(),
});



================================================
FILE: src/config/schema/conditions/custom/user-agent.ts
================================================
import { z } from 'zod';
import { regexSchema } from '../../common/regex';

export const userAgentConditionSchema = z.object({
  condition: z.literal('user_agent'),
  user_agent: z.string().optional(),
  user_agent_re: regexSchema.optional(),
  companion: z.boolean().optional(),
});



================================================
FILE: src/config/schema/conditions/custom/view.ts
================================================
import { z } from 'zod';

export const viewConditionSchema = z.object({
  condition: z.literal('view'),
  views: z.string().array().optional(),
});



================================================
FILE: src/config/schema/conditions/stock/numeric.ts
================================================
import { z } from 'zod';

// https://www.home-assistant.io/dashboards/conditional/#numeric-state
export const numericStateConditionSchema = z.object({
  condition: z.literal('numeric_state'),
  entity: z.string(),
  above: z.number().optional(),
  below: z.number().optional(),
});



================================================
FILE: src/config/schema/conditions/stock/screen.ts
================================================
import { z } from 'zod';

// https://www.home-assistant.io/dashboards/conditional/#screen
export const screenConditionSchema = z.object({
  condition: z.literal('screen'),
  media_query: z.string(),
});



================================================
FILE: src/config/schema/conditions/stock/state.ts
================================================
import { z } from 'zod';

// https://www.home-assistant.io/dashboards/conditional/#state
export const stateConditionSchema = z.object({
  // If the condition is not specified, a state condition is assumed. This
  // allows the syntax to match a picture elements conditional:
  // https://www.home-assistant.io/dashboards/picture-elements/#conditional-element
  condition: z.literal('state').optional(),
  entity: z.string(),
  state: z.string().or(z.string().array()).optional(),
  state_not: z.string().or(z.string().array()).optional(),
});



================================================
FILE: src/config/schema/conditions/stock/template.ts
================================================
import { z } from 'zod';

// https://www.home-assistant.io/docs/scripts/conditions/#template-condition
export const templateConditionSchema = z.object({
  condition: z.literal('template'),
  value_template: z.string(),
});



================================================
FILE: src/config/schema/conditions/stock/types.ts
================================================
import { z } from 'zod';
import { numericStateConditionSchema } from './numeric';
import { screenConditionSchema } from './screen';
import { stateConditionSchema } from './state';
import { usersConditionSchema } from './users';

export const stockConditionSchema = z.discriminatedUnion('condition', [
  stateConditionSchema,
  numericStateConditionSchema,
  screenConditionSchema,
  usersConditionSchema,
]);
export type StockCondition = z.infer<typeof stockConditionSchema>;



================================================
FILE: src/config/schema/conditions/stock/users.ts
================================================
import { z } from 'zod';

// https://www.home-assistant.io/dashboards/conditional/#user
export const usersConditionSchema = z.object({
  condition: z.literal('user'),
  users: z.string().array().min(1),
});



================================================
FILE: src/config/schema/elements/base.ts
================================================
import { z } from 'zod';
import { actionsBaseSchema } from '../actions/types';

export const elementsBaseSchema = actionsBaseSchema.extend({
  style: z.record(z.string().nullable().or(z.undefined()).or(z.number())).optional(),
  title: z.string().nullable().optional(),
});



================================================
FILE: src/config/schema/elements/types.ts
================================================
import { z } from 'zod';
import {
  statusBarIconItemSchema,
  statusBarImageItemSchema,
  statusBarStringItemSchema,
} from '../actions/types';
import { StockCondition, stockConditionSchema } from '../conditions/stock/types';
import {
  AdvancedCameraCardCondition,
  advancedCameraCardConditionSchema,
} from '../conditions/types';
import { menuIconSchema } from './custom/menu/icon';
import { menuStateIconSchema } from './custom/menu/state-icon';
import { menuSubmenuSchema } from './custom/menu/submenu';
import { menuSubmenuSelectSchema } from './custom/menu/submenu-select';
import { customSchema } from './stock/custom';
import { iconSchema } from './stock/icon';
import { imageSchema } from './stock/image';
import { serviceCallButtonSchema } from './stock/service-call';
import { stateBadgeIconSchema } from './stock/state-badge';
import { stateIconSchema } from './stock/state-icon';
import { stateLabelSchema } from './stock/state-label';

// Condition elements are included in this upper file as they recursively
// include other elements. Putting these elements elsewhere would cause
// typescript circular dependency errors as the types need to be both included
// in the master pictureElementSchema, but also refer to it internally.
//
// Provide a manual type definition to avoid the `any` that would be created by
// the lazy() evaluation below.
// See: https://zod.dev/?id=recursive-types

// https://www.home-assistant.io/lovelace/picture-elements/#image-element
type Conditional = {
  type: 'conditional';
  conditions: StockCondition[];
  elements?: PictureElements;
};
export const conditionalSchema: z.ZodSchema<Conditional, z.ZodTypeDef> = z.object({
  type: z.literal('conditional'),
  conditions: stockConditionSchema.array(),
  elements: z.lazy(() => pictureElementsSchema),
});

export type AdvancedCameraCardConditional = {
  type: 'custom:advanced-camera-card-conditional';
  conditions: AdvancedCameraCardCondition[];
  elements?: PictureElements;
};
const advancedCameraCardConditionalSchema: z.ZodSchema<
  AdvancedCameraCardConditional,
  z.ZodTypeDef
> = z.object({
  type: z.literal('custom:advanced-camera-card-conditional'),
  conditions: advancedCameraCardConditionSchema.array(),
  elements: z.lazy(() => pictureElementsSchema),
});

// Cannot use discriminatedUnion since customSchema uses a superRefine, which
// causes false rejections.
const pictureElementSchema = z.union([
  conditionalSchema,
  customSchema,
  advancedCameraCardConditionalSchema,
  iconSchema,
  imageSchema,
  menuIconSchema,
  menuStateIconSchema,
  menuSubmenuSchema,
  menuSubmenuSelectSchema,
  serviceCallButtonSchema,
  stateBadgeIconSchema,
  stateIconSchema,
  stateLabelSchema,
  statusBarIconItemSchema,
  statusBarImageItemSchema,
  statusBarStringItemSchema,
]);

export const pictureElementsSchema = pictureElementSchema.array().optional();
export type PictureElements = z.infer<typeof pictureElementsSchema>;



================================================
FILE: src/config/schema/elements/custom/menu/base.ts
================================================
import { z } from 'zod';
import { MENU_PRIORITY_DEFAULT, MENU_PRIORITY_MAX } from '../../../common/const';

export const menuBaseSchema = z.object({
  enabled: z.boolean().default(true).optional(),
  priority: z
    .number()
    .min(0)
    .max(MENU_PRIORITY_MAX)
    .default(MENU_PRIORITY_DEFAULT)
    .optional(),
  alignment: z.enum(['matching', 'opposing']).default('matching').optional(),
  icon: z.string().optional(),
  permanent: z.boolean().default(false).optional(),
});



================================================
FILE: src/config/schema/elements/custom/menu/icon.ts
================================================
import { z } from 'zod';
import { iconSchema } from '../../stock/icon';
import { menuBaseSchema } from './base';

export const menuIconSchema = menuBaseSchema.merge(iconSchema).extend({
  type: z.literal('custom:advanced-camera-card-menu-icon'),
});
export type MenuIcon = z.infer<typeof menuIconSchema>;



================================================
FILE: src/config/schema/elements/custom/menu/state-icon.ts
================================================
import { z } from 'zod';
import { stateIconSchema } from '../../stock/state-icon';
import { menuBaseSchema } from './base';

export const menuStateIconSchema = menuBaseSchema
  .merge(stateIconSchema)
  .extend({
    type: z.literal('custom:advanced-camera-card-menu-state-icon'),
  })
  .merge(menuBaseSchema);
export type MenuStateIcon = z.infer<typeof menuStateIconSchema>;



================================================
FILE: src/config/schema/elements/custom/menu/submenu-select.ts
================================================
import { z } from 'zod';
import { stateIconSchema } from '../../stock/state-icon';
import { menuBaseSchema } from './base';
import { menuSubmenuItemSchema } from './submenu';

export const menuSubmenuSelectSchema = menuBaseSchema.merge(stateIconSchema).extend({
  type: z.literal('custom:advanced-camera-card-menu-submenu-select'),
  options: z.record(menuSubmenuItemSchema.deepPartial()).optional(),
});
export type MenuSubmenuSelect = z.infer<typeof menuSubmenuSelectSchema>;



================================================
FILE: src/config/schema/elements/custom/menu/submenu.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../../base';
import { iconSchema } from '../../stock/icon';
import { menuBaseSchema } from './base';

export const menuSubmenuItemSchema = elementsBaseSchema.extend({
  entity: z.string().optional(),
  icon: z.string().optional(),
  state_color: z.boolean().default(true).optional(),
  selected: z.boolean().default(false).optional(),
  subtitle: z.string().optional(),
  enabled: z.boolean().default(true).optional(),
});
export type MenuSubmenuItem = z.infer<typeof menuSubmenuItemSchema>;

export const menuSubmenuSchema = menuBaseSchema.merge(iconSchema).extend({
  type: z.literal('custom:advanced-camera-card-menu-submenu'),
  items: menuSubmenuItemSchema.array(),
});
export type MenuSubmenu = z.infer<typeof menuSubmenuSchema>;



================================================
FILE: src/config/schema/elements/custom/menu/types.ts
================================================
import { MenuIcon } from './icon';
import { MenuStateIcon } from './state-icon';
import { MenuSubmenu } from './submenu';
import { MenuSubmenuSelect } from './submenu-select';

export type MenuItem = MenuIcon | MenuStateIcon | MenuSubmenu | MenuSubmenuSelect;



================================================
FILE: src/config/schema/elements/stock/custom.ts
================================================
import { z } from 'zod';

// https://www.home-assistant.io/lovelace/picture-elements/#custom-elements
export const customSchema = z
  .object({
    // Insist that Advanced Camera Card custom elements are handled by other schemas.
    type: z.string().superRefine((val, ctx) => {
      if (!val.match(/^custom:(?!advanced-camera-card).+/)) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: 'advanced-camera-card custom elements must match specific schemas',
          fatal: true,
        });
      }
    }),
  })
  .passthrough();



================================================
FILE: src/config/schema/elements/stock/icon.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../base';

// https://www.home-assistant.io/lovelace/picture-elements/#icon-element
export const iconSchema = elementsBaseSchema.extend({
  type: z.literal('icon'),
  icon: z.string(),
  entity: z.string().optional(),
});



================================================
FILE: src/config/schema/elements/stock/image.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../base';

// https://www.home-assistant.io/lovelace/picture-elements/#image-element
export const imageSchema = elementsBaseSchema.extend({
  type: z.literal('image'),
  entity: z.string().optional(),
  image: z.string().optional(),
  camera_image: z.string().optional(),
  camera_view: z.string().optional(),
  state_image: z.object({}).passthrough().optional(),
  filter: z.string().optional(),
  state_filter: z.object({}).passthrough().optional(),
  aspect_ratio: z.string().optional(),
});



================================================
FILE: src/config/schema/elements/stock/service-call.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../base';

// https://www.home-assistant.io/lovelace/picture-elements/#service-call-button
export const serviceCallButtonSchema = elementsBaseSchema.extend({
  type: z.literal('service-button'),

  // Title is required for service button.
  title: z.string(),
  service: z.string(),
  service_data: z.object({}).passthrough().optional(),
});



================================================
FILE: src/config/schema/elements/stock/state-badge.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../base';

// https://www.home-assistant.io/lovelace/picture-elements/#state-badge
export const stateBadgeIconSchema = elementsBaseSchema.extend({
  type: z.literal('state-badge'),
  entity: z.string(),
});



================================================
FILE: src/config/schema/elements/stock/state-icon.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../base';

// https://www.home-assistant.io/lovelace/picture-elements/#state-icon
export const stateIconSchema = elementsBaseSchema.extend({
  type: z.literal('state-icon'),
  entity: z.string(),
  icon: z.string().optional(),
  state_color: z.boolean().default(true),
});



================================================
FILE: src/config/schema/elements/stock/state-label.ts
================================================
import { z } from 'zod';
import { elementsBaseSchema } from '../base';

// https://www.home-assistant.io/lovelace/picture-elements/#state-label
export const stateLabelSchema = elementsBaseSchema.extend({
  type: z.literal('state-label'),
  entity: z.string(),
  attribute: z.string().optional(),
  prefix: z.string().optional(),
  suffix: z.string().optional(),
});



================================================
FILE: src/ha/README.md
================================================
This directory is intended to contain usage agnostic Home Assistant
functionality.

# Background

Functions in these files are inspired by or modified from the unmaintained
https://github.com/custom-cards/custom-card-helpers and are under CC-LICENSE.

- `compute-domain.ts`
- `const.ts`
- `fire-hass-event.ts`
- `haptic.ts`

Other files remain under the Advanced Camera Card license.



================================================
FILE: src/ha/brands-url.ts
================================================
// Small set of utility functions to transform brand URLs. This is a fairly
// hacky approach used by the HA frontend to transform logos (which may be wide
// and not fit well in thumbnails, or may not respect the users themes) into
// icons. In order to ensure consistency of iconography across the card and Home
// Assistant, this is mirrored here.
//
// See: https://github.com/home-assistant/frontend/blob/dev/src/util/brands-url.ts
interface BrandsOptions {
  domain: string;
  type: 'icon' | 'logo' | 'icon@2x' | 'logo@2x';
  useFallback?: boolean;
  darkOptimized?: boolean;
  brand?: boolean;
}

export const brandsUrl = (options: BrandsOptions): string =>
  `https://brands.home-assistant.io/${options.brand ? 'brands/' : ''}${
    options.useFallback ? '_/' : ''
  }${options.domain}/${options.darkOptimized ? 'dark_' : ''}${options.type}.png`;

export const extractDomainFromBrandUrl = (url: string) => url.split('/')[4];

export const isBrandUrl = (thumbnail?: string | null): boolean =>
  !!thumbnail?.startsWith('https://brands.home-assistant.io/');



================================================
FILE: src/ha/canonical-url.ts
================================================
import { isHARelativeURL } from './is-ha-relative-url';
import { HomeAssistant } from './types';

/**
 * Ensure URLs use the correct HA URL (relevant for Chromecast where the default
 * location will be the Chromecast receiver, not HA).
 * @param url The media URL
 */
export function canonicalizeHAURL(hass: HomeAssistant, url: string): string;
export function canonicalizeHAURL(hass: HomeAssistant, url?: string): string | null;
export function canonicalizeHAURL(hass: HomeAssistant, url?: string): string | null {
  if (isHARelativeURL(url)) {
    return hass.hassUrl(url);
  }
  return url ?? null;
}



================================================
FILE: src/ha/CC-LICENSE
================================================
MIT License

Copyright (c) 2019 Custom cards for Home Assistant

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/ha/compute-domain.ts
================================================
export const computeDomain = (entityId: string): string => {
  return entityId.substring(0, entityId.indexOf('.'));
};



================================================
FILE: src/ha/const.ts
================================================
export const STATES_OFF = ['off', 'closed', 'locked'];
export const STATES_ON = ['on', 'open', 'unlocked'];



================================================
FILE: src/ha/download.ts
================================================
import { Endpoint } from '../types';
import { canonicalizeHAURL } from './canonical-url';
import { ResolvedMediaCache, resolveMedia } from './resolved-media';
import { HomeAssistant } from './types';

export const getMediaDownloadPath = async (
  hass: HomeAssistant,
  contentID?: string | null,
  resolvedMediaCache?: ResolvedMediaCache | null,
): Promise<Endpoint | null> => {
  if (!contentID) {
    return null;
  }
  const resolvedMedia = await resolveMedia(hass, contentID, resolvedMediaCache);
  return resolvedMedia ? { endpoint: canonicalizeHAURL(hass, resolvedMedia.url) } : null;
};



================================================
FILE: src/ha/entity-state-translation.ts
================================================
import { HassEntity } from 'home-assistant-js-websocket';
import { computeDomain } from './compute-domain.js';
import { Entity } from './registry/entity/types.js';
import { HomeAssistant } from './types.js';

/**
 * Get the translation of an entity state. Inspired by:
 * https://github.com/home-assistant/frontend/blob/dev/src/common/entity/compute_state_display.ts#L204-L218
 *
 * This may no longer be necessary to custom implement if `custom-card-helpers`
 * is updated to reflect how the Home Assistant frontend now [as of 2023-03-04]
 * computes state display (e.g. supports usage of `translation_key`).
 *
 * https://github.com/custom-cards/custom-card-helpers/blob/master/src/compute-state-display.ts
 *
 */
export const getEntityStateTranslation = (
  hass: HomeAssistant,
  entityID: string,
  options?: {
    entity?: Entity;
    state?: string;
  },
): string | null => {
  const stateObj: HassEntity | undefined = hass.states[entityID];
  const state = options?.state ? options.state : stateObj ? stateObj.state : null;

  if (!state) {
    return null;
  }

  const domain = computeDomain(entityID);
  const attributes = stateObj ? stateObj.attributes : null;

  return (
    // Return the translation_key translation.
    (options?.entity?.translation_key &&
      hass.localize(
        `component.${options.entity.platform}.entity.${domain}` +
          `.${options.entity.translation_key}.state.${state}`,
      )) ||
    // Return device class translation
    (attributes?.device_class &&
      hass.localize(`component.${domain}.state.${attributes.device_class}.${state}`)) ||
    // Return default translation
    hass.localize(`component.${domain}.state._.${state}`) ||
    // We don't know! Return the raw state.
    state
  );
};



================================================
FILE: src/ha/fire-hass-event.ts
================================================
import { ValidHassDomEvent } from './types';

/**
 * Fire an event has per Home Assistant frontend specifications. All events
 * fired by this method has expected content/behavior based on type.
 */
export const fireHASSEvent = <HassEvent extends ValidHassDomEvent>(
  target: EventTarget,
  type: HassEvent,
  detail?: HASSDomEvents[HassEvent],
  options?: {
    bubbles?: boolean;
    cancelable?: boolean;
    composed?: boolean;
  },
) => {
  target.dispatchEvent(
    new CustomEvent<HASSDomEvents[HassEvent]>(type, {
      bubbles: options?.bubbles ?? true,
      composed: options?.composed ?? true,
      cancelable: options?.cancelable ?? false,
      detail: detail,
    }),
  );
};



================================================
FILE: src/ha/get-entities.ts
================================================
import { HomeAssistant } from './types';

/**
 * Get entities from the HASS object.
 * @param hass
 * @param domain
 * @returns A list of entities ids.
 */
export const getEntitiesFromHASS = (hass: HomeAssistant, domain?: string): string[] => {
  const entities = Object.keys(hass.states).filter(
    (eid) => !domain || eid.substring(0, eid.indexOf('.')) === domain,
  );
  return entities.sort();
};



================================================
FILE: src/ha/get-entity-title.ts
================================================
import { HomeAssistant } from './types';

/**
 * Get the title of an entity.
 * @param entity The entity id.
 * @param hass The Home Assistant object.
 * @returns The title or undefined.
 */
export function getEntityTitle(hass?: HomeAssistant, entity?: string): string | null {
  return entity ? hass?.states[entity]?.attributes?.friendly_name ?? null : null;
}



================================================
FILE: src/ha/get-hass-differences.ts
================================================
import { HassEntity } from 'home-assistant-js-websocket';
import { HassStateDifference, HomeAssistant } from './types';

/**
 * Get the difference between two hass objects.
 * @param newHass The new HA object.
 * @param oldHass The old HA object.
 * @param entities The entities to examine for changes.
 * @param options An options object. stateOnly: whether or not to compare state
 * strings only, firstOnly: whether or not to get the first difference only.
 * @returns An array of HassStateDifference objects.
 */

export function getHassDifferences(
  newHass: HomeAssistant | undefined | null,
  oldHass: HomeAssistant | undefined | null,
  entities: string[] | null,
  options?: {
    firstOnly?: boolean;
    stateOnly?: boolean;
  },
): HassStateDifference[] {
  if (!newHass || !entities?.length) {
    return [];
  }

  const differences: HassStateDifference[] = [];
  for (const entity of entities) {
    const oldState: HassEntity | undefined = oldHass?.states[entity];
    const newState: HassEntity | undefined = newHass.states[entity];
    if (
      (options?.stateOnly && oldState?.state !== newState?.state) ||
      (!options?.stateOnly && oldState !== newState)
    ) {
      differences.push({
        entityID: entity,
        oldState: oldState,
        newState: newState,
      });
      if (options?.firstOnly) {
        break;
      }
    }
  }
  return differences;
}



================================================
FILE: src/ha/haptic.ts
================================================
/**
 * Broadcast haptic feedback requests
 */
import { fireHASSEvent } from './fire-hass-event';

// Allowed types are from iOS HIG.
// https://developer.apple.com/design/human-interface-guidelines/ios/user-interaction/feedback/#haptics
// Implementors on platforms other than iOS should attempt to match the patterns (shown in HIG) as closely as possible.
export type HapticType =
  | 'success'
  | 'warning'
  | 'failure'
  | 'light'
  | 'medium'
  | 'heavy'
  | 'selection';

declare global {
  interface HASSDomEvents {
    haptic: HapticType;
  }

  interface GlobalEventHandlersEventMap {
    haptic: CustomEvent<HapticType>;
  }
}

export const forwardHaptic = (hapticType: HapticType) => {
  fireHASSEvent(window, 'haptic', hapticType);
};



================================================
FILE: src/ha/has-hass-connection-changed.ts
================================================
import { HomeAssistant } from './types';

/**
 * Determine if HA connection state has changed.
 * @param newHass The new HA object.
 * @param oldHass The old HA object.
 * @returns `true` if the connection state has changed.
 */
export const hasHAConnectionStateChanged = (
  oldHass?: HomeAssistant | null,
  newHass?: HomeAssistant | null,
): boolean => {
  return oldHass?.connected !== newHass?.connected;
};



================================================
FILE: src/ha/is-ha-relative-url.ts
================================================
export function isHARelativeURL(url?: string): boolean {
  return !!url?.startsWith('/');
}



================================================
FILE: src/ha/is-hass-different.ts
================================================
import { getHassDifferences } from './get-hass-differences';
import { HomeAssistant } from './types';

/**
 * Determine if two hass objects are different for a list of entities.
 * @param newHass The new HA object.
 * @param oldHass The old HA object.
 * @param entities The entities to examine for changes.
 * @param options An options object. stateOnly: whether or not to compare state strings only.
 * @returns An array of HassStateDifference objects.
 */
export function isHassDifferent(
  newHass: HomeAssistant | undefined | null,
  oldHass: HomeAssistant | undefined | null,
  entities: string[] | null,
  options?: {
    stateOnly?: boolean;
  },
): boolean {
  return !!getHassDifferences(newHass, oldHass, entities, {
    ...options,
    firstOnly: true,
  }).length;
}



================================================
FILE: src/ha/is-triggered-state.ts
================================================
import { STATES_ON } from './const';

/**
 * Determine if a given state qualifies as 'triggered'.
 * @param state The HA entity state string.
 * @returns `true` if triggered, `false` otherwise.
 */
export const isTriggeredState = (state?: string): boolean => {
  return !!state && STATES_ON.includes(state);
};



================================================
FILE: src/ha/panel.ts
================================================
/**
 * Determine if a card is in panel mode.
 */
export const isCardInPanel = (card: HTMLElement): boolean => {
  const parent = card.getRootNode();
  return !!(
    parent &&
    parent instanceof ShadowRoot &&
    parent.host.tagName === 'HUI-PANEL-VIEW'
  );
};



================================================
FILE: src/ha/resolved-media.ts
================================================
import { LRUCache } from '../cache/lru';
import { errorToConsole } from '../utils/basic';
import { HomeAssistant, ResolvedMedia, resolvedMediaSchema } from './types';
import { homeAssistantWSRequest } from './ws-request';

// It's important the cache size be at least as large as the largest likely
// media query or media items will from a given query will be evicted for other
// items in the same query (which would result in only partial results being
// returned to the user).
// Note: Each entry is about 400 bytes.
const RESOLVED_MEDIA_CACHE_SIZE = 1000;

export class ResolvedMediaCache extends LRUCache<string, ResolvedMedia> {
  constructor() {
    super(RESOLVED_MEDIA_CACHE_SIZE);
  }
}

/**
 * Resolve a given media source item.
 * @param hass The Home Assistant object.
 * @param mediaContentID The media content ID.
 * @param cache An optional ResolvedMediaCache object.
 * @returns The resolved media or `null`.
 */
export const resolveMedia = async (
  hass: HomeAssistant,
  mediaContentID: string,
  cache?: ResolvedMediaCache | null,
): Promise<ResolvedMedia | null> => {
  const cachedValue = cache?.get(mediaContentID) ?? null;
  if (cachedValue) {
    return cachedValue;
  }
  const request = {
    type: 'media_source/resolve_media',
    media_content_id: mediaContentID,
  };
  let resolvedMedia: ResolvedMedia | null = null;
  try {
    resolvedMedia = await homeAssistantWSRequest(hass, resolvedMediaSchema, request);
  } catch (e) {
    errorToConsole(e as Error);
  }
  if (cache && resolvedMedia) {
    cache.set(mediaContentID, resolvedMedia);
  }
  return resolvedMedia;
};



================================================
FILE: src/ha/side-load-ha-elements.ts
================================================
import { CardHelpers, LovelaceCardWithEditor } from '../types';

/**
 * Side loads the HA elements this card needs. This trickery is unfortunate
 * necessary, see:
 *  - https://github.com/thomasloven/hass-config/wiki/PreLoading-Lovelace-Elements
 * @returns `true` if the load is successful, `false` otherwise.
 */
export const sideLoadHomeAssistantElements = async (): Promise<boolean> => {
  const neededElements = [
    'ha-button-menu',
    'ha-button',
    'ha-camera-stream',
    'ha-card',
    'ha-combo-box',
    'ha-hls-player',
    'ha-icon-button',
    'ha-icon',
    'ha-menu-button',
    'ha-selector',
    'ha-spinner',
    'ha-state-icon',
    'ha-web-rtc-player',
    'mwc-button',
    'mwc-list-item',
    'state-badge',
  ];

  if (neededElements.every((element) => customElements.get(element))) {
    return true;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const helpers: CardHelpers = await (window as any).loadCardHelpers();

  // This bizarre combination of hacks creates a dummy picture glance card, then
  // waits for it to be fully loaded/upgraded as a custom element, so it will
  // have the getConfigElement() method which is necessary to load all the
  // elements this card requires.
  await helpers.createCardElement({
    type: 'picture-glance',
    entities: [],
    camera_image: 'dummy-to-load-editor-components',
  });

  // Some cast devices have a bug that causes whenDefined to return
  // undefined instead of a constructor.
  // See related: https://issues.chromium.org/issues/40846966
  await customElements.whenDefined('hui-picture-glance-card');
  const pgcConstructor = customElements.get('hui-picture-glance-card');
  if (!pgcConstructor) {
    return false;
  }

  const pgc = new pgcConstructor() as LovelaceCardWithEditor;

  await pgc.constructor.getConfigElement();

  return true;
};



================================================
FILE: src/ha/sign-path.ts
================================================
import { SignedPath, signedPathSchema } from '../types';
import { HomeAssistant } from './types';
import { homeAssistantWSRequest } from './ws-request';

/**
 * Request that HA sign a path. May throw.
 * @param hass The HomeAssistant object used to request the signature.
 * @param path The path to sign.
 * @param expires An optional number of seconds to sign the path for (by default
 * HA will sign for 30 seconds).
 * @returns The signed URL, or null if the response was malformed.
 */

export async function homeAssistantSignPath(
  hass: HomeAssistant,
  path: string,
  expires?: number,
): Promise<string | null> {
  const request = {
    type: 'auth/sign_path',
    path: path,
    expires: expires,
  };
  const response = await homeAssistantWSRequest<SignedPath>(
    hass,
    signedPathSchema,
    request,
  );
  if (!response) {
    return null;
  }
  return hass.hassUrl(response.path);
}



================================================
FILE: src/ha/supports-feature.ts
================================================
import { HassEntity } from 'home-assistant-js-websocket';

/**
 * Determine if a state object supports a given feature.
 * @param stateObj The state object.
 * @param feature The feature to check.
 * @returns `true` if the feature is supported, `false` otherwise.
 */

export const supportsFeature = (stateObj: HassEntity, feature: number): boolean =>
  ((stateObj.attributes.supported_features ?? 0) & feature) !== 0;



================================================
FILE: src/ha/types.ts
================================================
import {
  Auth,
  Connection,
  HassConfig,
  HassEntities,
  HassEntity,
  HassServices,
  HassServiceTarget,
  MessageBase,
} from 'home-assistant-js-websocket';
import { z } from 'zod';

declare global {
  interface HASSDomEvents {
    'value-changed': {
      value: unknown;
    };
    'config-changed': {
      config: unknown;
    };
    'hass-more-info': {
      entityId: string | undefined;
    };
    'll-rebuild': object;
    'll-custom': object;
    'location-changed': {
      replace: boolean;
    };
    'show-dialog': object;
    undefined: unknown;
    action: {
      action: string;
    };
  }
}

export type ValidHassDomEvent = keyof HASSDomEvents;

declare type LocalizeFunc = (key: string, ...args: unknown[]) => string;

interface Credential {
  auth_provider_type: string;
  auth_provider_id: string;
}

interface MFAModule {
  id: string;
  name: string;
  enabled: boolean;
}

export interface CurrentUser {
  id: string;
  is_owner: boolean;
  is_admin: boolean;
  name: string;
  credentials: Credential[];
  mfa_modules: MFAModule[];
}

interface Theme {
  'primary-color': string;
  'text-primary-color': string;
  'accent-color': string;
}

interface Themes {
  darkMode?: boolean;
  default_theme: string;
  themes: {
    [key: string]: Theme;
  };
}

interface Panel {
  component_name: string;
  config: {
    [key: string]: unknown;
  } | null;
  icon: string | null;
  title: string | null;
  url_path: string;
}

interface Panels {
  [name: string]: Panel;
}

interface Resources {
  [language: string]: {
    [key: string]: string;
  };
}

interface Translation {
  nativeName: string;
  isRTL: boolean;
  fingerprints: {
    [fragment: string]: string;
  };
}

export interface ServiceCallRequest {
  domain: string;
  service: string;
  serviceData?: Record<string, unknown>;
  target?: HassServiceTarget;
}

export interface HomeAssistant {
  auth: Auth;
  connection: Connection;
  connected: boolean;
  states: HassEntities;
  services: HassServices;
  config: HassConfig;
  themes: Themes;
  selectedTheme?: string | null;
  panels: Panels;
  panelUrl: string;
  language: string;
  locale: FrontendLocaleData;
  selectedLanguage: string | null;
  resources: Resources;
  localize: LocalizeFunc;
  translationMetadata: {
    fragments: string[];
    translations: {
      [lang: string]: Translation;
    };
  };
  dockedSidebar: boolean;
  moreInfoEntityId: string;
  user: CurrentUser;
  callService: (
    domain: ServiceCallRequest['domain'],
    service: ServiceCallRequest['service'],
    serviceData?: ServiceCallRequest['serviceData'],
    target?: ServiceCallRequest['target'],
  ) => Promise<void>;
  callApi: <T>(
    method: 'GET' | 'POST' | 'PUT' | 'DELETE',
    path: string,
    parameters?: {
      [key: string]: unknown;
    },
  ) => Promise<T>;
  fetchWithAuth: (
    path: string,
    init?: {
      [key: string]: unknown;
    },
  ) => Promise<Response>;
  hassUrl(path?): string;
  sendWS: (msg: MessageBase) => Promise<void>;
  callWS: <T>(msg: MessageBase) => Promise<T>;
}

declare enum NumberFormat {
  language = 'language',
  system = 'system',
  comma_decimal = 'comma_decimal',
  decimal_comma = 'decimal_comma',
  space_comma = 'space_comma',
  none = 'none',
}

declare enum TimeFormat {
  language = 'language',
  system = 'system',
  am_pm = '12',
  twenty_four = '24',
}

interface FrontendLocaleData {
  language: string;
  number_format: NumberFormat;
  time_format: TimeFormat;
}

export interface LovelaceCardConfig {
  index?: number;
  view_index?: number;
  type: string;
  [key: string]: unknown;
}

export interface LovelaceCard extends HTMLElement {
  hass?: HomeAssistant;
  isPanel?: boolean;
  editMode?: boolean;
  getCardSize(): number | Promise<number>;
  setConfig(config: LovelaceCardConfig): void;
}

export interface LovelaceCardEditor extends HTMLElement {
  hass?: HomeAssistant;
  lovelace?: LovelaceConfig;
  setConfig(config: LovelaceCardConfig): void;
}

interface LovelaceConfig {
  title?: string;
  views: LovelaceViewConfig[];
  background?: string;
}

interface LovelaceViewConfig {
  index?: number;
  title?: string;
  badges?: Array<string | LovelaceBadgeConfig>;
  cards?: LovelaceCardConfig[];
  path?: string;
  icon?: string;
  theme?: string;
  panel?: boolean;
  background?: string;
  visible?: boolean | ShowViewConfig[];
}

interface ShowViewConfig {
  user?: string;
}

interface LovelaceBadgeConfig {
  type?: string;
  [key: string]: unknown;
}

export interface ActionHandlerDetail {
  action: string;
}

export interface ActionHandlerOptions {
  hasHold?: boolean;
  hasDoubleClick?: boolean;
}

export interface HassStateDifference {
  entityID: string;
  oldState?: HassEntity;
  newState: HassEntity;
}

// *************************************************************************
//                     Home Assistant API types.
// *************************************************************************
// Server side data-type defined here:
// https://github.com/home-assistant/core/blob/dev/homeassistant/components/media_source/models.py

export const resolvedMediaSchema = z.object({
  url: z.string(),
  mime_type: z.string(),
});
export type ResolvedMedia = z.infer<typeof resolvedMediaSchema>;



================================================
FILE: src/ha/web-proxy.ts
================================================
import { CameraProxyConfig } from '../camera-manager/types';
import { HomeAssistant } from './types';

export const HASS_WEB_PROXY_DOMAIN = 'hass_web_proxy';

const hasWebProxyAvailable = (hass: HomeAssistant): boolean => {
  return hass.config.components.includes(HASS_WEB_PROXY_DOMAIN);
};

export const getWebProxiedURL = (url: string, v?: number): string => {
  return `/api/${HASS_WEB_PROXY_DOMAIN}/v${v ?? 0}/?url=${encodeURIComponent(url)}`;
};

export const shouldUseWebProxy = (
  hass: HomeAssistant,
  proxyConfig: CameraProxyConfig,
  context: 'media' = 'media',
): boolean => {
  return hasWebProxyAvailable(hass) && !!proxyConfig[context];
};

/**
 * Request that HA sign a path. May throw.
 * @param hass The HomeAssistant object used to request the signature.
 * @param path The path to sign.
 * @param expires An optional number of seconds to sign the path for (by default
 * HA will sign for 30 seconds).
 * @returns The signed URL, or null if the response was malformed.
 */
export async function addDynamicProxyURL(
  hass: HomeAssistant,
  url_pattern: string,
  options?: {
    urlID?: string;
    sslVerification?: boolean;
    sslCiphers?: string;
    openLimit?: number;
    ttl?: number;
    allowUnauthenticated?: boolean;
  },
): Promise<void> {
  await hass.callService(HASS_WEB_PROXY_DOMAIN, 'create_proxied_url', {
    url_pattern: url_pattern,
    ...(options && {
      url_id: options.urlID,
      ssl_verification: options.sslVerification,
      ssl_ciphers: options.sslCiphers,
      open_limit: options.openLimit,
      ttl: options.ttl,
      allow_unauthenticated: options.allowUnauthenticated,
    }),
  });
}



================================================
FILE: src/ha/ws-request.ts
================================================
import { MessageBase } from 'home-assistant-js-websocket';
import { ZodSchema } from 'zod';
import { localize } from '../localize/localize';
import { AdvancedCameraCardError } from '../types';
import { HomeAssistant } from './types';

/**
 * Make a HomeAssistant websocket request. May throw.
 * @param hass The HomeAssistant object to send the request with.
 * @param schema The expected Zod schema of the response.
 * @param request The request to make.
 * @returns The parsed valid response or null on malformed.
 */

export async function homeAssistantWSRequest<T>(
  hass: HomeAssistant,
  schema: ZodSchema<T>,
  request: MessageBase,
  passthrough = false,
): Promise<T> {
  let response: unknown;
  try {
    response = await hass.callWS<T>(request);
  } catch (e) {
    throw new AdvancedCameraCardError(localize('error.failed_response'), {
      request: request,
      response: e,
    });
  }

  if (!response) {
    throw new AdvancedCameraCardError(localize('error.empty_response'), {
      request: request,
    });
  }

  try {
    // Some endpoints in Home Assistant pass JSON directly though, these end up
    // wrapped in a string and must be unwrapped first.
    return schema.parse(passthrough ? JSON.parse(response as string) : response);
  } catch (e) {
    throw new AdvancedCameraCardError(localize('error.invalid_response'), {
      request: request,
      response: response,
      error: e,
    });
  }
}



================================================
FILE: src/ha/browse-media/browse-media-to-view-media.ts
================================================
import { isTruthy } from '../../utils/basic';
import { ViewItem, ViewMedia, ViewMediaSourceOptions } from '../../view/item';
import { ViewItemClassifier } from '../../view/item-classifier';
import { BrowseMediaViewItemFactory } from './item-factory';
import { BrowseMediaMetadata, RichBrowseMedia } from './types';

export const getViewMediaFromBrowseMediaArray = (
  browseMedia: RichBrowseMedia<BrowseMediaMetadata>[],
  options?: ViewMediaSourceOptions,
): ViewMedia[] => {
  return getViewItemsFromBrowseMediaArray(browseMedia, options).filter((item) =>
    ViewItemClassifier.isMedia(item),
  );
};

export const getViewItemsFromBrowseMediaArray = <M extends BrowseMediaMetadata>(
  browseMedia: RichBrowseMedia<M>[],
  options?: ViewMediaSourceOptions,
): ViewItem[] => {
  return browseMedia
    .map((item) =>
      BrowseMediaViewItemFactory.create(item, {
        cameraID: item._metadata?.cameraID,
        ...options,
      }),
    )
    .filter(isTruthy);
};



================================================
FILE: src/ha/browse-media/item-factory.ts
================================================
import { ViewItem, ViewMediaSourceOptions, ViewMediaType } from '../../view/item';
import { BrowseMediaEventViewMedia, BrowseMediaViewFolder } from './item';
import {
  BrowseMediaMetadata,
  MEDIA_CLASS_IMAGE,
  MEDIA_CLASS_VIDEO,
  RichBrowseMedia,
} from './types';

export class BrowseMediaViewItemFactory {
  static create(
    browseMedia: RichBrowseMedia<BrowseMediaMetadata>,
    options?: ViewMediaSourceOptions,
  ): ViewItem | null {
    if (browseMedia.can_expand) {
      return options?.folder
        ? new BrowseMediaViewFolder(options.folder, browseMedia)
        : null;
    }

    const mediaType =
      browseMedia.media_class === MEDIA_CLASS_VIDEO
        ? ViewMediaType.Clip
        : browseMedia.media_class === MEDIA_CLASS_IMAGE
          ? ViewMediaType.Snapshot
          : null;

    return mediaType
      ? new BrowseMediaEventViewMedia(mediaType, browseMedia, options)
      : null;
  }
}



================================================
FILE: src/ha/browse-media/item.ts
================================================
import { format } from 'date-fns';
import { isEqual } from 'lodash-es';
import { FolderConfig } from '../../config/schema/folders';
import { formatDateAndTime } from '../../utils/basic';
import {
  EventViewMedia,
  VideoContentType,
  ViewFolder,
  ViewMedia,
  ViewMediaSourceOptions,
  ViewMediaType,
} from '../../view/item';
import { BrowseMediaMetadata, RichBrowseMedia } from './types';

interface MediaClassBrowserSetting {
  icon: string;
}

const mediaClassBrowserSettings: Record<string, MediaClassBrowserSetting> = {
  album: { icon: 'mdi:album' },
  app: { icon: 'mdi:application' },
  artist: { icon: 'mdi:account-music' },
  channel: { icon: 'mdi:television-classic' },
  composer: { icon: 'mdi:account-music-outline' },
  contributing_artist: { icon: 'mdi:account-music' },
  directory: { icon: 'mdi:folder' },
  episode: { icon: 'mdi:television-classic' },
  game: { icon: 'mdi:gamepad-variant' },
  genre: { icon: 'mdi:drama-masks' },
  image: { icon: 'mdi:image' },
  movie: { icon: 'mdi:movie' },
  music: { icon: 'mdi:music' },
  playlist: { icon: 'mdi:playlist-music' },
  podcast: { icon: 'mdi:podcast' },
  season: { icon: 'mdi:television-classic' },
  track: { icon: 'mdi:file-music' },
  tv_show: { icon: 'mdi:television-classic' },
  url: { icon: 'mdi:web' },
  video: { icon: 'mdi:video' },
};

const getIcon = (mediaClass: string): string | null => {
  return mediaClassBrowserSettings[mediaClass]?.icon ?? null;
};

export class BrowseMediaEventViewMedia extends ViewMedia implements EventViewMedia {
  protected _browseMedia: RichBrowseMedia<BrowseMediaMetadata | undefined>;
  protected _id: string;
  protected _icon: string | null;

  constructor(
    mediaType: ViewMediaType,
    browseMedia: RichBrowseMedia<BrowseMediaMetadata | undefined>,
    options?: ViewMediaSourceOptions,
  ) {
    super(mediaType, {
      cameraID: options?.cameraID ?? browseMedia._metadata?.cameraID,
      ...options,
    });
    this._browseMedia = browseMedia;
    this._icon = getIcon(browseMedia.media_class);

    // Generate a custom ID that uses the start date (to allow multiple
    // BrowseMedia objects (e.g. images and movies) to be de-duplicated).
    this._id =
      browseMedia._metadata?.startDate && this._cameraID
        ? `${this._cameraID}/${format(
            browseMedia._metadata.startDate,
            'yyyy-MM-dd HH:mm:ss',
          )}`
        : browseMedia.media_content_id;
  }

  public getStartTime(): Date | null {
    return this._browseMedia._metadata?.startDate ?? null;
  }
  public getEndTime(): Date | null {
    return this._browseMedia._metadata?.endDate ?? null;
  }
  public getVideoContentType(): VideoContentType | null {
    return this._mediaType === ViewMediaType.Clip ? VideoContentType.MP4 : null;
  }
  public getID(): string {
    return this._id;
  }
  public getContentID(): string {
    return this._browseMedia.media_content_id;
  }
  public getTitle(): string | null {
    const startTime = this.getStartTime();
    return startTime ? formatDateAndTime(startTime) : this._browseMedia.title;
  }
  public getThumbnail(): string | null {
    return this._browseMedia.thumbnail;
  }
  public getIcon(): string | null {
    return this._icon;
  }
  public getWhat(): string[] | null {
    return this._browseMedia._metadata?.what ?? null;
  }
  public getScore(): number | null {
    return null;
  }
  public getTags(): string[] | null {
    return null;
  }
  public isGroupableWith(that: EventViewMedia): boolean {
    return (
      this.getMediaType() === that.getMediaType() &&
      isEqual(this.getWhat(), that.getWhat())
    );
  }
}

export class BrowseMediaViewFolder extends ViewFolder {
  private _browseMedia: RichBrowseMedia<BrowseMediaMetadata>;

  constructor(folder: FolderConfig, browseMedia: RichBrowseMedia<BrowseMediaMetadata>) {
    super(folder, {
      id: browseMedia.media_content_id,
      icon: getIcon(browseMedia.children_media_class ?? browseMedia.media_class),
      title: browseMedia.title,
      thumbnail: browseMedia.thumbnail,
    });
    this._browseMedia = browseMedia;
  }

  public getBrowseMedia(): RichBrowseMedia<BrowseMediaMetadata> {
    return this._browseMedia;
  }
}



================================================
FILE: src/ha/browse-media/sort.ts
================================================
import { orderBy } from 'lodash-es';
import { BrowseMediaMetadata, RichBrowseMedia } from './types';

// Unlike sorting of view items (see card-controller/view/sort.ts), for browse
// media we often need to sort by most recent first to apply an item count
// cutoff from the most recent (this differs from how items may be sorted prior
// to presentation).
//
// See: https://github.com/dermotduffy/advanced-camera-card/issues/2078

export const sortMostRecentFirst = (
  media: RichBrowseMedia<BrowseMediaMetadata>[],
): RichBrowseMedia<BrowseMediaMetadata>[] => {
  return orderBy(media, (media) => media._metadata?.startDate, 'desc');
};



================================================
FILE: src/ha/browse-media/types.ts
================================================
import { z } from 'zod';
import { ExpiringEqualityCache } from '../../cache/expiring-cache';

export interface BrowseMediaMetadata {
  cameraID?: string;
  startDate?: Date;
  endDate?: Date;
  what?: string[];
}
// Recursive type, cannot use type interference:
// See: https://github.com/colinhacks/zod#recursive-types
//
// Server side data-type defined here: https://github.com/home-assistant/core/blob/dev/homeassistant/components/media_player/browse_media.py#L90

export interface BrowseMedia {
  title: string;
  media_class: string;
  media_content_type: string;
  media_content_id: string;
  can_play: boolean;
  can_expand: boolean;
  children_media_class?: string | null;
  thumbnail: string | null;
  children?: BrowseMedia[] | null;
}

export const browseMediaSchema: z.ZodSchema<BrowseMedia> = z.lazy(() =>
  z.object({
    title: z.string(),
    media_class: z.string(),
    media_content_type: z.string(),
    media_content_id: z.string(),
    can_play: z.boolean(),
    can_expand: z.boolean(),
    children_media_class: z.string().nullable().optional(),
    thumbnail: z.string().nullable(),
    children: z.array(browseMediaSchema).nullable().optional(),
  }),
);

export interface RichBrowseMedia<M> extends BrowseMedia {
  _metadata?: M;
  children?: RichBrowseMedia<M>[] | null;
}

export class BrowseMediaCache<M = undefined> extends ExpiringEqualityCache<
  string,
  RichBrowseMedia<M>
> {}

export const MEDIA_CLASS_VIDEO = 'video' as const;
export const MEDIA_CLASS_IMAGE = 'image' as const;

export const BROWSE_MEDIA_CACHE_SECONDS = 60 as const;



================================================
FILE: src/ha/browse-media/walker.ts
================================================
import { add } from 'date-fns';
import { chunk } from 'lodash-es';
import { allPromises } from '../../utils/basic';
import { HomeAssistant } from '../types';
import { homeAssistantWSRequest } from '../ws-request';
import {
  BROWSE_MEDIA_CACHE_SECONDS,
  BrowseMedia,
  BrowseMediaCache,
  browseMediaSchema,
  RichBrowseMedia,
} from './types';

type RichMetadataGenerator<M> = (
  media: BrowseMedia,
  parent?: RichBrowseMedia<M>,
) => M | null;

export type BrowseMediaTarget<M = undefined> = string | RichBrowseMedia<M>;
type RichBrowseMediaPredicate<M> = (media: RichBrowseMedia<M>) => boolean;

export interface BrowseMediaStep<M = undefined> {
  // The targets to start the media walk from.
  targets: BrowseMediaTarget<M>[];

  // How many children to process concurrently. Default is infinite.
  concurrency?: number;

  // All children of the target have the metadata generator applied to them
  // first.
  metadataGenerator?: RichMetadataGenerator<M>;

  // If those children pass this matcher, then they will be included in the
  // output.
  matcher?: RichBrowseMediaPredicate<M>;

  // Children (once past the matcher) will be sorted before the next step.
  sorter?: (media: RichBrowseMedia<M>[]) => RichBrowseMedia<M>[];

  // Whether to exit the walk early with the given output.
  earlyExit?: (media: RichBrowseMedia<M>[]) => boolean;

  // advance will be called to generate a next step (or null if the child should
  // just be included straight through to the output with no further steps).
  advance?: BrowseMediaStepAdvancer<M>;
}

type BrowseMediaStepAdvancer<M> = (media: RichBrowseMedia<M>[]) => BrowseMediaStep<M>[];

export class BrowseMediaWalker {
  // Walk down a browse media tree according to instructions included in `steps`.
  public async walk<M = undefined>(
    hass: HomeAssistant,
    steps: BrowseMediaStep<M>[] | null,
    options?: {
      cache?: BrowseMediaCache<M>;
    },
  ): Promise<RichBrowseMedia<M>[]> {
    if (!steps || !steps.length) {
      return [];
    }

    return (
      await allPromises(
        steps,
        async (step) => await this._walkBrowseMedia(hass, step, options),
      )
    ).flat();
  }

  protected async _walkBrowseMedia<M>(
    hass: HomeAssistant,
    step: BrowseMediaStep<M>,
    options?: {
      cache?: BrowseMediaCache<M>;
    },
  ): Promise<RichBrowseMedia<M>[]> {
    let output: RichBrowseMedia<M>[] = [];

    for (const targetChunk of chunk(step.targets, step.concurrency ?? Infinity)) {
      const mediaChunk = await allPromises(
        targetChunk,
        async (target) =>
          await this._browseMedia(hass, target, {
            cache: options?.cache,
            metadataGenerator: step.metadataGenerator,
          }),
      );

      for (const parent of mediaChunk) {
        for (const child of parent.children ?? []) {
          if (!step.matcher || step.matcher(child)) {
            output.push(child);
          }
        }
      }

      if (step.sorter) {
        output = step.sorter(output);
      }

      if (step.earlyExit && step.earlyExit(output)) {
        break;
      }
    }

    const nextSteps = step.advance ? step.advance(output) : null;
    if (!nextSteps?.length) {
      return output;
    }
    return await this.walk(hass, nextSteps, options);
  }

  protected async _browseMedia<M>(
    hass: HomeAssistant,
    target: string | RichBrowseMedia<M>,
    options?: {
      cache?: BrowseMediaCache<M>;
      metadataGenerator?: RichMetadataGenerator<M>;
    },
  ): Promise<RichBrowseMedia<M>> {
    const mediaContentID = typeof target === 'object' ? target.media_content_id : target;
    const cachedResult = options?.cache ? options.cache.get(mediaContentID) : null;
    if (cachedResult) {
      return cachedResult;
    }

    const request = {
      type: 'media_source/browse_media',
      media_content_id: mediaContentID,
    };
    const browseMedia = await homeAssistantWSRequest<RichBrowseMedia<M>>(
      hass,
      browseMediaSchema,
      request,
    );

    if (options?.metadataGenerator) {
      for (const child of browseMedia.children ?? []) {
        child._metadata =
          options.metadataGenerator(
            child,
            typeof target === 'object' ? target : undefined,
          ) ?? undefined;
      }
    }

    if (options?.cache) {
      options.cache.set(
        mediaContentID,
        browseMedia,
        add(new Date(), { seconds: BROWSE_MEDIA_CACHE_SECONDS }),
      );
    }
    return browseMedia;
  }
}



================================================
FILE: src/ha/browse-media/within-dates.ts
================================================
import { rangesOverlap } from '../../camera-manager/range';
import { BrowseMediaMetadata, RichBrowseMedia } from './types';

/**
 * A utility method to determine if a browse media object matches against a
 * start and end date.
 * @param media The browse media object (with rich metadata).
 * @param start The optional start date.
 * @param end The optional end date.
 * @returns `true` if the media falls within the provided dates.
 */

export const isMediaWithinDates = (
  media: RichBrowseMedia<BrowseMediaMetadata>,
  start?: Date,
  end?: Date,
): boolean => {
  // If there's no metadata, nothing matches.
  if (!media._metadata?.startDate || !media._metadata?.endDate) {
    return false;
  }

  if (start && end) {
    // Determine if:
    // - The media starts within the query timeframe.
    // - The media ends within the query timeframe.
    // - The media entirely encompasses the query timeframe.
    return rangesOverlap(
      {
        start: media._metadata.startDate,
        end: media._metadata.endDate,
      },
      {
        start: start,
        end: end,
      },
    );
  }

  if (!start && end) {
    return media._metadata.startDate <= end;
  }
  if (start && !end) {
    return media._metadata.startDate >= start;
  }

  // If no date is specified at all, everything matches.
  return true;
};



================================================
FILE: src/ha/integration/index.ts
================================================
import { HomeAssistant } from '../types.js';
import { homeAssistantWSRequest } from '../ws-request.js';
import { IntegrationManifest, integrationManifestSchema } from './types.js';

export const getIntegrationManifest = async (
  hass: HomeAssistant,
  integration: string,
): Promise<IntegrationManifest> => {
  return await homeAssistantWSRequest(hass, integrationManifestSchema, {
    type: 'manifest/get',
    integration: integration,
  });
};



================================================
FILE: src/ha/integration/types.ts
================================================
import { z } from 'zod';

export const integrationManifestSchema = z
  .object({
    domain: z.string(),
    version: z.string().optional(),
  })
  .passthrough();
export type IntegrationManifest = z.infer<typeof integrationManifestSchema>;



================================================
FILE: src/ha/registry/device/index.ts
================================================
import { errorToConsole } from '../../../utils/basic';
import { HomeAssistant } from '../../types';
import { homeAssistantWSRequest } from '../../ws-request';
import { Device, DeviceCache, DeviceList, deviceListSchema } from './types';

export class DeviceRegistryManager {
  protected _cache: DeviceCache;
  protected _fetchedDeviceList = false;

  constructor(cache: DeviceCache) {
    this._cache = cache;
  }

  public async getDevice(hass: HomeAssistant, deviceID: string): Promise<Device | null> {
    if (this._cache.has(deviceID)) {
      return this._cache.get(deviceID);
    }

    // There is currently no way to fetch a single device.
    await this._fetchDeviceList(hass);
    return this._cache.get(deviceID) ?? null;
  }

  public async getMatchingDevices(
    hass: HomeAssistant,
    func: (arg: Device) => boolean,
  ): Promise<Device[]> {
    await this._fetchDeviceList(hass);
    return this._cache.getMatches(func);
  }

  protected async _fetchDeviceList(hass: HomeAssistant): Promise<void> {
    if (this._fetchedDeviceList) {
      return;
    }

    let deviceList: DeviceList | null = null;
    try {
      deviceList = await homeAssistantWSRequest<DeviceList>(hass, deviceListSchema, {
        type: 'config/device_registry/list',
      });
    } catch (e) {
      errorToConsole(e as Error);
      return;
    }
    deviceList.forEach((device) => {
      this._cache.set(device.id, device);
    });
    this._fetchedDeviceList = true;
  }
}



================================================
FILE: src/ha/registry/device/types.ts
================================================
import { z } from 'zod';
import { Cache } from '../../../cache/cache';

const deviceSchema = z.object({
  id: z.string(),
  model: z.string().nullable(),
  config_entries: z.string().array(),
  manufacturer: z.string().nullable(),
});
export type Device = z.infer<typeof deviceSchema>;

export const deviceListSchema = deviceSchema.array();
export type DeviceList = z.infer<typeof deviceListSchema>;

export class DeviceCache extends Cache<string, Device> {}



================================================
FILE: src/ha/registry/entity/index.ts
================================================
import { errorToConsole } from '../../../utils/basic.js';
import { HomeAssistant } from '../../types.js';
import { homeAssistantWSRequest } from '../../ws-request.js';
import {
  Entity,
  EntityCache,
  EntityList,
  entityListSchema,
  EntityRegistryManager,
  entitySchema,
} from './types.js';

// This class manages interactions with entities, caching results and fetching
// as necessary. Some calls require every entity to be fetched, which may be
// non-trivial in size (after which they are cached forever).

export class EntityRegistryManagerLive implements EntityRegistryManager {
  protected _cache: EntityCache;
  protected _fetchedEntityList = false;

  constructor(cache: EntityCache) {
    this._cache = cache;
  }

  public async getEntity(hass: HomeAssistant, entityID: string): Promise<Entity | null> {
    const cachedEntity = this._cache.get(entityID);
    if (cachedEntity) {
      return cachedEntity;
    }

    let entity: Entity | null = null;
    try {
      entity = await homeAssistantWSRequest<Entity>(hass, entitySchema, {
        type: 'config/entity_registry/get',
        entity_id: entityID,
      });
    } catch (e) {
      errorToConsole(e as Error);
      return null;
    }
    this._cache.set(entity.entity_id, entity);
    return entity;
  }

  public async getMatchingEntities(
    hass: HomeAssistant,
    func: (arg: Entity) => boolean,
  ): Promise<Entity[]> {
    await this.fetchEntityList(hass);
    return this._cache.getMatches(func);
  }

  public async getEntities(
    hass: HomeAssistant,
    entityIDs: string[],
  ): Promise<Map<string, Entity>> {
    const output: Map<string, Entity> = new Map();
    const _storeEntity = async (entityID: string): Promise<void> => {
      const entity = await this.getEntity(hass, entityID);

      if (entity) {
        // When asked to fetch multiple entities, ignore missing entities (they
        // will just not feature in the output).
        output.set(entityID, entity);
      }
    };
    await Promise.all(entityIDs.map(_storeEntity));
    return output;
  }

  public async fetchEntityList(hass: HomeAssistant): Promise<void> {
    if (this._fetchedEntityList) {
      return;
    }

    let entityList: EntityList | null = null;
    try {
      entityList = await homeAssistantWSRequest<EntityList>(hass, entityListSchema, {
        type: 'config/entity_registry/list',
      });
    } catch (e) {
      errorToConsole(e as Error);
      return;
    }
    entityList.forEach((entity) => {
      this._cache.set(entity.entity_id, entity);
    });
    this._fetchedEntityList = true;
  }
}



================================================
FILE: src/ha/registry/entity/types.ts
================================================
import { z } from 'zod';
import { HomeAssistant } from '../../types';
import { Cache } from '../../../cache/cache';

export const entitySchema = z.object({
  config_entry_id: z.string().nullable(),
  device_id: z.string().nullable(),
  disabled_by: z.string().nullable(),
  entity_id: z.string(),
  hidden_by: z.string().nullable(),
  platform: z.string(),
  translation_key: z.string().nullable(),
  // Technically the unique_id should be a string, but we want to tolerate
  // numeric unique_ids also in case they are used. See:
  // https://github.com/dermotduffy/advanced-camera-card/issues/1016
  unique_id: z.string().or(z.number()).optional(),
});
export type Entity = z.infer<typeof entitySchema>;

export const entityListSchema = entitySchema.array();
export type EntityList = z.infer<typeof entityListSchema>;

export interface EntityRegistryManager {
  getEntity(hass: HomeAssistant, entityID: string): Promise<Entity | null>;
  getEntities(hass: HomeAssistant, entityIDs: string[]): Promise<Map<string, Entity>>;
  getMatchingEntities(
    hass: HomeAssistant,
    func: (arg: Entity) => boolean,
  ): Promise<Entity[]>;
  fetchEntityList(hass: HomeAssistant): Promise<void>;
}

export class EntityCache extends Cache<string, Entity> {}



================================================
FILE: src/images/README.md
================================================
# Image Copyright

## iris-screensaver.jpg

**Link**: https://unsplash.com/photos/purple-and-white-flower-in-tilt-shift-lens-y4xISRK8TUg

**Description**: Iris flowers in Vancouver Park.

**Copyright**: Kevin Castel

**License**: https://unsplash.com/license

**Image Formatting Process**:

- Scaled down to 492x277
- Quality @ 85%

```sh
$ convert -strip -interlace Plane -quality 85% -scale 492x277 iris-screensaver-original.jpg iris-screensaver.jpg
```

## iris.svg / iris-outline.svg

**Link**: https://pictogrammers.com/library/mdi/icon/camera-iris/

**License**: https://www.apache.org/licenses/LICENSE-2.0

**Image Formatting Process**:

- Outline addded manually
- Opacity adjustmented manually



================================================
FILE: src/localize/localize.ts
================================================
import { HomeAssistant } from '../ha/types';
import * as en from './languages/en.json';

const DEFAULT_LANG = 'en' as const;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const languages: Record<string, any> = {
  // English as always loaded as it's the fallback language that will be used
  // when translations are not found or before they are loaded (via
  // loadLanguages()).
  [DEFAULT_LANG]: en,
};

// The language is calculated and stored once, then re-used to avoid needing to
// repeat the lookups and to ensure minimal information needs to be plumbed
// through on each localization call.
let advancedCameraCardLanguage: string | undefined;

/**
 * Get the configured language.
 */
export function getLanguage(hass?: HomeAssistant): string {
  const canonicalizeLanguage = (language: string): string => {
    return language.replace('-', '_');
  };

  // Try the hass language first...
  const hassLanguage = hass?.language ?? hass?.selectedLanguage;
  if (hassLanguage) {
    return canonicalizeLanguage(hassLanguage);
  }

  // Then the language that hass may have stored locally.
  const storageLanguage = localStorage.getItem('selectedLanguage');
  if (storageLanguage) {
    const parsedLanguage: string | null = JSON.parse(storageLanguage);
    if (parsedLanguage) {
      return canonicalizeLanguage(parsedLanguage);
    }
  }

  // Then fall back to the browser language.
  for (const language of navigator.languages) {
    const canonicalLanguage = canonicalizeLanguage(language);
    if (canonicalLanguage && canonicalLanguage in languages) {
      return canonicalLanguage;
    }
  }
  return DEFAULT_LANG;
}

/**
 * Load required languages.
 */
export const loadLanguages = async (hass: HomeAssistant): Promise<boolean> => {
  const lang = getLanguage(hass);
  if (lang === 'ca') {
    languages[lang] = await import('./languages/ca.json');
  } else if (lang === 'it') {
    languages[lang] = await import('./languages/it.json');
  } else if (lang === 'pt') {
    languages[lang] = await import('./languages/pt-PT.json');
  } else if (lang === 'pt_BR') {
    languages[lang] = await import('./languages/pt-BR.json');
  } else if (lang === 'fr') {
    languages[lang] = await import('./languages/fr.json');
  }

  if (lang) {
    advancedCameraCardLanguage = lang;
  }
  return true;
};

/**
 * Get a localized version of a given string key.
 * @param string The key.
 * @param search An optional search key to be used with 'replace'.
 * @param replace An optional replacement text to be used with 'search'.
 * @returns
 */
export function localize(string: string, search = '', replace = ''): string {
  let translated = '';

  try {
    translated = string
      .split('.')
      .reduce((o, i) => o[i], languages[advancedCameraCardLanguage ?? DEFAULT_LANG]);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (_e) {}

  if (!translated) {
    translated = string.split('.').reduce((o, i) => o[i], languages[DEFAULT_LANG]);
  }

  if (search !== '' && replace !== '') {
    translated = translated.replace(search, replace);
  }
  return translated;
}



================================================
FILE: src/localize/languages/ca.json
================================================
{
  "actions": {
    "abort": "",
    "confirmation": ""
  },
  "common": {
    "advanced_camera_card": "",
    "advanced_camera_card_description": "",
    "folder": "",
    "live": "En directe",
    "no_folder": "",
    "no_media": "No hi ha suport per mostrar",
    "recordings": "Enregistraments",
    "version": "Versió"
  },
  "config": {
    "cameras": {
      "always_error_if_entity_unavailable": "",
      "camera_entity": "Entitat de càmera",
      "capabilities": {
        "capabilities": {
          "clips": "",
          "favorite-events": "",
          "favorite-recordings": "",
          "live": "",
          "menu": "",
          "ptz": "",
          "recordings": "",
          "seek": "",
          "snapshots": "",
          "substream": ""
        },
        "disable": "",
        "disable_except": "",
        "editor_label": ""
      },
      "cast": {
        "dashboard": {
          "dashboard_path": "Ruta del tauler de control",
          "view_path": "Ruta de la visualització"
        },
        "editor_label": "Opcions d'emissió",
        "method": "Mètode d'emissió",
        "methods": {
          "dashboard": "Tauler de control",
          "standard": "Estàndard"
        }
      },
      "dependencies": {
        "all_cameras": "Mostra els esdeveniments de totes les càmeres amb aquesta càmera",
        "cameras": "Mostra esdeveniments per a càmeres específiques amb aquesta càmera",
        "editor_label": "Opcions de dependències"
      },
      "dimensions": {
        "aspect_ratio": "Relació d'aspecte estàtica",
        "editor_label": "Dimensions de la càmera",
        "layout": {
          "editor_label": "Maquetació de la càmera",
          "fit": "Ajust de la maquetació",
          "fits": {
            "contain": "Els mitjans multimèdia estan continguts/en bústia",
            "cover": "El suport s'expandeix proporcionalment per cobrir la targeta",
            "fill": "El suport s'estira per omplir la targeta"
          },
          "pan": {
            "x": "",
            "y": ""
          },
          "position": {
            "editor_label": "",
            "x": "Percentatge d'emplaçament horitzontal",
            "y": "Percentatge d'emplaçament vertical"
          },
          "view_box": {
            "bottom": "",
            "editor_label": "",
            "left": "",
            "right": "",
            "top": ""
          },
          "zoom": ""
        }
      },
      "engines": {
        "editor_label": "Opcions del motor de càmera"
      },
      "frigate": {
        "camera_name": "Nom de la càmera de Frigate (detecció automàtica de l'entitat)",
        "client_id": "Identificador de client de Frigate (per a > 1 servidor de Frigate)",
        "editor_label": "Opcions de Frigate",
        "labels": "Etiquetes de Frigate/filtres d'objectes",
        "url": "URL del servidor de Frigate",
        "zones": "Zones de Frigate"
      },
      "go2rtc": {
        "editor_label": "Opcions de go2rtc",
        "modes": {
          "editor_label": "Modes de go2rtc",
          "mjpeg": "",
          "mp4": "",
          "mse": "",
          "webrtc": ""
        },
        "stream": "nom del flux de go2rtc",
        "url": ""
      },
      "icon": "Icona d'aquesta càmera (detecció automàtica des de l'entitat)",
      "id": "Identificador únic per a aquesta càmera en aquesta targeta",
      "image": {
        "editor_label": "Opcions d'imatge",
        "refresh_seconds": "Nombre de segons després dels quals actualitzar la imatge en directe (0=mai)",
        "url": "URL de la imatge que cal utilitzar en lloc de la instantània de l'entitat de la càmera"
      },
      "live_provider": "Proveïdor de visualització en directe per a aquesta càmera",
      "live_provider_options": {
        "editor_label": "Opcions de proveïdor en directe"
      },
      "live_providers": {
        "auto": "Automàtic",
        "go2rtc": "",
        "ha": "Transmissió de vídeo de Home Assistant (és a dir, HLS, LL-HLS, WebRTC mitjançant HA)",
        "image": "Imatges de Home Assistant",
        "jsmpeg": "",
        "webrtc-card": "Targeta WebRTC (és a dir, la targeta WebRTC d'AlexxIT)"
      },
      "motioneye": {
        "editor_label": "Opcions de MotionEye",
        "images": {
          "directory_pattern": "Patró del directori d'imatges",
          "file_pattern": "Patró de fitxer d'imatges"
        },
        "movies": {
          "directory_pattern": "Patró del directori de pel·lícules",
          "file_pattern": "Patró de fitxer de pel·lícules"
        },
        "url": "URL de la interfície d'usuari de MotionEye"
      },
      "proxy": {
        "dynamic": "",
        "editor_label": "",
        "media": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        },
        "ssl_ciphers": {
          "auto": "",
          "default": "",
          "editor_label": "",
          "insecure": "",
          "intermediate": "",
          "modern": ""
        },
        "ssl_verification": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        }
      },
      "reolink": {
        "editor_label": "",
        "media_resolution": {
          "editor_label": "",
          "high": "",
          "low": ""
        },
        "url": ""
      },
      "title": "Títol d'aquesta càmera (detecció automàtica de l'entitat)",
      "triggers": {
        "editor_label": "Opcions d'activació",
        "entities": "Activador d'altres entitats",
        "events": {
          "clips": "Esdeveniments amb nous clips",
          "editor_label": "Activar esdeveniments",
          "events": "Tots els esdeveniments",
          "snapshots": "Esdeveniments amb noves instantànies"
        },
        "motion": "Activa la detecció automàtica del sensor de moviment",
        "occupancy": "Activa la detecció automàtica del sensor d'ocupació"
      },
      "webrtc_card": {
        "editor_label": "Opcions de la targeta WebRTC",
        "entity": "Entitat de càmera de targeta WebRTC (no una càmera de Frigate)",
        "url": "URL de la càmera de la targeta WebRTC"
      }
    },
    "common": {
      "controls": {
        "builtin": "Controls de vídeo integrats",
        "filter": {
          "editor_label": "Filtre multimèdia",
          "mode": "Mode de filtre",
          "modes": {
            "left": "Filtre multimèdia en un calaix a l'esquerra",
            "none": "Sense filtre multimèdia",
            "right": "Filtre multimèdia en un calaix a la dreta"
          }
        },
        "next_previous": {
          "editor_label": "Següent i anterior",
          "size": "Mida del control següent i anterior en píxels",
          "style": "Estil de control següent i anterior",
          "styles": {
            "chevrons": "Xebrons",
            "icons": "Icones",
            "none": "Cap",
            "thumbnails": "Miniatures"
          }
        },
        "thumbnails": {
          "editor_label": "Miniatures",
          "events_media_type": "Si voleu mostrar miniatures d'esdeveniments de clips o instantànies",
          "events_media_types": {
            "clips": "Miniatures de clips",
            "snapshots": "Miniatures d'instantànies"
          },
          "media_type": "Si voleu mostrar miniatures d'esdeveniments o enregistraments",
          "media_types": {
            "events": "Esdeveniments",
            "recordings": "Enregistraments"
          },
          "mode": "Mode de miniatures",
          "modes": {
            "above": "Miniatures a dalt",
            "below": "Miniatures a baix",
            "left": "Miniatures en un calaix a l'esquerra",
            "none": "Sense miniatures",
            "right": "Miniatures en un calaix a la dreta"
          },
          "show_details": "Mostra els detalls amb miniatures",
          "show_download_control": "Mostra el control de descàrrega a les miniatures",
          "show_favorite_control": "Mostra el control preferit a les miniatures",
          "show_timeline_control": "Mostra el control de la línia de temps a les miniatures",
          "size": "Mida de les miniatures en píxels"
        },
        "timeline": {
          "editor_label": "Mini cronologia",
          "format": {
            "24h": "",
            "editor_label": ""
          },
          "mode": "Mode",
          "modes": {
            "above": "A dalt",
            "below": "Baix",
            "none": "Cap"
          },
          "pan_mode": "Mode d'escombratge predeterminat",
          "pan_modes": {
            "pan": "Escombratge",
            "seek": "Cerca d'escombratge en tots els mitjans",
            "seek-in-camera": "Cerca d'escombratge només a la càmera seleccionada",
            "seek-in-media": "Cerca d'escombratge només dins de l'element multimèdia seleccionat"
          }
        }
      },
      "display": {
        "editor_label": "Visualització",
        "grid_columns": "Nombre exacte de columnes de la graella",
        "grid_max_columns": "Nombre màxim de columnes de la graella",
        "grid_selected_position": "",
        "grid_selected_positions": {
          "default": "",
          "first": "",
          "last": ""
        },
        "grid_selected_width_factor": "Augmenta l'amplada del suport multimèdia seleccionat en aquest factor",
        "mode": "Mode"
      },
      "image": {
        "entity": "",
        "entity_parameters": "",
        "mode": "Mode de visualització d'imatges",
        "modes": {
          "camera": "Instantània de l'entitat de la càmera de Home Assistant",
          "entity": "",
          "screensaver": "",
          "url": "Imatge arbitrària especificada per URL"
        },
        "refresh_seconds": "Nombre de segons després dels quals cal actualitzar (0=mai)",
        "url": "URL d'imatge estàtica per a la visualització d'imatges"
      },
      "media_action_conditions": {
        "all": "Totes les oportunitats",
        "hidden": "A l'amagat del navegador/pestanya",
        "microphone_mute": "Si el micròfon està en silenci",
        "microphone_unmute": "Si el micròfon no està en silenci",
        "never": "Mai",
        "selected": "A la selecció",
        "unselected": "En desselecció",
        "visible": "En la visualització del navegador/pestanya"
      },
      "timeline": {
        "clustering_threshold": "El recompte d'esdeveniments en què s'agrupen (0=sense agrupació)",
        "events_media_type": "Els esdeveniments multimèdia que mostra la línia de temps",
        "events_media_types": {
          "all": "Tots els tipus de mitjans",
          "clips": "Clips",
          "snapshots": "Imatges instantànies"
        },
        "show_recordings": "Mostra les gravacions",
        "style": "Estil de cronologia",
        "styles": {
          "ribbon": "Esdeveniments en una sola cinta",
          "stack": "Esdeveniments apilats i agrupats"
        },
        "window_seconds": "La durada predeterminada de la visualització de la línia de temps en segons"
      }
    },
    "dimensions": {
      "aspect_ratio": "Relació d'aspecte predeterminada (p. ex., '16:9')",
      "aspect_ratio_mode": "Mode de relació d'aspecte",
      "aspect_ratio_modes": {
        "dynamic": "La relació d'aspecte s'ajusta al suport multimèdia",
        "static": "Relació d'aspecte estàtica",
        "unconstrained": "Relació d'aspecte sense restriccions"
      },
      "height": ""
    },
    "folders": {
      "ha": {
        "editor_label": "",
        "path_info": "",
        "url": ""
      },
      "icon": "",
      "id": "",
      "title": "",
      "type": "",
      "types": {
        "ha": ""
      }
    },
    "live": {
      "auto_mute": "Silencia automàticament les càmeres en directe",
      "auto_pause": "Posa en pausa automàticament les càmeres en directe",
      "auto_play": "Reprodueix automàticament les càmeres en directe",
      "auto_unmute": "Activa automàticament el so de les càmeres en directe",
      "controls": {
        "editor_label": "Controls del directe",
        "ptz": {
          "editor_label": "PTZ",
          "hide_home": "Amaga el control de casa",
          "hide_pan_tilt": "Amaga el control d'escombratge i inclinació",
          "hide_zoom": "Amaga el control de zoom",
          "mode": "Mode",
          "modes": {
            "off": "Desactivat",
            "on": "Activat"
          },
          "orientation": "Orientació",
          "orientations": {
            "horizontal": "Horitzontal",
            "vertical": "Vertical"
          },
          "position": "Posició",
          "positions": {
            "bottom-left": "Inferior esquerra",
            "bottom-right": "Inferior dreta",
            "top-left": "Superior left",
            "top-right": "Superior dreta"
          }
        }
      },
      "draggable": "La vista de càmeres en directe es pot arrossegar/lliscar",
      "lazy_load": "Les càmeres en directe es carreguen amb mandra",
      "lazy_unload": "Les càmeres en directe es descarreguen amb mandra",
      "microphone": {
        "always_connected": "Mantingueu sempre el micròfon connectat",
        "disconnect_seconds": "Segons després dels quals desconnectar el micròfon (0=mai)",
        "editor_label": "Micròfon",
        "enabled": "El micròfon està activat",
        "mute_after_microphone_mute_seconds": "Segons després de silenciar el micròfon per silenciar l'àudio entrant"
      },
      "preload": "Carregueu prèviament la visualització en directe en segon pla",
      "show_image_during_load": "Mostra la imatge fixa mentre es carrega la reproducció en directe",
      "transition_effect": "Efecte de transició de càmera en directe",
      "zoomable": "Les càmeres en directe es poden ampliar/escombrar"
    },
    "media_viewer": {
      "auto_mute": "Silencia automàticament els continguts multimèdia",
      "auto_pause": "Atura automàticament el contingut multimèdia",
      "auto_play": "Reprodueix automàticament els continguts multimèdia",
      "auto_unmute": "Activa automàticament el so del contingut multimèdia",
      "controls": {
        "editor_label": "Controls del visualitzador de contingut multimèdia"
      },
      "draggable": "El visualitzador de mitjans es pot arrossegar/lliscar",
      "lazy_load": "El contingut multimèdia del visualitzador multimèdia es carreguen amb mandra al carrusel",
      "snapshot_click_plays_clip": "Si feu clic a una instantània, es reprodueix un clip relacionat",
      "transition_effect": "Efecte de transició del visualitzador multimèdia",
      "transition_effects": {
        "none": "Sense transició",
        "slide": "Transició de diapositives"
      },
      "zoomable": "El visualitzador de mitjans es pot ampliar/escombrar"
    },
    "menu": {
      "alignment": "Alineació del menú",
      "alignments": {
        "bottom": "Alineat a la part inferior",
        "left": "Alineat a l'esquerra",
        "right": "Alineat a la dreta",
        "top": "Alineat a la part superior"
      },
      "button_size": "Mida del botó del menú en píxels",
      "buttons": {
        "alignment": "Alineació de botons",
        "alignments": {
          "matching": "Coincideix amb l'alineació del menú",
          "opposing": "Oposat a l'alineació del menú"
        },
        "camera_ui": "Interfície d'usuari de la càmera",
        "cameras": "Càmeres",
        "clips": "Clips",
        "display_mode": "Mode de visualització",
        "download": "Descarregar",
        "enabled": "Botó habilitat",
        "expand": "Expandir",
        "folders": "",
        "fullscreen": "Pantalla completa",
        "icon": "Icona",
        "image": "Imatge",
        "iris": "",
        "live": "En directe",
        "media_player": "Envia al reproductor multimèdia",
        "microphone": "Micròfon",
        "mute": "Silenciar / Activar el so",
        "permanent": "",
        "play": "Reproduir / Pausa",
        "priority": "Prioritat",
        "ptz_controls": "",
        "ptz_home": "",
        "recordings": "Enregistraments",
        "screenshot": "Captura de pantalla",
        "snapshots": "Imatges instantànies",
        "substreams": "Subfluxos",
        "timeline": "Cronologia",
        "type": "Tipus de botó",
        "types": {
          "momentary": "Momentani",
          "toggle": "Commuta"
        }
      },
      "position": "Posició del menú",
      "positions": {
        "bottom": "Situat a la part inferior",
        "left": "Situat a l'esquerra",
        "right": "Situat a la dreta",
        "top": "Situat a la part superior"
      },
      "style": "Estil de menú",
      "styles": {
        "hidden": "Menú ocult",
        "hover": "Menú passant el cursor",
        "hover-card": "Menú passant el cursor (a tota la targeta)",
        "none": "Sense menú",
        "outside": "Menú exterior",
        "overlay": "Menú superposat"
      }
    },
    "overrides": {
      "info": "Aquesta configuració de targeta ha especificat manualment substitucions configurades que poden anul·lar els valors que es mostren a l'editor visual; consulteu l'editor de codi per veure/modificar aquestes substitucions."
    },
    "performance": {
      "features": {
        "animated_progress_indicator": "Indicador animat del progrés",
        "card_loading_indicator": "",
        "editor_label": "Opcions de característiques",
        "max_simultaneous_engine_requests": "",
        "media_chunk_size": "Mida del fragment multimèdia"
      },
      "style": {
        "border_radius": "Corbes",
        "box_shadow": "Ombres",
        "editor_label": "Opcions d'estil"
      },
      "warning": "Aquesta targeta està en mode de perfil baix, de manera que els valors predeterminats han canviat per optimitzar el rendiment"
    },
    "profiles": {
      "casting": "",
      "editor_label": "",
      "low-performance": "",
      "scrubbing": ""
    },
    "remote_control": {
      "entities": {
        "camera": "",
        "editor_label": ""
      }
    },
    "status_bar": {
      "height": "",
      "items": {
        "enabled": "",
        "engine": "",
        "live_provider": "",
        "priority": "",
        "resolution": "",
        "technology": "",
        "title": ""
      },
      "popup_seconds": "",
      "position": "",
      "positions": {
        "bottom": "",
        "top": ""
      },
      "style": "",
      "styles": {
        "hover": "",
        "hover-card": "",
        "none": "",
        "outside": "",
        "overlay": "",
        "popup": ""
      }
    },
    "view": {
      "camera_select": "Visualitza les càmeres seleccionades recentment",
      "default": "Vista per defecte",
      "default_cycle_camera": "Passeu per les càmeres quan s'actualitzi la vista predeterminada",
      "default_reset": {
        "after_interaction": "Restableix la vista predeterminada després de la interacció de l'usuari",
        "editor_label": "",
        "entities": "",
        "every_seconds": "Actualitza la vista predeterminada cada X segons (0=mai)",
        "interaction_mode": "",
        "interaction_modes": {
          "active": "",
          "all": "",
          "inactive": ""
        }
      },
      "dim": "",
      "interaction_seconds": "Segons després de l'acció de l'usuari per continuar interactuant (0=mai)",
      "keyboard_shortcuts": {
        "editor_label": "",
        "enabled": "",
        "ptz_down": "",
        "ptz_home": "",
        "ptz_left": "",
        "ptz_right": "",
        "ptz_up": "",
        "ptz_zoom_in": "",
        "ptz_zoom_out": ""
      },
      "theme": {
        "themes": {
          "dark": "",
          "editor_label": "",
          "ha": "",
          "light": "",
          "traditional": ""
        }
      },
      "triggers": {
        "actions": {
          "editor_label": "Activar accions",
          "interaction_mode": "Com gestionar les accions quan la targeta té interacció humana",
          "interaction_modes": {
            "active": "Activa només accions quan la targeta té interacció humana",
            "all": "Activa accions independentment de la interacció humana",
            "inactive": "Només activa accions quan la targeta no té interacció humana"
          },
          "trigger": "Activar l'acció",
          "triggers": {
            "default": "Canvia o actualitza la vista predeterminada",
            "live": "Canvia o actualitza la visualització en directe",
            "media": "Canvieu a la visualització de mitjans rellevants per als nous mitjans",
            "none": "Sense acció"
          },
          "untrigger": "Desactiva l'acció",
          "untriggers": {
            "default": "Canvia a la vista/càmera predeterminada",
            "none": "Sense acció"
          }
        },
        "editor_label": "Comportament quan s'activa una càmera",
        "filter_selected_camera": "Activa només a la càmera seleccionada",
        "show_trigger_status": "Mostra la vora intermitent quan s'activa",
        "untrigger_seconds": "Segons després del canvi d'estat inactiu a desactivat"
      },
      "views": {
        "clip": "Clip més recent",
        "clips": "Galeria de clips",
        "current": "Vista actual",
        "folder": "",
        "folders": "",
        "image": "Imatge estàtica",
        "live": "Visualització en directe",
        "recording": "Enregistrament més recent",
        "recordings": "Galeria d'enregistraments",
        "snapshot": "Instantània més recent",
        "snapshots": "Galeria d'instantànies",
        "timeline": "Vista cronològica"
      }
    }
  },
  "display_modes": {
    "grid": "Mostra el visualitzador multimèdia per a cada càmera d'una quadrícula",
    "single": "Mostra un visualitzador multimèdia únic"
  },
  "editor": {
    "add_new_camera": "Afegeix una càmera nova",
    "add_new_folder": "",
    "button": "Botó",
    "camera": "Càmera",
    "cameras": "Càmeres",
    "cameras_secondary": "Quines càmeres renderitzar en aquesta targeta",
    "delete": "Suprimeix",
    "dimensions": "Dimensions",
    "dimensions_secondary": "Opcions de dimensions i forma",
    "folders": "",
    "folders_secondary": "",
    "image": "Imatge",
    "image_secondary": "Opcions de visualització d'imatges estàtiques",
    "live": "En directe",
    "live_secondary": "Opcions de visualització de la càmera en directe",
    "media_gallery": "Galeria multimèdia",
    "media_gallery_secondary": "Opcions de la galeria multimèdia",
    "media_viewer": "Visor multimèdia",
    "media_viewer_secondary": "Visor de suports estàtics (clips, instantànies o enregistraments)",
    "menu": "Menú",
    "menu_secondary": "Opcions d'aspecte del menú",
    "move_down": "Moure cap avall",
    "move_up": "Moure cap amunt",
    "overrides": "Les substitucions estan actives",
    "overrides_secondary": "S'han detectat substitucions de configuració dinàmica",
    "performance": "Rendiment",
    "performance_secondary": "Opcions de rendiment de la targeta",
    "profiles": "",
    "profiles_secondary": "",
    "remote_control": "",
    "remote_control_secondary": "",
    "status_bar": "",
    "status_bar_secondary": "",
    "timeline": "Cronologia",
    "timeline_secondary": "Opcions de la cronologia d'esdeveniments",
    "upgrade": "Upgrade",
    "upgrade_available": "Hi ha disponible una actualització automàtica de la configuració de la targeta",
    "view": "Vista",
    "view_secondary": "Què ha de mostrar la targeta i com mostrar-la"
  },
  "elements": {
    "ptz": {
      "down": "Avall",
      "home": "Casa",
      "left": "Esquerra",
      "presets": "",
      "right": "Dreta",
      "up": "Amunt",
      "zoom_in": "Ampliar",
      "zoom_out": "Reduir"
    }
  },
  "error": {
    "awaiting_folder": "",
    "awaiting_live": "S'està esperant que es carregui la transmissió en directe ...",
    "awaiting_media": "",
    "camera_initialization": "",
    "camera_initialization_reolink": "",
    "configuration": "",
    "could_not_render_elements": "No s'han pogut representar els elements de la imatge",
    "could_not_resolve": "No s'ha pogut resoldre l'URL multimèdia",
    "diagnostics": "Diagnòstic de targetes. Reviseu la informació confidencial abans de compartir-la",
    "download_no_media": "No hi ha contingut multimèdia per descarregar",
    "download_sign_failed": "No s'ha pogut signar l'URL multimèdia per baixar-la",
    "duplicate_camera_id": "Duplica l'identificador de la càmera Frigate per a la següent càmera, utilitza el paràmetre 'id' per identificar les càmeres de manera única",
    "duplicate_folder_id": "",
    "empty_response": "S'ha rebut una resposta buida de Home Assistant per a la sol·licitud",
    "failed_response": "No s'ha pogut rebre la resposta de Home Assistant per a la sol·licitud",
    "failed_retain": "No s'ha pogut retenir l'esdeveniment",
    "failed_sign": "No s'ha pogut signar l'URL de Home Assistant",
    "fetching_diagnostics": "",
    "image_load_error": "No s'ha pogut carregar la imatge",
    "invalid_configuration": "Configuració no vàlida",
    "invalid_configuration_no_hint": "No hi ha cap indicació d'ubicació disponible (tipus dolent o faltant?)",
    "invalid_configuration_override": "",
    "invalid_elements_config": "La configuració dels elements de la imatge no és vàlida",
    "invalid_response": "S'ha rebut una resposta no vàlida de Home Assistant per a la sol·licitud",
    "jsmpeg_no_player": "No s'ha pogut iniciar el reproductor JSMPEG",
    "live_camera_no_endpoint": "No s'ha pogut obtenir el punt final de la càmera per a aquest proveïdor en directe (configuració incompleta?)",
    "live_camera_not_found": "No s'ha trobat la 'camera_entity' (entitat de la càmera) configurada",
    "live_camera_unavailable": "Càmera no disponible",
    "no_camera_engine": "No s'ha pogut determinar el motor adequat per a la càmera",
    "no_camera_entity": "No s'ha pogut trobar l'entitat de la càmera",
    "no_camera_entity_for_triggers": "Es requereix una entitat de càmera per detectar automàticament els activadors",
    "no_camera_id": "No s'ha pogut determinar l'identificador de la càmera per a la següent càmera, és possible que hagis d'establir el paràmetre 'id' manualment",
    "no_dashboard_or_view": "Tant els paràmetres 'dashboard_path' com 'view_path' són necessaris per al mètode d'emissió 'dashboard'",
    "no_live_camera": "El paràmetre 'camera_entity' s'ha de configurar i validar per a aquest proveïdor en directe",
    "no_supported_camera": "",
    "no_supported_cameras": "",
    "reconnecting": "Reconnectant",
    "stream_not_loading": "",
    "too_many_automations": "Hi ha massa trucades d'automatització imbricades, comproveu la vostra configuració per veure si hi ha bucles",
    "troubleshooting": "Comproveu la resolució de problemes",
    "unknown": "Error desconegut",
    "upgrade_available": "Hi ha disponible una actualització automàtica de la configuració de la targeta; visiteu l'editor de targetes visuals",
    "webrtc_card_reported_error": "La targeta WebRTC ha informat d'un error",
    "webrtc_card_waiting": "S'està esperant que es carregui la targeta WebRTC ..."
  },
  "key_assigner": {
    "assign": "",
    "modifiers": {
      "alt": "",
      "ctrl": "",
      "meta": "",
      "shift": ""
    },
    "unassign": ""
  },
  "media_filter": {
    "all": "Tots",
    "camera": "Càmera",
    "favorite": "Preferit",
    "media_type": "Tipus de suport multimèdia",
    "media_types": {
      "clips": "Clips",
      "recordings": "Enregistraments",
      "snapshots": "Imatges instantànies"
    },
    "not_favorite": "No preferit",
    "select_camera": "Selecciona la càmera...",
    "select_favorite": "Selecciona el preferit...",
    "select_media_type": "Selecciona el tipus de suport multimèdia...",
    "select_tag": "Selecciona l'etiqueta...",
    "select_what": "Selecciona el què...",
    "select_when": "Selecciona quan...",
    "select_where": "Selecciona on...",
    "tag": "Etiqueta",
    "what": "Què",
    "when": "Quan",
    "whens": {
      "custom": "Personalitzat",
      "past_month": "El mes passat",
      "past_week": "La setmana passada",
      "today": "Avui",
      "yesterday": "Ahir"
    },
    "where": "On"
  },
  "media_viewer": {
    "unseekable": "Busqueu temps no trobat als mitjans multimèdia"
  },
  "thumbnail": {
    "camera": "Càmera",
    "download": "Descarregar mitjans multimèdia",
    "duration": "Durada",
    "events": "Esdeveniments",
    "in_progress": "En procés",
    "no_thumbnail": "No hi ha cap miniatura disponible",
    "retain_indefinitely": "Els mitjans multimèdia es conservaran indefinidament",
    "score": "Puntuació",
    "seek": "Buscar",
    "start": "Començar",
    "tag": "Etiqueta",
    "timeline": "Veure els mitjans multimèdia a la línia de temps",
    "title": "",
    "what": "Què",
    "where": "On"
  },
  "timeline": {
    "select_date": "Escolliu la data"
  }
}



================================================
FILE: src/localize/languages/en.json
================================================
{
  "actions": {
    "abort": "Aborted action",
    "confirmation": "Are you sure you want to perform this action"
  },
  "common": {
    "advanced_camera_card": "Advanced Camera Card",
    "advanced_camera_card_description": "An Advanced Camera Card",
    "folder": "Folder",
    "live": "Live",
    "no_folder": "No folder to display",
    "no_media": "No media to display",
    "recordings": "Recordings",
    "version": "Version"
  },
  "config": {
    "cameras": {
      "always_error_if_entity_unavailable": "Always treat entity unavailability as error",
      "camera_entity": "Camera Entity",
      "capabilities": {
        "capabilities": {
          "clips": "Clips",
          "favorite-events": "Favorite Events",
          "favorite-recordings": "Favorite Recordings",
          "live": "Live",
          "menu": "Menu",
          "ptz": "PTZ",
          "recordings": "Recordings",
          "seek": "Seeking",
          "snapshots": "Snapshots",
          "substream": "Substream"
        },
        "disable": "Disable",
        "disable_except": "Disable except",
        "editor_label": "Camera capabilities"
      },
      "cast": {
        "dashboard": {
          "dashboard_path": "Dashboard path",
          "view_path": "View path"
        },
        "editor_label": "Cast options",
        "method": "Cast method",
        "methods": {
          "dashboard": "Dashboard",
          "standard": "Standard"
        }
      },
      "dependencies": {
        "all_cameras": "Show events for all cameras with this camera",
        "cameras": "Show events for specific cameras with this camera",
        "editor_label": "Dependency options"
      },
      "dimensions": {
        "aspect_ratio": "Static aspect ratio",
        "editor_label": "Camera dimensions",
        "layout": {
          "editor_label": "Camera Layout",
          "fit": "Layout fit",
          "fits": {
            "contain": "Media is contained/letterboxed",
            "cover": "Media expands proportionally to cover the card",
            "fill": "Media is stretched to fill the card"
          },
          "pan": {
            "x": "Pan horizontal percentage",
            "y": "Pan vertical percentage"
          },
          "position": {
            "editor_label": "Layout Cover Position",
            "x": "Horizontal placement percentage",
            "y": "Vertical placement percentage"
          },
          "view_box": {
            "bottom": "Bottom inset percentage",
            "editor_label": "Layout View Box",
            "left": "Left inset percentage",
            "right": "Right inset percentage",
            "top": "Top inset percentage"
          },
          "zoom": "Zoom factor"
        }
      },
      "engines": {
        "editor_label": "Camera engine options"
      },
      "frigate": {
        "camera_name": "Frigate camera name (Autodetected from entity)",
        "client_id": "Frigate client id (For >1 Frigate server)",
        "editor_label": "Frigate options",
        "labels": "Frigate labels/object filters",
        "url": "Frigate server URL",
        "zones": "Frigate zones"
      },
      "go2rtc": {
        "editor_label": "go2rtc Options",
        "modes": {
          "editor_label": "go2rtc Modes",
          "mjpeg": "Motion JPEG (MJPEG)",
          "mp4": "MPEG-4 (MP4)",
          "mse": "Media Source Extensions (MSE)",
          "webrtc": "Web Real-Time Communication (WebRTC)"
        },
        "stream": "go2rtc stream name",
        "url": "go2rtc URL"
      },
      "icon": "Icon for this camera (Autodetected from entity)",
      "id": "Unique ID for this camera in this card",
      "image": {
        "editor_label": "Image Options",
        "refresh_seconds": "Number of seconds after which to refresh live image (0=never)",
        "url": "Image URL to use instead of camera entity snapshot"
      },
      "live_provider": "Live view provider for this camera",
      "live_provider_options": {
        "editor_label": "Live provider options"
      },
      "live_providers": {
        "auto": "Automatic",
        "go2rtc": "go2rtc",
        "ha": "Home Assistant video stream (i.e. HLS, LL-HLS, WebRTC via HA)",
        "image": "Home Assistant images",
        "jsmpeg": "JSMpeg",
        "webrtc-card": "WebRTC Card (i.e. AlexxIT's WebRTC Card)"
      },
      "motioneye": {
        "editor_label": "MotionEye options",
        "images": {
          "directory_pattern": "Images directory pattern",
          "file_pattern": "Images file pattern"
        },
        "movies": {
          "directory_pattern": "Movies directory pattern",
          "file_pattern": "Movies file pattern"
        },
        "url": "MotionEye UI URL"
      },
      "proxy": {
        "dynamic": "Dynamic proxying",
        "editor_label": "Camera proxying",
        "media": {
          "auto": "Media proxying automatically configured",
          "editor_label": "Media proxying",
          "false": "Media proxying disabled",
          "true": "Media proxying enabled"
        },
        "ssl_ciphers": {
          "auto": "SSL ciphers automatically configured",
          "default": "Default SSL ciphers",
          "editor_label": "SSL ciphers",
          "insecure": "Insecure SSL ciphers",
          "intermediate": "Intermediate SSL ciphers",
          "modern": "Modern SSL ciphers"
        },
        "ssl_verification": {
          "auto": "SSL verification automatically configured",
          "editor_label": "SSL verification",
          "false": "SSL verification disabled",
          "true": "SSL verification enabled"
        }
      },
      "reolink": {
        "editor_label": "Reolink options",
        "media_resolution": {
          "editor_label": "Media Resolution",
          "high": "High Resolution",
          "low": "Low Resolution"
        },
        "url": "Reolink UI URL"
      },
      "title": "Title for this camera (Autodetected from entity)",
      "triggers": {
        "editor_label": "Trigger options",
        "entities": "Trigger from other entities",
        "events": {
          "clips": "Events with new clips",
          "editor_label": "Trigger Events",
          "events": "All events",
          "snapshots": "Events with new snapshots"
        },
        "motion": "Trigger by auto-detecting the motion sensor",
        "occupancy": "Trigger by auto-detecting the occupancy sensor"
      },
      "webrtc_card": {
        "editor_label": "WebRTC Card Options",
        "entity": "WebRTC Card Camera Entity",
        "url": "WebRTC Card Camera URL"
      }
    },
    "common": {
      "controls": {
        "builtin": "Built-in video controls",
        "filter": {
          "editor_label": "Media Filter",
          "mode": "Filter mode",
          "modes": {
            "left": "Media filter in a drawer to the left",
            "none": "No media filter",
            "right": "Media filter in a drawer to the right"
          }
        },
        "next_previous": {
          "editor_label": "Next & Previous",
          "size": "Next & previous control size in pixels",
          "style": "Next & previous control style",
          "styles": {
            "chevrons": "Chevrons",
            "icons": "Icons",
            "none": "None",
            "thumbnails": "Thumbnails"
          }
        },
        "thumbnails": {
          "editor_label": "Thumbnails",
          "events_media_type": "Whether to show event thumbnails of clips or snapshots",
          "events_media_types": {
            "clips": "Clip thumbnails",
            "snapshots": "Snapshot thumbnails"
          },
          "media_type": "Whether to show thumnails of events or recordings",
          "media_types": {
            "events": "Events",
            "recordings": "Recordings"
          },
          "mode": "Thumbnails mode",
          "modes": {
            "above": "Thumbnails above",
            "below": "Thumbnails below",
            "left": "Thumbnails in a drawer to the left",
            "none": "No thumbnails",
            "right": "Thumbnails in a drawer to the right"
          },
          "show_details": "Show details with thumbnails",
          "show_download_control": "Show download control on thumbnails",
          "show_favorite_control": "Show favorite control on thumbnails",
          "show_timeline_control": "Show timeline control on thumbnails",
          "size": "Thumbnails size in pixels"
        },
        "timeline": {
          "editor_label": "Mini Timeline",
          "format": {
            "24h": "Use 24-hour clock",
            "editor_label": "Time & date format"
          },
          "mode": "Mode",
          "modes": {
            "above": "Above",
            "below": "Below",
            "none": "None"
          },
          "pan_mode": "Default pan mode",
          "pan_modes": {
            "pan": "Pan",
            "seek": "Pan seeks across all media",
            "seek-in-camera": "Pan seeks within selected camera only",
            "seek-in-media": "Pan seeks within selected media item only"
          }
        }
      },
      "display": {
        "editor_label": "Display",
        "grid_columns": "Exact number of grid columns",
        "grid_max_columns": "Maximum number of grid columns",
        "grid_selected_position": "Position of selected media in grid",
        "grid_selected_positions": {
          "default": "Selected item in default position",
          "first": "Selected item is first in grid",
          "last": "Selected item is last in grid"
        },
        "grid_selected_width_factor": "Increase selected media width by this factor",
        "mode": "Mode"
      },
      "image": {
        "entity": "Entity for use with entity mode",
        "entity_parameters": "Query parameters added to the entity-based picture URLs (e.g. width=1920&height=1080)",
        "mode": "Image mode",
        "modes": {
          "camera": "Home Assistant camera snapshot of camera entity",
          "entity": "Entity with entity_picture attribute",
          "screensaver": "Embedded screensaver image",
          "url": "Arbitrary image specified by URL"
        },
        "refresh_seconds": "Number of seconds after which to refresh (0=never)",
        "url": "Static image URL"
      },
      "media_action_conditions": {
        "all": "All opportunities",
        "hidden": "On browser/tab hiding",
        "microphone_mute": "On microphone mute",
        "microphone_unmute": "On microphone unmute",
        "never": "Never",
        "selected": "On selection",
        "unselected": "On unselection",
        "visible": "On browser/tab visibility"
      },
      "timeline": {
        "clustering_threshold": "The count of events at which they are clustered (0=no clustering)",
        "events_media_type": "The events media the timeline displays",
        "events_media_types": {
          "all": "All event media types",
          "clips": "Clips",
          "snapshots": "Snapshots"
        },
        "show_recordings": "Show recordings",
        "style": "Timeline style",
        "styles": {
          "ribbon": "Events on a single ribbon",
          "stack": "Stacked & clustered events"
        },
        "window_seconds": "The default length of the timeline view in seconds"
      }
    },
    "dimensions": {
      "aspect_ratio": "Default aspect ratio (e.g. '16:9')",
      "aspect_ratio_mode": "Aspect ratio mode",
      "aspect_ratio_modes": {
        "dynamic": "Aspect ratio adjusts to media",
        "static": "Static aspect ratio",
        "unconstrained": "Unconstrained aspect ratio"
      },
      "height": "Card height in CSS units (e.g. '500px')"
    },
    "folders": {
      "ha": {
        "editor_label": "Home Assistant Media Folder Options",
        "url": "URL of media folder",
        "path_info": "Additional path matching functionality is available in the text editor"
      },
      "icon": "Icon for this folder",
      "id": "Unique ID for this folder in this card",
      "title": "Title for this folder",
      "type": "Folder type",
      "types": {
        "ha": "Home Assistant Media Folder"
      }
    },
    "live": {
      "auto_mute": "Automatically mute live cameras",
      "auto_pause": "Automatically pause live cameras",
      "auto_play": "Automatically play live cameras",
      "auto_unmute": "Automatically unmute live cameras",
      "controls": {
        "editor_label": "Live Controls",
        "ptz": {
          "editor_label": "PTZ",
          "hide_home": "Hide home & preset controls",
          "hide_pan_tilt": "Hide pan & tilt control",
          "hide_zoom": "Hide zoom control",
          "mode": "Mode",
          "modes": {
            "off": "Off",
            "on": "On"
          },
          "orientation": "Orientation",
          "orientations": {
            "horizontal": "Horizontal",
            "vertical": "Vertical"
          },
          "position": "Position",
          "positions": {
            "bottom-left": "Bottom left",
            "bottom-right": "Bottom right",
            "top-left": "Top left",
            "top-right": "Top right"
          }
        }
      },
      "draggable": "Live cameras view can be dragged/swiped",
      "lazy_load": "Live cameras are lazily loaded",
      "lazy_unload": "Live cameras are lazily unloaded",
      "microphone": {
        "always_connected": "Always keep the microphone connected",
        "disconnect_seconds": "Seconds after which to disconnect microphone (0=never)",
        "editor_label": "Microphone",
        "enabled": "Microphone enabled",
        "mute_after_microphone_mute_seconds": "Seconds after microphone mute to mute inbound audio"
      },
      "preload": "Preload live view in the background",
      "show_image_during_load": "Show still image while the live stream is loading",
      "transition_effect": "Live camera transition effect",
      "zoomable": "Live cameras can be zoomed/panned"
    },
    "media_viewer": {
      "auto_mute": "Automatically mute media",
      "auto_pause": "Automatically pause media",
      "auto_play": "Automatically play media",
      "auto_unmute": "Automatically unmute media",
      "controls": {
        "editor_label": "Media Viewer Controls"
      },
      "draggable": "Media Viewer can be dragged/swiped",
      "lazy_load": "Media Viewer media is lazily loaded in carousel",
      "snapshot_click_plays_clip": "Clicking on a snapshot plays a related clip",
      "transition_effect": "Media Viewer transition effect",
      "transition_effects": {
        "none": "No transition",
        "slide": "Slide transition"
      },
      "zoomable": "Media Viewer can be zoomed/panned"
    },
    "menu": {
      "alignment": "Menu alignment",
      "alignments": {
        "bottom": "Aligned to the bottom",
        "left": "Aligned to the left",
        "right": "Aligned to the right",
        "top": "Aligned to the top"
      },
      "button_size": "Menu button size in pixels",
      "buttons": {
        "alignment": "Button alignment",
        "alignments": {
          "matching": "Matching the menu alignment",
          "opposing": "Opposing the menu alignment"
        },
        "camera_ui": "Camera user interface",
        "cameras": "Cameras",
        "clips": "Clips",
        "display_mode": "Display mode",
        "download": "Download",
        "enabled": "Button enabled",
        "expand": "Expand",
        "folders": "Folders",
        "fullscreen": "Fullscreen",
        "icon": "Icon",
        "image": "Image",
        "iris": "Iris / Default View / Unhide menu",
        "live": "Live",
        "media_player": "Send to media player",
        "microphone": "Microphone",
        "mute": "Mute / Unmute",
        "permanent": "Show when the menu is hidden",
        "play": "Play / Pause",
        "priority": "Priority",
        "ptz_controls": "Show PTZ controls",
        "ptz_home": "PTZ Home",
        "recordings": "Recordings",
        "screenshot": "Screenshot",
        "snapshots": "Snapshots",
        "substreams": "Substream(s)",
        "timeline": "Timeline",
        "type": "Button type",
        "types": {
          "momentary": "Momentary",
          "toggle": "Toggle"
        }
      },
      "position": "Menu position",
      "positions": {
        "bottom": "Positioned on the bottom",
        "left": "Positioned on the left",
        "right": "Positioned on the right",
        "top": "Positioned on the top"
      },
      "style": "Menu style",
      "styles": {
        "hidden": "Hidden menu",
        "hover": "Hover menu",
        "hover-card": "Hover menu (card-wide)",
        "none": "No menu",
        "outside": "Outside menu",
        "overlay": "Overlay menu"
      }
    },
    "overrides": {
      "info": "This card configuration has manually specified overrides configured which may override values shown in the visual editor, please consult the code editor to view/modify these overrides"
    },
    "performance": {
      "features": {
        "animated_progress_indicator": "Animated Progress Indicator",
        "card_loading_indicator": "Card Loading Indicator",
        "editor_label": "Feature Options",
        "max_simultaneous_engine_requests": "Max simultaneous camera engine requests",
        "media_chunk_size": "Media chunk size"
      },
      "style": {
        "border_radius": "Curves",
        "box_shadow": "Shadows",
        "editor_label": "Style Options"
      },
      "warning": "This card is in low profile mode so defaults have changed to optimize performance"
    },
    "profiles": {
      "casting": "Casting",
      "editor_label": "Configuration profiles",
      "low-performance": "Low performance",
      "scrubbing": "Video scrubbing"
    },
    "remote_control": {
      "entities": {
        "camera": "Input Select entity to control camera",
        "editor_label": "Remote Control Entities"
      }
    },
    "status_bar": {
      "height": "Status bar height in pixels",
      "items": {
        "enabled": "Item enabled",
        "engine": "Camera engine",
        "live_provider": "Live provider",
        "priority": "Item priority",
        "resolution": "Resolution",
        "technology": "Technology",
        "title": "Title"
      },
      "popup_seconds": "Status bar popup seconds",
      "position": "Status bar position",
      "positions": {
        "bottom": "Positioned on the bottom",
        "top": "Positioned on the top"
      },
      "style": "Status bar style",
      "styles": {
        "hover": "Hover status bar",
        "hover-card": "Hover status bar (card-wide)",
        "none": "No status bar",
        "outside": "Outside status bar",
        "overlay": "Overlay status bar",
        "popup": "Popup status bar"
      }
    },
    "view": {
      "camera_select": "View for newly selected cameras",
      "default": "Default view",
      "default_cycle_camera": "Cycle through cameras when default view updates",
      "default_reset": {
        "after_interaction": "Reset to the default view after user interaction ends",
        "editor_label": "Default view reset behavior",
        "entities": "Reset to the default view on entity state change",
        "every_seconds": "Reset to default view every X seconds (0=never)",
        "interaction_mode": "How default reset behaves when the card has human interaction",
        "interaction_modes": {
          "active": "Only allow reset when card has active human interaction",
          "all": "Reset regardless of human interaction",
          "inactive": "Only reset when card has no human interaction"
        }
      },
      "dim": "Dim when no interaction",
      "interaction_seconds": "Seconds after user action to remain interacted with (0=never)",
      "keyboard_shortcuts": {
        "editor_label": "Keyboard shortcuts",
        "enabled": "Keyboard shortcuts enabled",
        "ptz_down": "PTZ Down",
        "ptz_home": "PTZ Home",
        "ptz_left": "PTZ Left",
        "ptz_right": "PTZ Right",
        "ptz_up": "PTZ Up",
        "ptz_zoom_in": "PTZ Zoom In",
        "ptz_zoom_out": "PTZ Zoom Out"
      },
      "theme": {
        "themes": {
          "dark": "Dark",
          "editor_label": "Themes",
          "ha": "Home Assistant",
          "light": "Light",
          "traditional": "Traditional"
        }
      },
      "triggers": {
        "actions": {
          "editor_label": "Trigger actions",
          "interaction_mode": "How to handle actions when the card has human interaction",
          "interaction_modes": {
            "active": "Only trigger actions when card has human interaction",
            "all": "Trigger actions regardless of human interaction",
            "inactive": "Only trigger actions when card has no human interaction"
          },
          "trigger": "Trigger action",
          "triggers": {
            "default": "Change to or update default view",
            "live": "Change to or update live view",
            "media": "Change to the relevant media view for new media",
            "none": "No action"
          },
          "untrigger": "Untrigger action",
          "untriggers": {
            "default": "Change to default view/camera",
            "none": "No action"
          }
        },
        "editor_label": "Trigger behavior",
        "filter_selected_camera": "Only trigger on selected camera",
        "show_trigger_status": "Show pulsing border when triggered",
        "untrigger_seconds": "Seconds after inactive state change to untrigger"
      },
      "views": {
        "clip": "Most recent clip",
        "clips": "Clips gallery",
        "current": "Current view",
        "folder": "Folder media",
        "folders": "Folders gallery",
        "image": "Static image",
        "live": "Live view",
        "recording": "Most recent recording",
        "recordings": "Recordings gallery",
        "snapshot": "Most recent snapshot",
        "snapshots": "Snapshots gallery",
        "timeline": "Timeline view"
      }
    }
  },
  "display_modes": {
    "grid": "Show media viewer for each camera in a grid",
    "single": "Show single media viewer"
  },
  "editor": {
    "add_new_camera": "Add new camera",
    "add_new_folder": "Add new folder",
    "button": "Button",
    "camera": "Camera",
    "cameras": "Cameras",
    "cameras_secondary": "What cameras to render on this card",
    "delete": "Delete",
    "dimensions": "Card dimensions",
    "dimensions_secondary": "Card dimensions & shape options",
    "folders": "Folders",
    "folders_secondary": "What folders to render on this card",
    "image": "Image",
    "image_secondary": "Static image view options",
    "live": "Live",
    "live_secondary": "Live camera view options",
    "media_gallery": "Media gallery",
    "media_gallery_secondary": "Media gallery options",
    "media_viewer": "Media viewer",
    "media_viewer_secondary": "Viewer for static media (clips, snapshots or recordings)",
    "menu": "Menu",
    "menu_secondary": "Menu look & feel options",
    "move_down": "Move down",
    "move_up": "Move up",
    "overrides": "Overrides are active",
    "overrides_secondary": "Dynamic configuration overrides detected",
    "performance": "Performance",
    "performance_secondary": "Card performance options",
    "profiles": "Configuration profiles",
    "profiles_secondary": "Choose pre-configured sets of defaults",
    "remote_control": "Remote Control",
    "remote_control_secondary": "Options for remote controlling the card",
    "status_bar": "Status bar",
    "status_bar_secondary": "Status bar look & feel options",
    "timeline": "Timeline",
    "timeline_secondary": "Event timeline options",
    "upgrade": "Upgrade",
    "upgrade_available": "An automatic card configuration upgrade is available",
    "view": "View",
    "view_secondary": "What the card should show and how to show it"
  },
  "elements": {
    "ptz": {
      "down": "Down",
      "home": "Home",
      "left": "Left",
      "presets": "Presets",
      "right": "Right",
      "up": "Up",
      "zoom_in": "Zoom In",
      "zoom_out": "Zoom Out"
    }
  },
  "error": {
    "awaiting_live": "Waiting for live stream to load ...",
    "awaiting_folder": "Waiting for folder to load",
    "awaiting_media": "Waiting for media to load",
    "camera_initialization": "Camera initialization failed",
    "camera_initialization_reolink": "Could not initialize Reolink camera",
    "configuration": "Check configuration",
    "could_not_render_elements": "Could not render picture elements",
    "could_not_resolve": "Could not resolve media URL",
    "diagnostics": "Card diagnostics. Please review for confidential information prior to sharing",
    "download_no_media": "No media to download",
    "download_sign_failed": "Could not sign media URL for download",
    "duplicate_camera_id": "Duplicate camera id for the following camera, use the 'id' parameter to uniquely identify cameras",
    "duplicate_folder_id": "Duplicate folder id for the following folder, use the 'id' parameter to uniquely identify folders",
    "empty_response": "Received empty response from Home Assistant for request",
    "failed_response": "Failed to receive response from Home Assistant for request",
    "failed_retain": "Could not retain event",
    "failed_sign": "Could not sign Home Assistant URL",
    "fetching_diagnostics": "Fetching diagnostics",
    "image_load_error": "The image could not be loaded",
    "invalid_configuration": "Invalid configuration",
    "invalid_configuration_no_hint": "No location hint available (bad or missing type?)",
    "invalid_configuration_override": "Invalid override configuration",
    "invalid_elements_config": "Invalid picture elements configuration",
    "invalid_response": "Received invalid response from Home Assistant for request",
    "jsmpeg_no_player": "Could not start JSMPEG player",
    "live_camera_no_endpoint": "Could not get camera endpoint for this live provider (incomplete configuration?)",
    "live_camera_not_found": "The configured camera_entity was not found",
    "live_camera_unavailable": "Camera unavailable",
    "no_camera_engine": "Could not determine suitable engine for camera",
    "no_camera_entity": "Could not find camera entity",
    "no_camera_entity_for_triggers": "A camera entity is required in order to autodetect triggers",
    "no_camera_id": "Could not determine camera id for the following camera, may need to set 'id' parameter manually",
    "no_dashboard_or_view": "Both 'dashboard_path' and 'view_path' parameters are required for the 'dashboard' cast method",
    "no_live_camera": "The camera_entity parameter must be set and valid for this live provider",
    "no_supported_camera": "The selected camera does not support this view",
    "no_supported_cameras": "No cameras support this view",
    "reconnecting": "Reconnecting",
    "stream_not_loading": "The video stream has not yet loaded. This is could for any number of reasons. If configured (and by default), there will be an image refreshing every second until the stream loads correctly",
    "too_many_automations": "Too many nested automation calls, please check your configuration for loops",
    "troubleshooting": "Check troubleshooting",
    "unknown": "Unknown error",
    "upgrade_available": "An automated card configuration upgrade is available, please visit the visual card editor",
    "webrtc_card_reported_error": "WebRTC Card reported an error",
    "webrtc_card_waiting": "Waiting for WebRTC Card to load ..."
  },
  "key_assigner": {
    "assign": "Assign",
    "modifiers": {
      "alt": "Alt",
      "ctrl": "Ctrl",
      "meta": "Meta",
      "shift": "Shift"
    },
    "unassign": "Unassign"
  },
  "media_filter": {
    "all": "All",
    "camera": "Camera",
    "favorite": "Favorite",
    "media_type": "Media Type",
    "media_types": {
      "clips": "Clips",
      "recordings": "Recordings",
      "snapshots": "Snapshots"
    },
    "not_favorite": "Not Favorite",
    "select_camera": "Select camera...",
    "select_favorite": "Select favorite...",
    "select_media_type": "Select media type...",
    "select_tag": "Select tag...",
    "select_what": "Select what...",
    "select_when": "Select when...",
    "select_where": "Select where...",
    "tag": "Tag",
    "what": "What",
    "when": "When",
    "whens": {
      "custom": "Custom",
      "past_month": "Past Month",
      "past_week": "Past Week",
      "today": "Today",
      "yesterday": "Yesterday"
    },
    "where": "Where"
  },
  "media_viewer": {
    "unseekable": "Seek time not found in media"
  },
  "thumbnail": {
    "camera": "Camera",
    "download": "Download media",
    "duration": "Duration",
    "events": "Events",
    "in_progress": "In Progress",
    "no_thumbnail": "No thumbnail available",
    "retain_indefinitely": "Media will be indefinitely retained",
    "score": "Score",
    "seek": "Seek",
    "start": "Start",
    "tag": "Tag",
    "timeline": "See media in timeline",
    "title": "Title",
    "what": "What",
    "where": "Where"
  },
  "timeline": {
    "select_date": "Choose date"
  }
}



================================================
FILE: src/localize/languages/fr.json
================================================
{
  "actions": {
    "abort": "",
    "confirmation": ""
  },
  "common": {
    "advanced_camera_card": "",
    "advanced_camera_card_description": "",
    "folder": "",
    "live": "En direct",
    "no_folder": "",
    "no_media": "Aucun média à afficher",
    "recordings": "Enregistrements",
    "version": "Version"
  },
  "config": {
    "cameras": {
      "always_error_if_entity_unavailable": "Toujours afficher les entités indisponibles comme erreur",
      "camera_entity": "Entité caméra",
      "capabilities": {
        "capabilities": {
          "clips": "Clips",
          "favorite-events": "Événements favoris",
          "favorite-recordings": "Enregistrements favoris",
          "live": "Vue en direct",
          "menu": "Menu",
          "ptz": "PTZ",
          "recordings": "Enregistrements",
          "seek": "Recherche",
          "snapshots": "Snapshots",
          "substream": "Flux secondaire"
        },
        "disable": "Désactiver",
        "disable_except": "Désactiver sauf",
        "editor_label": "Capacités de la caméra"
      },
      "cast": {
        "dashboard": {
          "dashboard_path": "Chemin du tableau de bord",
          "view_path": "Voir le chemin"
        },
        "editor_label": "Options de diffusion",
        "method": "Méthodes de diffusion",
        "methods": {
          "dashboard": "Tableau de bord",
          "standard": "Standard"
        }
      },
      "dependencies": {
        "all_cameras": "Afficher les événements pour toutes les caméras avec cette caméra",
        "cameras": "Afficher les événements pour des caméras spécifiques avec cette caméra",
        "editor_label": "Options de dépendance"
      },
      "dimensions": {
        "aspect_ratio": "Rapport d'aspect d'image",
        "editor_label": "Dimensions de la caméra",
        "layout": {
          "editor_label": "Disposition de la caméra",
          "fit": "Ajustement de la disposition",
          "fits": {
            "contain": "Le média est contenu",
            "cover": "Le média s'étend proportionnellement pour couvrir la carte",
            "fill": "Le média est étiré pour remplir la carte"
          },
          "pan": {
            "x": "Pourcentage de panoramique horizontal",
            "y": "Pourcentage de panoramique vertical"
          },
          "position": {
            "editor_label": "Position de la couverture",
            "x": "Pourcentage de positionnement horizontal",
            "y": "Pourcentage de positionnement vertical"
          },
          "view_box": {
            "bottom": "Pourcentage d'écart en bas",
            "editor_label": "Disposition de zone de visualisation",
            "left": "Pourcentage d'écart à gauche",
            "right": "Pourcentage d'écart à droite",
            "top": "Pourcentage d'écart en haut"
          },
          "zoom": "Facteur de zoom"
        }
      },
      "engines": {
        "editor_label": "Options du moteur de caméra"
      },
      "frigate": {
        "camera_name": "Nom de la caméra Frigate (détecté automatiquement par l'entité)",
        "client_id": "ID client Frigate (Si plus d'un serveur Frigate)",
        "editor_label": "Options de Frigate",
        "labels": "Étiquettes de Frigate/filtres d'objets",
        "url": "URL du serveur Frigate",
        "zones": "Zones Frigate"
      },
      "go2rtc": {
        "editor_label": "Options go2rtc",
        "modes": {
          "editor_label": "Modes go2rtc",
          "mjpeg": "Motion JPEG (MJPEG)",
          "mp4": "MPEG-4 (MP4)",
          "mse": "Extensions de sources multimédias (MSE)",
          "webrtc": "Web Real-Time Communication (WebRTC)"
        },
        "stream": "Nom du flux go2rtc",
        "url": ""
      },
      "icon": "Icône pour cette caméra (auto-détectée par l'entité)",
      "id": "ID unique pour cette caméra dans cette carte",
      "image": {
        "editor_label": "Options d'images",
        "refresh_seconds": "Nombre de secondes après lesquelles actualiser l'image en direct (0=jamais)",
        "url": "URL de l'image à utiliser à la place de l'instantané de l'entité de la caméra"
      },
      "live_provider": "Fournisseur de visualisation en direct pour cette caméra",
      "live_provider_options": {
        "editor_label": "Options du fournisseur en direct"
      },
      "live_providers": {
        "auto": "Automatique",
        "go2rtc": "go2rtc",
        "ha": "Flux vidéo Home Assistant (c'est-à-dire HLS, LL-HLS, WebRTC via HA)",
        "image": "Images d'Home Assistant",
        "jsmpeg": "JSMpeg",
        "webrtc-card": "Carte WebRTC (c.-⁠à-⁠d. la carte WebRTC d'AlexxIT)"
      },
      "motioneye": {
        "editor_label": "Options de MotionEye",
        "images": {
          "directory_pattern": "Modèle de répertoire d'images",
          "file_pattern": "Modèle de fichier images"
        },
        "movies": {
          "directory_pattern": "Modèle de répertoire de films",
          "file_pattern": "Modèle de fichier de films"
        },
        "url": "URL de l’interface MotionEye"
      },
      "proxy": {
        "dynamic": "Proxy dynamique",
        "editor_label": "Proxy de la caméra",
        "media": {
          "auto": "Proxy média automatique",
          "editor_label": "Proxy média",
          "false": "Proxy média désactivé",
          "true": "Proxy média activé"
        },
        "ssl_ciphers": {
          "auto": "Chiffrement SSL automatique",
          "default": "Chiffrement SSL par défaut",
          "editor_label": "Chiffrement SSL",
          "insecure": "Chiffrement SSL non sécurisé",
          "intermediate": "Chiffrement SSL intermédiaire",
          "modern": "Chiffrement SSL moderne"
        },
        "ssl_verification": {
          "auto": "Vérification SSL automatique",
          "editor_label": "Vérification SSL",
          "false": "Vérification SSL désactivée",
          "true": "Vérification SSL activée"
        }
      },
      "reolink": {
        "editor_label": "Option Reolink",
        "media_resolution": {
          "editor_label": "Résolution du média",
          "high": "Haute résolution",
          "low": "Basse résolution"
        },
        "url": "URL de l'interface utilisateur Reolink"
      },
      "title": "Titre de cette caméra (détection automatique à partir de l'entité)",
      "triggers": {
        "editor_label": "Modèle de répertoire des films",
        "entities": "Déclencheur à partir d'autres entités",
        "events": {
          "clips": "Événements avec de nouveaux clips",
          "editor_label": "Événements déclencheurs",
          "events": "Tous les événements",
          "snapshots": "Événements avec de nouveaux instantanés"
        },
        "motion": "Déclenchement par détection automatique du capteur de mouvement",
        "occupancy": "Déclenchement par détection automatique du capteur de présence"
      },
      "webrtc_card": {
        "editor_label": "Options de la carte WebRTC",
        "entity": "Entité de caméra de carte WebRTC (pas une caméra de Frigate)",
        "url": "URL de la caméra de la carte WebRTC"
      }
    },
    "common": {
      "controls": {
        "builtin": "Commandes vidéo intégrées",
        "filter": {
          "editor_label": "Filtre multimédia",
          "mode": "Mode de filtre",
          "modes": {
            "left": "Filtre média dans un menu à gauche",
            "none": "Pas de filtre média",
            "right": "Filtre média dans un menu à droite"
          }
        },
        "next_previous": {
          "editor_label": "Suivant et précédent",
          "size": "Taille des contrôles suivant et précédent en pixels",
          "style": "Style de contrôle suivant et précédent",
          "styles": {
            "chevrons": "Chevrons",
            "icons": "Icônes",
            "none": "Aucun",
            "thumbnails": "Vignettes"
          }
        },
        "thumbnails": {
          "editor_label": "Vignettes",
          "events_media_type": "S'il faut afficher des vignettes de clips ou des instantanés",
          "events_media_types": {
            "clips": "Vignettes de clips",
            "snapshots": "Vignettes d'instantanés"
          },
          "media_type": "Afficher ou non les vignettes des événements ou des enregistrements",
          "media_types": {
            "events": "Événements",
            "recordings": "Enregistrements"
          },
          "mode": "Mode vignettes",
          "modes": {
            "above": "Vignettes en haut",
            "below": "Vignettes en bas",
            "left": "Vignettes dans un menu à gauche",
            "none": "Aucune vignette",
            "right": "Vignettes dans un menu à droite"
          },
          "show_details": "Afficher les détails avec des vignettes",
          "show_download_control": "Afficher le contrôle de téléchargement sur les vignettes",
          "show_favorite_control": "Afficher le contrôle favori sur les vignettes",
          "show_timeline_control": "Afficher le contrôle de la chronologie sur les vignettes",
          "size": "Taille des vignettes en pixels"
        },
        "timeline": {
          "editor_label": "Mini-chronologie",
          "format": {
            "24h": "",
            "editor_label": ""
          },
          "mode": "Mode",
          "modes": {
            "above": "Au-dessus",
            "below": "En dessous",
            "none": "Aucun"
          },
          "pan_mode": "Mode panoramique par défaut",
          "pan_modes": {
            "pan": "Pan",
            "seek": "Pan cherche parmi toutes les caméras",
            "seek-in-camera": "Pan ne cherche que parmi la caméra sélectionnée",
            "seek-in-media": "Pan ne cherche que parmi les médias sélectionnés"
          }
        }
      },
      "display": {
        "editor_label": "Affichage",
        "grid_columns": "Nombre de colonnes de la grille",
        "grid_max_columns": "Nombre maximum de colonnes de la grille",
        "grid_selected_position": "Position du média sélectionné dans la grille",
        "grid_selected_positions": {
          "default": "L'élément sélectionné en position par défaut",
          "first": "L'élément sélectionné apparaît en premier dans la grille",
          "last": "L'élément sélectionné apparaît en dernier dans la grille"
        },
        "grid_selected_width_factor": "Augmenter la largeur du média sélectionnée par ce facteur",
        "mode": "Mode"
      },
      "image": {
        "entity": "Entité à utiliser avec le mode entité",
        "entity_parameters": "Paramètres de requête ajoutés aux URL des images basées sur l'entité (par exemple, width=1920&height=1080)",
        "mode": "Mode d'affichage des images",
        "modes": {
          "camera": "Instantané de la caméra Home Assistant de l'entité caméra",
          "entity": "Entité avec l'attribut entity_picture",
          "screensaver": "",
          "url": "Image arbitraire spécifiée par URL"
        },
        "refresh_seconds": "Nombre de secondes après lesquelles actualiser (0=jamais)",
        "url": "URL d'image statique pour l'affichage de l'image"
      },
      "media_action_conditions": {
        "all": "Toutes les opportunités",
        "hidden": "Sur le navigateur/onglet masqué",
        "microphone_mute": "Sourdine du microphone activée",
        "microphone_unmute": "Sourdine du microphone désactivée",
        "never": "Jamais",
        "selected": "Sur sélection",
        "unselected": "Lors de la désélection",
        "visible": "Sur la visibilité du navigateur/onglet"
      },
      "timeline": {
        "clustering_threshold": "Nombre d'événements pour lesquels ils sont regroupés (0 = pas de clustering)",
        "events_media_type": "Médias affichés par la chronologie",
        "events_media_types": {
          "all": "Tous types de médias",
          "clips": "Extraits",
          "snapshots": "Instantanés"
        },
        "show_recordings": "Afficher les enregistrements",
        "style": "Style de chronologie",
        "styles": {
          "ribbon": "Événements sur un seul ruban",
          "stack": "Événements empilés et groupés"
        },
        "window_seconds": "Durée par défaut de la vue chronologique en secondes"
      }
    },
    "dimensions": {
      "aspect_ratio": "Format d'image par défaut (par exemple '16:9')",
      "aspect_ratio_mode": "Mode rapport hauteur/largeur",
      "aspect_ratio_modes": {
        "dynamic": "Rapport hauteur/largeur s'adapte au média",
        "static": "Rapport hauteur/largeur statique",
        "unconstrained": "Rapport hauteur/largeur sans contrainte"
      },
      "height": "Hauteur de la carte en unités CSS (par exemple, '500px')"
    },
    "folders": {
      "ha": {
        "editor_label": "",
        "path_info": "",
        "url": ""
      },
      "icon": "",
      "id": "",
      "title": "",
      "type": "",
      "types": {
        "ha": ""
      }
    },
    "live": {
      "auto_mute": "Couper automatiquement le son des caméras en direct",
      "auto_pause": "Mettre automatiquement en pause les caméras en direct",
      "auto_play": "Lire automatiquement les caméras en direct",
      "auto_unmute": "Activer automatiquement le son des caméras en direct",
      "controls": {
        "editor_label": "Contrôles en direct",
        "ptz": {
          "editor_label": "PTZ",
          "hide_home": "Cacher le bouton position d'origine",
          "hide_pan_tilt": "Cacher les boutons panoramiques/inclinaison",
          "hide_zoom": "Cacher le bouton de zoom",
          "mode": "Mode",
          "modes": {
            "off": "Désactivé",
            "on": "Activé"
          },
          "orientation": "Orientation",
          "orientations": {
            "horizontal": "Horizontale",
            "vertical": "Verticale"
          },
          "position": "Position",
          "positions": {
            "bottom-left": "En bas à gauche",
            "bottom-right": "En bas à droite",
            "top-left": "En haut à gauche",
            "top-right": "En haut à droite"
          }
        }
      },
      "draggable": "La vue des caméras en direct peut être déplacée/glissée",
      "lazy_load": "Les caméras en direct sont chargeés en différé",
      "lazy_unload": "Les caméras en direct sont déchargées en différé",
      "microphone": {
        "always_connected": "Toujours garder le microphone connecté",
        "disconnect_seconds": "Secondes après quoi déconnecter le microphone (0=jamais)",
        "editor_label": "Microphone",
        "enabled": "Microphone activé",
        "mute_after_microphone_mute_seconds": "Secondes après la mise en sourdine du microphone pour couper l'audio entrant"
      },
      "preload": "Précharger la vue en direct en arrière-plan",
      "show_image_during_load": "Afficher une image fixe pendant le chargement du flux en direct",
      "transition_effect": "Effet de transition de caméra en direct",
      "zoomable": "Les caméras en direct peuvent être zoomées/panoramiques"
    },
    "media_viewer": {
      "auto_mute": "Couper automatiquement le son des médias",
      "auto_pause": "Mettre automatiquement en pause les médias",
      "auto_play": "Lire automatiquement les médias",
      "auto_unmute": "Activer automatiquement le son des médias",
      "controls": {
        "editor_label": "Commandes de la visionneuse multimédia"
      },
      "draggable": "La visionneuse multimédia peut être déplacée/glissée",
      "lazy_load": "Les médias Media Viewer sont chargés en différé dans le carrousel",
      "snapshot_click_plays_clip": "Cliquer sur un instantané lit l'extrait associé",
      "transition_effect": "Effet de transition de la visionneuse multimédia",
      "transition_effects": {
        "none": "Pas de transition",
        "slide": "Transition de diapositive"
      },
      "zoomable": "La visionneuse multimédia peut être zoomée/panoramique"
    },
    "menu": {
      "alignment": "Alignement des menus",
      "alignments": {
        "bottom": "Aligné vers le bas",
        "left": "Aligné à gauche",
        "right": "Aligné à droite",
        "top": "Aligné vers le haut"
      },
      "button_size": "Taille du bouton de menu en pixels",
      "buttons": {
        "alignment": "Alignement des boutons",
        "alignments": {
          "matching": "Faire correspondre l'alignement du menu",
          "opposing": "S'opposer à l'alignement des menus"
        },
        "camera_ui": "Interface utilisateur de la caméra",
        "cameras": "Caméras",
        "clips": "Extraits",
        "display_mode": "Mode d'affichage",
        "download": "Télécharger",
        "enabled": "Bouton activé",
        "expand": "Étendre",
        "folders": "",
        "fullscreen": "Plein écran",
        "icon": "Icône",
        "image": "Image",
        "iris": "",
        "live": "En direct",
        "media_player": "Envoyer au lecteur multimédia",
        "microphone": "Microphone",
        "mute": "Désactiver / Réactiver le son",
        "permanent": "Afficher lorsque le menu est caché",
        "play": "Jouer / Pause",
        "priority": "Priorité",
        "ptz_controls": "Afficher les controles PTZ",
        "ptz_home": "Position d'origine PTZ",
        "recordings": "Enregistrements",
        "screenshot": "Capture d'écran",
        "snapshots": "Instantanés",
        "substreams": "Flux secondaires",
        "timeline": "Chronologie",
        "type": "Type de bouton",
        "types": {
          "momentary": "Momentané",
          "toggle": "Basculer"
        }
      },
      "position": "Emplacement des menus",
      "positions": {
        "bottom": "Positionné en bas",
        "left": "Positionné à gauche",
        "right": "Positionné à droite",
        "top": "Positionné en haut"
      },
      "style": "Style de menu",
      "styles": {
        "hidden": "Menu caché",
        "hover": "Menu survolé",
        "hover-card": "Menu survolé (à l'échelle de la carte)",
        "none": "Pas de menu",
        "outside": "Menu extérieur",
        "overlay": "Menu superposé"
      }
    },
    "overrides": {
      "info": "Cette configuration de carte comporte des remplacements spécifiés manuellement et configurés qui peuvent remplacer les valeurs affichées dans l'éditeur visuel. Veuillez consulter l'éditeur de code pour afficher/modifier ces remplacements."
    },
    "performance": {
      "features": {
        "animated_progress_indicator": "Indicateur de progression animé",
        "card_loading_indicator": "Indicateur de chargement de la carte",
        "editor_label": "Options de fonctionnalités",
        "max_simultaneous_engine_requests": "Nombre maximal de requêtes simultanées au moteur de caméra",
        "media_chunk_size": "Taille du morceau de média"
      },
      "style": {
        "border_radius": "Courbes",
        "box_shadow": "Ombres",
        "editor_label": "Options de style"
      },
      "warning": "Cette carte est en mode basse performance, les paramètres par défaut ont donc été modifiés pour optimiser les performances."
    },
    "profiles": {
      "casting": "Diffusion",
      "editor_label": "Configuration des profils",
      "low-performance": "Basse performance",
      "scrubbing": "Balayage vidéo"
    },
    "remote_control": {
      "entities": {
        "camera": "",
        "editor_label": ""
      }
    },
    "status_bar": {
      "height": "Hauteur de la barre d'état en pixels",
      "items": {
        "enabled": "Élément activé",
        "engine": "Moteur de camera",
        "live_provider": "Fournisseur de flux en direct",
        "priority": "Priorité de l'élément",
        "resolution": "Résolution",
        "technology": "Technologie",
        "title": "Titre"
      },
      "popup_seconds": "Secondes de popup de la barre d'état",
      "position": "Position de la barre d'état",
      "positions": {
        "bottom": "Postionné en bas",
        "top": "Postionné en haut"
      },
      "style": "Style de la barre d'état",
      "styles": {
        "hover": "Barre d'état au survol",
        "hover-card": "Barre d'état au survol (sur toute la carte)",
        "none": "Pas de barre d'état",
        "outside": "Barre d'état extérieure",
        "overlay": "Barre d'état superposée",
        "popup": "Barre d'état contextuelle"
      }
    },
    "view": {
      "camera_select": "Vue pour les caméras nouvellement sélectionnées",
      "default": "Vue par défaut",
      "default_cycle_camera": "Parcourir les caméras lorsque la vue par défaut est mise à jour",
      "default_reset": {
        "after_interaction": "Réinitialiser à la vue par défaut après la fin de l'interaction de l'utilisateur",
        "editor_label": "Comportement de réinitialisation de la vue par défaut",
        "entities": "Réinitialiser à la vue par défaut lors du changement d'état de l'entité",
        "every_seconds": "Actualiser la vue par défaut toutes les X secondes (0=jamais)",
        "interaction_mode": "Comment la réinitialisation par défaut se comporte lorsque la carte a une interaction humaine",
        "interaction_modes": {
          "active": "Autoriser la réinitialisation uniquement lorsque la carte a une interaction humaine active",
          "all": "Réinitialiser indépendamment de l'interaction humaine",
          "inactive": "Réinitialiser uniquement lorsque la carte n'a pas d'interaction humaine"
        }
      },
      "dim": "Assombrir si pas d'interaction",
      "interaction_seconds": "Secondes après l'action de l'utilisateur pour maintenir l'interaction (0=jamais)",
      "keyboard_shortcuts": {
        "editor_label": "Raccourcis clavier",
        "enabled": "Raccourcis clavier activés",
        "ptz_down": "PTZ bas",
        "ptz_home": "PTZ position d'origine",
        "ptz_left": "PTZ gauche",
        "ptz_right": "PTZ droite",
        "ptz_up": "PTZ haut",
        "ptz_zoom_in": "PTZ zoomer",
        "ptz_zoom_out": "PTZ dézoomer"
      },
      "theme": {
        "themes": {
          "dark": "Sombre",
          "editor_label": "Thèmes",
          "ha": "Home Assistant",
          "light": "Clair",
          "traditional": "Traditionnel"
        }
      },
      "triggers": {
        "actions": {
          "editor_label": "Actions de déclenchement",
          "interaction_mode": "Comment gérer les actions lorsque la carte comporte une interaction humaine ?",
          "interaction_modes": {
            "active": "Ne déclencher des actions que lorsque la carte a une interaction humaine",
            "all": "Déclencher des actions sans interaction humaine",
            "inactive": "Ne déclencher des actions que lorsque la carte n'a pas d'interaction humaine"
          },
          "trigger": "Actions de déclenchement",
          "triggers": {
            "default": "Changement vers ou mise à jour de la vue par défaut",
            "live": "Changement vers ou mise à jour de la vue en direct",
            "media": "Changement d'affichage pour les nouveaux médias",
            "none": "Pas d'action"
          },
          "untrigger": "Action de désactivation",
          "untriggers": {
            "default": "Passage à la vue/caméra par défaut",
            "none": "Pas d'action"
          }
        },
        "editor_label": "Comportement en cas de déclenchement d'une caméra",
        "filter_selected_camera": "Déclenchement uniquement sur la caméra sélectionnée",
        "show_trigger_status": "Afficher la bordure clignotante lors du déclenchement",
        "untrigger_seconds": "Quelques secondes après le changement d'état inactif pour débloquer"
      },
      "views": {
        "clip": "Clip le plus récent",
        "clips": "Galerie de clips",
        "current": "Vue actuelle",
        "folder": "",
        "folders": "",
        "image": "Image statique",
        "live": "Vue en direct",
        "recording": "Enregistrement le plus récent",
        "recordings": "Galerie d'enregistrements",
        "snapshot": "Instantané le plus récent",
        "snapshots": "Galerie d'instantanés",
        "timeline": "Vue chronologique"
      }
    }
  },
  "display_modes": {
    "grid": "Afficher la visionneuse de médias pour chaque caméra dans une grille",
    "single": "Afficher une seule visionneuse"
  },
  "editor": {
    "add_new_camera": "Ajouter une nouvelle caméra",
    "add_new_folder": "",
    "button": "Bouton",
    "camera": "Caméra",
    "cameras": "Caméras",
    "cameras_secondary": "Quelles caméras afficher sur cette carte",
    "delete": "Supprimer",
    "dimensions": "Dimensions",
    "dimensions_secondary": "Options de dimensions et de forme",
    "folders": "",
    "folders_secondary": "",
    "image": "Image",
    "image_secondary": "Options d'affichage d'image statique",
    "live": "En direct",
    "live_secondary": "Options d'affichage de la caméra en direct",
    "media_gallery": "Galerie des médias",
    "media_gallery_secondary": "Options de la galerie multimédia",
    "media_viewer": "Visionneuse de médias",
    "media_viewer_secondary": "Visionneuse de médias statiques (clips, instantanés ou enregistrements)",
    "menu": "Menu",
    "menu_secondary": "Options d'apparence et de convivialité du menu",
    "move_down": "Descendre",
    "move_up": "Déplacer vers le haut",
    "overrides": "Remplacements activés",
    "overrides_secondary": "Remplacements de configuration dynamique détectés",
    "performance": "Performance",
    "performance_secondary": "Options de performances de la carte",
    "profiles": "Profils de configuration",
    "profiles_secondary": "Choisir des ensembles de paramètres par défaut pré-configurés",
    "remote_control": "",
    "remote_control_secondary": "",
    "status_bar": "Barre d'état",
    "status_bar_secondary": "Options d'apparence et de comportement de la barre d'état",
    "timeline": "Chronologie",
    "timeline_secondary": "Options de chronologie des événements",
    "upgrade": "Mise à niveau",
    "upgrade_available": "Une mise à niveau automatique de la configuration de la carte est disponible",
    "view": "Vue",
    "view_secondary": "Ce que la carte doit montrer et comment la montrer"
  },
  "elements": {
    "ptz": {
      "down": "Bas",
      "home": "Origine",
      "left": "Gauche",
      "presets": "",
      "right": "Droite",
      "up": "Haut",
      "zoom_in": "Zoomer",
      "zoom_out": "Dézoomer"
    }
  },
  "error": {
    "awaiting_folder": "",
    "awaiting_live": "En attente du flux en direct...",
    "awaiting_media": "En attente du chargement des médias",
    "camera_initialization": "Échec de l'initialisation de la caméra",
    "camera_initialization_reolink": "Impossible d'initialiser la caméra Reolink",
    "configuration": "",
    "could_not_render_elements": "Impossible de restituer les éléments de l'image",
    "could_not_resolve": "Impossible de résoudre l'URL du média",
    "diagnostics": "Diagnostic de la carte. Veuillez enlever les informations confidentielles avant de les partager",
    "download_no_media": "Aucun média à télécharger",
    "download_sign_failed": "Impossible de signer l'URL du média à télécharger",
    "duplicate_camera_id": "ID de caméra Frigate en double pour la caméra suivante, utilisez le paramètre « ID » pour identifier de manière unique les caméras",
    "duplicate_folder_id": "",
    "empty_response": "Réponse vide reçue de Home Assistant pour la demande",
    "failed_response": "Échec de la réponse de Home Assistant à la demande",
    "failed_retain": "Impossible de conserver l'événement",
    "failed_sign": "Impossible de signer l'URL de Home Assistant",
    "fetching_diagnostics": "Récupération des diagnostics",
    "image_load_error": "L'image n'a pas pu être chargée",
    "invalid_configuration": "Configuration invalide",
    "invalid_configuration_no_hint": "Aucune indication de localisation disponible (type incorrect ou manquant ?)",
    "invalid_configuration_override": "Configuration de remplacement invalide",
    "invalid_elements_config": "Configuration des éléments d'image invalide",
    "invalid_response": "Réponse non valide reçue de Home Assistant pour la demande",
    "jsmpeg_no_player": "Impossible de démarrer le lecteur JSMPEG",
    "live_camera_no_endpoint": "Impossible d'obtenir le point de terminaison de la caméra pour ce fournisseur en direct (configuration incomplète ?)",
    "live_camera_not_found": "L'entité caméra configurée n'a pas été trouvée",
    "live_camera_unavailable": "Caméra indisponible",
    "no_camera_engine": "Impossible de déterminer le moteur approprié pour la caméra",
    "no_camera_entity": "Impossible de trouver l'entité de caméra",
    "no_camera_entity_for_triggers": "Une entité caméra est requise pour détecter automatiquement les déclencheurs",
    "no_camera_id": "Impossible de déterminer l'identifiant de la caméra suivante. Il faudra peut-être définir le paramètre « ID » manuellement",
    "no_dashboard_or_view": "Les paramètres 'dashboard_path' et 'view_path' sont requis pour la méthode de conversion 'dashboard'",
    "no_live_camera": "Le paramètre camera_entity doit être défini et valide pour ce fournisseur en direct",
    "no_supported_camera": "La caméra sélectionnée ne prend pas en charge cette vue",
    "no_supported_cameras": "Aucune caméra ne prend en charge cette vue",
    "reconnecting": "Reconnexion",
    "stream_not_loading": "Le flux vidéo n'a pas encore été chargé. Cela peut être du à plusieurs raisons. Si configurée (et par défaut), une image se rafraichira toutes les secondes jusqu'au chargement correct du flux.",
    "too_many_automations": "Trop d'appels d'automatisation imbriqués, veuillez vérifier votre configuration pour les boucles",
    "troubleshooting": "Vérifier le dépannage",
    "unknown": "Erreur inconnue",
    "upgrade_available": "Une mise à niveau automatisée de la configuration de la carte est disponible, veuillez visiter l'éditeur visuel de la carte",
    "webrtc_card_reported_error": "La carte WebRTC a signalé une erreur",
    "webrtc_card_waiting": "En attente du chargement de la carte WebRTC..."
  },
  "key_assigner": {
    "assign": "Assigner",
    "modifiers": {
      "alt": "",
      "ctrl": "",
      "meta": "",
      "shift": ""
    },
    "unassign": "Désassigner"
  },
  "media_filter": {
    "all": "Tous",
    "camera": "Caméra",
    "favorite": "Préféré",
    "media_type": "Type de support",
    "media_types": {
      "clips": "Extraits",
      "recordings": "Enregistrements",
      "snapshots": "Instantanés"
    },
    "not_favorite": "Pas favori",
    "select_camera": "Sélectionnez une caméra...",
    "select_favorite": "Sélectionnez un favori...",
    "select_media_type": "Sélectionnez le type de média...",
    "select_tag": "Sélectionnez la balise...",
    "select_what": "Sélectionnez quoi...",
    "select_when": "Sélectionnez quand...",
    "select_where": "Sélectionnez où...",
    "tag": "Étiqueter",
    "what": "Quoi",
    "when": "Quand",
    "whens": {
      "custom": "Personnalisé",
      "past_month": "Mois passé",
      "past_week": "La semaine dernière",
      "today": "Aujourd'hui",
      "yesterday": "Hier"
    },
    "where": "Où"
  },
  "media_viewer": {
    "unseekable": "Temps non trouvé dans les médias"
  },
  "thumbnail": {
    "camera": "Caméra",
    "download": "Télécharger des médias",
    "duration": "Durée",
    "events": "Événements",
    "in_progress": "En cours",
    "no_thumbnail": "Aucune vignette disponible",
    "retain_indefinitely": "Les médias seront conservés indéfiniment",
    "score": "Score",
    "seek": "Chercher",
    "start": "Commencer",
    "tag": "Étiqueter",
    "timeline": "Voir les médias dans la chronologie",
    "title": "",
    "what": "Quoi",
    "where": "Où"
  },
  "timeline": {
    "select_date": "Choisir une date"
  }
}



================================================
FILE: src/localize/languages/it.json
================================================
{
  "actions": {
    "abort": "",
    "confirmation": ""
  },
  "common": {
    "advanced_camera_card": "",
    "advanced_camera_card_description": "",
    "folder": "",
    "live": "Live",
    "no_folder": "",
    "no_media": "Nessun contenuto multimediale da visualizzare",
    "recordings": "Registrazioni",
    "version": "Versione"
  },
  "config": {
    "cameras": {
      "always_error_if_entity_unavailable": "",
      "camera_entity": "Entità della telecamera",
      "capabilities": {
        "capabilities": {
          "clips": "",
          "favorite-events": "",
          "favorite-recordings": "",
          "live": "",
          "menu": "",
          "ptz": "",
          "recordings": "",
          "seek": "",
          "snapshots": "",
          "substream": ""
        },
        "disable": "",
        "disable_except": "",
        "editor_label": ""
      },
      "cast": {
        "dashboard": {
          "dashboard_path": "",
          "view_path": ""
        },
        "editor_label": "",
        "method": "",
        "methods": {
          "dashboard": "",
          "standard": ""
        }
      },
      "dependencies": {
        "all_cameras": "Mostra eventi per tutte le telecamere con questa telecamera",
        "cameras": "Mostra eventi per telecamere specifiche con questa telecamera",
        "editor_label": "Opzioni di dipendenza"
      },
      "dimensions": {
        "aspect_ratio": "",
        "editor_label": "",
        "layout": {
          "editor_label": "",
          "fit": "Adatta al layout",
          "fits": {
            "contain": "Il supporto è contenuto/in cassetta delle lettere",
            "cover": "Il supporto si espande proporzionalmente per coprire la scheda",
            "fill": "Il supporto viene allungato per riempire la scheda"
          },
          "pan": {
            "x": "",
            "y": ""
          },
          "position": {
            "editor_label": "",
            "x": "Percentuale di posizionamento orizzontale",
            "y": "Percentuale di posizionamento verticale"
          },
          "view_box": {
            "bottom": "",
            "editor_label": "",
            "left": "",
            "right": "",
            "top": ""
          },
          "zoom": ""
        }
      },
      "engines": {
        "editor_label": "Opzioni del motore della fotocamera"
      },
      "frigate": {
        "camera_name": "Nome della telecamera frigate (autodificato dall'entità)",
        "client_id": "ID client Frigate (per > 1 Frigate server)",
        "editor_label": "Frigate Opzione",
        "labels": "Etichette per fregate/filtri per oggetti",
        "url": "Frigate URL del server",
        "zones": "Frigate Zone"
      },
      "go2rtc": {
        "editor_label": "Opzioni go2rtc",
        "modes": {
          "editor_label": "Modalità go2rtc",
          "mjpeg": "JPEG animato (MJPEG)",
          "mp4": "MPEG-4 (MP4)",
          "mse": "Estensioni sorgente multimediale (MSE)",
          "webrtc": "Comunicazione Web in tempo reale (WebRTC)"
        },
        "stream": "nome del flusso go2rtc",
        "url": ""
      },
      "icon": "Icona per questa telecamera (Autoidentificato dall'entità)",
      "id": "ID univoco per questa telecamera in questa carta",
      "image": {
        "editor_label": "Opzioni immagine",
        "refresh_seconds": "Numero di secondi dopo i quali aggiornare l'immagine live (0=mai)",
        "url": "URL dell'immagine da utilizzare al posto dell'istantanea dell'entità fotocamera"
      },
      "live_provider": "Provider di visualizzazione dal vivo per questa telecamera",
      "live_provider_options": {
        "editor_label": "Opzioni del fornitore in tempo reale"
      },
      "live_providers": {
        "auto": "Automatica",
        "go2rtc": "go2rtc",
        "ha": "Streaming video di Home Assistant (ovvero HLS, LL-HLS, WebRTC tramite HA)",
        "image": "Immagini Home Assistant",
        "jsmpeg": "JSMpeg",
        "webrtc-card": "Scheda WebRTC (ovvero la scheda WebRTC di Alexxit)"
      },
      "motioneye": {
        "editor_label": "Opzioni di MotionEye",
        "images": {
          "directory_pattern": "Modello di directory delle immagini",
          "file_pattern": "Modello di file di immagini"
        },
        "movies": {
          "directory_pattern": "Modello di directory dei film",
          "file_pattern": "Modello di file di film"
        },
        "url": "URL dell'interfaccia utente di MotionEye"
      },
      "proxy": {
        "dynamic": "",
        "editor_label": "",
        "media": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        },
        "ssl_ciphers": {
          "auto": "",
          "default": "",
          "editor_label": "",
          "insecure": "",
          "intermediate": "",
          "modern": ""
        },
        "ssl_verification": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        }
      },
      "reolink": {
        "editor_label": "",
        "media_resolution": {
          "editor_label": "",
          "high": "",
          "low": ""
        },
        "url": ""
      },
      "title": "Titolo per questa telecamera (Autoidentificato dall'entità)",
      "triggers": {
        "editor_label": "Trigger Opzioni",
        "entities": "Trigger da altre entità",
        "events": {
          "clips": "",
          "editor_label": "",
          "events": "",
          "snapshots": ""
        },
        "motion": "Trigger rilevando automaticamente dal sensore di movimento",
        "occupancy": "Attivare rilevando automatico tramite il sensore di presenza"
      },
      "webrtc_card": {
        "editor_label": "Opzioni della scheda WebRTC",
        "entity": "Entità della telecamera della scheda WebRTC (non una telecamera Frigate)",
        "url": "URL della telecamera della scheda WebRTC"
      }
    },
    "common": {
      "controls": {
        "builtin": "",
        "filter": {
          "editor_label": "Filtro multimediale",
          "mode": "Modalità filtro",
          "modes": {
            "left": "Filtro multimediale in un cassetto a sinistra",
            "none": "Nessun filtro multimediale",
            "right": "Filtro multimediale in un cassetto a destra"
          }
        },
        "next_previous": {
          "editor_label": "Successivo e precedente",
          "size": "Successiva e Precedenti dimensioni di controllo nei pixel",
          "style": "Stile di controllo successivo e precedente",
          "styles": {
            "chevrons": "Chevrons",
            "icons": "Icone",
            "none": "Nessuno",
            "thumbnails": "Miniature"
          }
        },
        "thumbnails": {
          "editor_label": "Miniature",
          "events_media_type": "Se mostrare miniature di clip o istantanee",
          "events_media_types": {
            "clips": "Miniature di clip",
            "snapshots": "Miniature istantanee"
          },
          "media_type": "",
          "media_types": {
            "events": "",
            "recordings": ""
          },
          "mode": "Modalità miniatura",
          "modes": {
            "above": "Miniature sopra",
            "below": "Miniature sotto",
            "left": "Miniature in un cassetto a sinistra",
            "none": "Nessuna miniatura",
            "right": "Miniature in un cassetto a destra"
          },
          "show_details": "Mostra i dettagli con le miniature",
          "show_download_control": "Mostra il controllo del download sulle miniature",
          "show_favorite_control": "Mostra il controllo preferito sulle miniature",
          "show_timeline_control": "Mostra il controllo della sequenza temporale sulle miniature",
          "size": "Dimensione delle miniature in pixel"
        },
        "timeline": {
          "editor_label": "Mini Cronologia",
          "format": {
            "24h": "",
            "editor_label": ""
          },
          "mode": "Modalità",
          "modes": {
            "above": "sopra",
            "below": "sotto",
            "none": "sessuna"
          },
          "pan_mode": "",
          "pan_modes": {
            "pan": "",
            "seek": "",
            "seek-in-camera": "",
            "seek-in-media": ""
          }
        }
      },
      "display": {
        "editor_label": "",
        "grid_columns": "",
        "grid_max_columns": "",
        "grid_selected_position": "",
        "grid_selected_positions": {
          "default": "",
          "first": "",
          "last": ""
        },
        "grid_selected_width_factor": "",
        "mode": ""
      },
      "image": {
        "entity": "",
        "entity_parameters": "",
        "mode": "Modalità Visualizza immagine",
        "modes": {
          "camera": "Istantanea della telecamera di Home Assistant dell'entità telecamera",
          "entity": "",
          "screensaver": "",
          "url": "Immagine arbitraria specificata dall'URL"
        },
        "refresh_seconds": "Numero di secondi dopo i quali aggiornare (0 = mai)",
        "url": "URL di immagine statica per la vista dell'immagine"
      },
      "media_action_conditions": {
        "all": "Tutte le opportunità",
        "hidden": "Sul browser/nascondere le schede",
        "microphone_mute": "",
        "microphone_unmute": "",
        "never": "Mai",
        "selected": "Sulla selezione",
        "unselected": "Sulla non selezione",
        "visible": "Sul browser/visibilità della scheda"
      },
      "timeline": {
        "clustering_threshold": "Il conteggio degli eventi in cui sono raggruppati (0 = nessun clustering)",
        "events_media_type": "I media vengono visualizzati la sequenza temporale",
        "events_media_types": {
          "all": "Tutti i tipi di media",
          "clips": "Clip",
          "snapshots": "Istantanee"
        },
        "show_recordings": "Mostra registrazioni",
        "style": "",
        "styles": {
          "ribbon": "",
          "stack": ""
        },
        "window_seconds": "La lunghezza predefinita della vista della sequenza temporale in secondi"
      }
    },
    "dimensions": {
      "aspect_ratio": "Proporzioni predefinite (ad es. '16:9')",
      "aspect_ratio_mode": "Modalità proporzioni",
      "aspect_ratio_modes": {
        "dynamic": "Le proporzioni si adattano ai media",
        "static": "Proporzioni statiche",
        "unconstrained": "Proporzioni non vincolate"
      },
      "height": ""
    },
    "folders": {
      "ha": {
        "editor_label": "",
        "path_info": "",
        "url": ""
      },
      "icon": "",
      "id": "",
      "title": "",
      "type": "",
      "types": {
        "ha": ""
      }
    },
    "live": {
      "auto_mute": "Muta automaticamente le telecamere in diretta",
      "auto_pause": "Metti in pausa automaticamente le telecamere in diretta",
      "auto_play": "Gioca automaticamente le telecamere dal vivo",
      "auto_unmute": "Riattiva automaticamente l'audio delle telecamere live",
      "controls": {
        "editor_label": "Controlli dal vivo",
        "ptz": {
          "editor_label": "",
          "hide_home": "",
          "hide_pan_tilt": "",
          "hide_zoom": "",
          "mode": "",
          "modes": {
            "off": "",
            "on": ""
          },
          "orientation": "",
          "orientations": {
            "horizontal": "",
            "vertical": ""
          },
          "position": "",
          "positions": {
            "bottom-left": "",
            "bottom-right": "",
            "top-left": "",
            "top-right": ""
          }
        }
      },
      "draggable": "Il Visualizzatore eventi può essere trascinato oppure puoi scorrere",
      "lazy_load": "Le telecamere dal vivo sono pigramente cariche",
      "lazy_unload": "Le telecamere dal vivo sono pigramente non caricate",
      "microphone": {
        "always_connected": "",
        "disconnect_seconds": "",
        "editor_label": "",
        "enabled": "",
        "mute_after_microphone_mute_seconds": ""
      },
      "preload": "Precarica Live View in background",
      "show_image_during_load": "Mostra un'immagine fissa durante il caricamento del live streaming",
      "transition_effect": "Effetto di transizione della telecamera dal vivo",
      "zoomable": ""
    },
    "media_viewer": {
      "auto_mute": "Muta automaticamente i media",
      "auto_pause": "Metti in Pausa automaticamente i media",
      "auto_play": "Riproduci automaticamente i contenuti multimediali",
      "auto_unmute": "Riattiva automaticamente i contenuti multimediali",
      "controls": {
        "editor_label": "Controlli di visualizzatore multimediale"
      },
      "draggable": "Il visualizzatore multimediale può essere trascinato oppure può scorrere",
      "lazy_load": "Il media Viewer viene caricato pigramente nel carosello",
      "snapshot_click_plays_clip": "",
      "transition_effect": "Effetto di transizione del visualizzatore multimediale",
      "transition_effects": {
        "none": "Nessuna transizione",
        "slide": "Transizione diapositiva"
      },
      "zoomable": ""
    },
    "menu": {
      "alignment": "Allineamento dei menu",
      "alignments": {
        "bottom": "Allineato al fondo",
        "left": "Allineato a sinistra",
        "right": "Allineato a destra",
        "top": "Allineato in cima"
      },
      "button_size": "Dimensione del pulsante menu in pixel",
      "buttons": {
        "alignment": "Allineamento dei pulsanti",
        "alignments": {
          "matching": "Corrispondenza con l'allineamento del menu",
          "opposing": "Contrastare l'allineamento del menu"
        },
        "camera_ui": "Interfaccia utente della fotocamera",
        "cameras": "Telecamere",
        "clips": "Clip",
        "display_mode": "",
        "download": "Download",
        "enabled": "Pulsante abilitato",
        "expand": "Espandere",
        "folders": "",
        "fullscreen": "A schermo intero",
        "icon": "Icona",
        "image": "Immagine",
        "iris": "",
        "live": "Abitare",
        "media_player": "Invia a Media Player",
        "microphone": "",
        "mute": "",
        "permanent": "",
        "play": "",
        "priority": "Priorità",
        "ptz_controls": "",
        "ptz_home": "",
        "recordings": "",
        "screenshot": "",
        "snapshots": "Istantanee",
        "substreams": "Flusso/i secondario/i",
        "timeline": "Timeline",
        "type": "",
        "types": {
          "momentary": "",
          "toggle": ""
        }
      },
      "position": "Posizione del menu",
      "positions": {
        "bottom": "Posizionato sul fondo",
        "left": "Posizionato a sinistra",
        "right": "Posizionato a destra",
        "top": "Posizionato in alto"
      },
      "style": "Stile menu",
      "styles": {
        "hidden": "Menu nascosto",
        "hover": "Menu al passaggio del mouse",
        "hover-card": "",
        "none": "Nessun menu",
        "outside": "Menu esterno",
        "overlay": "Menu di overlay"
      }
    },
    "overrides": {
      "info": "Questa configurazione della scheda ha specificato manualmente le sostituzioni configurate che possono sostituire i valori mostrati nell'editor visivo, consultare l'editor di codice per visualizzare/modificare queste sostituzioni"
    },
    "performance": {
      "features": {
        "animated_progress_indicator": "Indicatore di avanzamento animato",
        "card_loading_indicator": "",
        "editor_label": "Opzioni funzionalità",
        "max_simultaneous_engine_requests": "",
        "media_chunk_size": "Dimensione del blocco multimediale"
      },
      "style": {
        "border_radius": "Curve",
        "box_shadow": "Ombre",
        "editor_label": "Opzione di stile"
      },
      "warning": "Questa scheda è in modalità basso profilo, quindi le impostazioni predefinite sono state modificate per ottimizzare le prestazioni"
    },
    "profiles": {
      "casting": "",
      "editor_label": "",
      "low-performance": "",
      "scrubbing": ""
    },
    "remote_control": {
      "entities": {
        "camera": "",
        "editor_label": ""
      }
    },
    "status_bar": {
      "height": "",
      "items": {
        "enabled": "",
        "engine": "",
        "live_provider": "",
        "priority": "",
        "resolution": "",
        "technology": "",
        "title": ""
      },
      "popup_seconds": "",
      "position": "",
      "positions": {
        "bottom": "",
        "top": ""
      },
      "style": "",
      "styles": {
        "hover": "",
        "hover-card": "",
        "none": "",
        "outside": "",
        "overlay": "",
        "popup": ""
      }
    },
    "view": {
      "camera_select": "Visualizza per le telecamere appena selezionate",
      "default": "Visualizzazione predefinita",
      "default_cycle_camera": "Scorri le telecamere quando si aggiorna la visualizzazione predefinita",
      "default_reset": {
        "after_interaction": "",
        "editor_label": "",
        "entities": "",
        "every_seconds": "Aggiorna la visualizzazione predefinita ogni x secondi (0 = mai)",
        "interaction_mode": "",
        "interaction_modes": {
          "active": "",
          "all": "",
          "inactive": ""
        }
      },
      "dim": "",
      "interaction_seconds": "",
      "keyboard_shortcuts": {
        "editor_label": "",
        "enabled": "",
        "ptz_down": "",
        "ptz_home": "",
        "ptz_left": "",
        "ptz_right": "",
        "ptz_up": "",
        "ptz_zoom_in": "",
        "ptz_zoom_out": ""
      },
      "theme": {
        "themes": {
          "dark": "",
          "editor_label": "",
          "ha": "",
          "light": "",
          "traditional": ""
        }
      },
      "triggers": {
        "actions": {
          "editor_label": "",
          "interaction_mode": "",
          "interaction_modes": {
            "active": "",
            "all": "",
            "inactive": ""
          },
          "trigger": "",
          "triggers": {
            "default": "",
            "live": "",
            "media": "",
            "none": ""
          },
          "untrigger": "",
          "untriggers": {
            "default": "",
            "none": ""
          }
        },
        "editor_label": "",
        "filter_selected_camera": "",
        "show_trigger_status": "Mostra bordo pulsante quando attivato",
        "untrigger_seconds": "Reimposta la vista ai valori predefiniti dopo aver annullato l'attivazione"
      },
      "views": {
        "clip": "Clip più recente",
        "clips": "Galleria delle clip",
        "current": "Vista corrente",
        "folder": "",
        "folders": "",
        "image": "Immagine statica",
        "live": "Dal vivo",
        "recording": "",
        "recordings": "",
        "snapshot": "Snapshot più recente",
        "snapshots": "Galleria delle istantanee",
        "timeline": "Vista della timeline"
      }
    }
  },
  "display_modes": {
    "grid": "",
    "single": ""
  },
  "editor": {
    "add_new_camera": "Aggiungi nuova telecamera",
    "add_new_folder": "",
    "button": "Pulsante",
    "camera": "Telecamera",
    "cameras": "Telecamere",
    "cameras_secondary": "Quali telecamere visualizzare su questa card",
    "delete": "Elimina",
    "dimensions": "",
    "dimensions_secondary": "",
    "folders": "",
    "folders_secondary": "",
    "image": "Immagine",
    "image_secondary": "Opzioni di visualizzazione dell'immagine statica",
    "live": "Live",
    "live_secondary": "Opzioni di visualizzazione della telecamera live",
    "media_gallery": "Galleria multimediale",
    "media_gallery_secondary": "Opzioni della galleria multimediale",
    "media_viewer": "Visualizzatore dei media",
    "media_viewer_secondary": "Visualizzatore per supporti statici (clip, istantanee o registrazioni)",
    "menu": "Menu",
    "menu_secondary": "Opzioni di aspetto e funzionalità del menu",
    "move_down": "Sposta verso il basso",
    "move_up": "Sposta verso l'alto",
    "overrides": "La sovrascrittura è attiva",
    "overrides_secondary": "Rilevate sovrascritture della configurazione dinamica",
    "performance": "",
    "performance_secondary": "",
    "profiles": "",
    "profiles_secondary": "",
    "remote_control": "",
    "remote_control_secondary": "",
    "status_bar": "",
    "status_bar_secondary": "",
    "timeline": "Timeline",
    "timeline_secondary": "Opzioni della timeline degli eventi",
    "upgrade": "Aggiornamento",
    "upgrade_available": "È disponibile un aggiornamento della configurazione della scheda automatica",
    "view": "Visualizzazione",
    "view_secondary": "Cosa dovrebbe mostrare la carta e come mostrarla"
  },
  "elements": {
    "ptz": {
      "down": "Giù",
      "home": "Home",
      "left": "Sinistra",
      "presets": "",
      "right": "Destra",
      "up": "Su",
      "zoom_in": "Ingrandire",
      "zoom_out": "Zoom indietro"
    }
  },
  "error": {
    "awaiting_folder": "",
    "awaiting_live": "",
    "awaiting_media": "",
    "camera_initialization": "",
    "camera_initialization_reolink": "",
    "configuration": "",
    "could_not_render_elements": "Impossibile renderizzare gli elementi dell'immagine",
    "could_not_resolve": "Impossibile risolvere l'URL dei media",
    "diagnostics": "Diagnostica delle carte.Si prega di rivedere per informazioni riservate prima di condividere",
    "download_no_media": "Nessun media da scaricare",
    "download_sign_failed": "Impossibile firmare URL multimediale per il download",
    "duplicate_camera_id": "Duplicato ID dellla telecamera Frigate, utilizzare il parametro 'ID' per identificare in modo univoco le telecamere",
    "duplicate_folder_id": "",
    "empty_response": "Ricevuto risposta vuota da Home Assistant per la richiesta",
    "failed_response": "Impossibile ricevere risposta da Home Assistant per la richiesta",
    "failed_retain": "Impossibile conservare l'evento",
    "failed_sign": "Impossibile firmare l'URL ad Home Assistant",
    "fetching_diagnostics": "",
    "image_load_error": "L'immagine non può essere caricata",
    "invalid_configuration": "Configurazione non valida",
    "invalid_configuration_no_hint": "Nessun suggerimento di posizione disponibile (tipo difettoso o mancante?)",
    "invalid_configuration_override": "",
    "invalid_elements_config": "Configurazione degli elementi di immagine non valida",
    "invalid_response": "Ricevuta una risposta non valida da Home Assistant per la richiesta",
    "jsmpeg_no_player": "Impossibile avviare JSMPEG Player",
    "live_camera_no_endpoint": "Impossibile ottenere l'endpoint della videocamera per questo provider live (configurazione incompleta?)",
    "live_camera_not_found": "La telecamera configurata non è stata trovata",
    "live_camera_unavailable": "Telecamera non disponibile",
    "no_camera_engine": "Impossibile determinare il motore adatto per la fotocamera",
    "no_camera_entity": "Impossibile trovare l'entità fotocamera",
    "no_camera_entity_for_triggers": "È necessaria un'entità telecamera per rilevare automaticamente i trigger",
    "no_camera_id": "Impossibile determinare l'ID della telecamera , potrebbe essere necessario impostare manualmente il parametro 'ID'",
    "no_dashboard_or_view": "",
    "no_live_camera": "Il parametro fotocamera_enty deve essere impostato e valido per questo provider live",
    "no_supported_camera": "",
    "no_supported_cameras": "",
    "reconnecting": "Riconnessione",
    "stream_not_loading": "",
    "too_many_automations": "",
    "troubleshooting": "Controllare la risoluzione dei problemi",
    "unknown": "Errore sconosciuto",
    "upgrade_available": "È disponibile un aggiornamento di configurazione della scheda automatizzato, visitare l'editor di schede visive",
    "webrtc_card_reported_error": "La scheda WebRTC ha riportato un errore",
    "webrtc_card_waiting": "Aspettando che la scheda WebRTC si carichi ..."
  },
  "key_assigner": {
    "assign": "",
    "modifiers": {
      "alt": "",
      "ctrl": "",
      "meta": "",
      "shift": ""
    },
    "unassign": ""
  },
  "media_filter": {
    "all": "Tutto",
    "camera": "Telecamera",
    "favorite": "Preferito",
    "media_type": "Tipo di supporto",
    "media_types": {
      "clips": "Clip",
      "recordings": "Registrazioni",
      "snapshots": "Istantanee"
    },
    "not_favorite": "Non preferito",
    "select_camera": "Seleziona fotocamera...",
    "select_favorite": "Seleziona preferito...",
    "select_media_type": "Seleziona il tipo di supporto...",
    "select_tag": "",
    "select_what": "Seleziona cosa...",
    "select_when": "Seleziona quando...",
    "select_where": "Seleziona dove...",
    "tag": "Tag",
    "what": "Che cosa",
    "when": "Quando",
    "whens": {
      "custom": "",
      "past_month": "Mese scorso",
      "past_week": "Settimana scorso",
      "today": "Oggi",
      "yesterday": "Ieri"
    },
    "where": "Dove"
  },
  "media_viewer": {
    "unseekable": ""
  },
  "thumbnail": {
    "camera": "Camera",
    "download": "",
    "duration": "Durata",
    "events": "Eventi",
    "in_progress": "In corso",
    "no_thumbnail": "Nessuna miniatura disponibile",
    "retain_indefinitely": "L'evento sarà mantenuto indefinitamente",
    "score": "Punteggio",
    "seek": "Cercare",
    "start": "Inizio",
    "tag": "",
    "timeline": "Vedi evento nella timeline",
    "title": "",
    "what": "Che cosa",
    "where": "Dove"
  },
  "timeline": {
    "select_date": "Scegli la data"
  }
}



================================================
FILE: src/localize/languages/pt-BR.json
================================================
{
  "actions": {
    "abort": "",
    "confirmation": ""
  },
  "common": {
    "advanced_camera_card": "",
    "advanced_camera_card_description": "",
    "folder": "",
    "live": "Ao Vivo",
    "no_folder": "",
    "no_media": "Nenhuma mídia para exibir",
    "recordings": "Gravações",
    "version": "Versão"
  },
  "config": {
    "cameras": {
      "always_error_if_entity_unavailable": "",
      "camera_entity": "Entidade da Câmera",
      "capabilities": {
        "capabilities": {
          "clips": "",
          "favorite-events": "",
          "favorite-recordings": "",
          "live": "",
          "menu": "",
          "ptz": "",
          "recordings": "",
          "seek": "",
          "snapshots": "",
          "substream": ""
        },
        "disable": "",
        "disable_except": "",
        "editor_label": ""
      },
      "cast": {
        "dashboard": {
          "dashboard_path": "",
          "view_path": ""
        },
        "editor_label": "",
        "method": "",
        "methods": {
          "dashboard": "",
          "standard": ""
        }
      },
      "dependencies": {
        "all_cameras": "Mostrar eventos para todas as câmeras nesta câmera",
        "cameras": "Mostrar eventos para câmeras específicas nesta câmera",
        "editor_label": "Opções de dependência"
      },
      "dimensions": {
        "aspect_ratio": "",
        "editor_label": "",
        "layout": {
          "editor_label": "",
          "fit": "Ajuste de layout",
          "fits": {
            "contain": "A mídia é contida no cartão",
            "cover": "A mídia se expande proporcionalmente para cobrir o cartão",
            "fill": "A mídia é esticada para preencher o cartão"
          },
          "pan": {
            "x": "",
            "y": ""
          },
          "position": {
            "editor_label": "",
            "x": "Porcentagem do posicionamento horizontal",
            "y": "Porcentagem do posicionamento vertical"
          },
          "view_box": {
            "bottom": "",
            "editor_label": "",
            "left": "",
            "right": "",
            "top": ""
          },
          "zoom": ""
        }
      },
      "engines": {
        "editor_label": "Opções do motor da câmera"
      },
      "frigate": {
        "camera_name": "Nome da câmera do Frigate (detectado automaticamente pela entidade)",
        "client_id": "ID do cliente do Frigate (para >1 servidor Frigate)",
        "editor_label": "Opções do Frigate",
        "labels": "Rótulos do Frigate/filtros de objetos",
        "url": "URL do servidor Frigate",
        "zones": "Zonas do Frigate"
      },
      "go2rtc": {
        "editor_label": "Opções do go2rtc",
        "modes": {
          "editor_label": "Modos do go2rtc",
          "mjpeg": "Motion JPEG (MJPEG)",
          "mp4": "MPEG-4 (MP4)",
          "mse": "Media Source Extensions (MSE)",
          "webrtc": "Web Real-Time Communication (WebRTC)"
        },
        "stream": "Nome do stream do go2rtc",
        "url": ""
      },
      "icon": "Ícone para esta câmera (detectado automaticamente pela entidade)",
      "id": "ID exclusivo para esta câmera nesse cartão",
      "image": {
        "editor_label": "Opções de Imagem",
        "refresh_seconds": "Número de segundos após os quais atualizar a imagem ao vivo (0=nunca)",
        "url": "URL da imagem para usar em vez do instantâneo da entidade da câmera"
      },
      "live_provider": "Provedor de visualização ao vivo para esta câmera",
      "live_provider_options": {
        "editor_label": "Opções do provedor de visualização ao vivo"
      },
      "live_providers": {
        "auto": "Automatico",
        "go2rtc": "go2rtc",
        "ha": "Stream de vídeo do Home Assistant (ou seja, HLS, LL-HLS, WebRTC via HA)",
        "image": "Imagens do Home Assistant",
        "jsmpeg": "JSMpeg",
        "webrtc-card": "Cartão WebRTC (de @AlexxIT)"
      },
      "motioneye": {
        "editor_label": "Opções do MotionEye",
        "images": {
          "directory_pattern": "Padrão de diretório de imagens",
          "file_pattern": "Padrão de arquivo de imagens"
        },
        "movies": {
          "directory_pattern": "Padrão de diretório de filmes",
          "file_pattern": "Padrão de arquivo de filmes"
        },
        "url": "URL da interface de usuário do MotionEye"
      },
      "proxy": {
        "dynamic": "",
        "editor_label": "",
        "media": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        },
        "ssl_ciphers": {
          "auto": "",
          "default": "",
          "editor_label": "",
          "insecure": "",
          "intermediate": "",
          "modern": ""
        },
        "ssl_verification": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        }
      },
      "reolink": {
        "editor_label": "",
        "media_resolution": {
          "editor_label": "",
          "high": "",
          "low": ""
        },
        "url": ""
      },
      "title": "Título para esta câmera (detectado automaticamente pela entidade)",
      "triggers": {
        "editor_label": "Opções de acionamento",
        "entities": "Acionar a partir de outras entidades",
        "events": {
          "clips": "",
          "editor_label": "",
          "events": "",
          "snapshots": ""
        },
        "motion": "Acionar detectando automaticamente o sensor de movimento",
        "occupancy": "Acionar detectando automaticamente o sensor de ocupação"
      },
      "webrtc_card": {
        "editor_label": "Opções do cartão WebRTC",
        "entity": "Entidade de câmera de cartão WebRTC (não é uma câmera Frigate)",
        "url": "URL da câmera do cartão WebRTC"
      }
    },
    "common": {
      "controls": {
        "builtin": "",
        "filter": {
          "editor_label": "Filtro de Mídia",
          "mode": "Modo do filtro",
          "modes": {
            "left": "Filtro de mídia em uma gaveta à esquerda",
            "none": "Sem filtro de mídia",
            "right": "Filtro de mídia em uma gaveta à direita"
          }
        },
        "next_previous": {
          "editor_label": "Próximo",
          "size": "Tamanho de controle próximo e anterior",
          "style": "Estilo do controle próximo e anterior",
          "styles": {
            "chevrons": "Setas",
            "icons": "Ícones",
            "none": "Nenhum",
            "thumbnails": "Miniaturas"
          }
        },
        "thumbnails": {
          "editor_label": "Miniaturas",
          "events_media_type": "Se deve mostrar miniaturas de clipes ou snapshots",
          "events_media_types": {
            "clips": "Miniaturas de clipes",
            "snapshots": "Miniaturas de Snapshots"
          },
          "media_type": "",
          "media_types": {
            "events": "",
            "recordings": ""
          },
          "mode": "Modo de miniaturas",
          "modes": {
            "above": "Miniaturas acima da mídia",
            "below": "Miniaturas abaixo da mídia",
            "left": "Miniaturas em uma gaveta à esquerda",
            "none": "Sem miniaturas",
            "right": "Miniaturas em uma gaveta à direita"
          },
          "show_details": "Mostrar detalhes com miniaturas",
          "show_download_control": "Mostrar controle de download nas miniaturas",
          "show_favorite_control": "Mostrar controle de favorito nas miniaturas",
          "show_timeline_control": "Mostrar controle da linha do tempo nas miniaturas",
          "size": "Tamanho das miniaturas em pixels"
        },
        "timeline": {
          "editor_label": "Controles da linha do tempo",
          "format": {
            "24h": "",
            "editor_label": ""
          },
          "mode": "Modo",
          "modes": {
            "above": "Acima",
            "below": "Abaixo",
            "none": "Nenhum"
          },
          "pan_mode": "",
          "pan_modes": {
            "pan": "",
            "seek": "",
            "seek-in-camera": "",
            "seek-in-media": ""
          }
        }
      },
      "display": {
        "editor_label": "",
        "grid_columns": "",
        "grid_max_columns": "",
        "grid_selected_position": "",
        "grid_selected_positions": {
          "default": "",
          "first": "",
          "last": ""
        },
        "grid_selected_width_factor": "",
        "mode": ""
      },
      "image": {
        "entity": "",
        "entity_parameters": "",
        "mode": "Modo de visualização de imagem",
        "modes": {
          "camera": "Instantâneo da câmera do Home Assistant, da entidade de câmera",
          "entity": "",
          "screensaver": "",
          "url": "Imagem arbitrária especificada por URL"
        },
        "refresh_seconds": "Número de segundos após o qual atualizar (0 = nunca)",
        "url": "Imagem arbitrária especificada por URL"
      },
      "media_action_conditions": {
        "all": "Todas as oportunidades",
        "hidden": "Ao ocultar o navegador/aba",
        "microphone_mute": "",
        "microphone_unmute": "",
        "never": "Nunca",
        "selected": "Ao selecionar",
        "unselected": "Ao desselecionar",
        "visible": "Ao mostrar o navegador/aba"
      },
      "timeline": {
        "clustering_threshold": "A contagem de eventos nos quais eles são agrupados (0 = sem agrupamento)",
        "events_media_type": "A mídia que a linha do tempo exibe",
        "events_media_types": {
          "all": "Todos os tipos de mídia",
          "clips": "Clipes",
          "snapshots": "Instantâneos"
        },
        "show_recordings": "Mostrar gravações",
        "style": "",
        "styles": {
          "ribbon": "",
          "stack": ""
        },
        "window_seconds": "A duração padrão da visualização da linha do tempo em segundos"
      }
    },
    "dimensions": {
      "aspect_ratio": "Proporção padrão (e.g. '16:9')",
      "aspect_ratio_mode": "Modo de proporção",
      "aspect_ratio_modes": {
        "dynamic": "A proporção se ajusta à mídia",
        "static": "Proporção estática",
        "unconstrained": "Proporção irrestrita"
      },
      "height": ""
    },
    "folders": {
      "ha": {
        "editor_label": "",
        "path_info": "",
        "url": ""
      },
      "icon": "",
      "id": "",
      "title": "",
      "type": "",
      "types": {
        "ha": ""
      }
    },
    "live": {
      "auto_mute": "Silenciar câmeras ao vivo automaticamente",
      "auto_pause": "Pausar câmeras ao vivo automaticamente",
      "auto_play": "Reproduzir câmeras ao vivo automaticamente",
      "auto_unmute": "Ativar automaticamente o som das câmeras ao vivo",
      "controls": {
        "editor_label": "Controles da visualização ao vivo",
        "ptz": {
          "editor_label": "",
          "hide_home": "",
          "hide_pan_tilt": "",
          "hide_zoom": "",
          "mode": "",
          "modes": {
            "off": "",
            "on": ""
          },
          "orientation": "",
          "orientations": {
            "horizontal": "",
            "vertical": ""
          },
          "position": "",
          "positions": {
            "bottom-left": "",
            "bottom-right": "",
            "top-left": "",
            "top-right": ""
          }
        }
      },
      "draggable": "A visualização ao vivo das câmeras pode ser arrastada/deslizada",
      "lazy_load": "As câmeras ao vivo são carregadas lentamente",
      "lazy_unload": "As câmeras ao vivo são descarregadas preguiçosamente",
      "microphone": {
        "always_connected": "",
        "disconnect_seconds": "",
        "editor_label": "",
        "enabled": "",
        "mute_after_microphone_mute_seconds": ""
      },
      "preload": "Pré-carregar a visualização ao vivo em segundo plano",
      "show_image_during_load": "Mostrar imagem estática enquanto a transmissão ao vivo está carregando",
      "transition_effect": "Efeito de transição de câmera ao vivo",
      "zoomable": ""
    },
    "media_viewer": {
      "auto_mute": "Silenciar mídia automaticamente",
      "auto_pause": "Pausar mídia automaticamente",
      "auto_play": "Reproduzir mídia automaticamente",
      "auto_unmute": "Ativar mídia automaticamente",
      "controls": {
        "editor_label": "Controles do visualizador de mídia"
      },
      "draggable": "Visualizador de eventos pode ser arrastado/deslizado",
      "lazy_load": "A mídia do Visualizador de eventos é carregada lentamente no carrossel",
      "snapshot_click_plays_clip": "Clicar em um instantâneo reproduz um clipe relacionado",
      "transition_effect": "Efeito de transição do Visualizador de eventos",
      "transition_effects": {
        "none": "Sem transição",
        "slide": "Transição de slides"
      },
      "zoomable": ""
    },
    "menu": {
      "alignment": "Alinhamento do menu",
      "alignments": {
        "bottom": "Alinhado à parte inferior",
        "left": "Alinhado à esquerda",
        "right": "Alinhado à direita",
        "top": "Alinhado ao topo"
      },
      "button_size": "Tamanho do botão de menu (e.g. '40px')",
      "buttons": {
        "alignment": "Alinhamento do botão",
        "alignments": {
          "matching": "Mesmo alinhamento do menu",
          "opposing": "Opor-se ao alinhamento do menu"
        },
        "camera_ui": "Interface de usuário da câmera",
        "cameras": "Selecionar câmera",
        "clips": "Clipes",
        "display_mode": "",
        "download": "Baixe a mídia do evento",
        "enabled": "Botão ativado",
        "expand": "Expandir",
        "folders": "",
        "fullscreen": "Tela cheia",
        "icon": "Ícone",
        "image": "Imagem",
        "iris": "",
        "live": "Ao vivo",
        "media_player": "Enviar para o reprodutor de mídia",
        "microphone": "",
        "mute": "",
        "permanent": "",
        "play": "",
        "priority": "Prioridade",
        "ptz_controls": "",
        "ptz_home": "",
        "recordings": "Gravações",
        "screenshot": "",
        "snapshots": "Instantâneos",
        "substreams": "Substream(s)",
        "timeline": "Linha do tempo",
        "type": "",
        "types": {
          "momentary": "",
          "toggle": ""
        }
      },
      "position": "Posição do menu",
      "positions": {
        "bottom": "Posicionado na parte inferior",
        "left": "Posicionado à esquerda",
        "right": "Posicionado à direita",
        "top": "Posicionado no topo"
      },
      "style": "Estilo do menu",
      "styles": {
        "hidden": "Menu oculto",
        "hover": "Menu suspenso",
        "hover-card": "Menu suspenso (em todo o cartão)",
        "none": "Sem menu",
        "outside": "Menu externo",
        "overlay": "Menu sobreposto"
      }
    },
    "overrides": {
      "info": "Esta configuração do cartão especificou manualmente as substituições configuradas que podem substituir os valores mostrados no editor visual, consulte o editor de código para visualizar/modificar essas substituições"
    },
    "performance": {
      "features": {
        "animated_progress_indicator": "Indicador de Carregamento Animado",
        "card_loading_indicator": "",
        "editor_label": "Opções de recursos",
        "max_simultaneous_engine_requests": "",
        "media_chunk_size": "Tamanho do bloco de mídia"
      },
      "style": {
        "border_radius": "Curvas",
        "box_shadow": "Sombras",
        "editor_label": "Opções de estilo"
      },
      "warning": "Este cartão está no modo de baixo desempenho, então os padrões foram alterados para otimizar o desempenho"
    },
    "profiles": {
      "casting": "",
      "editor_label": "",
      "low-performance": "",
      "scrubbing": ""
    },
    "remote_control": {
      "entities": {
        "camera": "",
        "editor_label": ""
      }
    },
    "status_bar": {
      "height": "",
      "items": {
        "enabled": "",
        "engine": "",
        "live_provider": "",
        "priority": "",
        "resolution": "",
        "technology": "",
        "title": ""
      },
      "popup_seconds": "",
      "position": "",
      "positions": {
        "bottom": "",
        "top": ""
      },
      "style": "",
      "styles": {
        "hover": "",
        "hover-card": "",
        "none": "",
        "outside": "",
        "overlay": "",
        "popup": ""
      }
    },
    "view": {
      "camera_select": "Visualização de câmeras recém-selecionadas",
      "default": "Visualização padrão",
      "default_cycle_camera": "Percorrer as câmeras quando a visualização padrão for atualizada",
      "default_reset": {
        "after_interaction": "",
        "editor_label": "",
        "entities": "",
        "every_seconds": "Atualize a visualização padrão a cada X segundos (0 = nunca)",
        "interaction_mode": "",
        "interaction_modes": {
          "active": "",
          "all": "",
          "inactive": ""
        }
      },
      "dim": "",
      "interaction_seconds": "",
      "keyboard_shortcuts": {
        "editor_label": "",
        "enabled": "",
        "ptz_down": "",
        "ptz_home": "",
        "ptz_left": "",
        "ptz_right": "",
        "ptz_up": "",
        "ptz_zoom_in": "",
        "ptz_zoom_out": ""
      },
      "theme": {
        "themes": {
          "dark": "",
          "editor_label": "",
          "ha": "",
          "light": "",
          "traditional": ""
        }
      },
      "triggers": {
        "actions": {
          "editor_label": "",
          "interaction_mode": "",
          "interaction_modes": {
            "active": "",
            "all": "",
            "inactive": ""
          },
          "trigger": "",
          "triggers": {
            "default": "",
            "live": "",
            "media": "",
            "none": ""
          },
          "untrigger": "",
          "untriggers": {
            "default": "",
            "none": ""
          }
        },
        "editor_label": "",
        "filter_selected_camera": "",
        "show_trigger_status": "Pulsar borda quando acionado",
        "untrigger_seconds": "Segundos após a mudar para o estado inativo para desacionar"
      },
      "views": {
        "clip": "Clipe mais recente",
        "clips": "Galeria de clipes",
        "current": "Visualização atual",
        "folder": "",
        "folders": "",
        "image": "Imagem estática",
        "live": "Visualização ao vivo",
        "recording": "Gravação mais recente",
        "recordings": "Galeria de gravações",
        "snapshot": "Snapshot mais recente",
        "snapshots": "Galeria de Snapshots",
        "timeline": "Visualização da linha do tempo"
      }
    }
  },
  "display_modes": {
    "grid": "",
    "single": ""
  },
  "editor": {
    "add_new_camera": "Adicionar nova câmera",
    "add_new_folder": "",
    "button": "Botão",
    "camera": "Câmera",
    "cameras": "Câmeras",
    "cameras_secondary": "Quais câmeras renderizar neste cartão",
    "delete": "Excluir",
    "dimensions": "",
    "dimensions_secondary": "",
    "folders": "",
    "folders_secondary": "",
    "image": "Imagem",
    "image_secondary": "Opções de visualização de imagem estática",
    "live": "Ao vivo",
    "live_secondary": "Opções de visualização da câmera ao vivo",
    "media_gallery": "Galeria de mídia",
    "media_gallery_secondary": "Opções da galeria de mídia",
    "media_viewer": "Visualizador de eventos",
    "media_viewer_secondary": "Opções do visualizador de Snapshots e clipes",
    "menu": "Menu",
    "menu_secondary": "Opções de aparência do menu",
    "move_down": "Descer",
    "move_up": "Subir",
    "overrides": "As substituições estão ativas",
    "overrides_secondary": "Substituições de configuração dinâmica detectadas",
    "performance": "Desempenho",
    "performance_secondary": "Opções de desempenho do cartão",
    "profiles": "",
    "profiles_secondary": "",
    "remote_control": "",
    "remote_control_secondary": "",
    "status_bar": "",
    "status_bar_secondary": "",
    "timeline": "Linha do tempo",
    "timeline_secondary": "Opções do evento da linha do tempo",
    "upgrade": "Upgrade",
    "upgrade_available": "Um upgrade automático da configuração de cartão está disponível",
    "view": "Visualizar",
    "view_secondary": "O que o cartão deve mostrar e como mostrá-lo"
  },
  "elements": {
    "ptz": {
      "down": "Baixo",
      "home": "Casa",
      "left": "Esquerda",
      "presets": "",
      "right": "Direita",
      "up": "Cima",
      "zoom_in": "Aumentar Zoom",
      "zoom_out": "Reduzir Zoom"
    }
  },
  "error": {
    "awaiting_folder": "",
    "awaiting_live": "",
    "awaiting_media": "",
    "camera_initialization": "",
    "camera_initialization_reolink": "",
    "configuration": "",
    "could_not_render_elements": "Não foi possível renderizar os elementos da imagem",
    "could_not_resolve": "Não foi possível resolver o URL de mídia",
    "diagnostics": "Diagnósticos do cartão. Revise as informações confidenciais antes de compartilhar",
    "download_no_media": "Nenhuma mídia para download",
    "download_sign_failed": "Não foi possível assinar o URL de mídia para download",
    "duplicate_camera_id": "Duplique o ID da câmera Frigate para a câmera a seguir, use o parâmetro 'id' para identificar exclusivamente as câmeras",
    "duplicate_folder_id": "",
    "empty_response": "Sem resposta do Home Assistant para a solicitação",
    "failed_response": "Falha ao receber resposta do Home Assistant para solicitação",
    "failed_retain": "Não foi possível reter o evento",
    "failed_sign": "Não foi possível assinar a URL do Home Assistant",
    "fetching_diagnostics": "",
    "image_load_error": "A imagem não pôde ser carregada",
    "invalid_configuration": "Configuração inválida",
    "invalid_configuration_no_hint": "Nenhuma dica de local disponível (tipo incorreto ou ausente?)",
    "invalid_configuration_override": "",
    "invalid_elements_config": "Configuração de elementos de imagem inválida",
    "invalid_response": "Resposta inválida recebida do Home Assistant para a solicitação",
    "jsmpeg_no_player": "Não foi possível iniciar o player JSMPEG",
    "live_camera_no_endpoint": "Não foi possível obter o endereço da câmera para este provedor ao vivo (configuração incompleta?)",
    "live_camera_not_found": "A entidade de câmera configurada não foi encontrada",
    "live_camera_unavailable": "Câmera indisponível",
    "no_camera_engine": "Não foi possível determinar o motor adequado para a câmera",
    "no_camera_entity": "Não foi possível encontrar a entidade da câmera",
    "no_camera_entity_for_triggers": "Uma entidade de câmera é necessária para detectar automaticamente os gatilhos",
    "no_camera_id": "Não foi possível determinar o ID da câmera para a câmera a seguir, pode ser necessário definir o parâmetro 'id' manualmente",
    "no_dashboard_or_view": "",
    "no_live_camera": "O parâmetro camera_entity deve ser definido e válido para este provedor ativo",
    "no_supported_camera": "",
    "no_supported_cameras": "",
    "reconnecting": "Reconectando",
    "stream_not_loading": "",
    "too_many_automations": "",
    "troubleshooting": "Verifique a solução de problemas",
    "unknown": "Erro desconhecido",
    "upgrade_available": "Uma atualização automatizada da configuração do cartão está disponível, visite o editor visual do cartão",
    "webrtc_card_reported_error": "O cartão WebRTC relatou um erro",
    "webrtc_card_waiting": "Aguardando o cartão WebRTC carregar ..."
  },
  "key_assigner": {
    "assign": "",
    "modifiers": {
      "alt": "",
      "ctrl": "",
      "meta": "",
      "shift": ""
    },
    "unassign": ""
  },
  "media_filter": {
    "all": "Todos",
    "camera": "Câmera",
    "favorite": "Favorito",
    "media_type": "Tipo de mídia",
    "media_types": {
      "clips": "Clipes",
      "recordings": "Gravações",
      "snapshots": "Instantâneos"
    },
    "not_favorite": "Não favorito",
    "select_camera": "Selecione a câmera...",
    "select_favorite": "Selecione favorito...",
    "select_media_type": "Selecione o tipo de mídia...",
    "select_tag": "Selecione a etiqueta...",
    "select_what": "Selecione o que...",
    "select_when": "Selecione quando...",
    "select_where": "Selecione onde...",
    "tag": "Etiqueta",
    "what": "O que",
    "when": "Quando",
    "whens": {
      "custom": "",
      "past_month": "Mês passado",
      "past_week": "Semana passada",
      "today": "Hoje",
      "yesterday": "Ontem"
    },
    "where": "Onde"
  },
  "media_viewer": {
    "unseekable": ""
  },
  "thumbnail": {
    "camera": "Câmera",
    "download": "Baixar mídia",
    "duration": "Duração",
    "events": "Eventos",
    "in_progress": "Em andamento",
    "no_thumbnail": "Nenhuma miniatura disponível",
    "retain_indefinitely": "Evento será retido por tempo indeterminado",
    "score": "Pontuação",
    "seek": "Procurar",
    "start": "Início",
    "tag": "Etiqueta",
    "timeline": "Ver evento na linha do tempo",
    "title": "",
    "what": "O que",
    "where": "Onde"
  },
  "timeline": {
    "select_date": "Escolha a data"
  }
}



================================================
FILE: src/localize/languages/pt-PT.json
================================================
{
  "actions": {
    "abort": "",
    "confirmation": ""
  },
  "common": {
    "advanced_camera_card": "",
    "advanced_camera_card_description": "",
    "folder": "",
    "live": "Ao Vivo",
    "no_folder": "",
    "no_media": "Sem média",
    "recordings": "Gravações",
    "version": "Versão"
  },
  "config": {
    "cameras": {
      "always_error_if_entity_unavailable": "",
      "camera_entity": "Entidade da Câmera",
      "capabilities": {
        "capabilities": {
          "clips": "",
          "favorite-events": "",
          "favorite-recordings": "",
          "live": "",
          "menu": "",
          "ptz": "",
          "recordings": "",
          "seek": "",
          "snapshots": "",
          "substream": ""
        },
        "disable": "",
        "disable_except": "",
        "editor_label": ""
      },
      "cast": {
        "dashboard": {
          "dashboard_path": "",
          "view_path": ""
        },
        "editor_label": "",
        "method": "",
        "methods": {
          "dashboard": "",
          "standard": ""
        }
      },
      "dependencies": {
        "all_cameras": "Mostrar eventos para todas as câmeras nesta câmera",
        "cameras": "Mostrar eventos para câmeras específicas nesta câmera",
        "editor_label": "Opções de dependência"
      },
      "dimensions": {
        "aspect_ratio": "",
        "editor_label": "",
        "layout": {
          "editor_label": "",
          "fit": "Fit",
          "fits": {
            "contain": "Conter",
            "cover": "Tapar",
            "fill": "Preencher"
          },
          "pan": {
            "x": "",
            "y": ""
          },
          "position": {
            "editor_label": "",
            "x": "Percentagem da localização horizontal",
            "y": "Percentagem da localização vertical"
          },
          "view_box": {
            "bottom": "",
            "editor_label": "",
            "left": "",
            "right": "",
            "top": ""
          },
          "zoom": ""
        }
      },
      "engines": {
        "editor_label": "Editor de etiquetas"
      },
      "frigate": {
        "camera_name": "Nome da câmera do Frigate (detectado automaticamente pela entidade)",
        "client_id": "ID do cliente do Frigate (para >1 servidor Frigate)",
        "editor_label": "Opções do Frigate",
        "labels": "Etiquetas",
        "url": "URL do servidor Frigate",
        "zones": "Zonas"
      },
      "go2rtc": {
        "editor_label": "Editor de etiquetas",
        "modes": {
          "editor_label": "Editor de etiquetas",
          "mjpeg": "Mjpeg",
          "mp4": "Mp4",
          "mse": "Mse",
          "webrtc": "Webrtc"
        },
        "stream": "Stream",
        "url": ""
      },
      "icon": "Ícone para esta câmera (detectado automaticamente pela entidade)",
      "id": "ID exclusivo para esta câmera nesse cartão",
      "image": {
        "editor_label": "Editor etiquetas",
        "refresh_seconds": "Atualizar em segundos",
        "url": "Link"
      },
      "live_provider": "Fonte de visualização ao vivo para esta câmera",
      "live_provider_options": {
        "editor_label": "Editor de etiquetas"
      },
      "live_providers": {
        "auto": "Automatico",
        "go2rtc": "Go2rtc",
        "ha": "Ha",
        "image": "Imagem",
        "jsmpeg": "JSMpeg",
        "webrtc-card": "Cartão WebRTC (de @AlexxIT)"
      },
      "motioneye": {
        "editor_label": "Directoria pre-definido",
        "images": {
          "directory_pattern": "Directoria pre-definido",
          "file_pattern": "Ficheiro pre-definido"
        },
        "movies": {
          "directory_pattern": "Directoria pre-definida",
          "file_pattern": "Ficheiro pre-definido"
        },
        "url": "Link"
      },
      "proxy": {
        "dynamic": "",
        "editor_label": "",
        "media": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        },
        "ssl_ciphers": {
          "auto": "",
          "default": "",
          "editor_label": "",
          "insecure": "",
          "intermediate": "",
          "modern": ""
        },
        "ssl_verification": {
          "auto": "",
          "editor_label": "",
          "false": "",
          "true": ""
        }
      },
      "reolink": {
        "editor_label": "",
        "media_resolution": {
          "editor_label": "",
          "high": "",
          "low": ""
        },
        "url": ""
      },
      "title": "Título para esta câmera (detectado automaticamente pela entidade)",
      "triggers": {
        "editor_label": "Opções de activação",
        "entities": "Activar a partir de outras entidades",
        "events": {
          "clips": "",
          "editor_label": "",
          "events": "",
          "snapshots": ""
        },
        "motion": "Activar detectando automaticamente o sensor de movimento",
        "occupancy": "Activar detectando automaticamente o sensor de ocupação"
      },
      "webrtc_card": {
        "editor_label": "Opções do cartão WebRTC",
        "entity": "Entidade de câmera de cartão WebRTC (não é uma câmera Frigate)",
        "url": "URL da câmera do cartão WebRTC"
      }
    },
    "common": {
      "controls": {
        "builtin": "",
        "filter": {
          "editor_label": "Editor de titulos",
          "mode": "Modo",
          "modes": {
            "left": "Esquerda",
            "none": "Nenhum",
            "right": "Direita"
          }
        },
        "next_previous": {
          "editor_label": "Editor de titulos",
          "size": "Tamanho de controle próximo e anterior",
          "style": "Estilo do controle próximo e anterior",
          "styles": {
            "chevrons": "Setas",
            "icons": "Ícones",
            "none": "Nenhum",
            "thumbnails": "Miniaturas"
          }
        },
        "thumbnails": {
          "editor_label": "Editor de titulos",
          "events_media_type": "Mostrar miniaturas de clipes ou snapshots",
          "events_media_types": {
            "clips": "Miniaturas de clipes",
            "snapshots": "Miniaturas de Snapshots"
          },
          "media_type": "",
          "media_types": {
            "events": "",
            "recordings": ""
          },
          "mode": "Modos",
          "modes": {
            "above": "Miniaturas acima da mídia",
            "below": "Miniaturas abaixo da mídia",
            "left": "Miniaturas em uma gaveta à esquerda",
            "none": "Sem miniaturas",
            "right": "Miniaturas em uma gaveta à direita"
          },
          "show_details": "Mostrar detalhes",
          "show_download_control": "Mostrar o botão de download",
          "show_favorite_control": "Mostrar o botão de favorito nas miniaturas",
          "show_timeline_control": "Mostrar a linha do tempo nas miniaturas",
          "size": "Tamanho das miniaturas em pixels"
        },
        "timeline": {
          "editor_label": "Controles de linha do tempo",
          "format": {
            "24h": "",
            "editor_label": ""
          },
          "mode": "Modo",
          "modes": {
            "above": "Por cima",
            "below": "Abaixo",
            "none": "Nenhum"
          },
          "pan_mode": "",
          "pan_modes": {
            "pan": "",
            "seek": "",
            "seek-in-camera": "",
            "seek-in-media": ""
          }
        }
      },
      "display": {
        "editor_label": "",
        "grid_columns": "",
        "grid_max_columns": "",
        "grid_selected_position": "",
        "grid_selected_positions": {
          "default": "",
          "first": "",
          "last": ""
        },
        "grid_selected_width_factor": "",
        "mode": ""
      },
      "image": {
        "entity": "",
        "entity_parameters": "",
        "mode": "Modo de visualização de imagem",
        "modes": {
          "camera": "Instantâneo da câmera do Home Assistant, da entidade de câmera",
          "entity": "",
          "screensaver": "",
          "url": "Imagem arbitrária especificada por URL"
        },
        "refresh_seconds": "Número de segundos após o qual atualizar (0 = nunca)",
        "url": "Imagem arbitrária especificada por URL"
      },
      "media_action_conditions": {
        "all": "Todas as oportunidades",
        "hidden": "Ao ocultar o navegador/aba",
        "microphone_mute": "",
        "microphone_unmute": "",
        "never": "Nunca",
        "selected": "Ao selecionar",
        "unselected": "Ao desselecionar",
        "visible": "Ao mostrar o navegador/aba"
      },
      "timeline": {
        "clustering_threshold": "A contagem de eventos nos quais eles são agrupados (0 = sem agrupamento)",
        "events_media_type": "A mídia que a linha do tempo exibe",
        "events_media_types": {
          "all": "Todos os tipos de mídia",
          "clips": "Clipes",
          "snapshots": "Instantâneos"
        },
        "show_recordings": "Mostrar gravações",
        "style": "",
        "styles": {
          "ribbon": "",
          "stack": ""
        },
        "window_seconds": "A duração padrão da visualização da linha do tempo em segundos"
      }
    },
    "dimensions": {
      "aspect_ratio": "Proporção padrão (e.g. '16:9')",
      "aspect_ratio_mode": "Modo de proporção",
      "aspect_ratio_modes": {
        "dynamic": "A proporção se ajusta à mídia",
        "static": "Proporção estática",
        "unconstrained": "Proporção irrestrita"
      },
      "height": ""
    },
    "folders": {
      "ha": {
        "editor_label": "",
        "path_info": "",
        "url": ""
      },
      "icon": "",
      "id": "",
      "title": "",
      "type": "",
      "types": {
        "ha": ""
      }
    },
    "live": {
      "auto_mute": "Silenciar câmeras ao vivo automaticamente",
      "auto_pause": "Parar câmeras ao vivo automaticamente",
      "auto_play": "Reproduzir câmeras ao vivo automaticamente",
      "auto_unmute": "Ativar automaticamente o som das câmeras ao vivo",
      "controls": {
        "editor_label": "Controles da visualização ao vivo",
        "ptz": {
          "editor_label": "",
          "hide_home": "",
          "hide_pan_tilt": "",
          "hide_zoom": "",
          "mode": "",
          "modes": {
            "off": "",
            "on": ""
          },
          "orientation": "",
          "orientations": {
            "horizontal": "",
            "vertical": ""
          },
          "position": "",
          "positions": {
            "bottom-left": "",
            "bottom-right": "",
            "top-left": "",
            "top-right": ""
          }
        }
      },
      "draggable": "A visualização ao vivo das câmeras pode ser arrastada/deslizada",
      "lazy_load": "As câmeras ao vivo são carregadas lentamente",
      "lazy_unload": "As câmeras ao vivo são descarregadas preguiçosamente",
      "microphone": {
        "always_connected": "",
        "disconnect_seconds": "",
        "editor_label": "",
        "enabled": "",
        "mute_after_microphone_mute_seconds": ""
      },
      "preload": "Pré-carregar a visualização ao vivo em segundo plano",
      "show_image_during_load": "Mostar imagem durante o carregamento",
      "transition_effect": "Efeito de transição de câmera ao vivo",
      "zoomable": ""
    },
    "media_viewer": {
      "auto_mute": "Silenciar mídia automaticamente",
      "auto_pause": "Parar mídia automaticamente",
      "auto_play": "Reproduzir mídia automaticamente",
      "auto_unmute": "Ativar mídia automaticamente",
      "controls": {
        "editor_label": "Controles do visualizador de mídia"
      },
      "draggable": "Visualizador de eventos pode ser arrastado/deslizado",
      "lazy_load": "A mídia do Visualizador de eventos é carregada lentamente no carrossel",
      "snapshot_click_plays_clip": "",
      "transition_effect": "Efeito de transição do Visualizador de eventos",
      "transition_effects": {
        "none": "Sem transição",
        "slide": "Transição de slides"
      },
      "zoomable": ""
    },
    "menu": {
      "alignment": "Alinhamento do menu",
      "alignments": {
        "bottom": "Alinhado à parte inferior",
        "left": "Alinhado à esquerda",
        "right": "Alinhado à direita",
        "top": "Alinhado ao topo"
      },
      "button_size": "Tamanho do botão de menu (e.g. '40px')",
      "buttons": {
        "alignment": "Alinhamento do botão",
        "alignments": {
          "matching": "Mesmo alinhamento do menu",
          "opposing": "Opor-se ao alinhamento do menu"
        },
        "camera_ui": "Camera",
        "cameras": "Selecionar câmera",
        "clips": "Clipes",
        "display_mode": "",
        "download": "Descarregar mídia do evento",
        "enabled": "Botão ativado",
        "expand": "Expandir",
        "folders": "",
        "fullscreen": "Tela cheia",
        "icon": "Ícone",
        "image": "Imagem",
        "iris": "",
        "live": "Ao vivo",
        "media_player": "Enviar para o reprodutor de mídia",
        "microphone": "",
        "mute": "",
        "permanent": "",
        "play": "",
        "priority": "Prioridade",
        "ptz_controls": "",
        "ptz_home": "",
        "recordings": "",
        "screenshot": "",
        "snapshots": "Instantâneos",
        "substreams": "substreams",
        "timeline": "Linha do tempo",
        "type": "",
        "types": {
          "momentary": "",
          "toggle": ""
        }
      },
      "position": "Posição do menu",
      "positions": {
        "bottom": "Posicionado na parte inferior",
        "left": "Posicionado à esquerda",
        "right": "Posicionado à direita",
        "top": "Posicionado no topo"
      },
      "style": "Estilo do menu",
      "styles": {
        "hidden": "Menu oculto",
        "hover": "Menu suspenso",
        "hover-card": "",
        "none": "Sem menu",
        "outside": "Menu externo",
        "overlay": "Menu sobreposto"
      }
    },
    "overrides": {
      "info": "Esta configuração do cartão especificou manualmente as substituições configuradas que podem substituir os valores mostrados no editor visual, consulte o editor de código para visualizar/modificar essas substituições"
    },
    "performance": {
      "features": {
        "animated_progress_indicator": "Animação na barra de progresso",
        "card_loading_indicator": "",
        "editor_label": "Editor de etiquetas",
        "max_simultaneous_engine_requests": "",
        "media_chunk_size": "Tamanho do ficheiro"
      },
      "style": {
        "border_radius": "Tamanho do bordo",
        "box_shadow": "Caixa de Fundo",
        "editor_label": "Editor de etiquetas"
      },
      "warning": "Avisos"
    },
    "profiles": {
      "casting": "",
      "editor_label": "",
      "low-performance": "",
      "scrubbing": ""
    },
    "remote_control": {
      "entities": {
        "camera": "",
        "editor_label": ""
      }
    },
    "status_bar": {
      "height": "",
      "items": {
        "enabled": "",
        "engine": "",
        "live_provider": "",
        "priority": "",
        "resolution": "",
        "technology": "",
        "title": ""
      },
      "popup_seconds": "",
      "position": "",
      "positions": {
        "bottom": "",
        "top": ""
      },
      "style": "",
      "styles": {
        "hover": "",
        "hover-card": "",
        "none": "",
        "outside": "",
        "overlay": "",
        "popup": ""
      }
    },
    "view": {
      "camera_select": "Visualização de câmeras recém-selecionadas",
      "default": "Visualização padrão",
      "default_cycle_camera": "Percorrer as câmeras quando a visualização padrão for atualizada",
      "default_reset": {
        "after_interaction": "",
        "editor_label": "",
        "entities": "",
        "every_seconds": "Atualize a visualização padrão a cada X segundos (0 = nunca)",
        "interaction_mode": "",
        "interaction_modes": {
          "active": "",
          "all": "",
          "inactive": ""
        }
      },
      "dim": "",
      "interaction_seconds": "",
      "keyboard_shortcuts": {
        "editor_label": "",
        "enabled": "",
        "ptz_down": "",
        "ptz_home": "",
        "ptz_left": "",
        "ptz_right": "",
        "ptz_up": "",
        "ptz_zoom_in": "",
        "ptz_zoom_out": ""
      },
      "theme": {
        "themes": {
          "dark": "",
          "editor_label": "",
          "ha": "",
          "light": "",
          "traditional": ""
        }
      },
      "triggers": {
        "actions": {
          "editor_label": "",
          "interaction_mode": "",
          "interaction_modes": {
            "active": "",
            "all": "",
            "inactive": ""
          },
          "trigger": "",
          "triggers": {
            "default": "",
            "live": "",
            "media": "",
            "none": ""
          },
          "untrigger": "",
          "untriggers": {
            "default": "",
            "none": ""
          }
        },
        "editor_label": "",
        "filter_selected_camera": "",
        "show_trigger_status": "Exibir estado do gatilho",
        "untrigger_seconds": "Segundos após a mudar para o estado inativo para desacionar"
      },
      "views": {
        "clip": "Clipe mais recente",
        "clips": "Galeria de clipes",
        "current": "Visualização atual",
        "folder": "",
        "folders": "",
        "image": "Imagem estática",
        "live": "Visualização ao vivo",
        "recording": "",
        "recordings": "",
        "snapshot": "Snapshot mais recente",
        "snapshots": "Galeria de Snapshots",
        "timeline": "Visualização da linha do tempo"
      }
    }
  },
  "display_modes": {
    "grid": "",
    "single": ""
  },
  "editor": {
    "add_new_camera": "Adicionar nova câmera",
    "add_new_folder": "",
    "button": "Botão",
    "camera": "Câmera",
    "cameras": "Câmeras",
    "cameras_secondary": "Câmeras para renderizar neste cartão",
    "delete": "Excluir",
    "dimensions": "",
    "dimensions_secondary": "",
    "folders": "",
    "folders_secondary": "",
    "image": "Imagem",
    "image_secondary": "Opções de visualização de imagem estática",
    "live": "Ao vivo",
    "live_secondary": "Opções de visualização da câmera ao vivo",
    "media_gallery": "Galeria",
    "media_gallery_secondary": "Galeria Secundaria",
    "media_viewer": "Visualizador de eventos",
    "media_viewer_secondary": "Opções do visualizador de Snapshots e clipes",
    "menu": "Menu",
    "menu_secondary": "Opções de aparência do menu",
    "move_down": "Descer",
    "move_up": "Subir",
    "overrides": "As substituições estão ativas",
    "overrides_secondary": "Substituições de configuração dinâmica detectadas",
    "performance": "",
    "performance_secondary": "",
    "profiles": "",
    "profiles_secondary": "",
    "remote_control": "",
    "remote_control_secondary": "",
    "status_bar": "",
    "status_bar_secondary": "",
    "timeline": "Linha do tempo",
    "timeline_secondary": "Opções do evento da linha do tempo",
    "upgrade": "Actualização",
    "upgrade_available": "Está disponível uma atualização automática do cartão",
    "view": "Visualizar",
    "view_secondary": "O que deve ser mostrado neste cartão"
  },
  "elements": {
    "ptz": {
      "down": "Baixo",
      "home": "Origem",
      "left": "Esquerda",
      "presets": "",
      "right": "Direira",
      "up": "Cima",
      "zoom_in": "Ampliar",
      "zoom_out": "Reduzir"
    }
  },
  "error": {
    "awaiting_folder": "",
    "awaiting_live": "",
    "awaiting_media": "",
    "camera_initialization": "",
    "camera_initialization_reolink": "",
    "configuration": "",
    "could_not_render_elements": "Não foi possível renderizar os elementos da imagem",
    "could_not_resolve": "Não foi possível resolver o URL de mídia",
    "diagnostics": "Diagnósticos do cartão. Reveja as informações confidenciais antes de partilhar",
    "download_no_media": "Nenhuma mídia para download",
    "download_sign_failed": "Não foi possível assinar o URL de mídia para download",
    "duplicate_camera_id": "Duplique o ID da câmera Frigate para a câmera a seguir, use o parâmetro 'id' para identificar exclusivamente as câmeras",
    "duplicate_folder_id": "",
    "empty_response": "Sem resposta do Home Assistant para a solicitação",
    "failed_response": "Falha ao receber resposta do Home Assistant para solicitação",
    "failed_retain": "Não foi possível reter o evento",
    "failed_sign": "Não foi possível assinar a URL do Home Assistant",
    "fetching_diagnostics": "",
    "image_load_error": "A imagem não pôde ser carregada",
    "invalid_configuration": "Configuração inválida",
    "invalid_configuration_no_hint": "Nenhuma dica de local disponível (tipo incorreto ou ausente?)",
    "invalid_configuration_override": "",
    "invalid_elements_config": "Configuração de elementos de imagem inválida",
    "invalid_response": "Resposta inválida recebida do Home Assistant para a solicitação",
    "jsmpeg_no_player": "Não foi possível iniciar o player JSMPEG",
    "live_camera_no_endpoint": "Nenhuma câmera ao vivo",
    "live_camera_not_found": "Nenhuma câmera ao vivo não foi encontrada",
    "live_camera_unavailable": "Câmera ao vivo indisponivel",
    "no_camera_engine": "Não existe câmera",
    "no_camera_entity": "Não existe uma entidade câmera",
    "no_camera_entity_for_triggers": "Não existe camera para a acção",
    "no_camera_id": "Não foi possível determinar o ID da câmera para a câmera a seguir, pode ser necessário definir o parâmetro 'id' manualmente",
    "no_dashboard_or_view": "",
    "no_live_camera": "O parâmetro camera_entity deve ser definido e válido para este serviço ativo",
    "no_supported_camera": "",
    "no_supported_cameras": "",
    "reconnecting": "A voltar a ligar",
    "stream_not_loading": "",
    "too_many_automations": "",
    "troubleshooting": "Verifique a solução de problemas",
    "unknown": "Erro desconhecido",
    "upgrade_available": "Uma atualização automatizada da configuração do cartão está disponível, visite o editor visual do cartão",
    "webrtc_card_reported_error": "O cartão WebRTC relatou um erro",
    "webrtc_card_waiting": "Aguardar o cartão WebRTC carregar ..."
  },
  "key_assigner": {
    "assign": "",
    "modifiers": {
      "alt": "",
      "ctrl": "",
      "meta": "",
      "shift": ""
    },
    "unassign": ""
  },
  "media_filter": {
    "all": "Todos",
    "camera": "Camera",
    "favorite": "Favoritos",
    "media_type": "Tipos de media",
    "media_types": {
      "clips": "Clips",
      "recordings": "Gravações",
      "snapshots": "Imagens"
    },
    "not_favorite": "Não favorito",
    "select_camera": "Seleciona a camara",
    "select_favorite": "Seleciona o favorito",
    "select_media_type": "Seleciona o tipo de media",
    "select_tag": "",
    "select_what": "Seleciona",
    "select_when": "Seleciona quando",
    "select_where": "Seleciona onde",
    "tag": "",
    "what": "O que",
    "when": "Quando",
    "whens": {
      "custom": "",
      "past_month": "O mes passado",
      "past_week": "A semana passada",
      "today": "Hoje",
      "yesterday": "Ontem"
    },
    "where": "Onde"
  },
  "media_viewer": {
    "unseekable": ""
  },
  "thumbnail": {
    "camera": "Camera",
    "download": "",
    "duration": "Duração",
    "events": "Eventos",
    "in_progress": "Em andamento",
    "no_thumbnail": "Nenhuma miniatura disponível",
    "retain_indefinitely": "Evento será retido por tempo indeterminado",
    "score": "Pontuação",
    "seek": "Procurar",
    "start": "Início",
    "tag": "",
    "timeline": "Ver evento na linha do tempo",
    "title": "",
    "what": "O quê",
    "where": "Onde"
  },
  "timeline": {
    "select_date": "Selecionar a data"
  }
}



================================================
FILE: src/patches/ha-camera-stream.ts
================================================
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

// ====================================================================
// ** Keep modifications to this file to a minimum **
//
// Type checking is disabled since this is a modified copy-and-paste of
// underlying render() function, but the rest of the class source it not
// available as compilation time.
// ====================================================================

import { css, CSSResultGroup, html, nothing, PropertyValues, unsafeCSS } from 'lit';
import { customElement } from 'lit/decorators.js';
import { query } from 'lit/decorators/query.js';
import '../components/image-player.js';
import liveHAComponentsStyle from '../scss/live-ha-components.scss';
import { MediaLoadedInfo, MediaPlayer, MediaPlayerController } from '../types.js';
import { dispatchExistingMediaLoadedInfoAsEvent } from '../utils/media-info.js';
import './ha-hls-player.js';
import './ha-web-rtc-player.js';

customElements.whenDefined('ha-camera-stream').then(() => {
  // ========================================================================================
  // From:
  // - https://github.com/home-assistant/frontend/blob/dev/src/data/camera.ts
  // - https://github.com/home-assistant/frontend/blob/dev/src/common/entity/compute_state_name.ts
  // - https://github.com/home-assistant/frontend/blob/dev/src/common/entity/compute_object_id.ts
  // ========================================================================================
  const computeMJPEGStreamUrl = (entity: CameraEntity): string =>
    `/api/camera_proxy_stream/${entity.entity_id}?token=${entity.attributes.access_token}`;

  const STREAM_TYPE_HLS = 'hls';
  const STREAM_TYPE_WEB_RTC = 'web_rtc';
  const STREAM_TYPE_MJPEG = 'mjpeg';
  type StreamType = STREAM_TYPE_HLS | STREAM_TYPE_WEB_RTC | STREAM_TYPE_MJPEG;

  @customElement('advanced-camera-card-ha-camera-stream')
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  class AdvancedCameraCardHaCameraStream
    extends customElements.get('ha-camera-stream')
    implements MediaPlayer
  {
    // Due to an obscure behavior when this card is casted, this element needs
    // to use query rather than the ref directive to find the player.
    @query('.player:not(.hidden)')
    protected _player: MediaPlayer;

    protected _mediaLoadedInfoPerStream: Record<StreamType, MediaLoadedInfo> = {};
    protected _mediaLoadedInfoDispatched: MediaLoadedInfo | null = null;

    // ========================================================================================
    // Minor modifications from:
    // - https://github.com/home-assistant/frontend/blob/dev/src/components/ha-camera-stream.ts
    // ========================================================================================

    public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
      await this.updateComplete;
      return (await this._player?.getMediaPlayerController()) ?? null;
    }

    protected _storeMediaLoadedInfoHandler(
      stream: StreamType,
      ev: CustomEvent<MediaLoadedInfo>,
    ) {
      this._storeMediaLoadedInfo(stream, ev.detail);
      ev.stopPropagation();
    }

    protected _storeMediaLoadedInfo(
      stream: StreamType,
      mediaLoadedInfo: MediaLoadedInfo,
    ) {
      this._mediaLoadedInfoPerStream[stream] = mediaLoadedInfo;
      this.requestUpdate();
    }

    protected _renderStream(stream: Stream) {
      if (!this.stateObj) {
        return nothing;
      }
      if (stream.type === STREAM_TYPE_MJPEG) {
        return html`
          <advanced-camera-card-image-player
            @advanced-camera-card:media:loaded=${(ev: CustomEvent<MediaLoadedInfo>) => {
              this._storeMediaLoadedInfo(STREAM_TYPE_MJPEG, ev.detail);
              ev.stopPropagation();
            }}
            src=${typeof this._connected == 'undefined' || this._connected
              ? computeMJPEGStreamUrl(this.stateObj)
              : this._posterUrl || ''}
            technology="mjpeg"
            class="player"
          ></advanced-camera-card-image-player>
        `;
      }

      if (stream.type === STREAM_TYPE_HLS) {
        return html` <advanced-camera-card-ha-hls-player
          ?autoplay=${false}
          playsinline
          .allowExoPlayer=${this.allowExoPlayer}
          .muted=${this.muted}
          .controls=${this.controls}
          .hass=${this.hass}
          .entityid=${this.stateObj.entity_id}
          .posterUrl=${this._posterUrl}
          @advanced-camera-card:media:loaded=${(ev: CustomEvent<MediaLoadedInfo>) => {
            this._storeMediaLoadedInfoHandler(STREAM_TYPE_HLS, ev);
            ev.stopPropagation();
          }}
          @streams=${this._handleHlsStreams}
          class="player ${stream.visible ? '' : 'hidden'}"
        ></advanced-camera-card-ha-hls-player>`;
      }

      if (stream.type === STREAM_TYPE_WEB_RTC) {
        return html`<advanced-camera-card-ha-web-rtc-player
          ?autoplay=${false}
          playsinline
          .muted=${this.muted}
          .controls=${this.controls}
          .hass=${this.hass}
          .entityid=${this.stateObj.entity_id}
          .posterUrl=${this._posterUrl}
          @advanced-camera-card:media:loaded=${(ev: CustomEvent<MediaLoadedInfo>) => {
            this._storeMediaLoadedInfoHandler(STREAM_TYPE_WEB_RTC, ev);
            ev.stopPropagation();
          }}
          @streams=${this._handleWebRtcStreams}
          class="player ${stream.visible ? '' : 'hidden'}"
        ></advanced-camera-card-ha-web-rtc-player>`;
      }

      return nothing;
    }

    public updated(changedProps: PropertyValues): void {
      super.updated(changedProps);

      const streams = this._streams(
        this._capabilities?.frontend_stream_types,
        this._hlsStreams,
        this._webRtcStreams,
      );

      const visibleStream = streams.find((stream) => stream.visible) ?? null;
      if (visibleStream) {
        const mediaLoadedInfo = this._mediaLoadedInfoPerStream[visibleStream.type];
        if (mediaLoadedInfo && mediaLoadedInfo !== this._mediaLoadedInfoDispatched) {
          this._mediaLoadedInfoDispatched = mediaLoadedInfo;
          dispatchExistingMediaLoadedInfoAsEvent(this, mediaLoadedInfo);
        }
      }
    }

    static get styles(): CSSResultGroup {
      return [
        super.styles,
        unsafeCSS(liveHAComponentsStyle),
        css`
          :host {
            width: 100%;
            height: 100%;
          }
          img {
            width: 100%;
            height: 100%;
          }
        `,
      ];
    }
  }
});

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-ha-camera-stream': AdvancedCameraCardHaCameraStream;
  }
}



================================================
FILE: src/patches/ha-hls-player.ts
================================================
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

// ====================================================================
// ** Keep modifications to this file to a minimum **
//
// Type checking is disabled since this is a modified copy-and-paste of
// underlying render() function, but the rest of the class source is not
// available as compilation time.
// ====================================================================

import { css, CSSResultGroup, html, TemplateResult, unsafeCSS } from 'lit';
import { customElement } from 'lit/decorators.js';
import { query } from 'lit/decorators/query.js';
import { dispatchLiveErrorEvent } from '../components-lib/live/utils/dispatch-live-error.js';
import { VideoMediaPlayerController } from '../components-lib/media-player/video.js';
import { renderMessage } from '../components/message.js';
import liveHAComponentsStyle from '../scss/live-ha-components.scss';
import { MediaPlayer, MediaPlayerController } from '../types.js';
import { mayHaveAudio } from '../utils/audio.js';
import { errorToConsole } from '../utils/basic.js';
import {
  hideMediaControlsTemporarily,
  MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
} from '../utils/controls.js';
import {
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
  dispatchMediaVolumeChangeEvent,
} from '../utils/media-info.js';
import { ConstructableLitElement } from './types.js';

customElements.whenDefined('ha-hls-player').then(() => {
  const HaHlsPlayer = customElements.get('ha-hls-player') as ConstructableLitElement;

  @customElement('advanced-camera-card-ha-hls-player')
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  class AdvancedCameraCardHaHlsPlayer extends HaHlsPlayer implements MediaPlayer {
    // Due to an obscure behavior when this card is casted, this element needs
    // to use query rather than the ref directive to find the player.
    @query('#video')
    protected _video: HTMLVideoElement;

    protected _mediaPlayerController = new VideoMediaPlayerController(
      this,
      () => this._video,
      () => this.controls,
    );

    public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
      return this._mediaPlayerController;
    }

    // =====================================================================================
    // Minor modifications from:
    // - https://github.com/home-assistant/frontend/blob/dev/src/components/ha-hls-player.ts
    // =====================================================================================
    protected render(): TemplateResult {
      if (this._error) {
        if (this._errorIsFatal) {
          dispatchLiveErrorEvent(this);
          return renderMessage({
            type: 'error',
            message: this._error,
            context: {
              entity_id: this.entityid,
            },
          });
        } else {
          errorToConsole(this._error, console.error);
        }
      }
      return html`
        <video
          id="video"
          .poster=${this.posterUrl}
          ?autoplay=${this.autoPlay}
          .muted=${this.muted}
          ?playsinline=${this.playsInline}
          ?controls=${this.controls}
          @loadedmetadata=${() => {
            if (this.controls) {
              hideMediaControlsTemporarily(
                this._video,
                MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
              );
            }
          }}
          @loadeddata=${(ev) => this._loadedDataHandler(ev)}
          @volumechange=${() => dispatchMediaVolumeChangeEvent(this)}
          @play=${() => dispatchMediaPlayEvent(this)}
          @pause=${() => dispatchMediaPauseEvent(this)}
        ></video>
      `;
    }

    private _loadedDataHandler(ev: Event) {
      super._loadedData();
      dispatchMediaLoadedEvent(this, ev, {
        mediaPlayerController: this._mediaPlayerController,
        capabilities: {
          supportsPause: true,
          hasAudio: mayHaveAudio(this._video),
        },
        technology: ['hls'],
      });
    }

    static get styles(): CSSResultGroup {
      return [
        super.styles,
        unsafeCSS(liveHAComponentsStyle),
        css`
          :host {
            width: 100%;
            height: 100%;
          }
          video {
            width: 100%;
            height: 100%;
          }
        `,
      ];
    }
  }
});

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-ha-hls-player': AdvancedCameraCardHaHlsPlayer;
  }
}



================================================
FILE: src/patches/ha-web-rtc-player.ts
================================================
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

// ====================================================================
// ** Keep modifications to this file to a minimum **
//
// Type checking is disabled since this is a modified copy-and-paste of
// underlying render() function, but the rest of the class source it not
// available as compilation time.
// ====================================================================

import { css, CSSResultGroup, html, TemplateResult, unsafeCSS } from 'lit';
import { customElement } from 'lit/decorators.js';
import { query } from 'lit/decorators/query.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { dispatchLiveErrorEvent } from '../components-lib/live/utils/dispatch-live-error.js';
import { VideoMediaPlayerController } from '../components-lib/media-player/video.js';
import { renderMessage } from '../components/message.js';
import liveHAComponentsStyle from '../scss/live-ha-components.scss';
import { MediaPlayer, MediaPlayerController } from '../types.js';
import { mayHaveAudio } from '../utils/audio.js';
import {
  hideMediaControlsTemporarily,
  MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
} from '../utils/controls.js';
import {
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
  dispatchMediaVolumeChangeEvent,
} from '../utils/media-info.js';
import { ConstructableLitElement } from './types.js';

customElements.whenDefined('ha-web-rtc-player').then(() => {
  const HaWebRtcPlayer = customElements.get(
    'ha-web-rtc-player',
  ) as ConstructableLitElement;

  @customElement('advanced-camera-card-ha-web-rtc-player')
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  class AdvancedCameraCardHaWebRtcPlayer extends HaWebRtcPlayer implements MediaPlayer {
    // Due to an obscure behavior when this card is casted, this element needs
    // to use query rather than the ref directive to find the player.
    @query('#remote-stream')
    protected _video: HTMLVideoElement;

    protected _mediaPlayerController = new VideoMediaPlayerController(
      this,
      () => this._video,
      () => this.controls,
    );

    public async getMediaPlayerController(): Promise<MediaPlayerController | null> {
      return this._mediaPlayerController;
    }

    private async _startWebRtc(): Promise<void> {
      // There is a race condition in the underlying HA frontend code between
      // the element connection and the async start of the WebRTC session. If
      // the element is rapidly connected and disconnected, the RTC connection
      // may be left permanently "dangling" causing leaks. To reproduce (without
      // this workaround), watch the number of open connections on the go2rtc
      // UI, then edit and rapidly save a dashboard with this card -- the number
      // of open connections will not return to 1.
      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1992
      await super._startWebRtc();

      // Workaround: After attempting to start a WebRTC session, check if the
      // element is connected and if not then clean up correctly.
      if (!this.isConnected) {
        this._cleanUp();
      }
    }

    // =====================================================================================
    // Minor modifications from:
    // - https://github.com/home-assistant/frontend/blob/dev/src/components/ha-web-rtc-player.ts
    // =====================================================================================
    protected render(): TemplateResult | void {
      if (this._error) {
        dispatchLiveErrorEvent(this);
        return renderMessage({
          type: 'error',
          message: this._error,
          context: {
            entity_id: this.entityid,
          },
        });
      }
      return html`
        <video
          id="remote-stream"
          ?autoplay=${this.autoPlay}
          .muted=${this.muted}
          ?playsinline=${this.playsInline}
          ?controls=${this.controls}
          poster=${ifDefined(this.posterUrl)}
          @loadedmetadata=${() => {
            if (this.controls) {
              hideMediaControlsTemporarily(
                this._video,
                MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
              );
            }
          }}
          @loadeddata=${(ev) => this._loadedDataHandler(ev)}
          @volumechange=${() => dispatchMediaVolumeChangeEvent(this)}
          @play=${() => dispatchMediaPlayEvent(this)}
          @pause=${() => dispatchMediaPauseEvent(this)}
        ></video>
      `;
    }

    private _loadedDataHandler(ev: Event) {
      super._loadedData();
      dispatchMediaLoadedEvent(this, ev, {
        mediaPlayerController: this._mediaPlayerController,
        capabilities: {
          supportsPause: true,
          hasAudio: mayHaveAudio(this._video),
        },
        technology: ['webrtc'],
      });
    }

    static get styles(): CSSResultGroup {
      return [
        super.styles,
        unsafeCSS(liveHAComponentsStyle),
        css`
          :host {
            width: 100%;
            height: 100%;
          }
          video {
            width: 100%;
            height: 100%;
          }
        `,
      ];
    }
  }
});

declare global {
  interface HTMLElementTagNameMap {
    'advanced-camera-card-ha-web-rtc-player': AdvancedCameraCardHaWebRtcPlayer;
  }
}



================================================
FILE: src/patches/types.ts
================================================
import { LitElement } from 'lit';

export type ConstructableLitElement = { new (...args: unknown[]): LitElement };



================================================
FILE: src/scoped-elements/gr-select.js
================================================
import { GrSelect } from '@graphiteds/core/components/gr-select';
import { GrMenuItem } from '@graphiteds/core/components/gr-menu-item';

// It was difficult to find a multi-select web component that matches these criteria:
// - Is a dropdown vs multi-select list.
// - Open source.
// - Supports being in a ScopedRegistry out of the box (i.e. does not auto-register with customElements).
// - Looks attractive / compatible with mostly Material elements.
// - Styleable
// - Does not bloat output size considerably.

// Web components evaluated (https://open-wc.org/guides/community/component-libraries/):
// - Material: No multiselect component.
// - Freshwords/@crayon: Considerable bloat in output due to i18n translations
//   that are used by _other_ components.
// - Carbon Design System: Workable, but less moderm / Material-like.
// - UI5: Auto-registers globally.
// - Vaadin: Auto-registers globally.
// - Liquid: Not open source.
// - [Many others]: No multiselect component.

export const grSelectElements = {
  'gr-select': GrSelect,
  'gr-menu-item': GrMenuItem,
};



================================================
FILE: src/scss/basic-block.scss
================================================
:host {
  width: 100%;
  height: 100%;
  display: block;
}



================================================
FILE: src/scss/button.scss
================================================
ha-icon-button {
  color: var(--advanced-camera-card-button-color);
  background-color: var(--advanced-camera-card-button-background);

  border-radius: 50%;
  padding: 0px;
  margin: 3px;
  --ha-icon-display: block;

  /* Buttons can always be clicked */
  pointer-events: auto;
}



================================================
FILE: src/scss/card.scss
================================================
@use './themes/base.scss';
@import './z-index.scss';

:host {
  display: block;

  // Anchor absolutes to the outermost part of the card.
  position: relative;

  // Different browsers use different colors as their fullscreen background,
  // this ensures the same experience across all browsers.
  background-color: var(--card-background-color);

  border-radius: var(--ha-card-border-radius, 4px);
  overflow: auto;

  height: var(--advanced-camera-card-height);
  min-height: 100px;

  // Ensure all clicks at the top level work.
  pointer-events: all;

  // The standard HA header is 56 pixels tall, so that much off the top (header)
  // and bottom (to maintain center), before doing the calculation of
  // max-height. This matters on small mobile devices in landscape orientation.
  --advanced-camera-card-expand-max-height: calc((100vh - (2 * 56px)) * 0.85);
  --advanced-camera-card-expand-max-width: 85vw;
  --advanced-camera-card-expand-width: none;
  --advanced-camera-card-expand-height: none;
  --advanced-camera-card-expand-aspect-ratio: unset;

  --advanced-camera-card-height: auto;
}

// Without hovering over the card, it is "flattened" to avoid z-index weaving
// from other cards. Tip: Best way to test this is with multiple Advanced Camera
// Cards, opening a submenu on the 1st (e.g. media players) and verifying the
// menu of the 2nd card is not visible through the opened submenu on the 1st.
:host(:not(:hover)) {
  z-index: #{$z-index-card-flatten};
}

advanced-camera-card-loading {
  position: absolute;
  inset: 0;
  z-index: #{$z-index-loading};
}

:host([dimmable]:not([interaction])) {
  filter: brightness(75%);
}
:host([panel]:not([casted])) {
  // Card always extends to the full height in panel mode minus the header.
  //
  // If the "Kiosk Mode" (https://github.com/maykar/kiosk-mode) plugin is
  // installed, the --kiosk-header-height variable will be authoritative
  // instead.
  // See: https://github.com/dermotduffy/advanced-camera-card/issues/1762
  height: calc(100vh - var(--kiosk-header-height, var(--header-height)));
}
:host([panel][casted]) {
  // Card always extends to the full height in panel mode when casting (there is
  // no header).
  // See: https://github.com/dermotduffy/advanced-camera-card/issues/1746
  height: 100%;
}

div.main {
  position: relative;

  overflow: auto;

  width: 100%;
  height: 100%;
  margin: auto;
  display: block;

  // Hide scrollbar: Firefox
  scrollbar-width: none;
  // Hide scrollbar: IE and Edge
  -ms-overflow-style: none;
}

/* Hide scrollbar for Chrome, Safari and Opera */
div.main::-webkit-scrollbar {
  display: none;
}

ha-card {
  display: flex;
  flex-direction: column;
  margin: auto;

  border: 0px;

  // Some elements (such as submenus) may need to extend beyond the card boundary.
  overflow: visible;
  width: 100%;
  height: 100%;
  position: static;
  color: var(--secondary-text-color, white);
}

/************
 * Fullscreen
 *************/

// Browsers will reject invalid whole CSS selectors if one selector is bad, so
// need to use mixin here instead of just comma-separated selectors.
//  - Related: https://stackoverflow.com/questions/16982449/why-isnt-it-possible-to-combine-vendor-specific-pseudo-elements-classes-into-on
@mixin fullscreen-ha-card {
  // Hide corners on Safari fullscreen.
  border-radius: 0px;

  // Theme styles may set these which are not helpful in fullscreen mode, reset
  // them.
  box-shadow: none;
  margin: 0;
}

// Need to use an id selector here to overcome theme styling that may
// incorrectly apply to ha-card style.
:host(:fullscreen) #ha-card {
  @include fullscreen-ha-card;
}
:host(:-webkit-full-screen) #ha-card {
  @include fullscreen-ha-card;
}

@mixin fullscreen-no-rounded-corners {
  // Hide corners on Safari fullscreen.
  border-radius: 0px;
}

:host(:fullscreen) div.main,
:host(:fullscreen) advanced-camera-card-menu {
  @include fullscreen-no-rounded-corners;
}
:host(:-webkit-full-screen) div.main,
:host(:-webkit-full-screen) advanced-camera-card-menu {
  @include fullscreen-no-rounded-corners;
}

/***************
 * Expanded mode
 ***************/

web-dialog {
  --dialog-padding: 0px;
  --dialog-container-padding: 0px;

  --dialog-max-height: var(--advanced-camera-card-expand-max-height);
  --dialog-max-width: var(--advanced-camera-card-expand-max-width);

  --dialog-width: var(--advanced-camera-card-expand-width);
  --dialog-height: var(--advanced-camera-card-expand-height);

  // Allow submenus to flow outside the edge of the dialog.
  --dialog-overflow-x: visible;
  --dialog-overflow-y: visible;

  // Required to ensure the dialog is centered vertically.
  max-height: 100vh;
}

web-dialog::part(dialog) {
  aspect-ratio: var(--advanced-camera-card-expand-aspect-ratio);

  // Fixes to render the dialog correctly in Safari.
  border-radius: 0px;
  background: transparent;
}

/*******************
 * Menu hover styles
 *******************/

advanced-camera-card-menu {
  z-index: #{$z-index-menu};
}

advanced-camera-card-menu[data-style*='hover'] {
  transition: opacity 0.5s ease;
  opacity: 0;
}
advanced-camera-card-menu[data-style*='hover']:hover,
ha-card:hover
  > advanced-camera-card-overlay
  > advanced-camera-card-menu[data-style='hover-card'] {
  opacity: 1;
}

/*************************
 * Status bar hover styles
 *************************/

advanced-camera-card-status-bar {
  z-index: #{$z-index-status-bar};
}

advanced-camera-card-status-bar[data-style*='hover'] {
  transition: opacity 0.5s ease;
  opacity: 0;
}
advanced-camera-card-status-bar[data-style*='hover']:hover,
ha-card:hover
  > advanced-camera-card-overlay
  > advanced-camera-card-status-bar[data-style='hover-card'] {
  opacity: 1;
}



================================================
FILE: src/scss/carousel.scss
================================================
:host {
  display: block;
  height: 100%;
  width: 100%;
}

.embla {
  width: 100%;
  height: 100%;
  margin-left: auto;
  margin-right: auto;
}

.embla__container {
  display: flex;
  width: 100%;
  height: 100%;

  user-select: none;
  -webkit-touch-callout: none;
  -khtml-user-select: none;
  -webkit-tap-highlight-color: transparent;
}
:host([direction='vertical']) .embla__container {
  flex-direction: column;
}
:host([direction='horizontal']) .embla__container {
  flex-direction: row;
}

.embla__viewport {
  width: 100%;
  height: 100%;
  overflow: hidden;

  // Center vertically in the viewport.
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.embla__viewport.is-draggable {
  cursor: move;
  cursor: grab;
}
.embla__viewport.is-dragging {
  cursor: grabbing;
}

:host([direction='vertical']) ::slotted(.embla__slide) {
  margin-bottom: 5px;
}

:host([direction='horizontal']) ::slotted(.embla__slide) {
  margin-right: 5px;
}



================================================
FILE: src/scss/const.scss
================================================
:host {
  --advanced-camera-card-thumbnail-size-max: 300px;
  --advanced-camera-card-thumbnail-details-width: calc(
    var(--advanced-camera-card-thumbnail-size) + 200px
  );
}



================================================
FILE: src/scss/date-picker.scss
================================================
:host {
  display: inline-block;
  position: relative;
  width: var(--mdc-icon-size, 24px);
  height: var(--mdc-icon-size, 24px);
}

input {
  display: block;
  height: 100%;
  width: 100%;
  position: absolute;

  padding: 0px;
  border: 0px;
}

/**
 * Hack warning: Safari on iOS does not support showPicker with
 * datetime-local:
 * https://caniuse.com/mdn-api_htmlinputelement_showpicker_datetime_local_input
 *
 * The hack is to render the input element in front of the icon, with an
 * opacity of 0. This only works if the underlying input element accepts the
 * click at the exact place the user happens to click. From trial and error,
 * this seems to work better than expected / quite reliably, but had the user
 * manually changed icon sizes with Safari iOS their experience may vary.
 */

// webkit-touch-callout used to "detect" Safari on iOS. See:
//  - https://stackoverflow.com/questions/30102792/css-media-query-to-target-only-ios-devices
@supports (-webkit-touch-callout: none) {
  input {
    // Need it to be in "front" but not visible to the naked eye.
    opacity: 0;
    z-index: 1;
  }
}
@supports not (-webkit-touch-callout: none) {
  input {
    visibility: hidden;
  }
}

advanced-camera-card-icon {
  display: block;
  height: 100%;
  width: 100%;
  position: absolute;
}



================================================
FILE: src/scss/dotdotdot.scss
================================================
.dotdotdot:after {
  @keyframes dots {
    0%,
    20% {
      content: '.';
    }
    40% {
      content: '..';
    }
    60% {
      content: '...';
    }
    90%,
    100% {
      content: '';
    }
  }

  animation: dots 2s linear infinite;
  content: '';
  display: inline-block;
  width: 3em;
}



================================================
FILE: src/scss/drawer-inject.scss
================================================
@import './z-index.scss';

:host {
  // Drawer width sizes to contents.
  width: unset;
}

#fs {
  // Hide the freespace screen.
  display: none;
  width: 100%;
  inset: 0;
}

#d,
#fs {
  // Override width/height to be 100% instead of 100v[wh].
  height: 100%;

  // Position absolutely.
  position: absolute;
}

#d {
  // Need to allow drawer controls to be visible.
  overflow: visible;

  // Don't let the drawer exceed 90% of the full width of the relative parent.
  max-width: 90%;

  // Drawer renders behind the menu/status-bar overlay (otherwise the drawer
  // controls render on top of menu items)
  z-index: #{$z-index-drawer};
}

:host([location='right']) #d {
  // Position to the right.
  left: unset;
  right: 0;
  transform: translateX(100%);
}

:host([location='right'][open]) #d {
  transform: none;
  box-shadow: var(--advanced-camera-card-css-box-shadow, 0px 0px 25px 0px black);
}

#ifs {
  // Override width/height to be 100% instead of 100v[wh].
  height: 100%;
}



================================================
FILE: src/scss/drawer.scss
================================================
$drawer-icon-size: 20px;
$drawer-padding-extend: 20px;

side-drawer {
  background-color: var(--card-background-color);
}

div.control-surround {
  position: absolute;
  bottom: 50%;
  transform: translateY(50%);
  padding-top: $drawer-padding-extend;
  padding-bottom: $drawer-padding-extend;
}
:host([location='left']) div.control-surround {
  @if $drawer-icon-size < 32 {
    // Ensure the clickable area is at least 32px wide.
    padding-right: calc(32px - $drawer-icon-size);
  }
  left: 100%;
}
:host([location='right']) div.control-surround {
  @if $drawer-icon-size < 32 {
    // See note above.
    padding-left: calc(32px - $drawer-icon-size);
  }
  right: 100%;
}
:host([empty]),
:host([empty]) > * {
  visibility: hidden;
}
:host(:not([empty])),
:host(:not([empty])) > * {
  visibility: visible;
}

advanced-camera-card-icon.control {
  color: var(--advanced-camera-card-button-color);
  background-color: var(--advanced-camera-card-button-background);
  pointer-events: all;

  --mdc-icon-size: #{$drawer-icon-size};
  padding-top: $drawer-padding-extend;
  padding-bottom: $drawer-padding-extend;

  transition: opacity 0.5s ease;
}

:host([location='left']) advanced-camera-card-icon.control {
  border-top-right-radius: $drawer-icon-size;
  border-bottom-right-radius: $drawer-icon-size;
}

:host([location='right']) advanced-camera-card-icon.control {
  border-top-left-radius: $drawer-icon-size;
  border-bottom-left-radius: $drawer-icon-size;
}



================================================
FILE: src/scss/editor.scss
================================================
@use './button.scss';

.option {
  padding: 4px 4px;
  cursor: pointer;
}
.option.option-overrides .title {
  color: var(--warning-color);
}
.row {
  display: flex;
  margin-bottom: -14px;
  pointer-events: none;
}
.title {
  padding-left: 16px;
  margin-top: -6px;
  pointer-events: none;
}
.title.warning {
  color: var(--warning-color);
}
.secondary {
  padding-left: 40px;
  color: var(--secondary-text-color);
  pointer-events: none;
}
.values {
  background: var(--secondary-background-color);
  display: grid;
}
// Space submenus from the next top-level options.
.values + .option,
.submenu + .option {
  margin-top: 10px;
}
div.upgrade {
  width: auto;
  border: 1px dotted var(--primary-color);
  margin: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
div.upgrade span {
  padding: 10px;
}

.submenu-header {
  display: flex;
  padding: 10px;

  cursor: pointer;
}
.submenu.selected > .submenu-header {
  background-color: var(--primary-color);
  color: var(--primary-text-color);
}

.submenu-header * {
  flex-basis: auto;

  // Only allow clicks on the header.
  pointer-events: none;
}
.submenu-header .new {
  font-style: italic;
}
.submenu:not(.selected) > .submenu-header .new {
  color: var(--secondary-text-color, 'black');
}

.submenu-header advanced-camera-card-icon {
  margin-right: 15px;
}

.submenu.selected {
  border: 1px solid var(--primary-color);
}

// Nested menus should shrink width.
.submenu {
  width: calc(100% - 10px * 2);
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 10px;
}

// Add a margin above a submenu unless it's another submenu.
.submenu:first-child,
:not(.submenu) + .submenu {
  margin-top: 10px;
}

.submenu .controls {
  display: inline-block;
  margin-left: auto;
  margin-right: 0px;
  margin-bottom: 5px;
}
.submenu .controls ha-icon-button {
  --mdc-icon-button-size: 32px;
  --mdc-icon-size: calc(var(--mdc-icon-button-size) / 2);
}
span.info {
  padding: 10px;
}

ha-selector {
  padding: 10px;
  border: 1px solid var(--divider-color);
}

advanced-camera-card-message::part(icon) {
  color: var(--primary-color);
}



================================================
FILE: src/scss/elements.scss
================================================
:host {
  position: absolute;
  inset: 0;

  // Don't let elements overflow.
  overflow: hidden;
  pointer-events: none;
}

.element {
  position: absolute;
  transform: translate(-50%, -50%);
  pointer-events: auto;
}

// Errors encountered by HA (not the card) during parsing of the configuration
// (e.g. custom picture element that does not exist).
hui-error-card.element {
  inset: 0px;
  transform: unset;
}



================================================
FILE: src/scss/folder-gallery.scss
================================================
@use 'basic-block.scss';
@use 'media-gallery.scss';



================================================
FILE: src/scss/folder.scss
================================================
:host {
  width: 100%;
  height: 100%;
  display: block;
}

advanced-camera-card-surround-basic {
  // The folder will grow indefinitely in the `unconstrained` aspect ratio
  // modes, the surround height needs to be limited to something reasonable in
  // order for the media filter to still display somewhere the user can
  // easily/continually access. See similar: gallery.scss.
  max-height: 110dvh;
}



================================================
FILE: src/scss/gallery-core.scss
================================================
:host {
  width: 100%;
  height: 100%;
  display: block;
  overflow: auto;

  // Hide scrollbar: IE and Edge
  -ms-overflow-style: none;

  // Hide scrollbar: Firefox
  scrollbar-width: none;

  --advanced-camera-card-gallery-gap: 3px;
  --advanced-camera-card-gallery-columns: 4;
}

.grid {
  display: grid;
  grid-template-columns: repeat(
    var(--advanced-camera-card-gallery-columns),
    minmax(0, 1fr)
  );
  grid-auto-rows: var(--advanced-camera-card-thumbnail-size);
  gap: var(--advanced-camera-card-gallery-gap);
}

// Hide scrollbar for Chrome, Safari and Opera
:host::-webkit-scrollbar {
  display: none;
}

advanced-camera-card-progress-indicator.top {
  // The top loading progress indicator should span the whole width.
  grid-column: 1/-1;
  box-sizing: border-box;
  padding: 5px 0px 5px 0px;
}



================================================
FILE: src/scss/icon.scss
================================================
:host {
  display: inline-block;
  width: var(--mdc-icon-size, 24px);
  height: var(--mdc-icon-size, 24px);

  --ha-icon-display: block;
}

ha-icon,
state-badge,
svg {
  display: block;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
}

svg path {
  // !important is necessary to overcome the fill set on the path itself.
  fill: currentColor !important;
}

:host([allow-override-non-active-styles]) state-badge {
  --state-inactive-color: inherit;
}



================================================
FILE: src/scss/image-player.scss
================================================
@use 'basic-block.scss';
@use 'media-layout.scss';

img {
  width: 100%;
  height: 100%;
  display: block;

  @include media-layout.media-layout();
}



================================================
FILE: src/scss/image-updating-player.scss
================================================
@use 'basic-block.scss';
@use 'media-background.scss';
@use 'media-layout.scss';

img {
  width: 100%;
  height: 100%;
  display: block;

  @include media-layout.media-layout();
}



================================================
FILE: src/scss/image.scss
================================================
@use 'basic-block.scss';
@use 'media-layout.scss';
@use 'media-background.scss';

img {
  width: 100%;
  height: 100%;
  display: block;

  @include media-layout.media-layout();
}



================================================
FILE: src/scss/key-assigner.scss
================================================
@use 'dotdotdot.scss';

:host {
  display: flex;
  flex-direction: row;
  align-items: center;

  // Values match other HA editor components.
  padding: 10px;
  height: 56px;
  border: 1px solid var(--divider-color);
}

:host([assigning]) ha-button.assign span,
:host([assigning]) ha-button.assign advanced-camera-card-icon {
  color: var(--warning-color);
}

advanced-camera-card-icon {
  padding: 10px;
}

div.label {
  width: 100px;
  margin-left: 4px;
}

div.key-row {
  flex: 1;

  display: flex;
  justify-content: center;
  align-items: center;

  padding-left: 10px;
  padding-right: 10px;
}

div.key {
  display: flex;
  align-items: center;

  height: 90%;
  width: min-content;

  margin-left: 5px;
  margin-right: 5px;
}

div.key-inner {
  height: 100%;
  width: 100%;

  padding-top: 2px;
  padding-bottom: 2px;
  padding-left: 4px;
  padding-right: 4px;

  border: 2px;
  border-radius: 4px;
  border-style: outset;
  border-color: var(--divider-color);

  font-family: monospace;
  text-transform: capitalize;
}

div.unassigned {
  font-style: italic;
}

div.key + div.key:before {
  display: flex;
  align-items: center;

  margin-right: 5px;

  content: ' + ';
}



================================================
FILE: src/scss/live-carousel.scss
================================================
:host {
  display: block;
  --video-max-height: none;

  transition: max-height 0.1s ease-in-out;

  // Keep carousel controls relative to the media carousel itself.
  position: relative;
}

// When the carousel is not part of a grid ensure its height matches its
// container.
:host(:not([grid-id])) {
  height: 100%;
}

// If the carousel has an unselected attribute set on it, do not let the
// pointer interact (e.g. hover, scroll) with underlying elements. This is used
// when the carousel is part of a media-grid. Without this next/prev controls
// will enlarge on hover, and the wheel-gestures plugin may block scrolling.
// See matching in viewer-carousel.scss .
:host([unselected]) advanced-camera-card-carousel {
  pointer-events: none;
}

.embla__slide {
  // Center the content horizontally (for cases where the configured aspect
  // ratio is a mismatch with the card).
  display: flex;
  justify-content: center;

  height: 100%;
  width: 100%;

  flex: 0 0 100%;
}



================================================
FILE: src/scss/live-go2rtc.scss
================================================
@use 'media-layout.scss';

:host {
  width: 100%;
  height: 100%;
  display: block;
}
video {
  @include media-layout.media-layout();

  // Note: These 3 properties will also be set directly on the video element by
  // the player. They are included here for completeness, or should the
  // underlying player change its behavior in future.
  width: 100%;
  height: 100%;
  display: block;
}



================================================
FILE: src/scss/live-grid.scss
================================================
@use 'basic-block.scss';

@keyframes warning-pulse {
  0% {
    border: solid 2px var(--trigger-border-color-base);
  }
  50% {
    border: solid 2px var(--trigger-border-color);
  }
  100% {
    border: solid 2px var(--trigger-border-color-base);
  }
}

advanced-camera-card-live-carousel {
  --trigger-border-color: var(--advanced-camera-card-trigger-border-color);
  --trigger-border-color-base: var(
    --advanced-camera-card-trigger-border-color-base,
    black
  );
}

advanced-camera-card-live-carousel[triggered] {
  animation: warning-pulse 5s infinite;
}
advanced-camera-card-live-carousel[selected] {
  --trigger-border-color-base: var(
    --advanced-camera-card-trigger-border-color-base,
    var(--advanced-camera-card-foreground-primary)
  );
}



================================================
FILE: src/scss/live-ha-components.scss
================================================
@use 'media-layout.scss';

img,
video {
  @include media-layout.media-layout();
}



================================================
FILE: src/scss/live-ha.scss
================================================
:host {
  width: 100%;
  height: 100%;
  display: block;
}



================================================
FILE: src/scss/live-jsmpeg.scss
================================================
@use 'media-layout.scss';

:host {
  width: 100%;
  height: 100%;
  display: flex;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;

  @include media-layout.media-layout();
}



================================================
FILE: src/scss/live-provider.scss
================================================
@use 'basic-block.scss';
@use 'media-background.scss';

:host {
  position: relative;
}

.hidden {
  display: none;
}

advanced-camera-card-icon {
  position: absolute;
  top: 10px;
  right: 10px;
  color: var(--primary-color);
  cursor: help;
}



================================================
FILE: src/scss/live-webrtc-card.scss
================================================
@use 'media-layout.scss';

:host {
  width: 100%;
  height: 100%;
  display: block;
}

/* Don't drop shadow or have radius for nested webrtc card */
#webrtc ha-card {
  border-radius: 0px;

  // To get the WebRTC player to line up correctly with some themes.
  margin: 0px;
  box-shadow: none;
}

ha-card,
div.fix-safari,
#video {
  background: unset;
  background-color: unset;
}

#webrtc #video {
  @include media-layout.media-layout();
}



================================================
FILE: src/scss/loading.scss
================================================
:host {
  width: intrinsic;
  height: intrinsic;

  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;

  pointer-events: none;

  background-color: var(--advanced-camera-card-loading-background-color);
  color: var(--advanced-camera-card-loading-foreground-color);

  transition: opacity 1.5s ease-in;
  opacity: 1;
}

:host([loaded]) {
  opacity: 0;
}

advanced-camera-card-icon {
  margin-bottom: 20px;
  height: 25%;
  width: auto;
  animation: rotate 8s linear infinite;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

span {
  font-size: x-large;
}



================================================
FILE: src/scss/media-background.scss
================================================
// Use the outlined Iris logo since the background color is unknown.
$bg-img: url('../images/iris-background.svg');

:host {
  background-color: var(--primary-background-color);
  background-position: center;
  background-repeat: no-repeat;
  background-image: $bg-img;
  background-size: 10%;
  background-position: center;
}



================================================
FILE: src/scss/media-filter.scss
================================================
:host {
  display: flex;

  flex-direction: column;
  overflow: auto;

  // Hide scrollbar: Firefox
  scrollbar-width: none;
  // Hide scrollbar: IE and Edge
  -ms-overflow-style: none;

  height: 100%;
  width: 300px;
  margin: 5px;
}

/* Hide scrollbar for Chrome, Safari and Opera */
:host::-webkit-scrollbar {
  display: none;
}

advanced-camera-card-select {
  padding: 5px;
}

div.when {
  display: inline-flex;
  align-items: flex-end;
}
div.when advanced-camera-card-select {
  flex: 1;
}
div.when advanced-camera-card-date-picker {
  // Visually line up the date-picker icon with the bottom of the select
  // dropdown.
  padding-bottom: 5px;
  transition: width 0.5s ease-in-out;
}
div.when advanced-camera-card-date-picker {
  color: var(--secondary-color);
}
div.when advanced-camera-card-date-picker.selected {
  color: var(--primary-color);
}
div.when advanced-camera-card-date-picker.hidden {
  width: 0px;
}



================================================
FILE: src/scss/media-gallery.scss
================================================
@use 'basic-block.scss';

advanced-camera-card-surround-basic {
  // The gallery will grow indefinitely in the `unconstrained` aspect ratio
  // modes, the surround height needs to be limited to something reasonable in
  // order for the media filter to still display somewhere the user can
  // easily/continually access. See similar: gallery.scss.
  max-height: 110dvh;
}

advanced-camera-card-thumbnail {
  height: 100%;
  min-height: var(--advanced-camera-card-thumbnail-size);

  background-color: var(--secondary-background-color);
}
advanced-camera-card-thumbnail:not([details]) {
  width: 100%;
}
advanced-camera-card-thumbnail.selected {
  border: 4px solid var(--accent-color);

  // Because this is box-sizing: border-box, the border is effectively
  // 'padding'. To get the curved borders to line up between the thumbnail and
  // this outer border, we need to add the size of the border to the thumbnail
  // image border radius.
  // Related: https://www.30secondsofcode.org/articles/s/css-nested-border-radius
  border-radius: calc(
    var(--advanced-camera-card-css-border-radius, var(--ha-card-border-radius, 4px)) +
      4px
  );
}



================================================
FILE: src/scss/media-grid.scss
================================================
:host {
  display: block;
  width: 100%;
  height: 100%;

  --advanced-camera-card-grid-border-size: 3px;
  --advanced-camera-card-grid-column-size: 100%;
  --advanced-camera-card-grid-selected-width-factor: 2;

  // Allow the grid to scroll if necessary (e.g. fullscreen).
  overflow: auto;

  // Hide scrollbar: Firefox
  scrollbar-width: none;
  // Hide scrollbar: IE and Edge
  -ms-overflow-style: none;
}

/* Hide scrollbar for Chrome, Safari and Opera */
:host::-webkit-scrollbar {
  display: none;
}

::slotted(*) {
  box-sizing: border-box;
  border-radius: var(--ha-card-border-radius, 4px);
  overflow: hidden;
  width: var(--advanced-camera-card-grid-column-size);

  // Unselected items included a transparent border to act as the effective
  // gutter between elements, and to ensure when the item is selected it does
  // not change in size (even border-box sizing appears to allow size to change
  // when the element has a non-fixed height).
  border: var(--advanced-camera-card-grid-border-size) solid transparent;
}

::slotted([selected]) {
  border: var(--advanced-camera-card-grid-border-size) solid
    var(--advanced-camera-card-grid-selected-border-color);
  width: min(
    100%,
    calc(
      var(--advanced-camera-card-grid-selected-width-factor) *
        var(--advanced-camera-card-grid-column-size)
    )
  );
}

slot {
  display: block;
}



================================================
FILE: src/scss/media-layout.scss
================================================
@mixin media-layout {
  object-fit: var(--advanced-camera-card-media-layout-fit, contain);
  object-position: var(--advanced-camera-card-media-layout-position-x, 50%)
    var(--advanced-camera-card-media-layout-position-y, 50%);

  // This is supported on limited browsers:
  // See: https://caniuse.com/?search=object-view-box
  object-view-box: inset(
    var(--advanced-camera-card-media-layout-view-box-top, 0%)
      var(--advanced-camera-card-media-layout-view-box-right, 0%)
      var(--advanced-camera-card-media-layout-view-box-bottom, 0%)
      var(--advanced-camera-card-media-layout-view-box-left, 0%)
  );
}



================================================
FILE: src/scss/menu-button.scss
================================================
@use './button.scss';

ha-icon-button {
  // Icons in the menu are expected to follow Advanced Camera Card theming
  // unless they are active (in which case we want to take advantage of the
  // whatever styling is appropriate, e.g. light icon partially lit).
  --state-inactive-color: var(--advanced-camera-card-button-color);

  color: var(--advanced-camera-card-menu-button-inactive-color);
  background-color: var(--advanced-camera-card-menu-button-background);
}



================================================
FILE: src/scss/menu.scss
================================================
@use './menu-button.scss';

:host {
  --advanced-camera-card-menu-button-size: 40px;
  --mdc-icon-button-size: var(--advanced-camera-card-menu-button-size);
  --mdc-icon-size: calc(var(--mdc-icon-button-size) / 2);

  pointer-events: auto;

  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

:host([data-style='outside']) {
  width: 100%;
}

/*******************************************************
 * Non-hover styles should not interact with the pointer
 *******************************************************/

:host(:not([data-style*='hover'])) {
  pointer-events: none;
}

/***********************************
 * Aligned divs: matching & opposing
 ***********************************/

div.matching,
div.opposing {
  display: flex;
  flex-wrap: wrap;
  flex-direction: row;
  align-items: flex-start;

  // Allow the divs to be resized.
  min-width: 0px;
  min-height: 0px;
}
div.matching {
  justify-content: flex-start;
}
div.opposing {
  justify-content: flex-end;
}

/********************************************************
 * Hack: Ensure host & div expand for column flex layouts
 ********************************************************/

:host(:not([data-style='outside'])[data-position='left']) {
  // Awful hack: Flexbox column wrapping doesn't work properly in most major
  // browsers -- the element boundary does not expand to cover the full wrapped
  // content as it should. This results in the wrapped 'content' appearing
  // outside the element background (the linear gradient in this case). The
  // workaround is to use flex row direction for both rows & columns, and use
  // vertical-lr/vertical-rl as the writing mode for columns -- resetting
  // writing-mode for descendant elements.
  //
  // For more information see the Chromium bug as an example:
  // - https://bugs.chromium.org/p/chromium/issues/detail?id=507397
  writing-mode: vertical-lr;
}
:host(:not([data-style='outside'])[data-position='right']) {
  // See "Awful hack" above.
  writing-mode: vertical-rl;
}
:host(:not([data-style='outside'])[data-style='overlay'][data-position='left']) div > *,
:host(:not([data-style='outside'])[data-style='overlay'][data-position='right']) div > *,
:host(:not([data-style='outside'])[data-style*='hover'][data-position='left']) div > *,
:host(:not([data-style='outside'])[data-style*='hover'][data-position='right']) div > *,
:host(:not([data-style='outside'])[data-style='hidden'][data-position='left']) div > *,
:host(:not([data-style='outside'])[data-style='hidden'][data-position='right']) div > * {
  // See "Awful hack" above. Note that this "cancelation" of writing mode only
  // affects from beyond the divs, i.e. the writing mode hack applies to host
  // and divs both.
  writing-mode: horizontal-tb;
}

/**********************
 * "Reverse" alignments
 **********************/

:host(:not([data-style='outside'])[data-position='left'][data-alignment='bottom']),
:host(:not([data-style='outside'])[data-position='right'][data-alignment='bottom']),
:host([data-position='top'][data-alignment='right']),
:host([data-position='bottom'][data-alignment='right']),
:host(:not([data-style='outside'])[data-position='left'][data-alignment='bottom']) div,
:host(:not([data-style='outside'])[data-position='right'][data-alignment='bottom']) div,
:host([data-position='top'][data-alignment='right']) div,
:host([data-position='bottom'][data-alignment='right']) div {
  flex-direction: row-reverse;
}

/****************************
 * Wrap upwards on the bottom
 ****************************/

:host(:not([data-style='outside'])[data-position='bottom']) div {
  // If the menu has more content that allows, "wrap upwards" to keep the Iris
  // button in the same place.
  flex-wrap: wrap-reverse;
}

/********************************************
 * Positioning for absolute based menu styles
 ********************************************/

:host([data-style='overlay'][data-position='top']),
:host([data-style='overlay'][data-position='bottom']),
:host([data-style*='hover'][data-position='top']),
:host([data-style*='hover'][data-position='bottom']),
:host([data-style='hidden'][data-position='top']),
:host([data-style='hidden'][data-position='bottom']) {
  width: 100%;
  height: auto;
}

:host([data-style='overlay'][data-position='left']),
:host([data-style='overlay'][data-position='right']),
:host([data-style*='hover'][data-position='left']),
:host([data-style*='hover'][data-position='right']),
:host([data-style='hidden'][data-position='left']),
:host([data-style='hidden'][data-position='right']) {
  width: auto;
  height: 100%;
}

/************
 * Menu theme
 ************/

// When the menu uses the hidden style, and is not expanded, the remaining
// permanent menu buttons use the menu background color instead of the button
// background color.
:host([data-style='hidden']:not([expanded])) ha-icon-button {
  background: var(--advanced-camera-card-menu-background);
}

// Further theme related styling is dynamically applied by `menu.ts`, see
// `_renderPerInstanceStyle`.



================================================
FILE: src/scss/message.scss
================================================
@use 'dotdotdot.scss';

:host {
  display: flex;
  flex-direction: column;
  justify-content: center;

  // Ensure error messages are selectable.
  user-select: text;
  // Safari only has prefixed support.
  -webkit-user-select: text;
}

:host(:not([overlay])) {
  height: 100%;
  width: 100%;

  background: var(--advanced-camera-card-message-background);
  color: var(--advanced-camera-card-message-color);
}

:host([overlay]) {
  position: absolute;
  inset: 5%;

  background: var(--advanced-camera-card-message-overlay-background);
  color: var(--advanced-camera-card-message-overlay-color);
}

div.wrapper {
  height: 100%;
}

div.message {
  display: flex;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  height: 100%;
}

div.message.padded {
  padding: 20px;
}

div.message div.contents {
  display: flex;
  flex-direction: column;
  padding: 10px;
  margin-top: auto;
  margin-bottom: auto;
  min-width: 0;
}

div.message div.icon {
  padding: 10px;
}

.vertical {
  flex-direction: column;
}

a {
  word-break: break-word;
}

:host(:not([overlay])) a {
  color: var(--advanced-camera-card-message-color);
}

:host([overlay]) a {
  color: var(--advanced-camera-card-message-overlay-color);
}

.message pre {
  margin-top: 20px;
  overflow-x: auto;
  border: 1px dotted var(--advanced-camera-card-divider-color);
  padding: 1em;
}



================================================
FILE: src/scss/next-previous-control.scss
================================================
@use './button.scss';

:host {
  --advanced-camera-card-next-prev-size: 48px;
  --advanced-camera-card-next-prev-size-hover: calc(
    var(--advanced-camera-card-next-prev-size) * 2
  );
  --advanced-camera-card-left-position: 45px;
  --advanced-camera-card-right-position: 45px;
  --mdc-icon-button-size: var(--advanced-camera-card-next-prev-size);
  --mdc-icon-size: calc(var(--mdc-icon-button-size) / 2);
}

.controls {
  position: absolute;
  z-index: 1;
  overflow: hidden;
}
.controls.left {
  left: var(--advanced-camera-card-left-position);
}
.controls.right {
  right: var(--advanced-camera-card-right-position);
}

.controls.icons {
  top: calc(50% - (var(--advanced-camera-card-next-prev-size) / 2));
}

.controls.thumbnails {
  border-radius: 50%;
  height: var(--advanced-camera-card-next-prev-size);
  top: calc(50% - (var(--advanced-camera-card-next-prev-size) / 2));
  box-shadow: var(--advanced-camera-card-css-box-shadow, 0px 0px 20px 5px black);
  transition: all 0.2s ease-out;
  opacity: 0.8;
  aspect-ratio: 1 / 1;
}
.controls.thumbnails:hover {
  opacity: 1 !important;
  height: var(--advanced-camera-card-next-prev-size-hover);
  top: calc(50% - (var(--advanced-camera-card-next-prev-size-hover) / 2));
}

.controls.left.thumbnails:hover {
  left: calc(
    var(--advanced-camera-card-left-position) -
      (
        var(--advanced-camera-card-next-prev-size-hover) - var(
            --advanced-camera-card-next-prev-size
          )
      ) / 2
  );
}

.controls.right.thumbnails:hover {
  right: calc(
    var(--advanced-camera-card-right-position) -
      (
        var(--advanced-camera-card-next-prev-size-hover) - var(
            --advanced-camera-card-next-prev-size
          )
      ) / 2
  );
}



================================================
FILE: src/scss/overlay.scss
================================================
@use './button.scss';

:host {
  position: absolute;
  width: 100%;
  height: 100%;

  // Overlay itself does not handle click events.
  pointer-events: none;
}

slot {
  position: absolute;
  display: flex;
}

/***************
 * Slot position
 ***************/

slot[name='top'] {
  top: 0px;
}
slot[name='bottom'] {
  bottom: 0px;
}
slot[name='left'] {
  left: 0px;
}
slot[name='right'] {
  right: 0px;
}

/***********
 * Slot size
 ***********/

slot[name='top'],
slot[name='bottom'] {
  width: 100%;
  flex-direction: column;
}
slot[name='left'],
slot[name='right'] {
  height: 100%;
  flex-direction: row;
}

slot[name='top'],
slot[name='left'] {
  justify-content: flex-start;
}

slot[name='bottom'],
slot[name='right'] {
  justify-content: flex-end;
}



================================================
FILE: src/scss/ptz.scss
================================================
// Inspired by:
// https://github.com/AlexxIT/WebRTC/blob/master/custom_components/webrtc/www/webrtc-camera.js
:host {
  position: absolute;

  width: fit-content;
  height: fit-content;

  --advanced-camera-card-ptz-icon-size: 24px;
}

:host([data-position$='-left']) {
  left: 5%;
}
:host([data-position$='-right']) {
  right: 5%;
}
:host([data-position^='top-']) {
  top: 5%;
}
:host([data-position^='bottom-']) {
  bottom: 5%;
}

/*****************
 * Main Containers
 *****************/
.ptz {
  display: flex;
  gap: 10px;

  color: var(--light-primary-color);
  opacity: 0.4;

  transition: opacity 0.3s ease-in-out;
}

:host([data-orientation='vertical']) .ptz {
  flex-direction: column;
}
:host([data-orientation='horizontal']) .ptz {
  flex-direction: row;
}

.ptz:hover {
  opacity: 1;
}

:host([data-orientation='vertical']) .ptz div {
  width: calc(var(--advanced-camera-card-ptz-icon-size) * 3);
}
:host([data-orientation='horizontal']) .ptz div {
  height: calc(var(--advanced-camera-card-ptz-icon-size) * 3);
}

.ptz-move,
.ptz-zoom,
.ptz-presets {
  position: relative;
  background-color: rgba(0, 0, 0, 0.3);
}

.ptz-move {
  height: calc(var(--advanced-camera-card-ptz-icon-size) * 3);
  width: calc(var(--advanced-camera-card-ptz-icon-size) * 3);

  border-radius: 50%;
}

:host([data-orientation='horizontal']) .ptz .ptz-zoom,
:host([data-orientation='horizontal']) .ptz .ptz-presets {
  width: calc(var(--advanced-camera-card-ptz-icon-size) * 1.5);
}
:host([data-orientation='vertical']) .ptz .ptz-zoom,
:host([data-orientation='vertical']) .ptz .ptz-presets {
  height: calc(var(--advanced-camera-card-ptz-icon-size) * 1.5);
}

.ptz-zoom,
.ptz-presets {
  border-radius: var(--ha-card-border-radius, 4px);
}

/***********
 * PTZ Icons
 ***********/
.ptz-move advanced-camera-card-icon {
  position: absolute;
  --mdc-icon-size: var(--advanced-camera-card-ptz-icon-size);
}
advanced-camera-card-icon:not(.disabled),
advanced-camera-card-submenu:not(.disabled) {
  cursor: pointer;
}
.disabled {
  color: var(--disabled-text-color);
}
.up {
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
}
.down {
  bottom: 5px;
  left: 50%;
  transform: translateX(-50%);
}
.left {
  left: 5px;
  top: 50%;
  transform: translateY(-50%);
}
.right {
  right: 5px;
  top: 50%;
  transform: translateY(-50%);
}

.ptz-presets,
.ptz-zoom {
  display: flex;
  align-items: center;
  justify-content: space-evenly;
}
:host([data-orientation='vertical']) .ptz-presets,
:host([data-orientation='vertical']) .ptz-zoom {
  flex-direction: row;
}
:host([data-orientation='horizontal']) .ptz-presets,
:host([data-orientation='horizontal']) .ptz-zoom {
  flex-direction: column;
}



================================================
FILE: src/scss/select.scss
================================================
@use '@graphiteds/core/css/core.css';

:host {
  // The graphite css (above) loads variables into :root, which is lost in the
  // shadow DOM, so copy them into the host.
  @extend :root;
}



================================================
FILE: src/scss/status.scss
================================================
@use './button.scss';

:host {
  --mdc-icon-size: calc(var(--advanced-camera-card-status-bar-height) / 2);

  display: block;
  width: 100%;

  pointer-events: auto;

  opacity: 1;
  transition: opacity 1s;
}

/*******************************************************
 * Non-hover styles should not interact with the pointer
 *******************************************************/

:host(:not([data-style*='hover'])) {
  pointer-events: none;
}

/**********************
 * Popup style behavior
 **********************/

:host([data-style='popup'][hide]) {
  opacity: 0;
}

/*********************
 * Status bar contents
 *********************/

.status {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;

  overflow: hidden;

  width: 100%;
  height: var(--advanced-camera-card-status-bar-height);
}

.item {
  display: inline-block;

  margin: 3px 5px;

  align-content: center;
}
.item:first-child {
  margin-left: 10px;
}
.item:last-child {
  margin-right: 10px;
}

.item.expand {
  flex: 1;
}

.item.action {
  cursor: pointer;
}

img.item,
advanced-camera-card-icon.item {
  display: block;

  // To ensure images render somewhat reasonably looking their height is kept to
  // the same height as icons.
  height: var(--mdc-icon-size, 24px);
  width: auto;
}

/************************
 * Status bar theme hooks
 ************************/

// Further theme related styling is dynamically applied by `status-bar.ts`, see
// `_renderPerInstanceStyle`.



================================================
FILE: src/scss/submenu.scss
================================================
@use './menu-button.scss';
@import './z-index.scss';

:host {
  pointer-events: auto;

  --mdc-menu-z-index: #{$z-index-submenu};
}



================================================
FILE: src/scss/surround-basic.scss
================================================
:host {
  width: 100%;
  height: 100%;

  // Share the screen space with thumbnails that may be above/below.
  display: flex;
  flex-direction: column;

  // Set the drawer relative to this host.
  position: relative;

  // Hide any content outside the main pane (e.g. side drawers) to ensure the
  // user cannot scroll across to the drawers without opening them.
  overflow: hidden;
}

::slotted(:not([slot])) {
  // Expand the main body to fill available content not otherwise used by the
  // named slots around the surround.
  flex: 1;
  min-height: 0px;
}



================================================
FILE: src/scss/thumbnail-carousel.scss
================================================
@use 'const.scss';

:host {
  display: block;
  width: 100%;
  height: 100%;

  background-color: var(--advanced-camera-card-thumbnail-background);

  --advanced-camera-card-carousel-thumbnail-opacity: 1;
}

:host([direction='vertical']) {
  height: 100%;
}
:host([direction='horizontal']) {
  // In fullscreen mode, without explicitly setting the height to auto Chrome
  // will construct a stylesheet with 100% height.
  height: auto;
}

.embla__slide {
  flex: 0 0 auto;
  opacity: var(--advanced-camera-card-carousel-thumbnail-opacity);
}
.embla__slide.slide-selected {
  opacity: 1;
}

advanced-camera-card-thumbnail {
  width: var(--advanced-camera-card-thumbnail-size);
  height: var(--advanced-camera-card-thumbnail-size);

  // Do not let thumbnails span beyond the width of the carousel.
  max-width: 100%;
}
advanced-camera-card-thumbnail[details] {
  width: var(--advanced-camera-card-thumbnail-details-width);
}



================================================
FILE: src/scss/thumbnail-details.scss
================================================
:host {
  display: flex;
  flex-direction: column;

  width: 100%;
  margin-left: 5px;
  padding: 5px;
  color: var(--advanced-camera-card-thumbnail-text-color);
  overflow: hidden;
  column-gap: 5%;
}

div.heading {
  font-size: 1.2rem;
  font-weight: bold;
}

div.details {
  flex: 1;
  justify-content: center;

  display: flex;
  flex-direction: column;
  flex-wrap: wrap;
  --mdc-icon-size: 16px;

  // Details panel can shrink as well as grow.
  min-height: 0px;
}

div.details div {
  display: flex;
  align-items: center;
}

div.details div * {
  margin: 0px 3px;
}



================================================
FILE: src/scss/thumbnail-feature-thumbnail.scss
================================================
:host {
  display: block;
  overflow: hidden;

  aspect-ratio: 1 / 1;

  display: flex;
  justify-content: center;
  align-items: center;
}

img {
  display: block;
}

img {
  // Safari will occasionally not load thumbnails correctly with display block.
  display: inline-block;

  width: 100%;
  height: 100%;

  // Ensure no whitespace around img with inline-block display.
  vertical-align: top;
  margin: 0;

  border-radius: var(
    --advanced-camera-card-css-border-radius,
    var(--ha-card-border-radius, 4px)
  );

  // Not 'contain' as some thumbnails may vary in aspect-ratio slightly and
  // should be clipped to fill the thumbnail div whilst maintaining
  // aspect-ratio.
  object-fit: cover;
}

advanced-camera-card-icon {
  display: flex;
  width: 50%;

  --mdc-icon-size: 100%;
  color: var(--primary-text-color);

  justify-content: center;
  align-items: center;
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-sizing: border-box;
  opacity: 0.2;
}



================================================
FILE: src/scss/thumbnail-feature.scss
================================================
:host {
  display: flex;
  flex-direction: column;
  justify-content: space-evenly;
  align-items: center;

  max-width: var(--advanced-camera-card-thumbnail-size);
  max-height: var(--advanced-camera-card-thumbnail-size);

  aspect-ratio: 1 / 1;

  border: 1px solid var(--secondary-color);
  background-color: var(--secondary-background-color);
  border-radius: var(
    --advanced-camera-card-css-border-radius,
    var(--ha-card-border-radius, 4px)
  );

  box-sizing: border-box;

  // Background icon relative to the thumbnail.
  position: relative;
}

advanced-camera-card-thumbnail-feature-thumbnail {
  height: 50%;
}
advanced-camera-card-thumbnail-feature-thumbnail.brand:only-child {
  height: 60%;
}
advanced-camera-card-thumbnail-feature-thumbnail:not(.brand):only-child {
  height: 100%;
}

advanced-camera-card-icon:only-child {
  width: 60%;
  height: 60%;

  --mdc-icon-size: 100%;
}

advanced-camera-card-icon.background {
  display: block;
  width: 100%;
  height: 100%;

  position: absolute;
  inset: 0;

  padding: 10%;
  box-sizing: border-box;

  pointer-events: none;

  opacity: 0.1;

  --mdc-icon-size: 100%;
}

div {
  text-align: center;
  color: var(--primary-text-color);
}
div.title {
  font-size: 1.5rem;
}
div.subtitle {
  font-size: 0.8em;
}



================================================
FILE: src/scss/thumbnail.scss
================================================
:host {
  display: flex;
  flex-direction: row;
  box-sizing: border-box;

  // Ensure control icons are relative to the thumbnail.
  position: relative;
  overflow: hidden;

  transition: transform 0.2s linear;
}

:host(:not([details])) {
  aspect-ratio: 1 / 1;
}

:host([details]) {
  border: 1px solid var(--advanced-camera-card-thumbnail-border-color);
  border-radius: var(
    --advanced-camera-card-css-border-radius,
    var(--ha-card-border-radius, 4px)
  );
  padding: 2px;

  // When details are enabled, use a background color so that the details have
  // contrast with the background.
  background-color: var(--advanced-camera-card-thumbnail-background);
}

:host(:hover) {
  transform: scale(1.04);
}

advanced-camera-card-icon {
  position: absolute;
  border-radius: 50%;
  color: var(--advanced-camera-card-thumbnail-icon-color);

  cursor: pointer;

  transition:
    opacity 0.2s ease-in-out,
    color 0.2s ease-in-out;
}
advanced-camera-card-icon:hover {
  opacity: 1;
}

advanced-camera-card-icon.star {
  top: 3px;
  left: 3px;
}
advanced-camera-card-icon.star.starred {
  color: var(--advanced-camera-card-thumbnail-icon-favorite-color);
}

advanced-camera-card-icon.timeline {
  top: 3px;
  right: 3px;
}

advanced-camera-card-icon.download {
  right: 3px;
  bottom: 3px;
}

advanced-camera-card-thumbnail-details {
  flex: 1;
}



================================================
FILE: src/scss/timeline-core.scss
================================================
@use 'vis-timeline/dist/vis-timeline-graph2d.css';
@use 'drawer';
@use 'const.scss';

:host {
  width: 100%;
  // Share the screen space with thumbnails that may be above/below.
  display: flex;
  flex-direction: column;

  // So that absolute sidedrawer is relative to this host.
  position: relative;

  background-color: var(--advanced-camera-card-timeline-background);
}

:host(:not([mini])) {
  // Timeline covers 100% of the parent unless it's in mini-mode.
  height: 100%;
}

advanced-camera-card-thumbnail {
  height: var(--advanced-camera-card-thumbnail-size);
  width: var(--advanced-camera-card-thumbnail-size);
}
advanced-camera-card-thumbnail[details] {
  width: var(--advanced-camera-card-thumbnail-details-width);
}

div.timeline {
  flex: 1;
}

.vis-text {
  color: var(--advanced-camera-card-timeline-text-color) !important;
}

.vis-timeline {
  border: none;
}

.vis-labelset .vis-label {
  // Group labels.
  color: var(--advanced-camera-card-timeline-text-color);
}

:host([ribbon]:not([groups])) .vis-item:not(.vis-background) {
  // When a ribbon timeline is used without groups, we need to add extra margin
  // to the top to center the bar vertically within the mini-timeline.
  margin-top: 7px;
}

:host([ribbon]) .vis-item:not(.vis-background) {
  // Ribbon timelines have a much shorter 'bar'.
  height: 6px;
}
.vis-item {
  border-color: var(--advanced-camera-card-timeline-item-color);
  background: none;
  color: var(--advanced-camera-card-timeline-text-color);
  background-color: var(--advanced-camera-card-timeline-item-color);

  transition:
    background-color ease-in-out 1s,
    border-color ease-in-out 1s,
    box-shadow ease-in-out 1s;
}
.vis-item.vis-selected {
  border-color: var(--advanced-camera-card-active-color);
  background-color: var(--advanced-camera-card-active-color);
  box-shadow: var(
    --advanced-camera-card-css-box-shadow,
    0px 0px 5px 1px var(--advanced-camera-card-active-color)
  );
}
.vis-item.vis-background {
  background-color: var(--advanced-camera-card-timeline-background-item-color);
}

// If there are no timeline groups shown (e.g. mini mode with a single camera),
// ensure the background (recordings) always span the full height. Otherwise, in
// cases where there are no events, the background is incorrectly rendered too
// short by visjs.
:host(:not([groups])) .vis-item.vis-background {
  min-height: 100%;
}

.vis-item:not(.vis-background) {
  cursor: pointer;
}
:host([recordings]) .vis-item.vis-background,
:host([recordings]) .vis-time-axis {
  cursor: crosshair;
}
.vis-item:active {
  cursor: unset;
}

.vis-item.vis-box {
  border: none;
}

.vis-item .vis-item-content {
  padding: 0px;
}

.vis-item.vis-cluster {
  border-style: dotted;
  color: var(--advanced-camera-card-timeline-text-color);
  background-color: var(--advanced-camera-card-timeline-background);
  box-shadow: var(
    --advanced-camera-card-css-box-shadow,
    0px 0px 5px 1px var(--advanced-camera-card-timeline-item-color)
  );
}
.vis-item.vis-range {
  border-radius: var(--advanced-camera-card-css-border-radius, unset);
}

.vis-time-axis .vis-grid.vis-minor {
  border-color: var(--advanced-camera-card-timeline-divider-color);
}

// Give an indication that the user can interact with the axes.
.vis-text.vis-minor,
.vis-label {
  transition: background-color 0.5s ease-out;
}
:host([recordings]) .vis-text.vis-minor:hover {
  background-color: color-mix(
    in oklab,
    var(--advanced-camera-card-timeline-text-color),
    transparent 80%
  );
}

.vis-time-axis .vis-grid.vis-major {
  border-color: var(--advanced-camera-card-timeline-divider-color);
}

.vis-label {
  display: flex;
  justify-content: center;
  align-items: center;
}

div.vis-tooltip {
  padding: 0px;
  background-color: unset;
  border: none;

  // Use browser default font-family for tooltips.
  font-family: unset;

  z-index: 30;
}

.target_bar {
  background-color: var(--advanced-camera-card-timeline-target-bar-color);
  width: 2px;

  z-index: 20;

  // Prevent the mouse interacting with the custom time.
  pointer-events: none;
}
.target_bar .vis-custom-time-marker {
  background-color: var(--advanced-camera-card-timeline-background);
  color: var(--advanced-camera-card-timeline-text-color);
  bottom: 0px;
  top: unset;
}
:host([target-bar-marker-direction='right']) .target_bar .vis-custom-time-marker {
  left: 2px;
}
:host([target-bar-marker-direction='left']) .target_bar .vis-custom-time-marker {
  right: 2px;
}
:host([target-bar-marker-direction='center']) .target_bar .vis-custom-time-marker {
  left: 0px;
  transform: translateX(-50%);
}

.timeline-tools {
  display: inline-flex;
  position: absolute;
  right: 0px;
  bottom: 0px;
  color: var(--advanced-camera-card-timeline-tool-color);
  z-index: 10;
}
.timeline-tools * {
  margin: 2px 5px;
  cursor: pointer;
}
.timeline-tools *:last-child {
  margin-right: 10px;
}



================================================
FILE: src/scss/video-player.scss
================================================
@use 'basic-block.scss';
@use 'media-layout.scss';

video {
  width: 100%;
  height: 100%;
  display: block;

  @include media-layout.media-layout();
}



================================================
FILE: src/scss/viewer-carousel.scss
================================================
:host {
  display: block;
  --video-max-height: none;

  transition: max-height 0.1s ease-in-out;

  // Keep carousel controls relative to the media carousel itself.
  position: relative;
}

// When the carousel is not part of a grid ensure its height matches its
// container.
:host(:not([grid-id])) {
  height: 100%;
}

// If the carousel has an unselected attribute set on it, do not let the
// pointer interact (e.g. hover, scroll) with underlying elements. This is used
// when the carousel is part of a media-grid. Without this next/prev controls
// will enlarge on hover, and the wheel-gestures plugin may block scrolling.
// See matching in live-carousel.scss .
:host([unselected]) advanced-camera-card-carousel,
:host([unselected]) .seek-warning {
  pointer-events: none;
}

:host([unseekable]) advanced-camera-card-carousel {
  filter: brightness(50%);
}
:host([unseekable]) .seek-warning {
  display: block;
}

.seek-warning {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translateX(-50%) translateY(-50%);
  color: white;
}

.embla__slide {
  height: 100%;
  width: 100%;

  flex: 0 0 100%;
}



================================================
FILE: src/scss/viewer-provider.scss
================================================
@use 'basic-block.scss';
@use 'media-background.scss';

advanced-camera-card-ha-hls-player,
advanced-camera-card-image-player,
advanced-camera-card-video-player {
  display: block;
  width: 100%;
  height: 100%;
}

advanced-camera-card-progress-indicator {
  padding: 30px;
  box-sizing: border-box;
}



================================================
FILE: src/scss/viewer.scss
================================================
:host {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

:host([empty]) {
  // If there is no media, render the message in suitably sized placeholder. The
  // alternative is falling back to the minimum card size, which is too small
  // for adequate use of the thumbnails carousel, which might be used to select
  // media for the viewer. This issue is especially prominent when navigating
  // folders via the thumbnail carousel.
  aspect-ratio: 16 / 9;
}

advanced-camera-card-viewer-carousel {
  flex: 1;
  min-height: 0;
}



================================================
FILE: src/scss/views.scss
================================================
:host {
  width: 100%;
  height: 100%;
  display: block;
}

:host([hidden]),
.hidden {
  // Views content is hidden in these cases:
  // - Live view being preloaded but live view not active.
  // - Overall views component marked as hidden (e.g. error message to display
  //   at the card level).
  display: none;
}



================================================
FILE: src/scss/z-index.scss
================================================
/************
 * Managing z-indicies and stacking contexts is very challenging on the card,
 * due to the volume of different potentially overlapping surfaces. In
 * particular, care must be taken to not generate new stacking contexts
 * inadvertently which would make "z-index" weaving challenging (e.g. submenu
 * shown for PTZ presets, needs to render "over" the media drawer open/close
 * control).
 *************/

// More-info dialog box has a z-index of 8, so everything meaningful needs to be
// below that.

$z-index-loading: 6;
$z-index-submenu: 5;

// Need menu to render above drawer (so the drawer button is below menu-submenus)
$z-index-menu: 4;
$z-index-drawer: 3;
$z-index-status-bar: 2;

// The base z-index when the card is not hovered over. See note in card.scss .
$z-index-card-flatten: 0;



================================================
FILE: src/scss/themes/base.scss
================================================
@use 'dark.scss';
@use 'light.scss';
@use 'traditional.scss';

:host {
  /*********
   * General
   *********/

  --advanced-camera-card-exterior: var(--secondary-background-color, black);
  --advanced-camera-card-background: var(--primary-background-color, white);

  --advanced-camera-card-foreground-primary: var(--primary-color, black);

  --advanced-camera-card-active-color: var(--accent-color, orange);
  --advanced-camera-card-warning-color: var(--error-color, red);

  --advanced-camera-card-text-color: var(--primary-text-color);
  --advanced-camera-card-divider-color: var(--divider-color);

  --advanced-camera-card-control-background: var(--app-header-background-color);
  --advanced-camera-card-control-background-transparent: color-mix(
    in oklab,
    var(--advanced-camera-card-control-background),
    transparent 60%
  );
  --advanced-camera-card-control-foreground: var(--app-header-text-color);

  /*********
   * Buttons
   *********/

  // The color of buttons (in general, menu or otherwise).
  --advanced-camera-card-button-color: var(--advanced-camera-card-control-foreground);

  // The color of button background "circles".
  --advanced-camera-card-button-background: var(
    --advanced-camera-card-control-background-transparent
  );

  /******
   * Menu
   ******/

  // The color of an active icon in the menu.
  --advanced-camera-card-menu-button-active-color: var(
    --advanced-camera-card-active-color
  );

  // The color of an inactive icon in the menu.
  --advanced-camera-card-menu-button-inactive-color: var(
    --advanced-camera-card-button-color
  );

  // The color of a critical icon in the menu.
  --advanced-camera-card-menu-button-critical-color: var(
    --error-color,
    var(--advanced-camera-card-warning-color)
  );

  // The background color of the button "circles" in the menu.
  --advanced-camera-card-menu-button-background: color-mix(
    in oklab,
    var(--advanced-camera-card-menu-button-inactive-color),
    transparent 60%
  );

  // The menu background color.
  --advanced-camera-card-menu-background: var(
    --advanced-camera-card-control-background-transparent
  );
  --advanced-camera-card-menu-style-outside-background: var(
    --advanced-camera-card-control-background
  );

  // May be overridden by the user to force a particular color.
  --advanced-camera-card-menu-override-background: unset;
  --advanced-camera-card-menu-override-button-inactive-color: unset;
  --advanced-camera-card-menu-override-button-background: unset;

  // Examples of precise theming for the menu:
  // --advanced-camera-card-menu-position-left-alignment-left-style-overlay-background: pink;
  // --advanced-camera-card-menu-position-left-background: purple;
  // --advanced-camera-card-menu-style-overlay-background: pink;

  /************
   * Status bar
   ************/

  // May be overridden by the user to force a particular color.
  --advanced-camera-card-status-bar-override-background: unset;
  --advanced-camera-card-status-bar-override-color: unset;

  // The color of items on the status bar.
  --advanced-camera-card-status-bar-color: var(
    --advanced-camera-card-control-foreground
  );

  // The background color of the outerlay above/below the card.
  --advanced-camera-card-status-bar-background: var(
    --advanced-camera-card-control-background-transparent
  );
  --advanced-camera-card-status-bar-style-outside-background: var(
    --advanced-camera-card-control-background
  );

  /************
   * Thumbnails
   ************/

  --advanced-camera-card-thumbnail-icon-color: var(
    --advanced-camera-card-foreground-primary
  );
  --advanced-camera-card-thumbnail-border-color: var(
    --advanced-camera-card-foreground-primary
  );
  --advanced-camera-card-thumbnail-background: var(--advanced-camera-card-background);
  --advanced-camera-card-thumbnail-icon-favorite-color: color-mix(
    in oklab,
    gold,
    transparent 25%
  );
  --advanced-camera-card-thumbnail-text-color: var(--advanced-camera-card-text-color);

  /**********
   * Timeline
   **********/

  --advanced-camera-card-timeline-text-color: var(--advanced-camera-card-text-color);
  --advanced-camera-card-timeline-item-color: var(
    --advanced-camera-card-foreground-primary
  );
  --advanced-camera-card-timeline-tool-color: var(
    --advanced-camera-card-foreground-primary
  );
  --advanced-camera-card-timeline-background: var(--advanced-camera-card-background);

  // style for the 'background' style of item (i.e. recordings).
  --advanced-camera-card-timeline-background-item-color: color-mix(
    in oklab,
    var(--advanced-camera-card-timeline-item-color),
    transparent 90%
  );

  --advanced-camera-card-timeline-divider-color: var(
    --advanced-camera-card-divider-color
  );
  --advanced-camera-card-timeline-target-bar-color: var(
    --advanced-camera-card-active-color
  );

  /*******************
   * Loading Indicator
   *******************/

  --advanced-camera-card-loading-background-color: var(
    --advanced-camera-card-control-background-transparent
  );
  --advanced-camera-card-loading-foreground-color: var(
    --advanced-camera-card-control-foreground
  );

  /*********
   * Message
   *********/
  --advanced-camera-card-message-color: var(--advanced-camera-card-text-color);
  --advanced-camera-card-message-background: var(--advanced-camera-card-background);

  --advanced-camera-card-message-overlay-background: var(
    --advanced-camera-card-control-background-transparent
  );
  --advanced-camera-card-message-overlay-color: var(
    --advanced-camera-card-control-foreground
  );

  /*********
  * Trigger
  *********/
  --advanced-camera-card-trigger-border-color: var(--advanced-camera-card-warning-color);
  --advanced-camera-card-trigger-border-color-base: unset;

  /*****
  * Grid
  ******/
  --advanced-camera-card-grid-selected-border-color: var(
    --advanced-camera-card-foreground-primary
  );
}



================================================
FILE: src/scss/themes/dark.scss
================================================
:host([themes~='dark']) {
  // This file should include only, and exactly match, values from
  // https://github.com/home-assistant/frontend/blob/dev/src/resources/styles-data.ts .

  --primary-background-color: #111111;
  --secondary-background-color: #282828;
  --primary-text-color: #e1e1e1;
  --divider-color: rgba(225, 225, 225, 0.12);
  --app-header-background-color: #101e24;
  --app-header-text-color: #e1e1e1;
}



================================================
FILE: src/scss/themes/light.scss
================================================
:host([themes~='light']) {
  // This file should include only, and exactly match, values from
  // https://github.com/home-assistant/frontend/blob/dev/src/resources/ha-style.ts

  --primary-background-color: #fafafa;
  --secondary-background-color: #e5e5e5;
  --primary-text-color: #212121;
  --divider-color: rgba(0, 0, 0, 0.12);
  --app-header-text-color: #ffffff;

  // HA dynamically sets these values based on choice of primary/secondary
  // colors and hex blending techniques. The card does not currently
  // re-implement this logic, rather just uses the default static value.
  // See: https://github.com/home-assistant/frontend/blob/dev/src/common/dom/apply_themes_on_element.ts

  --app-header-background-color: #03a9f4;
}



================================================
FILE: src/scss/themes/traditional.scss
================================================
@mixin background-gradient($var, $angle) {
  #{$var}: linear-gradient(
    $angle,
    var(--advanced-camera-card-menu-background),
    var(--advanced-camera-card-menu-background),
    var(--advanced-camera-card-menu-background),
    color-mix(in oklab, var(--advanced-camera-card-menu-background), transparent 100%)
  );
}

:host([themes~='traditional']) {
  /*********
   * General
   *********/

  --advanced-camera-card-control-background: black;

  /******
   * Menu
   ******/

  --advanced-camera-card-menu-button-active-color: var(--primary-color, white);
  --advanced-camera-card-menu-button-background: rgba(0, 0, 0, 0.6);

  @include background-gradient(
    '--advanced-camera-card-menu-position-left-alignment-top-background',
    180deg
  );
  @include background-gradient(
    '--advanced-camera-card-menu-position-left-alignment-bottom-background',
    0deg
  );
  @include background-gradient(
    '--advanced-camera-card-menu-position-right-alignment-top-background',
    180deg
  );
  @include background-gradient(
    '--advanced-camera-card-menu-position-right-alignment-bottom-background',
    0deg
  );

  @include background-gradient(
    '--advanced-camera-card-menu-position-top-alignment-left-background',
    90deg
  );
  @include background-gradient(
    '--advanced-camera-card-menu-position-top-alignment-right-background',
    270deg
  );
  @include background-gradient(
    '--advanced-camera-card-menu-position-bottom-alignment-left-background',
    90deg
  );
  @include background-gradient(
    '--advanced-camera-card-menu-position-bottom-alignment-right-background',
    270deg
  );

  --advanced-camera-card-menu-position-top-alignment-left-style-outside-background: var(
    --secondary-background-color
  );
  --advanced-camera-card-menu-position-top-alignment-right-style-outside-background: var(
    --secondary-background-color
  );
  --advanced-camera-card-menu-position-bottom-alignment-left-style-outside-background: var(
    --secondary-background-color
  );
  --advanced-camera-card-menu-position-bottom-alignment-right-style-outside-background: var(
    --secondary-background-color
  );

  /************
   * Status bar
   ************/

  --advanced-camera-card-status-bar-color: white;

  @include background-gradient(
    '--advanced-camera-card-status-bar-position-top-background',
    90deg
  );
  @include background-gradient(
    '--advanced-camera-card-status-bar-position-bottom-background',
    90deg
  );

  --advanced-camera-card-status-bar-position-top-style-outside-background: var(
    --secondary-background-color
  );
  --advanced-camera-card-status-bar-position-bottom-style-outside-background: var(
    --secondary-background-color
  );
  --advanced-camera-card-status-bar-position-top-style-outside-color: var(
    --secondary-text-color
  );
  --advanced-camera-card-status-bar-position-bottom-style-outside-color: var(
    --secondary-text-color
  );
}



================================================
FILE: src/utils/action.ts
================================================
import { CardActionsAPI } from '../card-controller/types.js';
import { ZoomSettingsBase } from '../components-lib/zoom/types.js';
import { CameraSelectActionConfig } from '../config/schema/actions/custom/camera-select.js';
import { DisplayModeActionConfig } from '../config/schema/actions/custom/display-mode.js';
import { FoldersViewActionConfig } from '../config/schema/actions/custom/folders-view.js';
import {
  AdvancedCameraCardGeneralAction,
  GeneralActionConfig,
} from '../config/schema/actions/custom/general.js';
import {
  INTERNAL_CALLBACK_ACTION,
  InternalCallbackActionConfig,
} from '../config/schema/actions/custom/internal.js';
import { LogActionConfig, LogActionLevel } from '../config/schema/actions/custom/log.js';
import { MediaPlayerActionConfig } from '../config/schema/actions/custom/media-player.js';
import { PTZControlsActionConfig } from '../config/schema/actions/custom/ptz-controls.js';
import { PTZDigitialActionConfig } from '../config/schema/actions/custom/ptz-digital.js';
import { PTZMultiActionConfig } from '../config/schema/actions/custom/ptz-multi.js';
import {
  PTZAction,
  PTZActionConfig,
  PTZActionPhase,
} from '../config/schema/actions/custom/ptz.js';
import { SubstreamSelectActionConfig } from '../config/schema/actions/custom/substream-select.js';
import { ViewActionConfig } from '../config/schema/actions/custom/view.js';
import { PerformActionActionConfig } from '../config/schema/actions/stock/perform-action.js';
import {
  ActionConfig,
  ActionsConfig,
  AdvancedCameraCardCustomActionConfig,
} from '../config/schema/actions/types.js';
import { AdvancedCameraCardUserSpecifiedView } from '../config/schema/common/const.js';
import { ServiceCallRequest } from '../ha/types.js';
import { arrayify } from './basic.js';

export function createGeneralAction(
  action: AdvancedCameraCardGeneralAction,
  options?: {
    cardID?: string;
  },
): GeneralActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: action,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createViewAction(
  action: Exclude<AdvancedCameraCardUserSpecifiedView, 'folder' | 'folders'>,
  options?: {
    cardID?: string;
  },
): ViewActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: action,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createCameraAction(
  action: 'camera_select' | 'live_substream_select',
  camera: string,
  options?: {
    cardID?: string;
  },
): CameraSelectActionConfig | SubstreamSelectActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: action,
    camera: camera,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createFoldersViewAction(
  view: 'folder' | 'folders',
  options?: {
    cardID?: string;
    folderID?: string;
  },
): FoldersViewActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: view,
    ...(options?.folderID && { folder: options.folderID }),
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createMediaPlayerAction(
  mediaPlayer: string,
  mediaPlayerAction: 'play' | 'stop',
  options?: {
    cardID?: string;
  },
): MediaPlayerActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'media_player',
    media_player: mediaPlayer,
    media_player_action: mediaPlayerAction,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createDisplayModeAction(
  displayMode: 'single' | 'grid',
  options?: {
    cardID?: string;
  },
): DisplayModeActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'display_mode_select',
    display_mode: displayMode,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createPTZControlsAction(
  enabled: boolean,
  options?: {
    cardID?: string;
  },
): PTZControlsActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'ptz_controls',
    enabled: enabled,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createPTZAction(options?: {
  cardID?: string;
  ptzAction?: PTZAction;
  ptzPhase?: PTZActionPhase;
  ptzPreset?: string;
  cameraID?: string;
}): PTZActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'ptz',
    ...(options?.cardID && { card_id: options.cardID }),
    ...(options?.ptzAction && { ptz_action: options.ptzAction }),
    ...(options?.ptzPhase && { ptz_phase: options.ptzPhase }),
    ...(options?.ptzPreset && { ptz_preset: options.ptzPreset }),
    ...(options?.cameraID && { camera: options.cameraID }),
  };
}

export function createPTZDigitalAction(options?: {
  cardID?: string;
  ptzPhase?: PTZActionPhase;
  ptzAction?: PTZAction;
  absolute?: ZoomSettingsBase;
  targetID?: string;
}): PTZDigitialActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'ptz_digital',
    ...(options?.cardID && { card_id: options.cardID }),
    ...(options?.ptzAction && { ptz_action: options.ptzAction }),
    ...(options?.ptzPhase && { ptz_phase: options.ptzPhase }),
    ...(options?.absolute && { absolute: options.absolute }),
    ...(options?.targetID && { target_id: options.targetID }),
  };
}

export function createPTZMultiAction(options?: {
  cardID?: string;
  ptzAction?: PTZAction;
  ptzPhase?: PTZActionPhase;
  ptzPreset?: string;
  targetID?: string;
}): PTZMultiActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'ptz_multi',
    ...(options?.cardID && { card_id: options.cardID }),
    ...(options?.ptzAction && { ptz_action: options.ptzAction }),
    ...(options?.ptzPhase && { ptz_phase: options.ptzPhase }),
    ...(options?.ptzPreset && { ptz_preset: options.ptzPreset }),
    ...(options?.targetID && { target_id: options.targetID }),
  };
}

export function createLogAction(
  message: string,
  options?: {
    cardID?: string;
    level?: LogActionLevel;
  },
): LogActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: 'log',
    message: message,
    level: options?.level ?? 'info',
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createInternalCallbackAction(
  callback: (api: CardActionsAPI) => Promise<void>,
  options?: {
    cardID?: string;
  },
): InternalCallbackActionConfig {
  return {
    action: 'fire-dom-event',
    advanced_camera_card_action: INTERNAL_CALLBACK_ACTION,
    callback: callback,
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createPerformAction(
  perform_action: string,
  options?: {
    cardID?: string;
    data?: ServiceCallRequest['serviceData'];
    target?: ServiceCallRequest['target'];
  },
): PerformActionActionConfig {
  return {
    action: 'perform-action' as const,
    perform_action: perform_action,
    ...(options?.target && { target: options.target }),
    ...(options?.data && { data: options.data }),
    ...(options?.cardID && { card_id: options.cardID }),
  };
}

export function createSelectOptionAction(
  domain: 'select' | 'input_select',
  entityID: string,
  option: string,
  options?: {
    cardID?: string;
  },
): PerformActionActionConfig {
  return createPerformAction(`${domain}.select_option`, {
    ...options,
    target: {
      entity_id: entityID,
    },
    data: {
      option: option,
    },
  });
}

/**
 * Get an action configuration given a config and an interaction (e.g. 'tap').
 * @param interaction The interaction: `tap`, `hold` or `double_tap`
 * @param config The configuration containing multiple actions.
 * @returns The relevant action configuration or null if none found.
 */
export function getActionConfigGivenAction(
  interaction?: string,
  config?: ActionsConfig | null,
): ActionConfig | ActionConfig[] | null {
  if (!interaction || !config) {
    return null;
  }
  if (interaction === 'tap' && config.tap_action) {
    return config.tap_action;
  } else if (interaction === 'tap' && config.entity) {
    // As a special case, if there is an entity specified, but no action, a
    // more-info action is assumed (e.g. a menu-state-icon).
    return {
      action: 'more-info',
    };
  } else if (interaction === 'hold' && config.hold_action) {
    return config.hold_action;
  } else if (interaction === 'double_tap' && config.double_tap_action) {
    return config.double_tap_action;
  } else if (interaction === 'end_tap' && config.end_tap_action) {
    return config.end_tap_action;
  } else if (interaction === 'start_tap' && config.start_tap_action) {
    return config.start_tap_action;
  }
  return null;
}

/**
 * Determine if an action config has a real action. A modified version of
 * custom-card-helpers hasAction to also work with arrays of action configs.
 * @param config The action config in question.
 * @returns `true` if there's a real action defined, `false` otherwise.
 */
export const hasAction = (config?: ActionConfig | ActionConfig[]): boolean => {
  return arrayify(config).some((item) => item.action !== 'none');
};

export const isAdvancedCameraCardCustomAction = (
  action: ActionConfig,
): action is AdvancedCameraCardCustomActionConfig => {
  return (
    action.action === 'fire-dom-event' &&
    'advanced_camera_card_action' in action &&
    typeof action.advanced_camera_card_action === 'string'
  );
};

/**
 * Stop an event from activating card wide actions.
 */
export const stopEventFromActivatingCardWideActions = (ev: Event): void => {
  ev.stopPropagation();
};



================================================
FILE: src/utils/audio.ts
================================================
export interface AudioProperties {
  mozHasAudio?: boolean;
  audioTracks?: unknown[];
}

// There is currently no consistent cross-browser modern way to determine if a
// video element has audio tracks. The below will work in ~24% of browsers, but
// notably not in Chrome. There used to be a usable
// `webkitAudioDecodedByteCount` property, but this now seems to be consistently
// 0 in Chrome. This generously defaults to assuming there is audio when we
// cannot rule it out.
export const mayHaveAudio = (video: HTMLVideoElement & AudioProperties): boolean => {
  if (video.mozHasAudio !== undefined) {
    return video.mozHasAudio;
  }
  if (video.audioTracks !== undefined) {
    return Boolean(video.audioTracks?.length);
  }
  return true;
};



================================================
FILE: src/utils/basic.ts
================================================
import {
  differenceInHours,
  differenceInMinutes,
  differenceInSeconds,
  format,
} from 'date-fns';
import { StyleInfo } from 'lit/directives/style-map';
import { isEqualWith, mergeWith, round, uniq } from 'lodash-es';
import { AdvancedCameraCardError } from '../types';

export type ModifyInterface<T, R> = Omit<T, keyof R> & R;

/**
 * Prettify a title by converting '_' to spaces and capitalizing words.
 * @param input The input string.
 * @returns A prettified name.
 */
export function prettifyTitle(input: string): string;
export function prettifyTitle(input?: string): string | undefined;
export function prettifyTitle(input?: string): string | undefined {
  if (!input) {
    return undefined;
  }
  const words = input.trim().split(/[_\s]+/);
  return words
    .map((word) => {
      return word[0].toUpperCase() + word.substring(1);
    })
    .join(' ');
}

/**
 * Move an element within an array.
 * @param target Target array.
 * @param from From index.
 * @param to To index.
 */
export function arrayMove(target: unknown[], from: number, to: number): unknown[] {
  const element = target[from];
  target.splice(from, 1);
  target.splice(to, 0, element);
  return target;
}

/**
 * Convert a value to an array if it is not already one.
 * @param value: A value (which may be an array).
 * @returns An array.
 */
export const arrayify = <T>(value?: T | T[]): T[] => {
  return value ? (Array.isArray(value) ? value : [value]) : [];
};

/**
 * Convert a value to an set if it is not already one.
 * @param value: A value (which may be a set, an array or a T)
 * @returns A set of T.
 */
export const setify = <T>(value: T | T[] | Set<T>): Set<T> => {
  return value instanceof Set ? value : new Set(arrayify(value));
};

/**
 * Determine if the contents of the n(ew) and o(ld) values have changed. For use
 * in lit web components that may have a value that changes address but not
 * contents -- and for which a re-render is expensive/jarring.
 * @param n The new value.
 * @param o The old value.
 * @returns `true` is the contents have changed.
 */
export function contentsChanged(
  n: unknown,
  o: unknown,
  customizer?: (a: unknown, b: unknown) => boolean | undefined,
): boolean {
  return !isEqualWith(n, o, customizer);
}

/**
 * Log an error as a warning to the console.
 * @param e The Error-like object.
 * @param func The Console func to call.
 */
export function errorToConsole(
  e: Error | { message: unknown } | string,
  func: CallableFunction = console.warn,
): void {
  if (e instanceof AdvancedCameraCardError && e.context) {
    func(e, e.context);
  } else if (typeof e === 'object' && 'message' in e) {
    func(e.message);
  } else {
    func(e);
  }
}

/**
 * Determine if the device supports hovering.
 * @returns `true` if the device supports hovering, `false` otherwise.
 */
export const isHoverableDevice = (): boolean =>
  window.matchMedia('(hover: hover) and (pointer: fine)').matches;

/**
 * Format a date object to RFC3339.
 * @param date A Date object.
 * @returns A date and time.
 */
export const formatDateAndTime = (date: Date, includeSeconds?: boolean): string => {
  return format(date, `yyyy-MM-dd HH:mm${includeSeconds ? ':ss' : ''}`);
};

/**
 * Format a date object to RFC3339.
 * @param date A Date object.
 * @returns A date.
 */
export const formatDate = (date: Date): string => {
  return format(date, 'yyyy-MM-dd');
};

/**
 * Run a function in idle periods. If idle callbacks are not supported (e.g.
 * Safari) the callback is run immediately.
 * @param func The function to call.
 * @param timeout The maximum number of seconds to wait.
 */
export const runWhenIdleIfSupported = (func: () => void, timeout?: number): void => {
  if (window.requestIdleCallback) {
    window.requestIdleCallback(func, {
      ...(timeout && { timeout: timeout }),
    });
  } else {
    func();
  }
};

/**
 * Convenience function to return a string representing the difference in hours,
 * minutes and seconds between two dates. Heavily inspired by, and returning the
 * same format as, the Frigate UI:
 * https://github.com/blakeblackshear/frigate/blob/master/web/src/components/RecordingPlaylist.jsx#L97
 * @param start The start date.
 * @param end The end date.
 * @returns A duration string.
 */
export function getDurationString(start: Date, end: Date): string {
  const hours = differenceInHours(end, start);
  const minutes = differenceInMinutes(end, start) - hours * 60;
  const seconds = differenceInSeconds(end, start) - hours * 60 * 60 - minutes * 60;
  let duration = '';

  if (hours) {
    duration += `${hours}h `;
  }
  if (minutes) {
    duration += `${minutes}m `;
  }
  duration += `${seconds}s`;
  return duration;
}

export const allPromises = async <T, R>(
  items: Iterable<T>,
  func: (arg: T) => R,
): Promise<Awaited<R>[]> => {
  return await Promise.all(Array.from(items).map((item) => func(item)));
};

/**
 * Simple efficient YYYY-MM-DD -> date converter.
 */
export const dayToDate = (day: string): Date => {
  // Must provide the hour:minute:second on parsing or Javascript will assume
  // *UTC* midnight.
  return new Date(`${day}T00:00:00`);
};

export const isSuperset = (superset: Set<unknown>, subset: Set<unknown>) => {
  for (const item of subset) {
    if (!superset.has(item)) {
      return false;
    }
  }
  return true;
};

export const isValidDate = (date: Date): boolean => {
  return !isNaN(date.getTime());
};

/**
 * Set or remove an attribute on a HTMLElement.
 * @param element The element.
 * @param set If `true` sets the attribute, otherwise removes it.
 * @param name The attribute name.
 * @param value An optional value to set the attribute to.
 */
export const setOrRemoveAttribute = (
  element: HTMLElement,
  set: boolean,
  name: string,
  value?: string,
): void => {
  if (set) {
    element.setAttribute(name, value ?? '');
  } else {
    element.removeAttribute(name);
  }
};

/**
 * Allow typescript to narrow types based on truthy filter.
 */
export const isTruthy = <T>(x: T | false | undefined | null | '' | 0): x is T => !!x;

/**
 * Allow typescript to narrow types for HTMLElements.
 */
export const isHTMLElement = (element: unknown): element is HTMLElement =>
  element instanceof HTMLElement;

export const getChildrenFromElement = (parent: HTMLElement): HTMLElement[] => {
  const children =
    parent instanceof HTMLSlotElement
      ? parent.assignedElements({ flatten: true })
      : [...parent.children];
  return children.filter(isHTMLElement);
};

export const recursivelyMergeObjectsNotArrays = <T>(target: T, src1: T, src2: T): T => {
  return mergeWith(target, src1, src2, (_a, b) => (Array.isArray(b) ? b : undefined));
};

export const recursivelyMergeObjectsConcatenatingArraysUniquely = <T>(
  target: T,
  src1: T,
  src2: T,
): T => {
  return mergeWith(target, src1, src2, (a, b) =>
    Array.isArray(a) ? uniq(a.concat(b)) : undefined,
  );
};

export const aspectRatioToString = (options?: {
  ratio?: number[];
  defaultStatic?: boolean;
}): string => {
  if (options?.ratio && options.ratio.length === 2) {
    return `${options.ratio[0]} / ${options.ratio[1]}`;
  } else if (options?.defaultStatic) {
    return '16 / 9';
  } else {
    return 'auto';
  }
};

export const aspectRatioToStyle = (options?: {
  ratio?: number[];
  defaultStatic?: boolean;
}): StyleInfo => {
  return {
    'aspect-ratio': aspectRatioToString(options),
  };
};

/**
 * Remove empty slots from nested arrays.
 */
export const desparsifyArrays = <T>(data: T): T => {
  if (Array.isArray(data)) {
    return <T>(
      data.filter((item) => item !== undefined).map((item) => desparsifyArrays(item))
    );
  } else if (typeof data === 'object' && data !== null) {
    const result: Record<string | number | symbol, unknown> = {};
    for (const key in data) {
      result[key] = desparsifyArrays(data[key]);
    }
    return <T>result;
  }
  return data;
};

export const arefloatsApproximatelyEqual = (
  a: number,
  b: number,
  precision?: number,
): boolean => {
  return round(a, precision) === round(b, precision);
};

/**
 * Create a lodash isEqualsWith customizer that can compare floats.
 */
export const generateFloatApproximatelyEqualsCustomizer = (
  precision: number,
): ((a: unknown, b: unknown) => boolean | undefined) => {
  return (a: unknown, b: unknown) => {
    return typeof a === 'number' && typeof b === 'number'
      ? arefloatsApproximatelyEqual(a, b, precision)
      : undefined;
  };
};



================================================
FILE: src/utils/camera.ts
================================================
import { CameraConfig } from '../config/schema/cameras';
import { RawAdvancedCameraCardConfig } from '../config/types';

/**
 * Get a camera id.
 * @param config The camera config (either parsed or raw).
 * @returns A camera id.
 */
export function getCameraID(
  config?: CameraConfig | RawAdvancedCameraCardConfig | null,
): string {
  return (
    (typeof config?.id === 'string' && config.id) ||
    (typeof config?.camera_entity === 'string' && config.camera_entity) ||
    (typeof config?.webrtc_card === 'object' &&
      config.webrtc_card &&
      ((typeof config.webrtc_card['entity'] === 'string' &&
        config.webrtc_card['entity']) ||
        (typeof config.webrtc_card['url'] === 'string' && config.webrtc_card['url']))) ||
    (typeof config?.go2rtc === 'object' &&
      config.go2rtc &&
      typeof config.go2rtc['url'] === 'string' &&
      typeof config.go2rtc['stream'] === 'string' &&
      // Artifical identifier that includes both url / stream.
      `${config.go2rtc['url']}#${config.go2rtc['stream']}`) ||
    (typeof config?.frigate === 'object' &&
      config.frigate &&
      typeof config?.frigate['camera_name'] === 'string' &&
      config.frigate['camera_name']) ||
    ''
  );
}



================================================
FILE: src/utils/casting.ts
================================================
/**
 * Determine if the card is currently being casted.
 * @returns
 */
export const isBeingCasted = (): boolean => {
  return !!navigator.userAgent.match(/CrKey\//);
};



================================================
FILE: src/utils/companion.ts
================================================
export const isCompanionApp = (userAgent: string): boolean => {
  return !!userAgent.match(/Home ?Assistant/);
};

export const isAndroidCompanionApp = (userAgent: string): boolean => {
  return !!userAgent.match(/(?=.*Home ?Assistant)(?=.*Android)/);
};

export const isIOSCompanionApp = (userAgent: string): boolean => {
  return !!userAgent.match(/(?=.*Home ?Assistant)(?=.*iOS)/);
};



================================================
FILE: src/utils/controls.ts
================================================
import { Timer } from './timer';

// The number of seconds to hide the video controls for after loading (in order
// to give a cleaner UI appearance, see:
// https://github.com/dermotduffy/advanced-camera-card/issues/856
export const MEDIA_LOAD_CONTROLS_HIDE_SECONDS = 2;
const MEDIA_SEEK_CONTROLS_HIDE_SECONDS = 1;

export type AdvancedCameraCardHTMLVideoElement = HTMLVideoElement & {
  _controlsHideTimer?: Timer;
  _controlsOriginalValue?: boolean;
};

/**
 * Sets the controls on a video and removes a timer that may have been added by
 * hideMediaControlsTemporarily.
 * @param video
 * @param value
 */
export const setControlsOnVideo = (
  video: AdvancedCameraCardHTMLVideoElement,
  value: boolean,
): void => {
  if (video._controlsHideTimer) {
    video._controlsHideTimer.stop();
    delete video._controlsHideTimer;
    delete video._controlsOriginalValue;
  }
  video.controls = value;
};

/**
 * Temporarily hide media controls.
 * @param element Any HTMLElement that has a controls property (e.g.
 * HTMLVideoElement, AdvancedCameraCardHaHlsPlayer)
 * @param seconds The number of seconds to hide the controls for.
 */
export const hideMediaControlsTemporarily = (
  video: AdvancedCameraCardHTMLVideoElement,
  seconds = MEDIA_SEEK_CONTROLS_HIDE_SECONDS,
): void => {
  const oldValue = video._controlsOriginalValue ?? video.controls;
  setControlsOnVideo(video, false);
  video._controlsHideTimer ??= new Timer();
  video._controlsOriginalValue = oldValue;

  // LitElement may change the src attribute of the video element during
  // rendering, so we need to ensure that the controls are reset on the 'old'
  // video. See:
  // https://github.com/dermotduffy/advanced-camera-card/issues/1310
  const resetIfReloaded = () => {
    setControlsOnVideo(video, oldValue);
    video.removeEventListener('loadstart', resetIfReloaded);
  };
  video.addEventListener('loadstart', resetIfReloaded);

  video._controlsHideTimer.start(seconds, () => {
    setControlsOnVideo(video, oldValue);
  });
};



================================================
FILE: src/utils/debug.ts
================================================
import { CardWideConfig } from '../config/schema/types';

export const log = (cardWideConfig?: CardWideConfig | null, ...args: unknown[]) => {
  if (cardWideConfig?.debug?.logging) {
    console.debug(...args);
  }
};



================================================
FILE: src/utils/diagnostics.ts
================================================
import pkg from '../../package.json';
import { RawAdvancedCameraCardConfig } from '../config/types';
import { getIntegrationManifest } from '../ha/integration';
import { IntegrationManifest } from '../ha/integration/types';
import { DeviceRegistryManager } from '../ha/registry/device';
import { HomeAssistant } from '../ha/types';
import { HASS_WEB_PROXY_DOMAIN } from '../ha/web-proxy';
import { getLanguage } from '../localize/localize';

type FrigateDevices = Record<string, string>;

interface GitDiagnostics {
  build_version?: string;
  build_date?: string;
  commit_date?: string;
}

interface IntegrationDiagnostics {
  detected: boolean;
  version?: string;
}

export const getReleaseVersion = (): string => {
  const releaseVersion: string = '__ADVANCED_CAMERA_CARD_RELEASE_VERSION__';

  /* istanbul ignore if: depends on rollup substitution -- @preserve */
  if (releaseVersion === 'pkg') {
    return pkg.version;
  }

  /* istanbul ignore if: depends on rollup substitution -- @preserve */
  if (releaseVersion === 'dev') {
    return `dev+${pkg['gitAbbrevHash']}`;
  }

  return releaseVersion;
};

interface Diagnostics {
  card_version: string;
  browser: string;
  date: Date;
  lang: string;
  timezone: string;
  git: GitDiagnostics;

  ha_version?: string;
  config?: RawAdvancedCameraCardConfig;

  custom_integrations: {
    frigate: IntegrationDiagnostics & {
      devices?: FrigateDevices;
    };
    hass_web_proxy: IntegrationDiagnostics;
  };
}

const getIntegrationDiagnostics = async (
  integration: string,
  hass?: HomeAssistant,
): Promise<IntegrationDiagnostics> => {
  let manifest: IntegrationManifest | null = null;

  if (hass) {
    try {
      manifest = await getIntegrationManifest(hass, integration);
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (e) {
      // Silently ignore integrations not being found.
    }
  }

  return {
    detected: !!manifest,
    ...(manifest?.version && { version: manifest.version }),
  };
};

export const getDiagnostics = async (
  hass?: HomeAssistant,
  deviceRegistryManager?: DeviceRegistryManager,
  rawConfig?: RawAdvancedCameraCardConfig,
): Promise<Diagnostics> => {
  // Get the Frigate devices in order to extract the Frigate integration and
  // server version numbers.
  const frigateDevices =
    hass && deviceRegistryManager
      ? await deviceRegistryManager.getMatchingDevices(
          hass,
          (device) => device.manufacturer === 'Frigate',
        )
      : [];

  const frigateVersionMap: Map<string, string> = new Map();
  frigateDevices?.forEach((device) => {
    device.config_entries.forEach((configEntry) => {
      if (device.model) {
        frigateVersionMap.set(configEntry, device.model);
      }
    });
  });

  return {
    card_version: getReleaseVersion(),
    browser: navigator.userAgent,
    date: new Date(),
    lang: getLanguage(),
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    git: {
      ...(pkg['gitAbbrevHash'] && { hash: pkg['gitAbbrevHash'] }),
      ...(pkg['buildDate'] && { build_date: pkg['buildDate'] }),
      ...(pkg['gitDate'] && { commit_date: pkg['gitDate'] }),
    },
    ...(hass && { ha_version: hass.config.version }),
    custom_integrations: {
      frigate: {
        ...(await getIntegrationDiagnostics('frigate', hass)),
        ...(frigateVersionMap.size && {
          devices: Object.fromEntries(frigateVersionMap),
        }),
      },
      hass_web_proxy: await getIntegrationDiagnostics(HASS_WEB_PROXY_DOMAIN, hass),
    },
    ...(rawConfig && { config: rawConfig }),
  };
};



================================================
FILE: src/utils/download.ts
================================================
export const downloadURL = (url: string, filename = 'download'): void => {
  // The download attribute only works on the same origin.
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attributes
  const isSameOrigin = new URL(url).origin === window.location.origin;
  const dataURL = url.startsWith('data:');

  if (!isSameOrigin && !dataURL) {
    window.open(url, '_blank');
    return;
  }

  // Use the HTML5 download attribute to prevent a new window from
  // temporarily opening.
  const link = document.createElement('a');
  link.setAttribute('download', filename);
  link.href = url;
  link.click();
  link.remove();
};



================================================
FILE: src/utils/endpoint.ts
================================================
import { homeAssistantSignPath } from '../ha/sign-path';
import { HomeAssistant } from '../ha/types';
import { Endpoint } from '../types';
import { errorToConsole } from './basic';

export const convertEndpointAddressToSignedWebsocket = async (
  hass: HomeAssistant,
  endpoint: Endpoint,
  expires?: number,
): Promise<string | null> => {
  if (!endpoint.sign) {
    return endpoint.endpoint;
  }

  let response: string | null | undefined;
  try {
    response = await homeAssistantSignPath(hass, endpoint.endpoint, expires);
  } catch (e) {
    errorToConsole(e as Error);
  }

  return response ? response.replace(/^http/i, 'ws') : null;
};



================================================
FILE: src/utils/find-best-media-time-index.ts
================================================
import { ViewItem } from '../view/item';
import { ViewItemClassifier } from '../view/item-classifier';

/**
 * Find the longest matching media object that contains a given targetTime.
 * Longest is chosen to give the most stability to the media viewer.
 * @param mediaArray The media.
 * @param targetTime The target time used to find the relevant child.
 * @returns The childindex or null if no matching child is found.
 */
export const findBestMediaTimeIndex = (
  mediaArray: ViewItem[],
  targetTime: Date,
  favorCameraID?: string,
): number | null => {
  let bestMatch:
    | {
        index: number;
        duration: number;
        cameraID: string | null;
      }
    | undefined;

  for (const [i, media] of mediaArray.entries()) {
    if (!ViewItemClassifier.isMedia(media)) {
      continue;
    }
    const start = media.getStartTime();
    const end = media.getUsableEndTime();

    if (media.includesTime(targetTime) && start && end) {
      const duration = end.getTime() - start.getTime();

      if (
        // No best match so far ...
        !bestMatch ||
        // ... or there is a best-match, but it's from a non-favored camera (unlike this one) ...
        (favorCameraID &&
          bestMatch.cameraID !== favorCameraID &&
          media.getCameraID() === favorCameraID) ||
        // ... or this match is longer and either there's no favored camera or this is it.
        (duration > bestMatch.duration &&
          (!favorCameraID ||
            bestMatch.cameraID !== favorCameraID ||
            media.getCameraID() === favorCameraID))
      ) {
        bestMatch = { index: i, duration: duration, cameraID: media.getCameraID() };
      }
    }
  }
  return bestMatch ? bestMatch.index : null;
};



================================================
FILE: src/utils/fire-advanced-camera-card-event.ts
================================================
/**
 * Dispatch an Advanced Camera Card event.
 * @param target The target from which send the event.
 * @param type The type of the Advanced Camera Card event to send.
 * @param detail An optional detail object to attach.
 */
export function fireAdvancedCameraCardEvent<T>(
  target: EventTarget,
  type: string,
  detail?: T,
  options?: {
    bubbles?: boolean;
    cancelable?: boolean;
    composed?: boolean;
  },
): void {
  target.dispatchEvent(
    new CustomEvent<T>(`advanced-camera-card:${type}`, {
      bubbles: options?.bubbles ?? true,
      composed: options?.composed ?? true,
      cancelable: options?.cancelable ?? false,
      detail: detail,
    }),
  );
}



================================================
FILE: src/utils/interaction-mode.ts
================================================
import { InteractionMode } from '../config/schema/view';

export const isActionAllowedBasedOnInteractionState = (
  interactionMode: InteractionMode,
  interactionState: boolean,
): boolean => {
  switch (interactionMode) {
    case 'all':
      return true;
    case 'active':
      return interactionState;
    case 'inactive':
      return !interactionState;
  }
};



================================================
FILE: src/utils/media-info.ts
================================================
import {
  MediaLoadedCapabilities,
  MediaLoadedInfo,
  MediaPlayerController,
  MediaTechnology,
} from '../types.js';
import { fireAdvancedCameraCardEvent } from './fire-advanced-camera-card-event.js';

const MEDIA_INFO_HEIGHT_CUTOFF = 50;
const MEDIA_INFO_WIDTH_CUTOFF = MEDIA_INFO_HEIGHT_CUTOFF;

/**
 * Create a MediaLoadedInfo object.
 * @param source An event or HTMLElement that should be used as a source.
 * @returns A new MediaLoadedInfo object or null if one could not be created.
 */
export function createMediaLoadedInfo(
  source: Event | HTMLElement,
  options?: {
    mediaPlayerController?: MediaPlayerController;
    capabilities?: MediaLoadedCapabilities;
    technology?: MediaTechnology[];
  },
): MediaLoadedInfo | null {
  let target: HTMLElement | EventTarget;
  if (source instanceof Event) {
    target = source.composedPath()[0];
  } else {
    target = source;
  }

  if (target instanceof HTMLImageElement) {
    return {
      width: (target as HTMLImageElement).naturalWidth,
      height: (target as HTMLImageElement).naturalHeight,
      ...options,
    };
  } else if (target instanceof HTMLVideoElement) {
    return {
      width: (target as HTMLVideoElement).videoWidth,
      height: (target as HTMLVideoElement).videoHeight,
      ...options,
    };
  } else if (target instanceof HTMLCanvasElement) {
    return {
      width: (target as HTMLCanvasElement).width,
      height: (target as HTMLCanvasElement).height,
      mediaPlayerController: options?.mediaPlayerController,
      ...options,
    };
  }
  return null;
}

/**
 * Dispatch an Advanced Camera Card media loaded event.
 * @param element The element to send the event.
 * @param source An event or HTMLElement that should be used as a source.
 */
export function dispatchMediaLoadedEvent(
  target: HTMLElement,
  source: Event | HTMLElement,
  options?: {
    mediaPlayerController?: MediaPlayerController;
    capabilities?: MediaLoadedCapabilities;
    technology?: MediaTechnology[];
  },
): void {
  const mediaLoadedInfo = createMediaLoadedInfo(source, options);
  if (mediaLoadedInfo) {
    dispatchExistingMediaLoadedInfoAsEvent(target, mediaLoadedInfo);
  }
}

/**
 * Dispatch a pre-existing MediaLoadedInfo object as an event.
 * @param element The element to send the event.
 * @param mediaLoadedInfo The MediaLoadedInfo object to send.
 */
export function dispatchExistingMediaLoadedInfoAsEvent(
  target: EventTarget,
  mediaLoadedInfo: MediaLoadedInfo,
): void {
  fireAdvancedCameraCardEvent<MediaLoadedInfo>(target, 'media:loaded', mediaLoadedInfo);
}

/**
 * Dispatch a media unloaded event.
 * @param element The element to send the event.
 */
export function dispatchMediaUnloadedEvent(element: HTMLElement): void {
  fireAdvancedCameraCardEvent(element, 'media:unloaded');
}

export function dispatchMediaVolumeChangeEvent(target: HTMLElement): void {
  fireAdvancedCameraCardEvent(target, 'media:volumechange');
}

export function dispatchMediaPlayEvent(target: HTMLElement): void {
  fireAdvancedCameraCardEvent(target, 'media:play');
}

export function dispatchMediaPauseEvent(target: HTMLElement): void {
  fireAdvancedCameraCardEvent(target, 'media:pause');
}

/**
 * Determine if a MediaLoadedInfo object is valid/acceptable.
 * @param info The MediaLoadedInfo object.
 * @returns True if the object is valid, false otherwise.
 */
export function isValidMediaLoadedInfo(info: MediaLoadedInfo): boolean {
  return (
    info.height >= MEDIA_INFO_HEIGHT_CUTOFF && info.width >= MEDIA_INFO_WIDTH_CUTOFF
  );
}

// Facilitates correct typing of event handlers.
export interface AdvancedCameraCardMediaLoadedEventTarget extends EventTarget {
  addEventListener(
    event: 'advanced-camera-card:media:loaded',
    listener: (
      this: AdvancedCameraCardMediaLoadedEventTarget,
      ev: CustomEvent<MediaLoadedInfo>,
    ) => void,
    options?: AddEventListenerOptions | boolean,
  ): void;
  addEventListener(
    event: 'advanced-camera-card:media:unloaded',
    listener: (this: AdvancedCameraCardMediaLoadedEventTarget, ev: CustomEvent) => void,
    options?: AddEventListenerOptions | boolean,
  ): void;
  addEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: AddEventListenerOptions | boolean,
  ): void;
  removeEventListener(
    event: 'advanced-camera-card:media:loaded',
    listener: (
      this: AdvancedCameraCardMediaLoadedEventTarget,
      ev: CustomEvent<MediaLoadedInfo>,
    ) => void,
    options?: boolean | EventListenerOptions,
  ): void;
  removeEventListener(
    event: 'advanced-camera-card:media:unloaded',
    listener: (this: AdvancedCameraCardMediaLoadedEventTarget, ev: CustomEvent) => void,
    options?: boolean | EventListenerOptions,
  ): void;
  removeEventListener(
    type: string,
    callback: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions,
  ): void;
}



================================================
FILE: src/utils/media-layout.ts
================================================
import { MediaLayoutConfig } from '../config/schema/camera/media-layout';

/**
 * Update element style from a media configuration.
 * @param element The element to update the style for.
 * @param mediaLayoutConfig The media config object.
 */
export const updateElementStyleFromMediaLayoutConfig = (
  element: HTMLElement,
  mediaLayoutConfig?: MediaLayoutConfig,
): void => {
  if (mediaLayoutConfig?.fit !== undefined) {
    element.style.setProperty(
      '--advanced-camera-card-media-layout-fit',
      mediaLayoutConfig.fit,
    );
  } else {
    element.style.removeProperty('--advanced-camera-card-media-layout-fit');
  }
  for (const dimension of ['x', 'y']) {
    if (mediaLayoutConfig?.position?.[dimension] !== undefined) {
      element.style.setProperty(
        `--advanced-camera-card-media-layout-position-${dimension}`,
        `${mediaLayoutConfig.position[dimension]}%`,
      );
    } else {
      element.style.removeProperty(
        `--advanced-camera-card-media-layout-position-${dimension}`,
      );
    }
  }
  for (const dimension of ['top', 'bottom', 'left', 'right']) {
    if (mediaLayoutConfig?.view_box?.[dimension] !== undefined) {
      element.style.setProperty(
        `--advanced-camera-card-media-layout-view-box-${dimension}`,
        `${mediaLayoutConfig.view_box[dimension]}%`,
      );
    } else {
      element.style.removeProperty(
        `--advanced-camera-card-media-layout-view-box-${dimension}`,
      );
    }
  }
};



================================================
FILE: src/utils/ptz.ts
================================================
import { CameraManager } from '../camera-manager/manager';
import { PTZAction } from '../config/schema/actions/custom/ptz';
import { IMAGE_VIEW_ZOOM_TARGET_SENTINEL } from '../const';
import { PTZCapabilities } from '../types';
import { View } from '../view/view';
import { getStreamCameraID } from './substream';

export type PTZType = 'digital' | 'ptz';
interface PTZTarget {
  targetID: string;
  type: PTZType;
}

export const getPTZTarget = (
  view: View,
  options?: {
    type?: PTZType;
    cameraManager?: CameraManager;
  },
): PTZTarget | null => {
  if (view.isViewerView()) {
    const targetID = view.queryResults?.getSelectedResult()?.getID() ?? null;
    return options?.type === 'ptz' || !targetID
      ? null
      : {
          targetID: targetID,
          type: 'digital',
        };
  } else if (view.is('live')) {
    const substreamAwareCameraID = getStreamCameraID(view);
    let type: PTZType = 'digital';

    if (options?.type !== 'digital' && options?.cameraManager) {
      if (hasCameraTruePTZ(options.cameraManager, substreamAwareCameraID)) {
        type = 'ptz';
      }
      if (type !== 'ptz' && options?.type === 'ptz') {
        return null;
      }
    }

    return {
      targetID: substreamAwareCameraID,
      type: type,
    };
  } else if (view.is('image')) {
    return {
      targetID: IMAGE_VIEW_ZOOM_TARGET_SENTINEL,
      type: 'digital',
    };
  }
  return null;
};

export const hasCameraTruePTZ = (
  cameraManager: CameraManager,
  cameraID: string,
): boolean => {
  return !!cameraManager
    .getStore()
    .getCamera(cameraID)
    ?.getCapabilities()
    ?.hasPTZCapability();
};

export const ptzActionToCapabilityKey = (
  action: PTZAction,
): keyof PTZCapabilities | null => {
  switch (action) {
    case 'left':
    case 'right':
    case 'up':
    case 'down':
      return action;
    case 'zoom_in':
      return 'zoomIn';
    case 'zoom_out':
      return 'zoomOut';
  }
  return null;
};



================================================
FILE: src/utils/regexp-extract.ts
================================================
/**
 * Extracts a substring from a string using a regular expression pattern, if
 * groupName / groupNumber is specified but not found in the result, the full
 * match is returned.
 */
export const regexpExtract = (
  pattern: string | RegExp,
  val: string,
  options?: {
    groupName?: string;
    groupNumber?: number;
  },
): string | null => {
  const match = val.match(pattern);
  if (options?.groupName && match?.groups?.[options.groupName]) {
    return match.groups[options.groupName];
  }
  if (options?.groupNumber !== undefined && match?.[options.groupNumber]) {
    return match[options.groupNumber];
  }
  return match ? match[0] : null;
};



================================================
FILE: src/utils/screenshot.ts
================================================
import { format } from 'date-fns';
import { View } from '../view/view';

export const screenshotImage = (image: HTMLImageElement): string | null => {
  return screenshotElement(image, image.naturalWidth, image.naturalHeight);
};

export const screenshotVideo = (video: HTMLVideoElement): string | null => {
  return screenshotElement(video, video.videoWidth, video.videoHeight);
};

const screenshotElement = (
  src: CanvasImageSource,
  width: number,
  height: number,
): string | null => {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    return null;
  }
  ctx.drawImage(src, 0, 0, canvas.width, canvas.height);
  return canvas.toDataURL('image/jpeg');
};

export const generateScreenshotFilename = (view?: View | null): string => {
  if (view?.is('live') || view?.is('image')) {
    return `${view.view}_${view.camera}_${format(
      new Date(),
      `yyyy-MM-dd-HH-mm-ss`,
    )}.jpg`;
  } else if (view?.isViewerView()) {
    const media = view.queryResults?.getSelectedResult();
    const id = media?.getID() ?? null;
    return `${view.view}_${view.camera}${id ? `_${id}` : ''}.jpg`;
  }
  return 'screenshot.jpg';
};



================================================
FILE: src/utils/scroll.ts
================================================
import { compute as computeScroll, Options } from 'compute-scroll-into-view';

// Alternative to the stock element.scrollIntoView that suppports limiting
// scrolling to a boundary, rather than the entire browser root.
//
// See: https://github.com/dermotduffy/advanced-camera-card/issues/1814
// See: https://github.com/w3c/csswg-drafts/issues/9452
export const scrollIntoView = (element: HTMLElement, options: Options) => {
  computeScroll(element, options).forEach(({ el, top, left }) => {
    el.scrollTop = top;
    el.scrollLeft = left;
  });
};



================================================
FILE: src/utils/sleep.ts
================================================
// Usage of this function needs to be justified with a comment.
export const sleep = async (seconds: number) => {
  await new Promise((r) => setTimeout(r, seconds * 1000));
};



================================================
FILE: src/utils/substream.ts
================================================
import { View } from '../view/view';

export const getStreamCameraID = (view: View, cameraID?: string): string => {
  return (
    view.context?.live?.overrides?.get(cameraID ?? view.camera) ??
    cameraID ??
    view.camera
  );
};

export const hasSubstream = (view: View): boolean => {
  return getStreamCameraID(view) !== view.camera;
};

export const setSubstream = (view: View, substreamID: string): void => {
  const overrides: Map<string, string> = view.context?.live?.overrides ?? new Map();
  overrides.set(view.camera, substreamID);
  view.mergeInContext({
    live: { overrides: overrides },
  });
};

export const removeSubstream = (view: View): void => {
  const overrides: Map<string, string> | undefined = view.context?.live?.overrides;
  if (overrides && overrides.has(view.camera)) {
    view.context?.live?.overrides?.delete(view.camera);
  }
};



================================================
FILE: src/utils/task.ts
================================================
import { Task } from '@lit-labs/task';
import { html, TemplateResult } from 'lit';
import { renderProgressIndicator } from '../components/progress-indicator';
import { CardWideConfig } from '../config/schema/types';
import { errorToConsole } from './basic';

/**
 * Render the result of a Lit task.
 * @param host The host object.
 * @param task The Lit task.
 * @param completeFunc The function to call with the result.
 * @param inProgressFunc The function to call whilst in progress.
 * @returns A template.
 */
export const renderTask = <R>(
  task: Task<unknown[], R>,
  completeFunc: (result: R) => TemplateResult | void,
  options?: {
    cardWideConfig?: CardWideConfig;
    inProgressFunc?: () => TemplateResult | void;
    errorFunc?: (e: Error) => TemplateResult | void;
  },
): TemplateResult => {
  const progressConfig = {
    ...(options?.cardWideConfig && { cardWideConfig: options.cardWideConfig }),
  };
  return html` ${task.render({
    initial: () =>
      options?.inProgressFunc?.() ?? renderProgressIndicator(progressConfig),
    pending: () =>
      options?.inProgressFunc?.() ?? renderProgressIndicator(progressConfig),
    error: (e: unknown) => {
      errorToConsole(e as Error);
      return options?.errorFunc?.(e as Error);
    },
    complete: completeFunc,
  })}`;
};



================================================
FILE: src/utils/text-direction.ts
================================================
export type TextDirection = 'ltr' | 'rtl';

export const getTextDirection = (element: HTMLElement): TextDirection => {
  return getComputedStyle(element).direction === 'rtl' ? 'rtl' : 'ltr';
};



================================================
FILE: src/utils/thumbnail.ts
================================================
import { Task } from '@lit-labs/task';
import { ReactiveControllerHost } from '@lit/reactive-element';
import { HomeAssistant } from '../ha/types';

// See: https://github.com/sindresorhus/is-absolute-url
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;

/**
 * Fetch a thumbnail URL and return a data URL.
 * @param hass Home Assistant object.
 * @param thumbnailURL The thumbnail URL.
 * @returns A base64 encoded data URL for the thumbnail.
 */
const fetchThumbnail = async (
  hass: HomeAssistant,
  thumbnailURL: string,
): Promise<string | null> => {
  if (thumbnailURL.startsWith('data:') || thumbnailURL.match(ABSOLUTE_URL_REGEX)) {
    return thumbnailURL;
  }
  return new Promise((resolve, reject) => {
    hass
      .fetchWithAuth(thumbnailURL)
      // Since we are fetching with an authorization header, we cannot just put the
      // URL directly into the document; we need to embed the image. We could do this
      // using blob URLs, but then we would need to keep track of them in order to
      // release them properly. Instead, we embed the thumbnail using base64.
      .then((response) => {
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        return response.blob();
      })
      .then((blob) => {
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          resolve(typeof result === 'string' ? result : null);
        };
        reader.onerror = (e) => reject(e);
        reader.readAsDataURL(blob);
      })
      .catch((e) => reject(e));
  });
};

export type FetchThumbnailTaskArgs = [boolean, string | undefined];

/**
 * Create a Lit task to fetch a thumbnail.
 * @param host The Lit Element.
 * @param getHASS A function to get the Home Assistant object.
 * @param getThumbnail A function to get the Thumbnail URL.
 * @returns A new Lit Task.
 */
export const createFetchThumbnailTask = (
  host: ReactiveControllerHost,
  getHASS: () => HomeAssistant | undefined,
  getThumbnailURL: () => string | undefined,
  autoRun = true,
): Task<FetchThumbnailTaskArgs, string | null> => {
  return new Task(host, {
    // Do not re-run the task if hass changes, unless it was previously undefined.
    args: (): FetchThumbnailTaskArgs => [!!getHASS(), getThumbnailURL()],
    task: async ([haveHASS, thumbnailURL]: FetchThumbnailTaskArgs): Promise<
      string | null
    > => {
      const hass = getHASS();
      if (!haveHASS || !hass || !thumbnailURL) {
        return null;
      }
      return await fetchThumbnail(hass, thumbnailURL);
    },
    autoRun: autoRun,
  });
};



================================================
FILE: src/utils/timer.ts
================================================
export class Timer {
  protected _timer: number | null = null;
  protected _repeated = false;

  public stop(): void {
    if (this._timer) {
      if (this._repeated) {
        window.clearInterval(this._timer);
      } else {
        window.clearTimeout(this._timer);
      }
      this._timer = null;
    }
  }

  public isRunning(): boolean {
    return this._timer !== null;
  }

  public start(seconds: number, func: () => void): void {
    this.stop();
    this._timer = window.setTimeout(() => {
      this._timer = null;
      func();
    }, seconds * 1000);
    this._repeated = false;
  }

  public startRepeated(seconds: number, func: () => void): void {
    this.stop();
    this._timer = window.setInterval(() => {
      func();
    }, seconds * 1000);
    this._repeated = true;
  }
}



================================================
FILE: src/utils/zod.ts
================================================
import { z } from 'zod';

/**
 * Recursively remove defaults from a zod schema.
 *
 * See: https://github.com/colinhacks/zod/discussions/845#discussioncomment-1936943
 *
 * @param schema The Zod schema.
 * @returns A new Zod schema.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function deepRemoveDefaults<T extends z.ZodTypeAny>(schema: T): any {
  if (schema instanceof z.ZodDefault) {
    return deepRemoveDefaults(schema.removeDefault());
  }

  if (schema instanceof z.ZodObject) {
    const newShape = {};

    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = z.ZodOptional.create(deepRemoveDefaults(fieldSchema));
    }
    return new z.ZodObject({
      ...schema._def,
      shape: () => newShape,
    });
  }

  if (schema instanceof z.ZodArray) {
    return z.ZodArray.create(deepRemoveDefaults(schema.element))
      .min(schema._def.minLength?.value, schema._def.minLength?.message)
      .max(schema._def.maxLength?.value, schema._def.maxLength?.message)
      .length(schema._def.exactLength?.value, schema._def.exactLength?.message);
  }

  if (schema instanceof z.ZodOptional) {
    return z.ZodOptional.create(deepRemoveDefaults(schema.unwrap()));
  }

  if (schema instanceof z.ZodNullable) {
    return z.ZodNullable.create(deepRemoveDefaults(schema.unwrap()));
  }

  if (schema instanceof z.ZodTuple) {
    return z.ZodTuple.create(
      schema.items.map((item: z.ZodTypeAny) => deepRemoveDefaults(item)),
    );
  }
  return schema;
}

/**
 * Get the keys that didn't parse from a ZodError.
 * @param error The zoderror to extract the keys from.
 * @returns An array of error keys.
 */
export function getParseErrorKeys<T>(error: z.ZodError<T>): string[] {
  const errors = error.format();
  return Object.keys(errors).filter((v) => !v.startsWith('_'));
}

/**
 * Get configuration parse errors.
 * @param error The ZodError object from parsing.
 * @returns An array of string error paths.
 */
export const getParseErrorPaths = <T>(error: z.ZodError<T>): Set<string> => {
  /* Zod errors involving unions are complex, as Zod may not be able to tell
   * where the 'real' error is vs simply a union option not matching. This
   * function finds all ZodError "issues" that don't have an error with 'type'
   * in that object ('type' is the union discriminator for picture elements,
   * the major union in the schema). An array of user-readable error
   * locations is returned, or an empty list if none is available. None being
   * available suggests the configuration has an error, but we can't tell
   * exactly why (or rather Zod simply says it doesn't match any of the
   * available unions). This usually suggests the user specified an incorrect
   * type name entirely. */
  const contenders = new Set<string>();
  if (error.issues.length) {
    for (const issue of error.issues) {
      if (issue.code === 'invalid_union') {
        const unionErrors = (issue as z.ZodInvalidUnionIssue).unionErrors;
        for (const unionError of unionErrors) {
          getParseErrorPaths(unionError).forEach(contenders.add, contenders);
        }
      } else {
        contenders.add(getParseErrorPathString(issue.path));
      }
    }
  }
  return contenders;
};

/**
 * Convert an array of strings and indices into a more user readable string,
 * e.g. [a, 1, b, 2] => 'a[1] -> b[2]'
 * @param path An array of strings and numbers.
 * @returns A single string.
 */
const getParseErrorPathString = (path: (string | number)[]): string => {
  let out = '';
  for (let i = 0; i < path.length; i++) {
    const item = path[i];
    if (typeof item == 'number') {
      out += '[' + item + ']';
    } else if (out) {
      out += ' -> ' + item;
    } else {
      out = item;
    }
  }
  return out;
};



================================================
FILE: src/utils/embla/carousel-controller.ts
================================================
import EmblaCarousel, { EmblaCarouselType } from 'embla-carousel';
import { WheelGesturesPlugin } from 'embla-carousel-wheel-gestures';
import { CreatePluginType, LoosePluginType } from 'embla-carousel/components/Plugins';
import { isEqual } from 'lodash-es';
import { TransitionEffect } from '../../config/schema/common/transition-effect.js';
import { getChildrenFromElement } from '../basic.js';
import { fireAdvancedCameraCardEvent } from '../fire-advanced-camera-card-event';
import { TextDirection } from '../text-direction';

export interface CarouselSelected {
  index: number;
  element: HTMLElement;
}

type EmblaCarouselPlugins = CreatePluginType<LoosePluginType, Record<string, unknown>>[];

export type CarouselDirection = 'vertical' | 'horizontal';

export class CarouselController {
  protected _parent: HTMLElement;
  protected _root: HTMLElement;
  protected _direction: CarouselDirection;
  protected _startIndex: number;
  protected _transitionEffect: TransitionEffect;
  protected _loop: boolean;
  protected _dragFree: boolean;
  protected _draggable: boolean;
  protected _textDirection: TextDirection;

  protected _plugins: EmblaCarouselPlugins;
  protected _carousel: EmblaCarouselType;

  protected _mutationObserver = new MutationObserver(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (_mutations: MutationRecord[], _observer: MutationObserver) =>
      this._refreshCarouselContents(),
  );

  constructor(
    root: HTMLElement,
    parent: HTMLElement,
    options?: {
      direction?: CarouselDirection;
      transitionEffect?: TransitionEffect;
      startIndex?: number;
      loop?: boolean;
      dragEnabled?: boolean;
      dragFree?: boolean;
      plugins?: EmblaCarouselPlugins;
      textDirection?: TextDirection;
    },
  ) {
    this._root = root;
    this._parent = parent;
    this._direction = options?.direction ?? 'horizontal';
    this._transitionEffect = options?.transitionEffect ?? 'slide';
    this._startIndex = options?.startIndex ?? 0;
    this._dragFree = options?.dragFree ?? false;
    this._loop = options?.loop ?? false;
    this._draggable = options?.dragEnabled ?? true;
    this._plugins = options?.plugins ?? [];
    this._textDirection = options?.textDirection ?? 'ltr';

    this._carousel = this._createCarousel(getChildrenFromElement(this._parent));

    // Need to separately listen for slotchanges since mutation observer will
    // not be called for shadom DOM slotted changes.
    if (parent instanceof HTMLSlotElement) {
      parent.addEventListener('slotchange', this._refreshCarouselContents);
    }
    this._mutationObserver.observe(this._parent, { childList: true });
  }

  public destroy() {
    if (this._parent instanceof HTMLSlotElement) {
      this._parent.removeEventListener('slotchange', this._refreshCarouselContents);
    }
    this._mutationObserver.disconnect();
    this._carousel.destroy();
  }

  public getSlide(index: number): HTMLElement | null {
    return this._carousel.slideNodes()[index] ?? null;
  }

  public getSelectedSlide(): HTMLElement | null {
    return this.getSlide(this.getSelectedIndex());
  }

  public getSelectedIndex(): number {
    return this._carousel.selectedScrollSnap();
  }

  public selectSlide(index: number): void {
    this._carousel.scrollTo(index, this._transitionEffect === 'none');

    // This event exists to allow the caller to know the difference between
    // programatically force slide selections and user-driven slide selections
    // (e.g. carousel drags). See the note in auto-media-loaded-info.ts on how
    // this is used.
    const newSlide = this.getSlide(index);
    if (newSlide) {
      fireAdvancedCameraCardEvent<CarouselSelected>(
        this._parent,
        'carousel:force-select',
        {
          index: index,
          element: newSlide,
        },
      );
    }
  }

  protected _refreshCarouselContents = (): void => {
    const newSlides = getChildrenFromElement(this._parent);
    const slidesChanged = !isEqual(this._carousel.slideNodes(), newSlides);
    if (slidesChanged) {
      this._carousel.destroy();
      this._carousel = this._createCarousel(newSlides);
    }
  };

  protected _createCarousel(slides: HTMLElement[]): EmblaCarouselType {
    const carousel = EmblaCarousel(
      this._root,
      {
        slides: slides,

        axis: this._direction === 'horizontal' ? 'x' : 'y',
        duration: 20,
        startIndex: this._startIndex,
        dragFree: this._dragFree,
        loop: this._loop,

        containScroll: 'trimSnaps',

        // This controller manages slide changes (including shadow DOM
        // assignments, which the stock watcher does not handle).
        watchSlides: false,
        watchResize: true,
        watchDrag: this._draggable,

        direction: this._textDirection,
      },
      [
        ...this._plugins,
        ...(slides.length > 1
          ? [
              WheelGesturesPlugin({
                // Whether the carousel is vertical or horizontal, interpret y-axis wheel
                // gestures as scrolling for the carousel.
                forceWheelAxis: 'y',
              }),
            ]
          : []),
      ],
    );

    const getCarouselSelectedObject = (): CarouselSelected | null => {
      // Caution: Must use methods/accessors of the new carousel, not the public
      // API of this controller which may use a different carousel.
      const selectedIndex = carousel.selectedScrollSnap();
      const slide = carousel.slideNodes()[selectedIndex] ?? null;
      if (slide) {
        return {
          index: selectedIndex,
          element: slide,
        };
      }
      return null;
    };

    const selectSlide = (): void => {
      const carouselSelected = getCarouselSelectedObject();
      if (carouselSelected) {
        fireAdvancedCameraCardEvent<CarouselSelected>(
          this._parent,
          'carousel:select',
          carouselSelected,
        );
      }
    };

    carousel.on('select', () => selectSlide());
    return carousel;
  }
}



================================================
FILE: src/utils/embla/plugins/auto-media-loaded-info/auto-media-loaded-info.ts
================================================
import { EmblaCarouselType } from 'embla-carousel';
import { LooseOptionsType } from 'embla-carousel/components/Options';
import { CreatePluginType, LoosePluginType } from 'embla-carousel/components/Plugins';
import { MediaLoadedInfo } from '../../../../types';
import {
  AdvancedCameraCardMediaLoadedEventTarget,
  dispatchExistingMediaLoadedInfoAsEvent,
} from '../../../media-info';

declare module 'embla-carousel/components/Plugins' {
  interface EmblaPluginsType {
    autoMediaLoadedInfo?: AutoMediaLoadedInfoType;
  }
}

/**
 * On the relationship between carousel:select and carousel:force-select:
 *
 * There is a complex interplay here. `carousel:force-select` is an event
 * dispatched by the carousel when it is forced to select a particular slide
 * (i.e. the view has changed). `carousel:select` is dispatched for any
 * selection -- forced or human (e.g. the user dragging the carousel).
 *
 * The media info should only be dispatched _after_ the view object has been
 * updated (since the view will clear the loaded media info). The setting of the
 * view (trigged by `carousel:select`) may require async fetches and may take a
 * while -- and so if the card dispatched media on `carousel:selecte` then the
 * media info may be dispatched before the view is set (which could result in
 * the dispatched media immediately being cleared by the view).
 *
 * It is fine to have media info dispatched from the `carousel:init` event,
 * since the carousel will be initialized based on a particular view object. In
 * practice, the carousel will be initialized before the media is loaded, so
 * there may not be anything to dispatch at that point.
 *
 * When media is loaded, that media loaded info will always be allowed to
 * propogate upwards as long as it is selected.
 */

type AutoMediaLoadedInfoType = CreatePluginType<LoosePluginType, LooseOptionsType>;

function AutoMediaLoadedInfo(): AutoMediaLoadedInfoType {
  let emblaApi: EmblaCarouselType;
  let slides: (HTMLElement & AdvancedCameraCardMediaLoadedEventTarget)[] = [];
  const mediaLoadedInfo: MediaLoadedInfo[] = [];

  function init(emblaApiInstance: EmblaCarouselType): void {
    emblaApi = emblaApiInstance;
    slides = emblaApi.slideNodes();

    for (const slide of slides) {
      slide.addEventListener(
        'advanced-camera-card:media:loaded',
        mediaLoadedInfoHandler,
      );
      slide.addEventListener(
        'advanced-camera-card:media:unloaded',
        mediaUnloadedInfoHandler,
      );
    }

    emblaApi.on('init', slideSelectHandler);
    emblaApi
      .containerNode()
      .addEventListener(
        'advanced-camera-card:carousel:force-select',
        slideSelectHandler,
      );
  }

  function destroy(): void {
    for (const slide of slides) {
      slide.removeEventListener(
        'advanced-camera-card:media:loaded',
        mediaLoadedInfoHandler,
      );
      slide.removeEventListener(
        'advanced-camera-card:media:unloaded',
        mediaUnloadedInfoHandler,
      );
    }

    emblaApi.off('init', slideSelectHandler);
    emblaApi
      .containerNode()
      .removeEventListener(
        'advanced-camera-card:carousel:force-select',
        slideSelectHandler,
      );
  }

  function mediaLoadedInfoHandler(ev: CustomEvent<MediaLoadedInfo>): void {
    const eventPath = ev.composedPath();

    // As an optimization, the most recent slide is the one at the end. That's
    // where most users are spending time, so start the search there.
    for (const [index, slide] of [...slides.entries()].reverse()) {
      if (eventPath.includes(slide)) {
        mediaLoadedInfo[index] = ev.detail;
        if (index !== emblaApi.selectedScrollSnap()) {
          ev.stopPropagation();
        }
        break;
      }
    }
  }

  function mediaUnloadedInfoHandler(ev: CustomEvent): void {
    const eventPath = ev.composedPath();

    for (const [index, slide] of slides.entries()) {
      if (eventPath.includes(slide)) {
        delete mediaLoadedInfo[index];
        if (index !== emblaApi.selectedScrollSnap()) {
          ev.stopPropagation();
        }
        break;
      }
    }
  }

  function slideSelectHandler(): void {
    const index = emblaApi.selectedScrollSnap();
    const savedMediaLoadedInfo: MediaLoadedInfo | undefined = mediaLoadedInfo[index];
    if (savedMediaLoadedInfo) {
      dispatchExistingMediaLoadedInfoAsEvent(
        // Event is redispatched from source element.
        slides[index],
        savedMediaLoadedInfo,
      );
    }
  }

  const self: AutoMediaLoadedInfoType = {
    name: 'autoMediaLoadedInfo',
    options: {},
    init,
    destroy,
  };
  return self;
}

export default AutoMediaLoadedInfo;



================================================
FILE: src/utils/initializer/initializer.ts
================================================
import { allPromises } from '../basic';

type InitializationCallback = () => Promise<boolean>;

/**
 * Manages initialization state & calling initializers. There is no guarantee
 * something will not be initialized twice unless there are concurrency controls
 * applied to the usage of this class.
 */
export class Initializer {
  protected _initialized: Set<string> = new Set();

  public async initializeMultipleIfNecessary(
    aspects: Record<string, InitializationCallback>,
  ): Promise<boolean> {
    const results = await allPromises(
      Object.entries(aspects),
      async ([aspect, options]) => await this.initializeIfNecessary(aspect, options),
    );
    return results.every(Boolean);
  }

  public async initializeIfNecessary(
    aspect: string,
    initializer?: InitializationCallback,
  ): Promise<boolean> {
    if (this._initialized.has(aspect)) {
      return true;
    }
    if (!initializer) {
      this._initialized.add(aspect);
      return true;
    }
    if (await initializer()) {
      this._initialized.add(aspect);
      return true;
    }
    return false;
  }

  public uninitialize(aspect: string): void {
    this._initialized.delete(aspect);
  }

  public isInitialized(aspect: string): boolean {
    return this._initialized.has(aspect);
  }

  public isInitializedMultiple(aspects: string[]): boolean {
    return aspects.every((aspect) => this.isInitialized(aspect));
  }
}



================================================
FILE: src/view/item-classifier.ts
================================================
import {
  EventViewMedia,
  RecordingViewMedia,
  ViewFolder,
  ViewItem,
  ViewMedia,
} from './item';

export class ViewItemClassifier {
  public static isMedia(item?: ViewItem | null): item is ViewMedia {
    return item instanceof ViewMedia;
  }
  public static isFolder(item?: ViewItem | null): item is ViewFolder {
    return item instanceof ViewFolder;
  }
  public static isEvent(item?: ViewItem | null): item is EventViewMedia {
    return this.isMedia(item) && (this.isClip(item) || this.isSnapshot(item));
  }
  public static isRecording(item?: ViewItem | null): item is RecordingViewMedia {
    return this.isMedia(item) && item.getMediaType() === 'recording';
  }
  public static isClip(item?: ViewItem | null): boolean {
    return this.isMedia(item) && item.getMediaType() === 'clip';
  }
  public static isSnapshot(item?: ViewItem | null): boolean {
    return this.isMedia(item) && item.getMediaType() === 'snapshot';
  }
  public static isVideo(item?: ViewItem | null): boolean {
    return this.isMedia(item) && (this.isClip(item) || this.isRecording(item));
  }
}



================================================
FILE: src/view/item.ts
================================================
import { FolderConfig } from '../config/schema/folders';

export enum ViewMediaType {
  Clip = 'clip',
  Snapshot = 'snapshot',
  Recording = 'recording',
}

export enum VideoContentType {
  MP4 = 'mp4',
  HLS = 'hls',
}

export interface ViewMediaSourceOptions {
  cameraID?: string;
  folder?: FolderConfig;
}

export class ViewMedia {
  protected _mediaType: ViewMediaType;
  protected _cameraID: string | null;
  protected _folder: FolderConfig | null;

  constructor(mediaType: ViewMediaType, options?: ViewMediaSourceOptions) {
    this._mediaType = mediaType;
    this._cameraID = options?.cameraID ?? null;
    this._folder = options?.folder ?? null;
  }
  public getCameraID(): string | null {
    return this._cameraID;
  }
  public getFolder(): FolderConfig | null {
    return this._folder;
  }
  public getMediaType(): ViewMediaType {
    return this._mediaType;
  }
  public getVideoContentType(): VideoContentType | null {
    return null;
  }
  public getID(): string | null {
    return null;
  }
  public getStartTime(): Date | null {
    return null;
  }
  public getEndTime(): Date | null {
    return null;
  }
  public getUsableEndTime(): Date | null {
    return this.getEndTime() ?? (this.inProgress() ? new Date() : this.getStartTime());
  }
  public inProgress(): boolean | null {
    return null;
  }
  public getContentID(): string | null {
    return null;
  }
  public getTitle(): string | null {
    return null;
  }
  public getThumbnail(): string | null {
    return null;
  }
  public getIcon(): string | null {
    return null;
  }
  public isFavorite(): boolean | null {
    return null;
  }
  public includesTime(seek: Date): boolean {
    const startTime = this.getStartTime();
    const endTime = this.getUsableEndTime();
    return !!startTime && !!endTime && seek >= startTime && seek <= endTime;
  }

  // Sets the favorite attribute (if any). This purely sets the media item as a
  // favorite in JS.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public setFavorite(_favorite: boolean): void {
    return;
  }
  public getWhere(): string[] | null {
    return null;
  }
}

export interface EventViewMedia extends ViewMedia {
  getScore(): number | null;
  getWhat(): string[] | null;
  getTags(): string[] | null;
  isGroupableWith(that: EventViewMedia): boolean;
}

export interface RecordingViewMedia extends ViewMedia {
  getEventCount(): number | null;
}

interface ViewFolderParameters {
  icon?: string | null;
  id?: string | null;
  title?: string | null;
  thumbnail?: string | null;
}

export class ViewFolder {
  private _folder: FolderConfig;

  private _icon: string | null;
  private _id: string | null;
  private _title: string | null;
  private _thumbnail: string | null;

  constructor(folder: FolderConfig, params?: ViewFolderParameters) {
    this._folder = folder;

    this._icon = params?.icon ?? null;
    this._id = params?.id ?? null;
    this._title = params?.title ?? null;
    this._thumbnail = params?.thumbnail ?? null;
  }

  public getFolder(): FolderConfig {
    return this._folder;
  }
  public getID(): string | null {
    return this._id;
  }
  public getTitle(): string | null {
    return this._title;
  }
  public getThumbnail(): string | null {
    return this._thumbnail;
  }
  public getIcon(): string | null {
    return this._icon;
  }
  public isFavorite(): boolean | null {
    return null;
  }
}

export type ViewItem = ViewMedia | ViewFolder;



================================================
FILE: src/view/query-classifier.ts
================================================
import { EventMediaQuery, FolderViewQuery, Query, RecordingMediaQuery } from './query';

export type QueryType = 'event' | 'recording' | 'folder';
type MediaType = 'clips' | 'snapshots' | 'recordings';

export class QueryClassifier {
  public static isEventQuery(query?: Query | null): query is EventMediaQuery {
    return query instanceof EventMediaQuery;
  }

  public static isRecordingQuery(query?: Query | null): query is RecordingMediaQuery {
    return query instanceof RecordingMediaQuery;
  }

  public static isMediaQuery(
    query?: Query | null,
  ): query is EventMediaQuery | RecordingMediaQuery {
    return this.isEventQuery(query) || this.isRecordingQuery(query);
  }

  public static isFolderQuery(query?: Query | null): query is FolderViewQuery {
    return query instanceof FolderViewQuery;
  }

  public static isClipsQuery(query?: Query | null): boolean {
    return (
      this.isEventQuery(query) && !!query?.getQuery()?.every((query) => query.hasClip)
    );
  }

  public static isSnapshotQuery(query?: Query | null): boolean {
    return (
      this.isEventQuery(query) &&
      !!query?.getQuery()?.every((query) => query.hasSnapshot)
    );
  }

  public static getQueryType(query?: Query | null): QueryType | null {
    return this.isEventQuery(query)
      ? 'event'
      : this.isRecordingQuery(query)
        ? 'recording'
        : this.isFolderQuery(query)
          ? 'folder'
          : null;
  }

  public static getMediaType(query?: Query | null): MediaType | null {
    return this.isClipsQuery(query)
      ? 'clips'
      : this.isSnapshotQuery(query)
        ? 'snapshots'
        : this.isRecordingQuery(query)
          ? 'recordings'
          : null;
  }
}



================================================
FILE: src/view/query-results.ts
================================================
import { isSuperset } from '../utils/basic.js';
import { ViewItemClassifier } from './item-classifier.js';
import { ViewItem } from './item.js';

type CameraResultSlices = Map<string, ResultSlice>;
type SelectApproach = 'first' | 'last';

interface ResultSliceOptions {
  results?: ViewItem[];
  selectedIndex?: number | null;
  selectApproach?: SelectApproach;
}

class ResultSlice {
  protected _results: ViewItem[];
  protected _selectedIndex: number | null;

  constructor(options?: ResultSliceOptions) {
    this._results = options?.results ?? [];
    this._selectedIndex = this._getInitialSelectedIndex(options);
  }

  protected _getInitialSelectedIndex(options?: ResultSliceOptions): number | null {
    if (options?.selectedIndex !== undefined && options?.selectedIndex !== null) {
      return options.selectedIndex;
    }
    if (options?.results && options.results.length) {
      if (!options?.selectApproach || options?.selectApproach === 'last') {
        return options.results.length - 1;
      } else {
        return 0;
      }
    }
    return null;
  }

  public clone(): ResultSlice {
    return new ResultSlice({
      results: this._results,
      selectedIndex: this._selectedIndex,
    });
  }

  public getResults(): ViewItem[] {
    return this._results;
  }
  public getSelectedIndex(): number | null {
    return this._selectedIndex;
  }
  public getResultsCount(): number {
    return this.getResults().length;
  }
  public hasResults(): boolean {
    return this.getResultsCount() !== 0;
  }
  public getResult(index?: number): ViewItem | null {
    return index === undefined ? null : this._results[index];
  }
  public getSelectedResult(): ViewItem | null {
    const index = this.getSelectedIndex();
    return index !== null ? this.getResult(index) : null;
  }
  public hasSelectedResult(): boolean {
    return this.getSelectedResult() !== null;
  }
  public resetSelectedResult(): void {
    this._selectedIndex = null;
  }

  public selectIndex(index: number | null): void {
    if (index === null || (index >= 0 && index < this._results.length)) {
      this._selectedIndex = index;
    }
  }
  public selectResultIfFound(func: (item: ViewItem) => boolean): void {
    for (const [index, result] of this._results.entries()) {
      if (func(result)) {
        this.selectIndex(index);
        break;
      }
    }
  }
  public selectBestResult(func: (item: ViewItem[]) => number | null): void {
    const resultIndex = func(this._results);
    if (resultIndex !== null) {
      this.selectIndex(resultIndex);
    }
  }
}

interface ResultSliceSelectionCriteria {
  main?: boolean;
  cameraID?: string;
  allCameras?: boolean;
}

export class QueryResults {
  protected _resultsTimestamp: Date | null = null;
  protected _main: ResultSlice;
  protected _cameras: CameraResultSlices = new Map();

  constructor(options?: ResultSliceOptions) {
    this._resultsTimestamp = new Date();
    this._main = new ResultSlice(options);
    this._buildByCameraSlices(options?.selectApproach);
  }

  protected _buildByCameraSlices(selectApproach?: SelectApproach): void {
    const cameraMap: Map<string, ViewItem[]> = new Map();
    for (const result of this._main.getResults()) {
      const cameraID = ViewItemClassifier.isMedia(result) ? result.getCameraID() : null;
      if (cameraID) {
        const items: ViewItem[] = cameraMap.get(cameraID) ?? [];
        items.push(result);
        cameraMap.set(cameraID, items);
      }
    }

    for (const [cameraID, items] of cameraMap.entries()) {
      this._cameras.set(
        cameraID,
        new ResultSlice({
          results: items,
          selectApproach: selectApproach,
        }),
      );
    }
  }

  public clone(): QueryResults {
    // Shallow clone -- will reuse the same results object (as there are no
    // methods that support modification of the results themselves, and since
    // changing the index on a consistent set of results is a very common
    // operation).
    const copy = new QueryResults();
    copy._resultsTimestamp = this._resultsTimestamp;
    copy._main = this._main.clone();

    for (const [cameraID, slice] of this._cameras.entries()) {
      copy._cameras.set(cameraID, slice.clone());
    }
    return copy;
  }

  public isSupersetOf(that: QueryResults): boolean {
    const thisItemIDs = new Set(this._main.getResults()?.map((item) => item.getID()));
    const thatItemIDs = new Set(that._main.getResults()?.map((item) => item.getID()));

    if (
      !thisItemIDs.size ||
      !thatItemIDs.size ||
      // If either item sets contain a null identifier (i.e. an item item with
      // no ID) we must assume this is not a subset as multiple items may reduce
      // to the same null identifier above.
      thisItemIDs.has(null) ||
      thatItemIDs.has(null)
    ) {
      return false;
    }
    return isSuperset(thisItemIDs, thatItemIDs);
  }

  public getCameraIDs(): Set<string> {
    return new Set(this._cameras.keys());
  }

  public getSlice(cameraID?: string): ResultSlice | null {
    return cameraID ? this._cameras.get(cameraID) ?? null : this._main;
  }

  public getResults(cameraID?: string): ViewItem[] | null {
    return this.getSlice(cameraID)?.getResults() ?? null;
  }
  public getResultsCount(cameraID?: string): number {
    return this.getSlice(cameraID)?.getResultsCount() ?? 0;
  }
  public hasResults(cameraID?: string): boolean {
    return this.getSlice(cameraID)?.getResultsCount() !== 0;
  }
  public getResult(index?: number, cameraID?: string): ViewItem | null {
    return this.getSlice(cameraID)?.getResult(index) ?? null;
  }
  public getSelectedIndex(cameraID?: string): number | null {
    return this.getSlice(cameraID)?.getSelectedIndex() ?? null;
  }
  public getSelectedResult(cameraID?: string): ViewItem | null {
    return this.getSlice(cameraID)?.getSelectedResult() ?? null;
  }
  public getMultipleSelectedResults(
    criteria?: ResultSliceSelectionCriteria,
  ): ViewItem[] {
    const results: ViewItem[] = [];
    if (!criteria || criteria.main) {
      const mainResult = this.getSelectedResult();
      if (mainResult) {
        results.push(mainResult);
      }
    }
    const cameraIDs = this._getCameraIDsFromCriteria(criteria);
    for (const cameraID of cameraIDs ?? []) {
      const result = this.getSelectedResult(cameraID);
      if (result) {
        results.push(result);
      }
    }
    return results;
  }
  public hasSelectedResult(cameraID?: string): boolean {
    return this.getSlice(cameraID)?.hasSelectedResult() ?? false;
  }
  public resetSelectedResult(cameraID?: string): QueryResults {
    this.getSlice(cameraID)?.resetSelectedResult();
    return this;
  }
  public getResultsTimestamp(): Date | null {
    return this._resultsTimestamp;
  }

  public selectIndex(index: number, cameraID?: string): QueryResults {
    this.getSlice(cameraID)?.selectIndex(index);
    if (!cameraID) {
      // If the main selection is changed, it must also change the matching
      // camera selection.
      this.demoteMainSelectionToCameraSelection();
    }
    return this;
  }

  public demoteMainSelectionToCameraSelection(): QueryResults {
    const selected = this.getSelectedResult();
    const cameraID = ViewItemClassifier.isMedia(selected)
      ? selected?.getCameraID()
      : null;

    if (selected && cameraID) {
      this.resetSelectedResult(cameraID);
      this.selectResultIfFound((item) => item === selected, { cameraID: cameraID });
    }
    return this;
  }

  public promoteCameraSelectionToMainSelection(cameraID: string): QueryResults {
    const selected = this.getSelectedResult(cameraID);
    this.resetSelectedResult();
    this.selectResultIfFound((item) => item === selected);
    return this;
  }

  protected _getCameraIDsFromCriteria(
    criteria?: ResultSliceSelectionCriteria,
  ): Set<string> | null {
    return criteria?.allCameras
      ? this.getCameraIDs()
      : criteria?.cameraID
        ? new Set([criteria.cameraID])
        : null;
  }

  public selectResultIfFound(
    func: (item: ViewItem) => boolean,
    criteria?: ResultSliceSelectionCriteria,
  ): QueryResults {
    if (!criteria || criteria?.main) {
      this._main.selectResultIfFound(func);
      this.demoteMainSelectionToCameraSelection();
    }
    const cameraIDs = this._getCameraIDsFromCriteria(criteria);
    for (const cameraID of cameraIDs ?? []) {
      this.getSlice(cameraID)?.selectResultIfFound(func);
    }
    return this;
  }
  public selectBestResult(
    func: (item: ViewItem[]) => number | null,
    criteria?: ResultSliceSelectionCriteria,
  ): QueryResults {
    if (!criteria || criteria.main) {
      this._main.selectBestResult(func);
      this.demoteMainSelectionToCameraSelection();
    }
    const cameraIDs = this._getCameraIDsFromCriteria(criteria);
    for (const cameraID of cameraIDs ?? []) {
      this.getSlice(cameraID)?.selectBestResult(func);
    }
    return this;
  }
}



================================================
FILE: src/view/query.ts
================================================
import { cloneDeep, isEqual, uniqWith } from 'lodash-es';
import { EventQuery, MediaQuery, RecordingQuery } from '../camera-manager/types.js';
import { FolderQuery } from '../card-controller/folders/types.js';
import { setify } from '../utils/basic.js';

export type MediaQueries = EventMediaQuery | RecordingMediaQuery;
export type Query = MediaQueries | FolderViewQuery;

class ViewQuery<T> {
  protected _query: T | null = null;

  public constructor(query?: T) {
    if (query) {
      this._query = query;
    }
  }

  public getQuery(): T | null {
    return this._query;
  }

  public setQuery(query: T): this {
    this._query = query;
    return this;
  }

  public clone(): this {
    return cloneDeep(this);
  }
}

class MediaQueryBase<T extends MediaQuery> extends ViewQuery<T[]> {
  public getQueryCameraIDs(): Set<string> | null {
    if (!this._query) {
      return null;
    }
    const cameraIDs: Set<string> = new Set();
    this._query.forEach((query) =>
      [...query.cameraIDs].forEach((cameraID) => cameraIDs.add(cameraID)),
    );
    return cameraIDs;
  }

  public setQueryCameraIDs(cameraIDs: string | Set<string>): this {
    if (!this._query) {
      return this;
    }
    const rewrittenQueries: T[] = [];
    this._query.forEach((query) =>
      rewrittenQueries.push({ ...query, cameraIDs: setify(cameraIDs) }),
    );
    this._query = uniqWith(rewrittenQueries, isEqual);
    return this;
  }

  public hasQueriesForCameraIDs(cameraIDs: Set<string>) {
    for (const cameraID of cameraIDs) {
      if (!this._query?.some((query) => query.cameraIDs.has(cameraID))) {
        return false;
      }
    }
    return true;
  }

  public isSupersetOf(that: MediaQueries): boolean {
    // Queries are typically a single item, so quadratic complexity here is
    // likely still a lot better than going to the network for a new set of
    // query results.
    for (const thatQuery of that.getQuery() ?? []) {
      let haveMatch = false;
      for (const thisQuery of this._query ?? []) {
        // Compare the query except the times, and then separately compare the
        // times taking into account whether source time is larger than target
        // time.
        if (
          isEqual(
            {
              ...thisQuery,
              end: null,
              start: null,
            },
            { ...thatQuery, end: null, start: null },
          ) &&
          ((!thisQuery.start && !thatQuery.start) ||
            (thisQuery.start &&
              thatQuery.start &&
              thisQuery.start <= thatQuery.start)) &&
          ((!thisQuery.end && !thatQuery.end) ||
            (thisQuery.end && thatQuery.end && thisQuery.end >= thatQuery.end))
        ) {
          haveMatch = true;
          break;
        }
      }

      if (!haveMatch) {
        return false;
      }
    }
    return true;
  }
}

export class EventMediaQuery extends MediaQueryBase<EventQuery> {
  public convertToClipsQueries(): this {
    for (const query of this._query ?? []) {
      delete query.hasSnapshot;
      query.hasClip = true;
    }
    return this;
  }
}

export class RecordingMediaQuery extends MediaQueryBase<RecordingQuery> {}

export class FolderViewQuery extends ViewQuery<FolderQuery> {}



================================================
FILE: src/view/types.ts
================================================
export interface ViewItemCapabilities {
  canFavorite: boolean;
  canDownload: boolean;
}



================================================
FILE: src/view/view-to-cameras.ts
================================================
import { CameraManager } from '../camera-manager/manager';
import { CapabilitySearchOptions } from '../camera-manager/types';
import { AdvancedCameraCardView } from '../config/schema/common/const';

/**
 * Get cameraIDs that are relevant for a given view name based on camera
 * capability (if camera specified).
 */
export const getCameraIDsForViewName = (
  cameraManager: CameraManager,
  viewName: AdvancedCameraCardView,
  cameraID?: string,
): Set<string> => {
  const capabilityMatchAnyMedia: CapabilitySearchOptions = {
    anyCapabilities: ['clips', 'snapshots', 'recordings'],
  };

  switch (viewName) {
    case 'diagnostics':
    case 'image':
    case 'folder':
    case 'folders':
    case 'media':
      return cameraManager.getStore().getCameraIDs();

    case 'live':
    case 'clip':
    case 'clips':
    case 'snapshot':
    case 'snapshots':
    case 'recording':
    case 'recordings':
      const capability =
        viewName === 'clip'
          ? 'clips'
          : viewName === 'snapshot'
            ? 'snapshots'
            : viewName === 'recording'
              ? 'recordings'
              : viewName;
      return cameraID
        ? cameraManager.getStore().getAllDependentCameras(cameraID, capability)
        : cameraManager.getStore().getCameraIDsWithCapability(capability);

    case 'timeline':
      return cameraManager
        .getStore()
        .getCameraIDsWithCapability(capabilityMatchAnyMedia);
  }
};



================================================
FILE: src/view/view.ts
================================================
import { merge } from 'lodash-es';
import { ViewContext } from 'view';
import { AdvancedCameraCardView } from '../config/schema/common/const';
import { ViewDisplayMode } from '../config/schema/common/display';
import { Query } from './query';
import { QueryResults } from './query-results';

declare module 'view' {
  interface ViewContext {
    loading?: {
      query?: unknown;
    };
  }
}

interface ViewEvolveParameters {
  view?: AdvancedCameraCardView;
  camera?: string;
  query?: Query | null;
  queryResults?: QueryResults | null;
  context?: ViewContext | null;
  displayMode?: ViewDisplayMode | null;
}

export interface ViewParameters extends ViewEvolveParameters {
  view: AdvancedCameraCardView;
  camera: string;
}

export const mergeViewContext = (
  a?: ViewContext | null,
  b?: ViewContext | null,
): ViewContext => {
  return merge({}, a, b);
};

export class View {
  public view: AdvancedCameraCardView;
  public camera: string;
  public query: Query | null;
  public queryResults: QueryResults | null;
  public context: ViewContext | null;
  public displayMode: ViewDisplayMode | null;

  constructor(params: ViewParameters) {
    this.view = params.view;
    this.camera = params.camera;
    this.query = params.query ?? null;
    this.queryResults = params.queryResults ?? null;
    this.context = params.context ?? null;
    this.displayMode = params.displayMode ?? null;
  }

  public clone(): View {
    return new View({
      view: this.view,
      camera: this.camera,
      query: this.query?.clone() ?? null,
      queryResults: this.queryResults?.clone() ?? null,
      context: this.context,
      displayMode: this.displayMode,
    });
  }

  /**
   * Evolve this view by changing parameters and returning a new view.
   * @param params Parameters to change.
   * @returns A new evolved view.
   */
  public evolve(params: ViewEvolveParameters): View {
    return new View({
      view: params.view !== undefined ? params.view : this.view,
      camera: params.camera !== undefined ? params.camera : this.camera,
      query: params.query !== undefined ? params.query : this.query?.clone() ?? null,
      queryResults:
        params.queryResults !== undefined
          ? params.queryResults
          : this.queryResults?.clone() ?? null,
      context: params.context !== undefined ? params.context : this.context,
      displayMode:
        params.displayMode !== undefined ? params.displayMode : this.displayMode,
    });
  }

  /**
   * Merge view contexts.
   * @param context The context to merge in.
   * @returns This view.
   */
  public mergeInContext(context?: ViewContext | null): View {
    this.context = mergeViewContext(this.context, context);
    return this;
  }

  /**
   * Remove a context key.
   * @param key The key to remove.
   * @returns This view.
   */
  public removeContext(key: keyof ViewContext): View {
    if (this.context) {
      delete this.context[key];
    }
    return this;
  }

  public removeContextProperty(
    contextKey: keyof ViewContext,
    removeKey: PropertyKey,
  ): View {
    const contextObj = this.context?.[contextKey];
    if (contextObj) {
      delete contextObj[removeKey];
    }
    return this;
  }

  /**
   * Determine if current view matches a named view.
   */
  public is(view: AdvancedCameraCardView): boolean {
    return this.view == view;
  }

  /**
   * Determine if a view is a media gallery.
   */
  public isMediaGalleryView(): boolean {
    return ['clips', 'folders', 'snapshots', 'recordings'].includes(this.view);
  }

  /**
   * Determine if a view is of a piece of media (including the media viewer,
   * live view, image view -- anything that can create a MediaLoadedInfo event).
   */
  public isAnyMediaView(): boolean {
    return this.isViewerView() || this.is('live') || this.is('image');
  }

  public isAnyFolderView(): boolean {
    return ['folder', 'folders'].includes(this.view);
  }

  /**
   * Determine if a view is for the media viewer.
   */
  public isViewerView(): boolean {
    return ['folder', 'media', 'clip', 'snapshot', 'recording'].includes(this.view);
  }

  public supportsMultipleDisplayModes(): boolean {
    return this.isViewerView() || this.is('live');
  }

  /**
   * Get the default media type for this view if available.
   * @returns Whether the default media is `clips`, `snapshots`, `recordings` or unknown
   * (`null`).
   */
  public getDefaultMediaType(): 'clips' | 'snapshots' | 'recordings' | null {
    if (['clip', 'clips'].includes(this.view)) {
      return 'clips';
    }
    if (['snapshot', 'snapshots'].includes(this.view)) {
      return 'snapshots';
    }
    if (['recording', 'recordings'].includes(this.view)) {
      return 'recordings';
    }
    return null;
  }

  public isGrid(): boolean {
    return this.displayMode === 'grid';
  }
}



================================================
FILE: tests/cached-value-controller.test.ts
================================================
import { ReactiveControllerHost } from 'lit';
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CachedValueController } from '../src/components-lib/cached-value-controller';

// @vitest-environment jsdom
describe('CachedValueController', () => {
  afterEach(() => {
    vi.useRealTimers();
  });

  it('should construct', () => {
    const host = mock<ReactiveControllerHost>();
    const callback = vi.fn();
    const controller = new CachedValueController(host, 10, callback);

    expect(controller).toBeTruthy();
  });

  it('should remove host', () => {
    const host = mock<ReactiveControllerHost>();
    const callback = vi.fn();
    const controller = new CachedValueController(host, 10, callback);

    controller.removeController();
    expect(host.removeController).toBeCalled();
  });

  it('should have timer', () => {
    const host = mock<ReactiveControllerHost>();
    const callback = vi.fn();
    const startCallback = vi.fn();
    const stopCallback = vi.fn();

    vi.useFakeTimers();

    const controller = new CachedValueController(
      host,
      10,
      callback,
      startCallback,
      stopCallback,
    );

    controller.startTimer();
    expect(startCallback).toBeCalled();

    callback.mockReturnValue(3);
    vi.runOnlyPendingTimers();
    expect(callback).toBeCalled();
    expect(host.requestUpdate).toBeCalled();
    expect(controller.value).toBe(3);

    callback.mockReturnValue(4);
    vi.runOnlyPendingTimers();
    expect(callback).toBeCalled();
    expect(host.requestUpdate).toBeCalled();
    expect(controller.value).toBe(4);

    expect(controller.hasTimer()).toBeTruthy();

    controller.stopTimer();
    expect(stopCallback).toBeCalled();

    callback.mockReset();
    vi.runOnlyPendingTimers();
    expect(callback).not.toBeCalled();
  });

  it('should clear value', () => {
    const host = mock<ReactiveControllerHost>();
    const callback = vi.fn().mockReturnValue(42);

    vi.useFakeTimers();

    const controller = new CachedValueController(host, 10, callback);
    controller.startTimer();

    vi.runOnlyPendingTimers();
    expect(controller.value).equal(42);

    controller.clearValue();
    expect(controller.value).toBeUndefined();
  });

  it('should connect and disconnect host', () => {
    const host = mock<ReactiveControllerHost>();
    const callback = vi.fn().mockReturnValue(43);
    const startCallback = vi.fn();
    const stopCallback = vi.fn();

    const controller = new CachedValueController(
      host,
      10,
      callback,
      startCallback,
      stopCallback,
    );

    controller.hostConnected();
    expect(controller.value).equal(43);
    expect(startCallback).toBeCalled();
    expect(host.requestUpdate).toBeCalled();

    controller.hostDisconnected();
    expect(controller.value).toBeUndefined();
    expect(stopCallback).toBeCalled();
  });
});



================================================
FILE: tests/test-utils.ts
================================================
import { HassEntities, HassEntity } from 'home-assistant-js-websocket';
import { LitElement } from 'lit';
import screenfull from 'screenfull';
import { expect, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { Camera } from '../src/camera-manager/camera';
import { Capabilities } from '../src/camera-manager/capabilities';
import { CameraManagerEngine } from '../src/camera-manager/engine';
import { FrigateEvent, FrigateRecording } from '../src/camera-manager/frigate/types';
import { GenericCameraManagerEngine } from '../src/camera-manager/generic/engine-generic';
import { CameraManager } from '../src/camera-manager/manager';
import { CameraManagerStore } from '../src/camera-manager/store';
import { CameraEventCallback } from '../src/camera-manager/types';
import { ActionsManager } from '../src/card-controller/actions/actions-manager';
import { AutomationsManager } from '../src/card-controller/automations-manager';
import { CameraURLManager } from '../src/card-controller/camera-url-manager';
import { CardElementManager } from '../src/card-controller/card-element-manager';
import { ConfigManager } from '../src/card-controller/config/config-manager';
import { CardController } from '../src/card-controller/controller';
import { DefaultManager } from '../src/card-controller/default-manager';
import { ExpandManager } from '../src/card-controller/expand-manager';
import { FoldersManager } from '../src/card-controller/folders/manager';
import { FullscreenManager } from '../src/card-controller/fullscreen/fullscreen-manager';
import { HASSManager } from '../src/card-controller/hass/hass-manager';
import { StateWatcherSubscriptionInterface } from '../src/card-controller/hass/state-watcher';
import { InitializationManager } from '../src/card-controller/initialization-manager';
import { InteractionManager } from '../src/card-controller/interaction-manager';
import { KeyboardStateManager } from '../src/card-controller/keyboard-state-manager';
import { MediaLoadedInfoManager } from '../src/card-controller/media-info-manager';
import { MediaPlayerManager } from '../src/card-controller/media-player-manager';
import { MessageManager } from '../src/card-controller/message-manager';
import { MicrophoneManager } from '../src/card-controller/microphone-manager';
import { QueryStringManager } from '../src/card-controller/query-string-manager';
import { StatusBarItemManager } from '../src/card-controller/status-bar-item-manager';
import { StyleManager } from '../src/card-controller/style-manager';
import { TriggersManager } from '../src/card-controller/triggers-manager';
import { ViewItemManager } from '../src/card-controller/view/item-manager';
import { ViewManager } from '../src/card-controller/view/view-manager';
import { SubmenuInteraction, SubmenuItem } from '../src/components/submenu/types';
import { ConditionStateManager } from '../src/conditions/state-manager';
import { CameraConfig, cameraConfigSchema } from '../src/config/schema/cameras';
import { FolderConfig } from '../src/config/schema/folders';
import {
  PerformanceConfig,
  performanceConfigSchema,
} from '../src/config/schema/performance';
import {
  AdvancedCameraCardConfig,
  advancedCameraCardConfigSchema,
} from '../src/config/schema/types';
import { RawAdvancedCameraCardConfig } from '../src/config/types';
import {
  BrowseMedia,
  BrowseMediaMetadata,
  RichBrowseMedia,
} from '../src/ha/browse-media/types';
import { Device } from '../src/ha/registry/device/types';
import { Entity, EntityRegistryManager } from '../src/ha/registry/entity/types';
import { CurrentUser, HassStateDifference, HomeAssistant } from '../src/ha/types';
import { CapabilitiesRaw, Interaction, MediaLoadedInfo } from '../src/types';
import { EventViewMedia, ViewMedia, ViewMediaType } from '../src/view/item';
import { QueryResults } from '../src/view/query-results';
import { ViewItemCapabilities } from '../src/view/types';
import { View, ViewParameters } from '../src/view/view';

export const createCameraConfig = (config?: unknown): CameraConfig => {
  return cameraConfigSchema.parse(config ?? {});
};

export const createRawConfig = (
  config?: Partial<RawAdvancedCameraCardConfig>,
): RawAdvancedCameraCardConfig => {
  return {
    type: 'advanced-camera-card',
    cameras: [{}],
    ...config,
  };
};

export const createConfig = (
  config?: RawAdvancedCameraCardConfig,
): AdvancedCameraCardConfig => {
  return advancedCameraCardConfigSchema.parse(createRawConfig(config));
};

export const createCamera = (
  config: CameraConfig,
  engine: CameraManagerEngine,
  capabilities?: Capabilities,
): Camera => {
  return new Camera(config, engine, { capabilities: capabilities });
};

export const createHASS = (states?: HassEntities, user?: CurrentUser): HomeAssistant => {
  const hass = mock<HomeAssistant>();
  if (states) {
    hass.states = states;
  }
  if (user) {
    hass.user = user;
  }
  hass.connection.subscribeMessage = vi.fn();
  hass.connection.sendMessagePromise = vi.fn();
  return hass;
};

export const createUser = (user?: Partial<CurrentUser>): CurrentUser => ({
  id: 'user',
  is_owner: false,
  is_admin: false,
  name: 'User',
  credentials: [],
  mfa_modules: [],
  ...user,
});

export const createRegistryDevice = (device?: Partial<Device>): Device => {
  return {
    id: device?.id ?? 'id',
    model: device?.model ?? null,
    config_entries: device?.config_entries ?? [],
    manufacturer: device?.manufacturer ?? null,
  };
};

export const createRegistryEntity = (entity?: Partial<Entity>): Entity => {
  return {
    config_entry_id: entity?.config_entry_id ?? null,
    device_id: entity?.device_id ?? null,
    disabled_by: entity?.disabled_by ?? null,
    entity_id: entity?.entity_id ?? 'entity_id',
    hidden_by: entity?.hidden_by ?? null,
    platform: entity?.platform ?? 'platform',
    translation_key: entity?.translation_key ?? null,
    ...(entity?.unique_id && { unique_id: entity?.unique_id }),
  };
};

export const createStateEntity = (entity?: Partial<HassEntity>): HassEntity => {
  return {
    entity_id: entity?.entity_id ?? 'entity_id',
    state: entity?.state ?? 'on',
    last_changed: entity?.last_changed ?? 'never',
    last_updated: entity?.last_updated ?? 'never',
    attributes: entity?.attributes ?? {},
    context: entity?.context ?? {
      id: 'id',
      parent_id: 'parent_id',
      user_id: 'user_id',
    },
  };
};

export const createFrigateEvent = (event?: Partial<FrigateEvent>) => {
  return {
    camera: 'camera',
    end_time: 1683397124,
    false_positive: false,
    has_clip: true,
    has_snapshot: true,
    id: '1683396875.643998-hmzrh5',
    label: 'person',
    sub_label: null,
    start_time: 1683395000,
    top_score: 0.841796875,
    zones: [],
    retain_indefinitely: false,
    ...event,
  };
};

export const createFrigateRecording = (recording?: Partial<FrigateRecording>) => {
  return {
    cameraID: 'cameraID',
    startTime: new Date('2023-04-29T14:00:00'),
    endTime: new Date('2023-04-29T14:59:59'),
    events: 42,
    ...recording,
  };
};

export const createView = (options?: Partial<ViewParameters>): View => {
  return new View({
    view: 'live',
    camera: 'camera',
    ...options,
  });
};

export const createViewWithMedia = (options?: Partial<ViewParameters>): View => {
  const media = generateViewMediaArray({ count: 5 });
  return createView({
    queryResults: new QueryResults({
      results: media,
      selectedIndex: 0,
    }),
    ...options,
  });
};

export const createStore = (
  cameras?: {
    cameraID: string;
    engine?: CameraManagerEngine;
    config?: CameraConfig;
    capabilities?: Capabilities | null;
    eventCallback?: CameraEventCallback;
  }[],
): CameraManagerStore => {
  const store = new CameraManagerStore();
  for (const cameraProps of cameras ?? []) {
    const eventCallback = cameraProps.eventCallback ?? vi.fn();
    const camera = new Camera(
      cameraProps.config ?? createCameraConfig(),
      cameraProps.engine ??
        new GenericCameraManagerEngine(
          mock<StateWatcherSubscriptionInterface>(),
          eventCallback,
        ),
      {
        capabilities:
          cameraProps.capabilities === undefined
            ? createCapabilities()
            : cameraProps.capabilities ?? undefined,
        eventCallback: eventCallback,
      },
    );
    camera.setID(cameraProps.cameraID);
    store.addCamera(camera);
  }
  return store;
};

export const createCameraManager = (store?: CameraManagerStore): CameraManager => {
  const cameraStore = store ?? createStore();
  const cameraManager = mock<CameraManager>();
  vi.mocked(cameraManager.getStore).mockReturnValue(cameraStore);
  vi.mocked(cameraManager.getCameraCapabilities).mockImplementation(
    (cameraID: string): Capabilities | null => {
      return cameraStore.getCamera(cameraID)?.getCapabilities() ?? null;
    },
  );

  return cameraManager;
};

export const createCapabilities = (capabilities?: CapabilitiesRaw): Capabilities => {
  return new Capabilities({
    'favorite-events': false,
    'favorite-recordings': false,
    'remote-control-entity': true,
    clips: false,
    live: false,
    recordings: false,
    seek: false,
    snapshots: false,
    ...capabilities,
  });
};

export const createMediaCapabilities = (
  options?: Partial<ViewItemCapabilities>,
): ViewItemCapabilities => {
  return {
    canFavorite: false,
    canDownload: false,
    ...options,
  };
};

export const createMediaLoadedInfo = (
  options?: Partial<MediaLoadedInfo>,
): MediaLoadedInfo => {
  return {
    width: 100,
    height: 100,
    ...options,
  };
};

export const createMediaLoadedInfoEvent = (
  mediaLoadedInfo?: MediaLoadedInfo,
): CustomEvent<MediaLoadedInfo> => {
  return new CustomEvent('advanced-camera-card:media:loaded', {
    detail: mediaLoadedInfo ?? createMediaLoadedInfo(),
    composed: true,
    bubbles: true,
  });
};

export const createPerformanceConfig = (config: unknown): PerformanceConfig => {
  return performanceConfigSchema.parse(config);
};

export const generateViewMediaArray = (options?: {
  cameraIDs?: string[];
  count?: number;
}): ViewMedia[] => {
  const media: ViewMedia[] = [];
  for (let i = 0; i < (options?.count ?? 100); ++i) {
    for (const cameraID of options?.cameraIDs ?? ['kitchen', 'office']) {
      media.push(
        new TestViewMedia({
          cameraID: cameraID,
          id: `id-${cameraID}-${i}`,
        }),
      );
    }
  }
  return media;
};

// ViewMedia itself has no native way to set startTime and ID that aren't linked
// to an engine.
export class TestViewMedia extends ViewMedia implements EventViewMedia {
  protected _icon: string | null = null;
  protected _id: string | null;
  protected _startTime: Date | null;
  protected _endTime: Date | null;
  protected _inProgress: boolean | null;
  protected _contentID: string | null;
  protected _title: string | null;
  protected _thumbnail: string | null;
  protected _what: string[] | null = null;
  protected _score: number | null = null;
  protected _tags: string[] | null = null;
  protected _where: string[] | null = null;

  constructor(options?: {
    id?: string | null;
    startTime?: Date | null;
    mediaType?: ViewMediaType;
    cameraID?: string | null;
    folder?: FolderConfig | null;
    endTime?: Date | null;
    inProgress?: boolean;
    contentID?: string;
    title?: string | null;
    thumbnail?: string | null;
    icon?: string | null;
    what?: string[] | null;
    score?: number | null;
    tags?: string[] | null;
    where?: string[] | null;
  }) {
    super(options?.mediaType ?? ViewMediaType.Clip, {
      ...(options?.cameraID !== null &&
        !options?.folder && { cameraID: options?.cameraID ?? 'camera' }),
      ...(options?.folder && { folder: options.folder }),
    });
    this._id = options?.id !== undefined ? options.id : 'id';
    this._startTime = options?.startTime ?? null;
    this._endTime = options?.endTime ?? null;
    this._inProgress = options?.inProgress !== undefined ? options.inProgress : false;
    this._contentID = options?.contentID ?? null;
    this._title = options?.title !== undefined ? options.title : null;
    this._thumbnail = options?.thumbnail !== undefined ? options.thumbnail : null;
    this._icon = options?.icon !== undefined ? options.icon : null;
    this._what = options?.what !== undefined ? options.what : null;
    this._score = options?.score !== undefined ? options.score : null;
    this._tags = options?.tags !== undefined ? options.tags : null;
    this._where = options?.where !== undefined ? options.where : null;
  }
  public getIcon(): string | null {
    return this._icon;
  }
  public getID(): string | null {
    return this._id;
  }
  public getStartTime(): Date | null {
    return this._startTime;
  }
  public getEndTime(): Date | null {
    return this._endTime;
  }
  public inProgress(): boolean | null {
    return this._inProgress;
  }
  public getContentID(): string | null {
    return this._contentID;
  }
  public getTitle(): string | null {
    return this._title;
  }
  public getThumbnail(): string | null {
    return this._thumbnail;
  }
  public getWhat(): string[] | null {
    return this._what;
  }
  public getScore(): number | null {
    return this._score;
  }
  public getTags(): string[] | null {
    return this._tags;
  }
  public getWhere(): string[] | null {
    return this._where;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public isGroupableWith(_that: EventViewMedia): boolean {
    return false;
  }
}

export const ResizeObserverMock = vi.fn(() => ({
  disconnect: vi.fn(),
  observe: vi.fn(),
  unobserve: vi.fn(),
}));

export const IntersectionObserverMock = vi.fn(() => ({
  disconnect: vi.fn(),
  observe: vi.fn(),
  unobserve: vi.fn(),
}));

export const MutationObserverMock = vi.fn(() => ({
  disconnect: vi.fn(),
  observe: vi.fn(),
  unobserve: vi.fn(),
}));

export const requestAnimationFrameMock = (callback: FrameRequestCallback) => {
  callback(new Date().getTime());
  return 1;
};

export const getMockIntersectionObserver = (n = 0): IntersectionObserver | null => {
  const mockResult = vi.mocked(IntersectionObserver).mock.results[n];
  if (mockResult.type !== 'return') {
    return null;
  }
  return mockResult.value;
};

export const callIntersectionHandler = async (
  intersecting = true,
  n = 0,
): Promise<void> => {
  const observer = getMockIntersectionObserver(n);
  if (!observer) {
    return;
  }
  await (
    vi.mocked(IntersectionObserver).mock.calls[n][0] as
      | IntersectionObserverCallback
      | ((_: unknown) => Promise<void>)
  )(
    // Note this is a very incomplete / invalid IntersectionObserverEntry that
    // just provides the bare basics current implementation uses.
    intersecting ? [{ isIntersecting: true } as IntersectionObserverEntry] : [],
    observer,
  );
};

export const callMutationHandler = async (n = 0): Promise<void> => {
  const mockResult = vi.mocked(MutationObserver).mock.results[n];
  if (mockResult.type !== 'return') {
    return;
  }
  const observer = mockResult.value;
  await (
    vi.mocked(MutationObserver).mock.calls[n][0] as
      | MutationCallback
      | ((_: unknown) => Promise<void>)
  )(
    // Note this is a very incomplete / invalid IntersectionObserverEntry that
    // just provides the bare basics current implementation uses.
    [],
    observer,
  );
};

export const callVisibilityHandler = async (visible: boolean): Promise<void> => {
  Object.defineProperty(document, 'visibilityState', {
    value: visible ? 'visible' : 'hidden',
    writable: true,
  });

  const mock = vi.mocked(global.document.addEventListener).mock;
  for (const [evt, cb] of mock.calls) {
    if (evt === 'visibilitychange' && typeof cb === 'function') {
      await (cb as EventListener | ((_: unknown) => Promise<void>))(new Event('foo'));
    }
  }
};

export const createSlotHost = (options?: {
  slot?: HTMLSlotElement;
  children?: HTMLElement[];
  parent?: LitElement;
}): LitElement => {
  const parent = options?.parent ?? createLitElement();
  parent.attachShadow({ mode: 'open' });

  if (options?.slot) {
    parent.shadowRoot?.append(options.slot);
  }
  if (options?.children) {
    // Children will automatically be slotted into the default slot when it is
    // created.
    parent.append(...options.children);
  }
  return parent;
};

export const createSlot = (): HTMLSlotElement => {
  return document.createElement('slot');
};

export const createParent = (options?: { children?: HTMLElement[] }): HTMLElement => {
  const parent = document.createElement('div');
  parent.append(...(options?.children ?? []));
  return parent;
};

export const createLitElement = (): LitElement => {
  const element = document.createElement('div') as unknown as LitElement;
  element.addController = vi.fn();
  element.removeController = vi.fn();
  element.requestUpdate = vi.fn();

  const promise: Promise<boolean> = new Promise((resolve) => {
    resolve(false);
  });

  // Need to overwrite a read-only property.
  Object.defineProperty(element, 'updateComplete', {
    value: promise,
  });
  return element;
};

export const createCardAPI = (): CardController => {
  const api = mock<CardController>();

  api.getActionsManager.mockReturnValue(mock<ActionsManager>());
  api.getAutomationsManager.mockReturnValue(mock<AutomationsManager>());
  api.getDefaultManager.mockReturnValue(mock<DefaultManager>());
  api.getCameraManager.mockReturnValue(mock<CameraManager>());
  api.getCameraURLManager.mockReturnValue(mock<CameraURLManager>());
  api.getCardElementManager.mockReturnValue(mock<CardElementManager>());
  api.getConditionStateManager.mockReturnValue(mock<ConditionStateManager>());
  api.getConfigManager.mockReturnValue(mock<ConfigManager>());
  api.getEntityRegistryManager.mockReturnValue(mock<EntityRegistryManager>());
  api.getExpandManager.mockReturnValue(mock<ExpandManager>());
  api.getFoldersManager.mockReturnValue(mock<FoldersManager>());
  api.getFullscreenManager.mockReturnValue(mock<FullscreenManager>());
  api.getHASSManager.mockReturnValue(mock<HASSManager>());
  api.getInitializationManager.mockReturnValue(mock<InitializationManager>());
  api.getInteractionManager.mockReturnValue(mock<InteractionManager>());
  api.getKeyboardStateManager.mockReturnValue(mock<KeyboardStateManager>());
  api.getMediaLoadedInfoManager.mockReturnValue(mock<MediaLoadedInfoManager>());
  api.getMediaPlayerManager.mockReturnValue(mock<MediaPlayerManager>());
  api.getMessageManager.mockReturnValue(mock<MessageManager>());
  api.getMicrophoneManager.mockReturnValue(mock<MicrophoneManager>());
  api.getQueryStringManager.mockReturnValue(mock<QueryStringManager>());
  api.getStatusBarItemManager.mockReturnValue(mock<StatusBarItemManager>());
  api.getStyleManager.mockReturnValue(mock<StyleManager>());
  api.getTriggersManager.mockReturnValue(mock<TriggersManager>());
  api.getViewItemManager.mockReturnValue(mock<ViewItemManager>());
  api.getViewManager.mockReturnValue(mock<ViewManager>());

  return api;
};

export const callStateWatcherCallback = (
  stateWatcher: StateWatcherSubscriptionInterface,
  diff: HassStateDifference,
  n = 0,
): void => {
  const mock = vi.mocked(stateWatcher.subscribe).mock;
  expect(mock.calls.length).greaterThan(n);
  mock.calls[n][0](diff);
};

/**
 * Flush resolved promises.
 */
export const flushPromises = async (): Promise<void> => {
  await new Promise(process.nextTick);
};

export const createInteractionActionEvent = (
  action: string,
): CustomEvent<Interaction> => {
  return new CustomEvent<Interaction>('@action', {
    detail: {
      action: action,
    },
  });
};

export const createSubmenuInteractionActionEvent = (
  action: string,
  item: SubmenuItem,
): CustomEvent<SubmenuInteraction> => {
  return new CustomEvent<SubmenuInteraction>('@action', {
    detail: {
      action,
      item,
    },
  });
};

export const setScreenfulEnabled = (enabled: boolean): void => {
  Object.defineProperty(screenfull, 'isEnabled', { value: enabled, writable: true });
};

export const createTouch = (touch?: Partial<Touch>): Touch => ({
  clientX: touch?.clientX ?? 0,
  clientY: touch?.clientY ?? 0,
  force: touch?.force ?? 0,
  identifier: touch?.identifier ?? 0,
  pageX: touch?.pageX ?? 0,
  pageY: touch?.pageY ?? 0,
  radiusX: touch?.radiusX ?? 0,
  radiusY: touch?.radiusY ?? 0,
  rotationAngle: touch?.rotationAngle ?? 0,
  screenX: touch?.screenX ?? 0,
  screenY: touch?.screenY ?? 0,
  target: touch?.target ?? document.createElement('div'),
});

export const createTouchEvent = (
  type: string,
  options?: { touches?: Touch[]; changedTouches?: Touch[] },
): TouchEvent => {
  return new TouchEvent(type, {
    bubbles: false,
    touches: options?.touches,
    changedTouches: options?.changedTouches,
  });
};

export const createFolder = (config?: Partial<FolderConfig>): FolderConfig => {
  return {
    type: 'ha',
    ha: {
      path: [{ id: 'media-source://' }],
    },
    ...config,
  };
};

export const createBrowseMedia = (media?: Partial<BrowseMedia>): BrowseMedia => {
  return {
    title: 'Test Media',
    media_class: 'video',
    media_content_type: 'video/mp4',
    media_content_id: 'content_id',
    can_play: true,
    can_expand: false,
    thumbnail: null,
    children: null,
    ...media,
  };
};

export const createRichBrowseMedia = (
  media?: Partial<RichBrowseMedia<BrowseMediaMetadata>>,
): RichBrowseMedia<BrowseMediaMetadata> => {
  return {
    ...createBrowseMedia(media),
    _metadata: media?._metadata ?? {
      cameraID: 'camera.test',
      startDate: new Date('2024-11-19T07:23:00'),
      endDate: new Date('2025-11-19T07:24:00'),
    },
  };
};



================================================
FILE: tests/cache/cache.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { Cache } from '../../src/cache/cache';

interface TestCacheValue {
  val: number;
}

describe('Cache', () => {
  describe('has', () => {
    it('positive', () => {
      const cache = new Cache<string, TestCacheValue>();
      cache.set('test', { val: 2 });
      expect(cache.has('test')).toBeTruthy();
    });

    it('negative', () => {
      const cache = new Cache<string, TestCacheValue>();
      expect(cache.has('absent')).toBeFalsy();
    });
  });

  describe('get', () => {
    it('positive', () => {
      const cache = new Cache<string, TestCacheValue>();
      cache.set('test', { val: 2 });
      expect(cache.get('test')).toEqual({ val: 2 });
    });

    it('negative', () => {
      const cache = new Cache<string, TestCacheValue>();
      expect(cache.get('absent')).toBeNull();
    });
  });

  it('delete', () => {
    const cache = new Cache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    cache.delete('test-2');

    expect(cache.get('test-2')).toBeNull();
    expect(cache.get('test-1')).toEqual({ val: 1 });
    expect(cache.get('test-3')).toEqual({ val: 3 });
  });

  it('clear', () => {
    const cache = new Cache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    cache.clear();

    expect(cache.get('test-1')).toBeNull();
    expect(cache.get('test-2')).toBeNull();
    expect(cache.get('test-3')).toBeNull();
  });

  it('getMatches', () => {
    const cache = new Cache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    expect(cache.getMatches((obj) => obj.val >= 2)).toEqual([{ val: 2 }, { val: 3 }]);
  });

  it('entries', () => {
    const cache = new Cache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    expect([...cache.entries()]).toEqual([
      ['test-1', { val: 1 }],
      ['test-2', { val: 2 }],
      ['test-3', { val: 3 }],
    ]);
  });
});



================================================
FILE: tests/cache/equality-cache.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { EqualityCache } from '../../src/cache/equality-cache';

interface TestCacheValue {
  val: number;
}

describe('EqualityCache', () => {
  describe('has', () => {
    it('positive', () => {
      const cache = new EqualityCache<string, TestCacheValue>();
      cache.set('test', { val: 2 });
      expect(cache.has('test')).toBeTruthy();
    });

    it('negative', () => {
      const cache = new EqualityCache<string, TestCacheValue>();
      expect(cache.has('absent')).toBeFalsy();
    });
  });

  describe('get', () => {
    it('positive', () => {
      const cache = new EqualityCache<string, TestCacheValue>();
      const original = { val: 2 };
      cache.set('test', original);

      const replacement = { val: 2 };
      cache.set('test', replacement);

      expect(cache.get('test')).not.toBe(original);
      expect(cache.get('test')).toBe(replacement);
    });

    it('negative', () => {
      const cache = new EqualityCache<string, TestCacheValue>();
      expect(cache.get('absent')).toBeNull();
    });
  });

  it('delete', () => {
    const cache = new EqualityCache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    cache.delete('test-2');

    expect(cache.get('test-2')).toBeNull();
    expect(cache.get('test-1')).toEqual({ val: 1 });
    expect(cache.get('test-3')).toEqual({ val: 3 });
  });

  it('clear', () => {
    const cache = new EqualityCache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    cache.clear();

    expect(cache.get('test-1')).toBeNull();
    expect(cache.get('test-2')).toBeNull();
    expect(cache.get('test-3')).toBeNull();
  });

  it('getMatches', () => {
    const cache = new EqualityCache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    expect(cache.getMatches((obj) => obj.val >= 2)).toEqual([{ val: 2 }, { val: 3 }]);
  });

  it('entries', () => {
    const cache = new EqualityCache<string, TestCacheValue>();
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    expect([...cache.entries()]).toEqual([
      ['test-1', { val: 1 }],
      ['test-2', { val: 2 }],
      ['test-3', { val: 3 }],
    ]);
  });
});



================================================
FILE: tests/cache/equality-map.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { EqualityMap } from '../../src/cache/equality-map';

describe('EqualityMap', () => {
  it('should set and get values with primitive keys', () => {
    const map = new EqualityMap<string, number>();
    map.set('a', 1);
    expect(map.get('a')).toBe(1);
    expect(map.has('a')).toBe(true);
    expect(map.get('b')).toBeUndefined();
    expect(map.has('b')).toBe(false);
  });

  it('should set and get values with object keys using deep equality', () => {
    const map = new EqualityMap<{ x: number }, string>();
    map.set({ x: 1 }, 'foo');
    expect(map.get({ x: 1 })).toBe('foo');
    expect(map.has({ x: 1 })).toBe(true);
    expect(map.get({ x: 2 })).toBeUndefined();
  });

  it('should overwrite value if key is deeply equal', () => {
    const map = new EqualityMap<{ y: number }, string>();
    map.set({ y: 2 }, 'bar');
    map.set({ y: 2 }, 'baz');
    expect(map.get({ y: 2 })).toBe('baz');
    expect(map.size).toBe(1);
  });

  it('should delete values by deep equality', () => {
    const map = new EqualityMap<{ z: number }, string>();
    map.set({ z: 3 }, 'val');
    expect(map.delete({ z: 3 })).toBe(true);
    expect(map.get({ z: 3 })).toBeUndefined();
    expect(map.size).toBe(0);
  });

  it('should clear all values', () => {
    const map = new EqualityMap<number, string>();
    map.set(1, 'a');
    map.set(2, 'b');
    map.clear();
    expect(map.size).toBe(0);
    expect(map.get(1)).toBeUndefined();
    expect(map.get(2)).toBeUndefined();
  });

  it('should iterate entries', () => {
    const map = new EqualityMap<string, number>();
    map.set('a', 1);
    map.set('b', 2);
    const entries = Array.from(map);
    expect(entries).toContainEqual(['a', 1]);
    expect(entries).toContainEqual(['b', 2]);
  });

  it('should iterate keys', () => {
    const map = new EqualityMap<string, number>();
    map.set('x', 10);
    map.set('y', 20);
    const keys = Array.from(map.keys());
    expect(keys).toContain('x');
    expect(keys).toContain('y');
  });

  it('should iterate values', () => {
    const map = new EqualityMap<string, number>();
    map.set('foo', 100);
    map.set('bar', 200);
    const values = Array.from(map.values());
    expect(values).toContain(100);
    expect(values).toContain(200);
  });

  it('should call forEach with correct arguments', () => {
    const map = new EqualityMap<string, number>();
    map.set('a', 1);
    map.set('b', 2);
    const calls: [number, string][] = [];
    map.forEach((value, key) => {
      calls.push([value, key]);
    });
    expect(calls).toContainEqual([1, 'a']);
    expect(calls).toContainEqual([2, 'b']);
  });

  it('should have correct Symbol.toStringTag', () => {
    const map = new EqualityMap<number, number>();
    expect(Object.prototype.toString.call(map)).toBe('[object EqualityMap]');
  });
});



================================================
FILE: tests/cache/expiring-cache.test.ts
================================================
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { ExpiringEqualityCache } from '../../src/cache/expiring-cache';

describe('ExpiringEqualityCache', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should set and get a value', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123);
    expect(cache.get('foo')).toBe(123);
  });

  it('should return null for a non-existent key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    expect(cache.get('foo')).toBeNull();
  });

  it('should return null for an expired key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    const expiryDate = new Date(Date.now() + 1000);
    cache.set('foo', 123, expiryDate);
    vi.advanceTimersByTime(1001);
    expect(cache.get('foo')).toBeNull();
  });

  it('should return the value if not expired', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    const expiryDate = new Date(Date.now() + 1000);
    cache.set('foo', 123, expiryDate);
    vi.advanceTimersByTime(500);
    expect(cache.get('foo')).toBe(123);
  });

  it('should correctly report has for existing non-expired key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123, new Date(Date.now() + 1000));
    expect(cache.has('foo')).toBe(true);
  });

  it('should correctly report has for existing key with no expiry', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123);
    expect(cache.has('foo')).toBe(true);
  });

  it('should correctly report not for has for non-existent key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    expect(cache.has('foo')).toBe(false);
  });

  it('should correctly report not for has for expired key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123, new Date(Date.now() + 1000));
    vi.advanceTimersByTime(1001);
    expect(cache.has('foo')).toBe(false);
  });

  it('should delete a key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123);
    expect(cache.delete('foo')).toBe(true);
    expect(cache.get('foo')).toBeNull();
    expect(cache.has('foo')).toBe(false);
  });

  it('should return false when deleting a non-existent key', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    expect(cache.delete('foo')).toBe(false);
  });

  it('should clear all keys', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123);
    cache.set('bar', 456, new Date(Date.now() + 1000));
    cache.clear();
    expect(cache.get('foo')).toBeNull();
    expect(cache.get('bar')).toBeNull();
    expect(cache.has('foo')).toBe(false);
    expect(cache.has('bar')).toBe(false);
  });

  it('should iterate over entries', () => {
    const cache = new ExpiringEqualityCache<string, number>();

    cache.set('forever', 42);
    cache.set('bas', 43, new Date(Date.now()));
    cache.set('foo', 44, new Date(Date.now() + 1000));
    cache.set('bar', 45, new Date(Date.now() + 2000));

    vi.advanceTimersByTime(1001);

    expect([...cache.entries()]).toEqual([
      ['forever', 42],
      ['bar', 45],
    ]);
  });

  it('should return empty iterator for an empty cache', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    const entries = Array.from(cache.entries());
    expect(entries).toHaveLength(0);
  });

  it('should return empty iterator if all entries are expired', () => {
    const cache = new ExpiringEqualityCache<string, number>();
    cache.set('foo', 123, new Date(Date.now() - 1000));
    cache.set('bar', 456, new Date(Date.now() - 500));
    vi.advanceTimersByTime(1); // Ensure current time is past expiry
    const entries = Array.from(cache.entries());
    expect(entries).toHaveLength(0);
  });

  it('should get matches for non-expired values', () => {
    const cache = new ExpiringEqualityCache<string, { id: number; type: string }>();
    cache.set('a', { id: 1, type: 'A' });
    cache.set('b', { id: 2, type: 'B' }, new Date(Date.now() + 1000));
    cache.set('c', { id: 3, type: 'A' }, new Date(Date.now() - 1000)); // expired
    cache.set('d', { id: 4, type: 'A' }, new Date(Date.now() + 500));

    const matches = cache.getMatches((value) => value.type === 'A');
    expect(matches).toHaveLength(2);
    expect(matches).toContainEqual({ id: 1, type: 'A' });
    expect(matches).toContainEqual({ id: 4, type: 'A' });
  });

  it('should return empty array for getMatches on an empty cache', () => {
    const cache = new ExpiringEqualityCache<string, { id: number }>();
    const matches = cache.getMatches((value) => value.id > 0);
    expect(matches).toHaveLength(0);
  });

  it('should return empty array for getMatches if no values match predicate', () => {
    const cache = new ExpiringEqualityCache<string, { id: number }>();
    cache.set('a', { id: 1 });
    cache.set('b', { id: 2 });
    const matches = cache.getMatches((value) => value.id > 5);
    expect(matches).toHaveLength(0);
  });
});



================================================
FILE: tests/cache/lru.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { LRUCache } from '../../src/cache/lru';

interface TestCacheValue {
  val: number;
}

describe('LRUCache', () => {
  describe('has', () => {
    it('positive', () => {
      const cache = new LRUCache<string, TestCacheValue>(1);
      cache.set('test', { val: 2 });
      expect(cache.has('test')).toBeTruthy();
    });

    it('negative', () => {
      const cache = new LRUCache<string, TestCacheValue>(1);
      expect(cache.has('absent')).toBeFalsy();
    });
  });

  describe('get', () => {
    it('positive', () => {
      const cache = new LRUCache<string, TestCacheValue>(1);
      cache.set('test', { val: 2 });
      expect(cache.get('test')).toEqual({ val: 2 });
    });

    it('negative', () => {
      const cache = new LRUCache<string, TestCacheValue>(1);
      expect(cache.get('absent')).toBeNull();
    });
  });

  it('delete', () => {
    const cache = new LRUCache<string, TestCacheValue>(1);
    cache.set('test-1', { val: 1 });

    cache.delete('test-1');

    expect(cache.get('test-1')).toBeNull();
  });

  it('clear', () => {
    const cache = new LRUCache<string, TestCacheValue>(1);
    cache.set('test-1', { val: 1 });

    cache.clear();

    expect(cache.get('test-1')).toBeNull();
  });

  it('getMatches', () => {
    const cache = new LRUCache<string, TestCacheValue>(1);
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    expect(cache.getMatches((obj) => obj.val >= 0)).toEqual([{ val: 3 }]);
  });

  it('entries', () => {
    const cache = new LRUCache<string, TestCacheValue>(1);
    cache.set('test-1', { val: 1 });
    cache.set('test-2', { val: 2 });
    cache.set('test-3', { val: 3 });

    expect([...cache.entries()]).toEqual([['test-3', { val: 3 }]]);
  });
});



================================================
FILE: tests/camera-manager/cache.test.ts
================================================
import { add, sub } from 'date-fns';
import { sortBy } from 'lodash-es';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { RecordingSegmentsCache } from '../../src/camera-manager/cache.js';
import { DateRange } from '../../src/camera-manager/range.js';
import {
  CameraManagerRequestCache,
  CameraQuery,
  Engine,
  EventQuery,
  QueryResultsType,
  QueryReturnType,
  QueryType,
  RecordingSegment,
} from '../../src/camera-manager/types.js';

describe('MemoryRequestCache', () => {
  const cache = new CameraManagerRequestCache();
  const request: CameraQuery = {
    type: QueryType.Event,
    cameraIDs: new Set(['camera-1']),
  };
  const response: QueryReturnType<EventQuery> = {
    type: QueryResultsType.Event,
    engine: Engine.Generic,
  };

  beforeEach(() => {
    cache.clear();
  });

  it('should get value when set', () => {
    cache.set(request, response);
    expect(cache.get(request)).toBe(response);
  });
  it('should get similar value when set', () => {
    cache.set(request, response);
    expect(cache.get({ ...request })).toBe(response);
  });
  it('should be empty when cleared', () => {
    cache.set(request, response);
    expect(cache.get({ ...request })).toBe(response);
    cache.clear();
    expect(cache.get(request)).toBeNull();
  });
  it('should have value when set', () => {
    cache.set(request, response);
    expect(cache.has(request)).toBeTruthy();
  });
  it('should not have value when set expired', () => {
    cache.set(request, response, sub(new Date(), { hours: 1 }));
    expect(cache.has(request)).toBeFalsy();
  });
  it('should not have value when get expired', () => {
    const now = new Date();
    cache.set(request, response, add(now, { hours: 1 }));
    expect(cache.has(request)).toBeTruthy();

    vi.useFakeTimers();
    vi.setSystemTime(add(now, { hours: 2 }));
    expect(cache.has(request)).toBeFalsy();
    vi.useRealTimers();
  });
});

describe('RecordingSegmentsCache', () => {
  const cache = new RecordingSegmentsCache();
  const now = new Date();
  const range: DateRange = {
    start: now,
    end: add(now, { hours: 1 }),
  };
  const pastRange = { start: sub(now, { hours: 1 }), end: now };
  const createSegment = (date: Date, id: string): RecordingSegment => {
    return {
      start_time: date.getTime() / 1000,
      end_time: date.getTime() / 1000 + 10,
      id: id,
    };
  };
  const segments = [
    createSegment(now, 'segment-1'),
    createSegment(add(now, { seconds: 10 }), 'segment-2'),
    createSegment(add(now, { seconds: 20 }), 'segment-3'),
  ];

  beforeEach(() => {
    cache.clear();
  });

  it('should get segments when added', () => {
    cache.add('camera-1', range, segments);
    expect(cache.get('camera-1', range)).toEqual(segments);
  });
  it('should get some segments for shorter range', () => {
    cache.add('camera-1', range, segments);
    expect(cache.get('camera-1', { ...range, end: add(now, { seconds: 5 }) })).toEqual([
      segments[0],
    ]);
  });
  it('should not get for other range', () => {
    cache.add('camera-1', range, segments);
    expect(cache.get('camera-1', pastRange)).toBeNull();
  });

  it('should have coverage when added', () => {
    cache.add('camera-1', range, segments);
    expect(cache.hasCoverage('camera-1', range)).toBeTruthy();
  });
  it('should not have coverage for other camera', () => {
    cache.add('camera-1', range, segments);
    expect(cache.hasCoverage('camera-2', range)).toBeFalsy();
  });
  it('should not have coverage for other range', () => {
    cache.add('camera-1', range, segments);
    expect(cache.hasCoverage('camera-1', pastRange)).toBeFalsy();
  });

  it('should be empty when cleared', () => {
    cache.add('camera-1', range, segments);
    cache.clear();
    expect(cache.get('camera-1', range)).toBeNull();
    expect(cache.hasCoverage('camera-1', range)).toBeFalsy();
  });

  it('should get size', () => {
    cache.add('camera-1', range, segments);
    expect(cache.getSize('camera-1')).toBe(3);
  });
  it('should not size for other camera', () => {
    cache.add('camera-1', range, segments);
    expect(cache.getSize('camera-2')).toBeNull();
  });

  it('should return cameraIDs', () => {
    cache.add('camera-1', range, segments);
    cache.add('camera-2', range, segments);
    expect(sortBy(cache.getCameraIDs())).toEqual(sortBy(['camera-1', 'camera-2']));
  });

  it('should add segments to existing range', () => {
    cache.add('camera-1', range, segments);
    cache.add('camera-1', range, [
      createSegment(add(now, { seconds: 15 }), 'segment-2.5'),
    ]);
    expect(cache.get('camera-1', range)?.length).toBe(4);
  });
  it('should not get segments that are outside range', () => {
    cache.add('camera-1', range, segments);
    expect(cache.get('camera-1', range)?.length).toBe(3);
    // Add a segment before and after the desired range.
    cache.add('camera-1', range, [
      createSegment(sub(now, { seconds: 15 }), 'segment-0'),
      createSegment(add(range.end, { seconds: 10 }), 'segment-4'),
    ]);
    expect(cache.get('camera-1', range)?.length).toBe(3);
  });

  it('should remove expired matches', () => {
    cache.add('camera-1', range, segments);
    cache.expireMatches('camera-1', (segment) => segment === segments[0]);
    expect(sortBy(cache.get('camera-1', range))).toEqual(segments.splice(1));
  });
});



================================================
FILE: tests/camera-manager/camera.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { Camera } from '../../src/camera-manager/camera.js';
import { GenericCameraManagerEngine } from '../../src/camera-manager/generic/engine-generic.js';
import { CameraProxyConfig } from '../../src/camera-manager/types.js';
import { StateWatcherSubscriptionInterface } from '../../src/card-controller/hass/state-watcher.js';
import { ProxyConfig } from '../../src/config/schema/cameras.js';
import {
  callStateWatcherCallback,
  createCameraConfig,
  createCapabilities,
  createStateEntity,
} from '../test-utils.js';

describe('Camera', () => {
  it('should get config', async () => {
    const config = createCameraConfig();
    const camera = new Camera(
      config,
      new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
    );
    expect(camera.getConfig()).toBe(config);
  });

  describe('should get capabilities', async () => {
    it('when populated', async () => {
      const capabilities = createCapabilities();
      const camera = new Camera(
        createCameraConfig(),
        new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
        {
          capabilities: capabilities,
        },
      );
      expect(camera.getCapabilities()).toBe(capabilities);
    });

    it('when unpopulated', async () => {
      const camera = new Camera(
        createCameraConfig(),
        new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
      );
      expect(camera.getCapabilities()).toBeNull();
    });
  });

  it('should get engine', async () => {
    const engine = new GenericCameraManagerEngine(
      mock<StateWatcherSubscriptionInterface>(),
    );
    const camera = new Camera(createCameraConfig(), engine);
    expect(camera.getEngine()).toBe(engine);
  });

  it('should set and get id', async () => {
    const camera = new Camera(
      createCameraConfig(),
      new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
    );
    camera.setID('foo');
    expect(camera.getID()).toBe('foo');
    expect(camera.getConfig().id).toBe('foo');
  });

  it('should throw without id', async () => {
    const camera = new Camera(
      createCameraConfig(),
      new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
    );
    expect(() => camera.getID()).toThrowError(
      'Could not determine camera id for the following ' +
        "camera, may need to set 'id' parameter manually",
    );
  });

  it('should initialize and destroy', async () => {
    const camera = new Camera(
      createCameraConfig({
        triggers: {
          entities: ['camera.foo'],
        },
      }),
      new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
      {
        capabilities: createCapabilities({ trigger: true }),
      },
    );

    const stateWatcher = mock<StateWatcherSubscriptionInterface>();
    await camera.initialize({
      stateWatcher: stateWatcher,
    });

    expect(stateWatcher.subscribe).toBeCalledWith(expect.any(Function), ['camera.foo']);

    await camera.destroy();

    expect(stateWatcher.unsubscribe).toBeCalled();
  });

  describe('should handle trigger state changes', () => {
    beforeEach(() => {
      vi.restoreAllMocks();
    });

    it.each([
      ['off' as const, 'on' as const, 'new' as const],
      ['on' as const, 'off' as const, 'end' as const],
    ])(
      'from %s to %s',
      async (stateFrom: string, stateTo: string, eventType: 'new' | 'end') => {
        vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

        const eventCallback = vi.fn();
        const camera = new Camera(
          createCameraConfig({
            id: 'camera_1',
            triggers: {
              entities: ['binary_sensor.foo'],
            },
          }),
          new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
          {
            capabilities: createCapabilities({ trigger: true }),
            eventCallback: eventCallback,
          },
        );

        const stateWatcher = mock<StateWatcherSubscriptionInterface>();
        await camera.initialize({
          stateWatcher: stateWatcher,
        });

        expect(stateWatcher.subscribe).toBeCalled();

        const diff = {
          entityID: 'sensor.force_update',
          oldState: createStateEntity({ state: stateFrom }),
          newState: createStateEntity({ state: stateTo }),
        };
        callStateWatcherCallback(stateWatcher, diff);

        expect(eventCallback).toBeCalledWith({
          cameraID: 'camera_1',
          type: eventType,
        });
      },
    );

    it('should not trigger without trigger capability', async () => {
      const eventCallback = vi.fn();
      const camera = new Camera(
        createCameraConfig({
          id: 'camera_1',
          triggers: {
            entities: ['binary_sensor.foo'],
          },
        }),
        new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
        {
          capabilities: createCapabilities({ trigger: false }),
          eventCallback: eventCallback,
        },
      );

      const stateWatcher = mock<StateWatcherSubscriptionInterface>();
      await camera.initialize({
        stateWatcher: stateWatcher,
      });

      expect(stateWatcher.subscribe).not.toBeCalled();
    });
  });

  describe('should get proxy config', () => {
    it.each([
      [
        'when unspecified',
        {},
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when media set to true',
        { media: true },
        {
          dynamic: true,
          media: true,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when media set to false',
        { media: false as const },
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when media set to auto',
        { media: 'auto' as const },
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when ssl_verification is set to auto',
        { ssl_verification: 'auto' as const },
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when ssl_verification is set to true',
        { ssl_verification: true },
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when ssl_verification is set to false',
        { ssl_verification: false },
        {
          dynamic: true,
          media: false,
          ssl_verification: false,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when ssl_ciphers is set to auto',
        { ssl_ciphers: 'auto' as const },
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
      [
        'when ssl_ciphers is set to modern',
        { ssl_ciphers: 'modern' as const },
        {
          dynamic: true,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'modern' as const,
        },
      ],
      [
        'when dynamic is set to false',
        { dynamic: false },
        {
          dynamic: false,
          media: false,
          ssl_verification: true,
          ssl_ciphers: 'default' as const,
        },
      ],
    ])(
      '%s',
      (
        _name: string,
        proxyConfig: Partial<ProxyConfig>,
        expectedResult: CameraProxyConfig,
      ) => {
        const camera = new Camera(
          createCameraConfig({
            proxy: proxyConfig,
          }),
          new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>()),
        );
        expect(camera.getProxyConfig()).toEqual(expectedResult);
      },
    );
  });
});



================================================
FILE: tests/camera-manager/capabilities.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { Capabilities } from '../../src/camera-manager/capabilities';
import {
  CapabilityKey,
  PTZCapabilities,
  PTZMovementType,
  capabilityKeys,
} from '../../src/types';

describe('Capabilities', () => {
  it('default capabilities', () => {
    const capabilities = new Capabilities({});
    for (const key of capabilityKeys) {
      expect(capabilities.has(key)).toBeFalsy();
    }
  });

  describe('simple presence checks', () => {
    it.each([
      'clips',
      'favorite-events',
      'favorite-recordings',
      'live',
      'menu',
      'recordings',
      'seek',
      'snapshots',
      'substream',
    ] as const)('%s', (capability: CapabilityKey) => {
      const capabilities = new Capabilities({
        [capability]: true,
      });
      expect(capabilities.has(capability)).toBeTruthy();
    });
  });

  describe('complex matches', () => {
    it('string matcher', () => {
      const capabilities = new Capabilities({
        live: true,
      });
      expect(capabilities.matches('live')).toBeTruthy();
      expect(capabilities.matches('clips')).toBeFalsy();
    });

    it('allCapabilities matcher', () => {
      const capabilities = new Capabilities({
        live: true,
        clips: true,
      });
      expect(capabilities.matches({ allCapabilities: ['live', 'clips'] })).toBeTruthy();
      expect(
        capabilities.matches({ allCapabilities: ['live', 'snapshots'] }),
      ).toBeFalsy();
    });

    it('anyCapabilities matcher', () => {
      const capabilities = new Capabilities({
        live: true,
        clips: true,
      });
      expect(capabilities.matches({ anyCapabilities: ['live', 'clips'] })).toBeTruthy();
      expect(
        capabilities.matches({ anyCapabilities: ['live', 'snapshots'] }),
      ).toBeTruthy();
      expect(
        capabilities.matches({ anyCapabilities: ['snapshots', 'menu'] }),
      ).toBeFalsy();
    });
  });

  describe('getPTZCapabilities', () => {
    it('when unset', () => {
      const capabilities = new Capabilities({});
      expect(capabilities.getPTZCapabilities()).toBeNull();
      expect(capabilities.hasPTZCapability()).toBeFalsy();
    });

    it('when set', () => {
      const ptz: PTZCapabilities = {
        left: [PTZMovementType.Continuous],
        presets: ['1', '2'],
      };
      const capabilities = new Capabilities({
        ptz: ptz,
      });
      expect(capabilities.getPTZCapabilities()).toBe(ptz);
      expect(capabilities.hasPTZCapability()).toBeTruthy();
    });
  });

  describe('disable capabilities', () => {
    it('disable', () => {
      const capabilities = new Capabilities(
        {
          live: true,
          clips: true,
          snapshots: true,
        },
        {
          disable: ['live', 'clips'],
        },
      );
      expect(capabilities.has('live')).toBeFalsy();
      expect(capabilities.has('clips')).toBeFalsy();
      expect(capabilities.has('snapshots')).toBeTruthy();
    });

    it('disableExcept', () => {
      const capabilities = new Capabilities(
        {
          live: true,
          clips: true,
          snapshots: true,
        },
        {
          disableExcept: ['live', 'clips'],
        },
      );
      expect(capabilities.has('live')).toBeTruthy();
      expect(capabilities.has('clips')).toBeTruthy();
      expect(capabilities.has('snapshots')).toBeFalsy();
    });
  });
});



================================================
FILE: tests/camera-manager/engine-factory.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CameraManagerEngineFactory } from '../../src/camera-manager/engine-factory.js';
import { FrigateCameraManagerEngine } from '../../src/camera-manager/frigate/engine-frigate';
import { GenericCameraManagerEngine } from '../../src/camera-manager/generic/engine-generic';
import { MotionEyeCameraManagerEngine } from '../../src/camera-manager/motioneye/engine-motioneye';
import { ReolinkCameraManagerEngine } from '../../src/camera-manager/reolink/engine-reolink.js';
import { Engine } from '../../src/camera-manager/types.js';
import { StateWatcherSubscriptionInterface } from '../../src/card-controller/hass/state-watcher.js';
import { CardWideConfig } from '../../src/config/schema/types.js';
import { EntityRegistryManager } from '../../src/ha/registry/entity/types.js';
import { ResolvedMediaCache } from '../../src/ha/resolved-media.js';
import { EntityRegistryManagerMock } from '../ha/registry/entity/mock.js';
import {
  createCameraConfig,
  createHASS,
  createRegistryEntity,
  createStateEntity,
} from '../test-utils';

vi.mock('../../src/utils/ha/entity-registry');
vi.mock('../../src/utils/ha/entity-registry/cache');

const createFactory = (options?: {
  entityRegistryManager?: EntityRegistryManager;
  cardWideConfig?: CardWideConfig;
}): CameraManagerEngineFactory => {
  return new CameraManagerEngineFactory(
    options?.entityRegistryManager ?? new EntityRegistryManagerMock(),
  );
};

describe('getEngineForCamera()', () => {
  describe('should get a frigate camera', () => {
    it('from manually set engine', async () => {
      const config = createCameraConfig({ engine: 'frigate' });
      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.Frigate,
      );
    });

    it('from auto detection', async () => {
      const config = createCameraConfig({ engine: 'auto', camera_entity: 'camera.foo' });
      const entityRegistryManager = new EntityRegistryManagerMock([
        createRegistryEntity({ entity_id: 'camera.foo', platform: 'frigate' }),
      ]);

      expect(
        await createFactory({
          entityRegistryManager: entityRegistryManager,
        }).getEngineForCamera(createHASS(), config),
      ).toBe(Engine.Frigate);
    });

    it('from config with camera_name', async () => {
      const config = createCameraConfig({
        frigate: { client_id: 'bar', camera_name: 'foo' },
      });
      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.Frigate,
      );
    });
  });

  describe('should get a motioneye camera', () => {
    it('from manually set engine', async () => {
      const config = createCameraConfig({ engine: 'motioneye' });
      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.MotionEye,
      );
    });

    it('from auto detection', async () => {
      const config = createCameraConfig({ engine: 'auto', camera_entity: 'camera.foo' });
      const entityRegistryManager = new EntityRegistryManagerMock([
        createRegistryEntity({ entity_id: 'camera.foo', platform: 'motioneye' }),
      ]);

      expect(
        await createFactory({
          entityRegistryManager: entityRegistryManager,
        }).getEngineForCamera(createHASS(), config),
      ).toBe(Engine.MotionEye);
    });
  });

  describe('should get a reolink camera', () => {
    it('from manually set engine', async () => {
      const config = createCameraConfig({ engine: 'reolink' });
      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.Reolink,
      );
    });

    it('from auto detection', async () => {
      const config = createCameraConfig({ engine: 'auto', camera_entity: 'camera.foo' });
      const entityRegistryManager = new EntityRegistryManagerMock([
        createRegistryEntity({ entity_id: 'camera.foo', platform: 'reolink' }),
      ]);

      expect(
        await createFactory({
          entityRegistryManager: entityRegistryManager,
        }).getEngineForCamera(createHASS(), config),
      ).toBe(Engine.Reolink);
    });
  });

  describe('should get a generic camera', () => {
    it('from manually set engine', async () => {
      const config = createCameraConfig({ engine: 'generic' });
      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.Generic,
      );
    });

    it('from auto detection', async () => {
      const config = createCameraConfig({ engine: 'auto', camera_entity: 'camera.foo' });
      const entityRegistryManager = new EntityRegistryManagerMock([
        createRegistryEntity({ entity_id: 'camera.foo', platform: 'generic' }),
      ]);

      expect(
        await createFactory({
          entityRegistryManager: entityRegistryManager,
        }).getEngineForCamera(createHASS(), config),
      ).toBe(Engine.Generic);
    });

    it('from entity not in registry but with state', async () => {
      const config = createCameraConfig({
        engine: 'auto',
        webrtc_card: { entity: 'camera.foo' },
      });
      const entityRegistryManager = new EntityRegistryManagerMock();

      expect(
        await createFactory({
          entityRegistryManager: entityRegistryManager,
        }).getEngineForCamera(
          createHASS({
            'camera.foo': createStateEntity(),
          }),
          config,
        ),
      ).toBe(Engine.Generic);
    });

    it('from entity not in registry and not in state', async () => {
      const config = createCameraConfig({
        engine: 'auto',
        webrtc_card: { entity: 'camera.foo' },
      });
      const entityRegistryManager = new EntityRegistryManagerMock();

      expect(
        async () =>
          await createFactory({
            entityRegistryManager: entityRegistryManager,
          }).getEngineForCamera(createHASS(), config),
      ).rejects.toThrow(/Could not find camera entity/);
    });

    it('from webrtc-card url', async () => {
      const config = createCameraConfig({
        engine: 'auto',
        webrtc_card: { url: 'camera.foo' },
      });

      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.Generic,
      );
    });

    it('from go2rtc url and stream', async () => {
      const config = createCameraConfig({
        engine: 'auto',
        go2rtc: { url: 'https://my-go2rtc', stream: 'office' },
      });

      expect(await createFactory().getEngineForCamera(createHASS(), config)).toBe(
        Engine.Generic,
      );
    });
  });

  it('should get no engine from config with insufficient details', async () => {
    const config = createCameraConfig({});
    expect(await createFactory().getEngineForCamera(createHASS(), config)).toBeNull();
  });

  it('should throw error on invalid entity', async () => {
    const config = createCameraConfig({ engine: 'auto', camera_entity: 'camera.foo' });
    const entityRegistryManager = mock<EntityRegistryManager>();
    entityRegistryManager.getEntity.mockRejectedValue(new Error());

    await expect(
      createFactory({
        entityRegistryManager: entityRegistryManager,
      }).getEngineForCamera(createHASS(), config),
    ).rejects.toThrow();
  });
});

describe('createEngine()', () => {
  it('should create generic engine', async () => {
    expect(
      await createFactory().createEngine(Engine.Generic, {
        stateWatcher: mock<StateWatcherSubscriptionInterface>(),
        resolvedMediaCache: mock<ResolvedMediaCache>(),
      }),
    ).toBeInstanceOf(GenericCameraManagerEngine);
  });
  it('should create frigate engine', async () => {
    expect(
      await createFactory().createEngine(Engine.Frigate, {
        stateWatcher: mock<StateWatcherSubscriptionInterface>(),
        resolvedMediaCache: mock<ResolvedMediaCache>(),
      }),
    ).toBeInstanceOf(FrigateCameraManagerEngine);
  });
  it('should create motioneye engine', async () => {
    expect(
      await createFactory().createEngine(Engine.MotionEye, {
        stateWatcher: mock<StateWatcherSubscriptionInterface>(),
        resolvedMediaCache: mock<ResolvedMediaCache>(),
      }),
    ).toBeInstanceOf(MotionEyeCameraManagerEngine);
  });
  it('should create reolink engine', async () => {
    expect(
      await createFactory().createEngine(Engine.Reolink, {
        stateWatcher: mock<StateWatcherSubscriptionInterface>(),
        resolvedMediaCache: mock<ResolvedMediaCache>(),
      }),
    ).toBeInstanceOf(ReolinkCameraManagerEngine);
  });
});



================================================
FILE: tests/camera-manager/manager.test.ts
================================================
import { add } from 'date-fns';
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { Camera } from '../../src/camera-manager/camera.js';
import { Capabilities } from '../../src/camera-manager/capabilities.js';
import { CameraManagerEngineFactory } from '../../src/camera-manager/engine-factory.js';
import { CameraManagerEngine } from '../../src/camera-manager/engine.js';
import {
  CameraManager,
  CameraQueryClassifier,
  QueryResultClassifier,
} from '../../src/camera-manager/manager.js';
import {
  CameraEndpoints,
  CameraEndpointsContext,
  CameraEvent,
  CameraManagerCameraMetadata,
  Engine,
  EventQuery,
  EventQueryResults,
  MediaMetadata,
  QueryResults,
  QueryResultsType,
  QueryType,
} from '../../src/camera-manager/types.js';
import { CardController } from '../../src/card-controller/controller.js';
import { sortItems } from '../../src/card-controller/view/sort.js';
import { CameraConfig } from '../../src/config/schema/cameras.js';
import { HomeAssistant } from '../../src/ha/types.js';
import { Endpoint, PTZMovementType } from '../../src/types.js';
import { ViewFolder, ViewItem, ViewMedia } from '../../src/view/item.js';
import { ViewItemCapabilities } from '../../src/view/types.js';
import {
  TestViewMedia,
  createCamera,
  createCameraConfig,
  createCapabilities,
  createCardAPI,
  createConfig,
  createFolder,
  createHASS,
  generateViewMediaArray,
} from '../test-utils.js';

describe('QueryClassifier', async () => {
  it('should classify event query', async () => {
    expect(CameraQueryClassifier.isEventQuery({ type: QueryType.Event })).toBeTruthy();
    expect(
      CameraQueryClassifier.isEventQuery({ type: QueryType.Recording }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isEventQuery({ type: QueryType.RecordingSegments }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isEventQuery({ type: QueryType.MediaMetadata }),
    ).toBeFalsy();
  });
  it('should classify recording query', async () => {
    expect(
      CameraQueryClassifier.isRecordingQuery({ type: QueryType.Event }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isRecordingQuery({ type: QueryType.Recording }),
    ).toBeTruthy();
    expect(
      CameraQueryClassifier.isRecordingQuery({ type: QueryType.RecordingSegments }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isRecordingQuery({ type: QueryType.MediaMetadata }),
    ).toBeFalsy();
  });
  it('should classify recording segments query', async () => {
    expect(
      CameraQueryClassifier.isRecordingSegmentsQuery({ type: QueryType.Event }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isRecordingSegmentsQuery({ type: QueryType.Recording }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isRecordingSegmentsQuery({
        type: QueryType.RecordingSegments,
      }),
    ).toBeTruthy();
    expect(
      CameraQueryClassifier.isRecordingSegmentsQuery({ type: QueryType.MediaMetadata }),
    ).toBeFalsy();
  });
  it('should classify media metadata query', async () => {
    expect(
      CameraQueryClassifier.isMediaMetadataQuery({ type: QueryType.Event }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isMediaMetadataQuery({ type: QueryType.Recording }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isMediaMetadataQuery({ type: QueryType.RecordingSegments }),
    ).toBeFalsy();
    expect(
      CameraQueryClassifier.isMediaMetadataQuery({ type: QueryType.MediaMetadata }),
    ).toBeTruthy();
  });
});

describe('QueryResultClassifier', async () => {
  const createResults = (type: Partial<QueryResultsType>): QueryResults => {
    return {
      type: type,
      engine: Engine.Generic,
    };
  };

  it('should classify event query result', async () => {
    expect(
      QueryResultClassifier.isEventQueryResult(createResults(QueryResultsType.Event)),
    ).toBeTruthy();
    expect(
      QueryResultClassifier.isEventQueryResult(
        createResults(QueryResultsType.Recording),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isEventQueryResult(
        createResults(QueryResultsType.RecordingSegments),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isEventQueryResult(
        createResults(QueryResultsType.MediaMetadata),
      ),
    ).toBeFalsy();
  });
  it('should classify recording query result', async () => {
    expect(
      QueryResultClassifier.isRecordingQueryResult(
        createResults(QueryResultsType.Event),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isRecordingQueryResult(
        createResults(QueryResultsType.Recording),
      ),
    ).toBeTruthy();
    expect(
      QueryResultClassifier.isRecordingQueryResult(
        createResults(QueryResultsType.RecordingSegments),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isRecordingQueryResult(
        createResults(QueryResultsType.MediaMetadata),
      ),
    ).toBeFalsy();
  });
  it('should classify recording segments query result', async () => {
    expect(
      QueryResultClassifier.isRecordingSegmentsQueryResult(
        createResults(QueryResultsType.Event),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isRecordingSegmentsQueryResult(
        createResults(QueryResultsType.Recording),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isRecordingSegmentsQueryResult(
        createResults(QueryResultsType.RecordingSegments),
      ),
    ).toBeTruthy();
    expect(
      QueryResultClassifier.isRecordingSegmentsQueryResult(
        createResults(QueryResultsType.MediaMetadata),
      ),
    ).toBeFalsy();
  });
  it('should classify media metadata query result', async () => {
    expect(
      QueryResultClassifier.isMediaMetadataQueryResult(
        createResults(QueryResultsType.Event),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isMediaMetadataQueryResult(
        createResults(QueryResultsType.Recording),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isMediaMetadataQueryResult(
        createResults(QueryResultsType.RecordingSegments),
      ),
    ).toBeFalsy();
    expect(
      QueryResultClassifier.isMediaMetadataQueryResult(
        createResults(QueryResultsType.MediaMetadata),
      ),
    ).toBeTruthy();
  });
});

describe('CameraManager', async () => {
  const baseCameraConfig = {
    id: 'id',
    camera_entity: 'camera.foo',
    engine: 'generic',
  };

  const baseEventQuery: EventQuery = {
    type: QueryType.Event as const,
    cameraIDs: new Set(['id']),
  };

  const baseEventQueryResults: EventQueryResults = {
    type: QueryResultsType.Event as const,
    engine: Engine.Generic,
  };

  const baseRecordingQuery = {
    type: QueryType.Recording as const,
    cameraIDs: new Set(['id']),
  };

  const baseRecordingQueryResults = {
    type: QueryResultsType.Recording as const,
    engine: Engine.Generic,
  };

  const createCameraManager = (
    api: CardController,
    engine?: CameraManagerEngine,
    cameras: {
      config?: CameraConfig;
      engineType?: Engine | null;
      capabilties?: Capabilities;
    }[] = [{}],
    factory?: CameraManagerEngineFactory,
  ): CameraManager => {
    const camerasConfig = cameras?.map(
      (camera) => camera.config ?? createCameraConfig(baseCameraConfig),
    );
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        cameras: camerasConfig,
      }),
    );

    const mockFactory = factory ?? mock<CameraManagerEngineFactory>();
    const mockEngine = engine ?? mock<CameraManagerEngine>();
    vi.mocked(mockFactory.createEngine).mockResolvedValueOnce(mockEngine);

    for (const camera of cameras ?? []) {
      const engineType =
        camera.engineType === undefined ? Engine.Generic : camera.engineType;
      if (engineType) {
        vi.mocked(mockEngine.createCamera).mockImplementationOnce(
          async (_hass: HomeAssistant, cameraConfig: CameraConfig): Promise<Camera> =>
            createCamera(
              cameraConfig,
              mockEngine,
              camera.capabilties ?? createCapabilities(),
            ),
        );
      }
      vi.mocked(mockFactory.getEngineForCamera).mockResolvedValueOnce(engineType);
    }

    return new CameraManager(api, { factory: mockFactory });
  };

  it('should construct', async () => {
    const manager = new CameraManager(createCardAPI());
    expect(manager.getStore()).toBeTruthy();
  });

  describe('should initialize cameras from config', () => {
    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      const manager = createCameraManager(api);

      await manager.initializeCamerasFromConfig();
      expect(manager.getStore().getCameraCount()).toBe(1);
      expect(manager.isInitialized()).toBeTruthy();
    });

    it('without hass', async () => {
      const manager = createCameraManager(createCardAPI());

      await manager.initializeCamerasFromConfig();
      expect(manager.getStore().getCameraCount()).toBe(0);
    });

    it('without a config', async () => {
      const api = createCardAPI();
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(null);

      const manager = createCameraManager(api);

      await manager.initializeCamerasFromConfig();
      expect(manager.getStore().getCameraCount()).toBe(0);
    });

    it('without an id', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = createCameraManager(api, mock<CameraManagerEngine>(), [
        {
          config: createCameraConfig({
            // No id.
            engine: 'generic',
          }),
        },
      ]);
      expect(await manager.initializeCamerasFromConfig()).toBeFalsy();
      expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(
        new Error(
          'Could not determine camera id for the following camera, ' +
            "may need to set 'id' parameter manually",
        ),
        'Camera initialization failed',
      );
    });

    it('with a duplicate id', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const cameraConfig = createCameraConfig({
        id: 'DUPLICATE',
        engine: 'generic',
      });
      const manager = createCameraManager(api, mock<CameraManagerEngine>(), [
        {
          config: cameraConfig,
        },
        {
          config: cameraConfig,
        },
      ]);
      expect(await manager.initializeCamerasFromConfig()).toBeFalsy();
      expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(
        new Error(
          'Duplicate camera id for the following camera, ' +
            "use the 'id' parameter to uniquely identify cameras",
        ),
        'Camera initialization failed',
      );
    });

    it('with no engine', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = createCameraManager(api, mock<CameraManagerEngine>(), [
        {
          config: createCameraConfig({
            id: 'id',
          }),
          engineType: null,
        },
      ]);
      expect(await manager.initializeCamerasFromConfig()).toBeFalsy();
      expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(
        new Error('Could not determine suitable engine for camera'),
        'Camera initialization failed',
      );
    });

    it('should pass events to triggers manager', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const factory = mock<CameraManagerEngineFactory>();
      const manager = createCameraManager(
        api,
        mock<CameraManagerEngine>(),
        [{}],
        factory,
      );
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
      const eventCallback = factory.createEngine.mock.calls[0][1].eventCallback;

      const cameraEvent: CameraEvent = {
        cameraID: 'camera',
        type: 'new',
      };
      eventCallback?.(cameraEvent);
      expect(api.getTriggersManager().handleCameraEvent).toBeCalledWith(cameraEvent);
    });

    describe('should fetch entity list when required', () => {
      it('with entity based trigger', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = createCameraManager(api, mock<CameraManagerEngine>(), [
          {
            config: createCameraConfig({
              ...baseCameraConfig,
              triggers: {
                occupancy: true,
              },
            }),
          },
        ]);

        expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
        expect(api.getEntityRegistryManager().fetchEntityList).toBeCalled();
      });

      it('without entity based trigger', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = createCameraManager(api);

        expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
        expect(api.getEntityRegistryManager().fetchEntityList).not.toBeCalled();
      });
    });

    describe('generate default queries', () => {
      it.each([
        [
          QueryType.Event as const,
          'generateDefaultEventQuery',
          'generateDefaultEventQueries',
        ],
        [
          QueryType.Recording as const,
          'generateDefaultRecordingQuery',
          'generateDefaultRecordingQueries',
        ],
        [
          QueryType.RecordingSegments as const,
          'generateDefaultRecordingSegmentsQuery',
          'generateDefaultRecordingSegmentsQueries',
        ],
      ])(
        'basic %s',
        async (
          queryType: string,
          engineMethodName: string,
          managerMethodName: string,
        ) => {
          const api = createCardAPI();
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

          const engine = mock<CameraManagerEngine>();
          const manager = createCameraManager(api, engine);
          expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

          const queries = [{ type: queryType, cameraIDs: new Set(['id']) }];
          engine[engineMethodName].mockReturnValue(queries);
          expect(manager[managerMethodName]('id')).toEqual(queries);
        },
      );

      it('without camera', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = createCameraManager(api, mock<CameraManagerEngine>());

        expect(manager.generateDefaultEventQueries('not_a_camera')).toBeNull();
      });

      it('without queries', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const engine = mock<CameraManagerEngine>();
        const manager = createCameraManager(api, engine);
        expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

        engine.generateDefaultEventQuery.mockReturnValue(null);
        expect(manager.generateDefaultEventQueries('id')).toBeNull();
      });
    });

    it('should merge defaults correctly', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine, [
        {
          config: createCameraConfig({
            ...baseCameraConfig,
            triggers: {
              events: ['snapshots'],
            },
          }),
        },
      ]);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
      expect(manager.getStore().getCamera('id')?.getConfig().triggers.events).toEqual([
        'snapshots',
      ]);
    });
  });

  describe('should get media metadata', () => {
    const query = {
      type: QueryType.MediaMetadata as const,
      cameraIDs: new Set('id'),
    };

    it('with nothing', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const queryResults = {
        type: QueryResultsType.MediaMetadata as const,
        engine: Engine.Generic,
        metadata: {},
      };

      engine.getMediaMetadata.mockResolvedValue(new Map([[query, queryResults]]));
      expect(await manager.getMediaMetadata()).toBeNull();
    });

    it.each([['days'], ['tags'], ['where'], ['what']])(
      'with %s',
      async (metadataType: string) => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const engine = mock<CameraManagerEngine>();
        const manager = createCameraManager(api, engine);
        expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

        const metadata: MediaMetadata = {
          [metadataType]: new Set(['data']),
        };
        const queryResults = {
          type: QueryResultsType.MediaMetadata as const,
          engine: Engine.Generic,
          metadata: metadata,
        };

        engine.getMediaMetadata.mockResolvedValue(new Map([[query, queryResults]]));
        expect(await manager.getMediaMetadata()).toEqual(metadata);
      },
    );
  });

  describe('should get events', () => {
    it('without hass', async () => {
      const manager = createCameraManager(createCardAPI());
      expect(await manager.getEvents(baseEventQuery)).toEqual(new Map());
    });

    it('without cameras', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const manager = createCameraManager(api);
      expect(await manager.getEvents(baseEventQuery)).toEqual(new Map());
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const engineOptions = {};
      const results = new Map([[baseEventQuery, baseEventQueryResults]]);
      engine.getEvents.mockResolvedValue(results);
      expect(await manager.getEvents(baseEventQuery, engineOptions)).toEqual(results);
      expect(engine.getEvents).toBeCalledWith(
        hass,
        expect.anything(),
        baseEventQuery,
        engineOptions,
      );
    });
  });

  describe('should get recordings', () => {
    it('successfully', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const engineOptions = {};
      const results = new Map([[baseRecordingQuery, baseRecordingQueryResults]]);
      engine.getRecordings.mockResolvedValue(results);
      expect(await manager.getRecordings(baseRecordingQuery, engineOptions)).toEqual(
        results,
      );
    });
  });

  describe('should get recording segments', () => {
    const query = {
      type: QueryType.RecordingSegments as const,
      cameraIDs: new Set(['id']),
      start: new Date(),
      end: new Date(),
    };

    const queryResults = {
      type: QueryResultsType.RecordingSegments as const,
      engine: Engine.Generic,
      segments: [],
    };

    it('successfully', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const engineOptions = {};
      const results = new Map([[query, queryResults]]);
      engine.getRecordingSegments.mockResolvedValue(results);
      expect(await manager.getRecordingSegments(query, engineOptions)).toEqual(results);
    });
  });

  describe('should execute media queries', () => {
    it('events', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const results = new Map([[baseEventQuery, baseEventQueryResults]]);
      engine.getEvents.mockResolvedValue(results);
      const media = sortItems(generateViewMediaArray({ count: 5 }));
      engine.generateMediaFromEvents.mockReturnValue(media);

      expect(await manager.executeMediaQueries([baseEventQuery])).toEqual(media);
    });

    it('no converted media', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const results = new Map([[baseEventQuery, baseEventQueryResults]]);
      engine.getEvents.mockResolvedValue(results);
      engine.generateMediaFromEvents.mockReturnValue(null);

      expect(await manager.executeMediaQueries([baseEventQuery])).toEqual([]);
    });

    it('without matching camera engine during conversion', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const results = new Map([
        [baseEventQuery, { ...baseEventQueryResults, engine: Engine.MotionEye }],
      ]);
      engine.getEvents.mockResolvedValue(results);

      expect(await manager.executeMediaQueries([baseEventQuery])).toEqual([]);
    });

    it('recordings', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const engine = mock<CameraManagerEngine>();
      vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

      const manager = createCameraManager(api, engine);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const results = new Map([[baseRecordingQuery, baseRecordingQueryResults]]);
      engine.getRecordings.mockResolvedValue(results);
      const media = sortItems(generateViewMediaArray({ count: 5 }));
      engine.generateMediaFromRecordings.mockReturnValue(media);

      expect(await manager.executeMediaQueries([baseRecordingQuery])).toEqual(media);
    });

    it('without hass', async () => {
      const engine = mock<CameraManagerEngine>();
      vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

      const manager = createCameraManager(createCardAPI(), engine);
      const results = new Map([[baseEventQuery, baseEventQueryResults]]);
      engine.getEvents.mockResolvedValue(results);

      expect(await manager.executeMediaQueries([baseEventQuery])).toEqual([]);
    });
  });

  describe('should extend media queries', () => {
    const dateBase = new Date('2024-03-01T20:01:00');
    const mediaTwoCameras = generateViewMediaArray({ count: 5 });
    const mediaMixedStart: ViewItem[] = [
      new TestViewMedia({
        startTime: dateBase,
      }),
      new TestViewMedia({
        startTime: add(dateBase, { days: 1 }),
      }),
      new TestViewMedia({
        startTime: add(dateBase, { days: 2 }),
      }),
      new ViewFolder(createFolder()),
    ];

    it('without hass', async () => {
      const engine = mock<CameraManagerEngine>();
      vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

      const manager = createCameraManager(createCardAPI(), engine);
      expect(await manager.extendMediaQueries([baseEventQuery], [], 'later')).toBeNull();
    });

    it.each([
      ['empty query and results', new Map(), [], [], [], null],
      [
        'query without existing media',
        new Map([[baseEventQuery, baseEventQueryResults]]),
        [],
        [{ ...baseEventQuery, limit: 50 }],
        generateViewMediaArray({ count: 5 }),
        {
          queries: [{ ...baseEventQuery, limit: 50 }],
          results: sortItems(generateViewMediaArray({ count: 5 })),
        },
      ],
      [
        'query that extends existing results',
        new Map([[baseEventQuery, baseEventQueryResults]]),
        generateViewMediaArray({ count: 5, cameraIDs: ['kitchen'] }),
        [{ ...baseEventQuery, limit: 50 }],
        generateViewMediaArray({ count: 5, cameraIDs: ['office'] }),
        {
          queries: [{ ...baseEventQuery, limit: 50 }],
          results: sortItems(mediaTwoCameras),
        },
      ],
      [
        'query with existing media but no new media',
        new Map([[baseEventQuery, baseEventQueryResults]]),
        mediaTwoCameras,
        [
          {
            ...baseEventQuery,
            limit: 50,
          },
        ],

        // Fetch identical media again.
        mediaTwoCameras,

        // Returns null to signify nothing new.
        null,
      ],
      [
        'query fetching later',
        new Map([[{ ...baseEventQuery, start: dateBase }, baseEventQueryResults]]),
        mediaMixedStart,
        [
          {
            ...baseEventQuery,
            limit: 50,
            start: add(dateBase, { days: 2 }),
          },
        ],
        mediaTwoCameras,
        {
          queries: [{ ...baseEventQuery, limit: 50, start: dateBase }],
          results: sortItems(mediaMixedStart.concat(mediaTwoCameras)),
        },
        'later' as const,
      ],
      [
        'query fetching earlier',
        new Map([[{ ...baseEventQuery, start: dateBase }, baseEventQueryResults]]),
        mediaMixedStart,
        [
          {
            ...baseEventQuery,
            limit: 50,
            end: dateBase,
          },
        ],
        mediaTwoCameras,
        {
          queries: [{ ...baseEventQuery, limit: 50, start: dateBase }],
          results: sortItems(mediaMixedStart.concat(mediaTwoCameras)),
        },
        'earlier' as const,
      ],
    ])(
      'handles %s',
      async (
        _name: string,
        // The previously submitted query & results.
        inputQueries: Map<EventQuery, EventQueryResults>,

        // The previously received media.
        inputResults: ViewItem[],

        // The queries expected to be dispatched.
        newChunkQueries: EventQuery[],

        // The media received from the new queries.
        outputMediaResults: ViewMedia[],

        // The expect extended queries and results.
        expected?: {
          queries: EventQuery[];
          results: ViewItem[];
        } | null,
        direction?: 'earlier' | 'later',
      ) => {
        const engine = mock<CameraManagerEngine>();
        vi.mocked(engine.getEngineType).mockReturnValue(Engine.Generic);

        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = createCameraManager(api, engine);
        expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

        engine.getEvents.mockResolvedValue(inputQueries);
        engine.generateMediaFromEvents.mockReturnValue(outputMediaResults);

        expect(
          await manager.extendMediaQueries(
            [...inputQueries.keys()],
            inputResults,
            direction ?? 'later',
          ),
        ).toEqual(expected);

        // Make sure the issued queries are correct.
        for (const query of newChunkQueries) {
          expect(engine.getEvents).toHaveBeenCalledWith(
            expect.anything(),
            expect.anything(),
            query,
            undefined,
          );
        }
      },
    );
  });

  describe('should get media download path', () => {
    it('without camera', async () => {
      const manager = createCameraManager(createCardAPI());
      expect(await manager.getMediaDownloadPath(new TestViewMedia())).toBeNull();
    });

    it('without hass', async () => {
      const api = createCardAPI();
      const manager = createCameraManager(api);
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(null);
      expect(await manager.getMediaDownloadPath(new TestViewMedia())).toBeNull();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);

      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const result: Endpoint = {
        endpoint: 'http://localhost/path/to/media',
      };
      vi.mocked(engine.getMediaDownloadPath).mockResolvedValue(result);
      expect(
        await manager.getMediaDownloadPath(new TestViewMedia({ cameraID: 'id' })),
      ).toBe(result);
    });
  });

  describe('should get media capabilities', () => {
    it('without camera', async () => {
      const manager = createCameraManager(createCardAPI());
      expect(manager.getMediaCapabilities(new TestViewMedia())).toBeNull();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const result: ViewItemCapabilities = {
        canFavorite: false,
        canDownload: false,
      };
      vi.mocked(engine.getMediaCapabilities).mockReturnValue(result);
      expect(manager.getMediaCapabilities(new TestViewMedia({ cameraID: 'id' }))).toBe(
        result,
      );
    });
  });

  describe('should favorite media', () => {
    it('without camera', async () => {
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(createCardAPI(), engine);
      manager.favoriteMedia(new TestViewMedia(), true);

      expect(engine.favoriteMedia).not.toBeCalled();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);

      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const media = new TestViewMedia({ cameraID: 'id' });
      manager.favoriteMedia(media, true);
      expect(engine.favoriteMedia).toBeCalledWith(hass, expect.anything(), media, true);
    });
  });

  describe('should get camera endpoints', () => {
    it('without camera', () => {
      const manager = createCameraManager(createCardAPI());
      expect(manager.getCameraEndpoints('BAD')).toBeNull();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);

      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const result: CameraEndpoints = {};
      const context: CameraEndpointsContext = {};
      vi.mocked(engine.getCameraEndpoints).mockReturnValue(result);

      expect(manager.getCameraEndpoints('id', context)).toBe(result);
      expect(engine.getCameraEndpoints).toBeCalledWith(expect.anything(), context);
    });
  });

  describe('should get camera metadata', () => {
    it('without camera', () => {
      const manager = createCameraManager(createCardAPI());
      expect(manager.getCameraMetadata('BAD')).toBeNull();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);

      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const result: CameraManagerCameraMetadata = {
        title: 'My Camera',
        icon: {
          icon: 'mdi:camera',
        },
      };
      vi.mocked(engine.getCameraMetadata).mockReturnValue(result);

      expect(manager.getCameraMetadata('id')).toBe(result);
    });
  });

  describe('should get camera capabilities', () => {
    it('without camera', () => {
      const manager = createCameraManager(createCardAPI());
      expect(manager.getCameraCapabilities('BAD')).toBeNull();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(api, engine);

      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
      expect(manager.getCameraCapabilities('id')).toEqual(createCapabilities());
    });
  });

  describe('should get aggregate camera capabilities', () => {
    it('without camera', () => {
      const manager = createCameraManager(createCardAPI());
      const capabilities = manager.getAggregateCameraCapabilities();

      expect(capabilities.has('favorite-events')).toBeFalsy();
      expect(capabilities.has('favorite-recordings')).toBeFalsy();
      expect(capabilities.has('seek')).toBeFalsy();

      expect(capabilities.has('live')).toBeFalsy();
      expect(capabilities.has('clips')).toBeFalsy();
      expect(capabilities.has('recordings')).toBeFalsy();
      expect(capabilities.has('snapshots')).toBeFalsy();
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const manager = createCameraManager(api, mock<CameraManagerEngine>(), [
        {
          capabilties: new Capabilities({
            'favorite-events': false,
            'favorite-recordings': false,
            seek: false,

            live: false,
            clips: false,
            recordings: false,
            snapshots: false,
          }),
        },
        {
          config: createCameraConfig({ baseCameraConfig, id: 'another' }),
          capabilties: new Capabilities({
            'favorite-events': true,
            'favorite-recordings': true,
            seek: true,

            live: true,
            clips: true,
            recordings: true,
            snapshots: true,

            ptz: {
              left: [PTZMovementType.Continuous],
            },
          }),
        },
      ]);
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      const capabilities = manager.getAggregateCameraCapabilities();

      expect(capabilities.has('favorite-events')).toBeTruthy();
      expect(capabilities.has('favorite-recordings')).toBeTruthy();
      expect(capabilities.has('seek')).toBeTruthy();

      expect(capabilities.has('live')).toBeTruthy();
      expect(capabilities.has('clips')).toBeTruthy();
      expect(capabilities.has('recordings')).toBeTruthy();
      expect(capabilities.has('snapshots')).toBeTruthy();
    });
  });

  describe('should execute PTZ action', () => {
    it('without camera', () => {
      const engine = mock<CameraManagerEngine>();
      const manager = createCameraManager(createCardAPI(), engine);

      manager.executePTZAction('id', 'left', {});

      // No visible action.
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);
      const action = {
        action: 'perform-action' as const,
        perform_action: 'action',
      };
      const manager = createCameraManager(api, engine, [
        {
          config: createCameraConfig({
            baseCameraConfig,
            id: 'another',
            ptz: {
              actions_left: action,
            },
          }),
        },
      ]);
      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

      manager.executePTZAction('another', 'left');

      expect(api.getActionsManager().executeActions).toBeCalledWith({ actions: action });
    });
  });

  describe('should determine if queries are fresh', () => {
    beforeAll(() => {
      const start = new Date('2024-03-02T20:35:00');
      vi.useFakeTimers();
      vi.setSystemTime(start);
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    it.each([
      ['not fresh', new Date('2024-03-02T20:32:00'), false],
      ['fresh on lower bound', new Date('2024-03-02T20:34:00'), true],
      ['fresh at current time', new Date('2024-03-02T20:35:00'), true],
      ['fresh in the future', new Date('2024-03-02T20:40:00'), true],
      [
        'unknown camera',
        new Date('2024-03-02T20:35:00'),

        // Default assumed to be fresh.
        true,
        [
          {
            ...baseEventQuery,
            cameraIDs: new Set(['BAD']),
          },
        ],
      ],
    ])(
      '%s',
      async (
        _name: string,
        resultsTimestamp: Date,
        expectedFresh: boolean,
        queries: EventQuery[] = [baseEventQuery],
      ) => {
        const api = createCardAPI();
        const engine = mock<CameraManagerEngine>();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
        const manager = createCameraManager(api, engine);

        expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

        engine.getQueryResultMaxAge.mockReturnValue(60);
        expect(manager.areMediaQueriesResultsFresh(queries, resultsTimestamp)).toBe(
          expectedFresh,
        );
      },
    );
  });

  describe('should get media seek time', () => {
    const startTime = new Date('2024-03-02T20:52:00');
    const endTime = new Date('2024-03-02T20:53:00');
    const middleTime = new Date('2024-03-02T20:52:30');

    describe('invalid requests', () => {
      it.each([
        ['null start and end', null, null, middleTime],
        ['no start', null, endTime, middleTime],
        ['no end', startTime, null, middleTime],
        ['target < start', endTime, endTime, startTime],
        ['target > end', startTime, startTime, endTime],
      ])(
        '%s',
        async (_name: string, start: Date | null, end: Date | null, target: Date) => {
          const api = createCardAPI();
          const engine = mock<CameraManagerEngine>();
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
          const manager = createCameraManager(api, engine);

          expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

          expect(
            await manager.getMediaSeekTime(
              new TestViewMedia({ startTime: start, endTime: end }),
              target,
            ),
          ).toBeNull();
        },
      );
    });

    it('successfully', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      const manager = createCameraManager(api, engine);

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
      engine.getMediaSeekTime.mockResolvedValue(42);

      const media = new TestViewMedia({
        cameraID: 'id',
        startTime: startTime,
        endTime: endTime,
      });
      expect(await manager.getMediaSeekTime(media, middleTime)).toBe(42);

      expect(engine.getMediaSeekTime).toBeCalledWith(
        expect.anything(),
        expect.anything(),
        media,
        middleTime,
      );
    });

    it('handles null return value', async () => {
      const api = createCardAPI();
      const engine = mock<CameraManagerEngine>();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      const manager = createCameraManager(api, engine);

      expect(await manager.initializeCamerasFromConfig()).toBeTruthy();
      engine.getMediaSeekTime.mockResolvedValue(null);

      const media = new TestViewMedia({
        cameraID: 'id',
        startTime: startTime,
        endTime: endTime,
      });
      expect(await manager.getMediaSeekTime(media, middleTime)).toBeNull();
    });
  });

  it('should destroy', async () => {
    const api = createCardAPI();
    const engine = mock<CameraManagerEngine>();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
    const manager = createCameraManager(api, engine);

    expect(await manager.initializeCamerasFromConfig()).toBeTruthy();

    expect(manager.getStore().getCameraCount()).toBe(1);

    await manager.destroy();

    expect(manager.getStore().getCameraCount()).toBe(0);
  });
});



================================================
FILE: tests/camera-manager/range.test.ts
================================================
import { add, sub } from 'date-fns';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  compressRanges,
  DateRange,
  ExpiringMemoryRangeSet,
  ExpiringRange,
  MemoryRangeSet,
  rangesOverlap,
} from '../../src/camera-manager/range.js';

describe('MemoryRangeSet', () => {
  const rangeSet = new MemoryRangeSet();
  const now = new Date();
  const range: DateRange = {
    start: now,
    end: add(now, { hours: 1 }),
  };

  beforeEach(() => {
    rangeSet.clear();
  });

  it('should have coverage when added', () => {
    rangeSet.add(range);
    expect(rangeSet.hasCoverage(range)).toBeTruthy();
  });
  it('should not have coverage when overlapping', () => {
    rangeSet.add(range);
    expect(rangeSet.hasCoverage({ ...range, end: add(now, { hours: 2 }) })).toBeFalsy();
  });
  it('should not have coverage when non-overlapping', () => {
    rangeSet.add(range);
    expect(
      rangeSet.hasCoverage({
        start: add(now, { hours: 2 }),
        end: add(now, { hours: 3 }),
      }),
    ).toBeFalsy();
  });

  it('should be empty when cleared', () => {
    rangeSet.add(range);
    rangeSet.clear();
    expect(rangeSet.hasCoverage(range)).toBeFalsy();
  });
});

describe('ExpiringMemoryRangeSet', () => {
  const expiringRangeSet = new ExpiringMemoryRangeSet();
  const now = new Date();
  const expiringRange: ExpiringRange<Date> = {
    start: now,
    end: add(now, { hours: 1 }),
    expires: add(now, { hours: 1 }),
  };

  beforeEach(() => {
    expiringRangeSet.clear();
  });

  it('should have coverage when added', () => {
    expiringRangeSet.add(expiringRange);
    expect(expiringRangeSet.hasCoverage(expiringRange)).toBeTruthy();
  });
  it('should not have coverage when overlapping', () => {
    expiringRangeSet.add(expiringRange);
    expect(
      expiringRangeSet.hasCoverage({ ...expiringRange, end: add(now, { hours: 2 }) }),
    ).toBeFalsy();
  });
  it('should not have coverage when non-overlapping', () => {
    expiringRangeSet.add(expiringRange);
    expect(
      expiringRangeSet.hasCoverage({
        start: add(now, { hours: 2 }),
        end: add(now, { hours: 3 }),
      }),
    ).toBeFalsy();
  });
  it('should not have coverage when expired', () => {
    expiringRangeSet.add(expiringRange);

    vi.useFakeTimers();
    vi.setSystemTime(add(now, { hours: 2 }));
    expect(expiringRangeSet.hasCoverage(expiringRange)).toBeFalsy();
    vi.useRealTimers();
  });

  it('should be empty when cleared', () => {
    expiringRangeSet.add(expiringRange);
    expiringRangeSet.clear();
    expect(expiringRangeSet.hasCoverage(expiringRange)).toBeFalsy();
  });
});

describe('rangesOverlap', () => {
  const now = new Date();
  const a: DateRange = {
    start: now,
    end: add(now, { hours: 1 }),
  };

  it('should overlap when A starts within B', () => {
    expect(rangesOverlap(a, { ...a, start: add(now, { minutes: 30 }) })).toBeTruthy();
  });
  it('should overlap when A ends within B', () => {
    expect(rangesOverlap(a, { ...a, end: add(now, { hours: 2 }) })).toBeTruthy();
  });
  it('should overlap when A is entirely within B', () => {
    expect(
      rangesOverlap(a, {
        start: add(now, { minutes: 1 }),
        end: add(now, { minutes: 59 }),
      }),
    ).toBeTruthy();
  });

  it('should not overlap when A is entirely unrelated to B', () => {
    expect(
      rangesOverlap(a, { start: sub(now, { hours: 2 }), end: sub(now, { hours: 1 }) }),
    ).toBeFalsy();
  });
});

describe('compressRanges', () => {
  const now = new Date();
  const nowPlusOne = add(now, { minutes: 1 });
  const nowPlusTwo = add(now, { minutes: 2 });
  const nowPlusThree = add(now, { minutes: 3 });

  it('should compress nearby ranges', () => {
    expect(
      compressRanges([
        { start: now, end: nowPlusOne },
        { start: nowPlusOne, end: nowPlusTwo },
        { start: now, end: nowPlusOne },
      ]),
    ).toEqual([{ start: now, end: nowPlusTwo }]);
  });

  it('should not compress unrelated ranges', () => {
    const input = [
      { start: now, end: nowPlusOne },
      { start: nowPlusTwo, end: nowPlusThree },
    ];
    expect(compressRanges(input)).toEqual(input);
  });

  it('should compress unrelated ranges with large tolerance', () => {
    const input = [
      { start: now, end: nowPlusOne },
      { start: nowPlusTwo, end: nowPlusThree },
    ];
    expect(compressRanges(input, 60 * 60)).toEqual([{ start: now, end: nowPlusThree }]);
  });

  it('should compress number based ranges', () => {
    const input = [
      { start: 1, end: 2 },
      { start: 2, end: 3 },
    ];
    expect(compressRanges(input)).toEqual([{ start: 1, end: 3 }]);
  });

  it('should return nothing with no input', () => {
    expect(compressRanges([])).toEqual([]);
  });
});



================================================
FILE: tests/camera-manager/store.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { Camera } from '../../src/camera-manager/camera.js';
import { Capabilities } from '../../src/camera-manager/capabilities.js';
import { CameraManagerEngineFactory } from '../../src/camera-manager/engine-factory.js';
import { CameraManagerStore } from '../../src/camera-manager/store.js';
import { Engine } from '../../src/camera-manager/types.js';
import { StateWatcherSubscriptionInterface } from '../../src/card-controller/hass/state-watcher.js';
import { EntityRegistryManager } from '../../src/ha/registry/entity/types.js';
import { ResolvedMediaCache } from '../../src/ha/resolved-media.js';
import { TestViewMedia, createCameraConfig } from '../test-utils.js';

describe('CameraManagerStore', async () => {
  const configVisible = createCameraConfig({
    id: 'camera-visible',
  });
  const configHidden = createCameraConfig({
    id: 'camera-hidden',
    hide: true,
  });

  const engineFactory = new CameraManagerEngineFactory(mock<EntityRegistryManager>());

  const engineGeneric = await engineFactory.createEngine(Engine.Generic, {
    stateWatcher: mock<StateWatcherSubscriptionInterface>(),
    resolvedMediaCache: mock<ResolvedMediaCache>(),
  });
  const engineFrigate = await engineFactory.createEngine(Engine.Frigate, {
    stateWatcher: mock<StateWatcherSubscriptionInterface>(),
    resolvedMediaCache: mock<ResolvedMediaCache>(),
  });

  const setupStore = (): CameraManagerStore => {
    const store = new CameraManagerStore();
    const camera_1 = new Camera(configVisible, engineGeneric);
    const camera_2 = new Camera(configHidden, engineFrigate);

    camera_1.destroy = vi.fn();
    camera_2.destroy = vi.fn();

    store.addCamera(camera_1);
    store.addCamera(camera_2);
    return store;
  };

  it('getCameraConfig', async () => {
    const store = setupStore();
    expect(store.getCameraConfig('camera-visible')).toBe(configVisible);
    expect(store.getCameraConfig('camera-hidden')).toBe(configHidden);
    expect(store.getCameraConfig('camera-not-exist')).toBeNull();
  });

  it('hasCameraID', async () => {
    const store = setupStore();
    expect(store.hasCameraID('camera-visible')).toBeTruthy();
    expect(store.hasCameraID('camera-hidden')).toBeTruthy();
  });

  it('getCameraCount', async () => {
    const store = setupStore();
    expect(store.getCameraCount()).toBe(2);
  });

  describe('getDefaultCameraID', () => {
    it('with camera', async () => {
      const store = setupStore();
      expect(store.getDefaultCameraID()).toBe('camera-visible');
    });
    it('without camera', async () => {
      const store = new CameraManagerStore();
      expect(store.getDefaultCameraID()).toBeNull();
    });
  });

  describe('getCamera', async () => {
    it('present', async () => {
      const store = setupStore();
      expect(store.getCamera('camera-visible')?.getConfig()).toEqual(configVisible);
    });

    it('absent', async () => {
      const store = setupStore();
      expect(store.getCamera('not-a-camera')).toBeNull();
    });
  });

  describe('getCameraConfigs', async () => {
    it('all', async () => {
      const store = setupStore();
      expect([...store.getCameraConfigs()]).toEqual([configVisible, configHidden]);
    });

    it('named', async () => {
      const store = setupStore();
      expect([...store.getCameraConfigs(['camera-visible', 'not-a-camera'])]).toEqual([
        configVisible,
      ]);
    });
  });

  describe('getCameraConfigEntries', async () => {
    it('all', async () => {
      const store = setupStore();
      expect([...store.getCameraConfigEntries()]).toEqual([
        ['camera-visible', configVisible],
        ['camera-hidden', configHidden],
      ]);
    });

    it('named', async () => {
      const store = setupStore();
      expect([
        ...store.getCameraConfigEntries(['camera-visible', 'not-a-camera']),
      ]).toEqual([['camera-visible', configVisible]]);
    });
  });

  it('getCameras', async () => {
    const store = setupStore();
    expect([...store.getCameras().keys()]).toEqual(['camera-visible', 'camera-hidden']);
    expect(store.getCameras().get('camera-visible')?.getConfig()).toEqual(configVisible);
    expect(store.getCameras().get('camera-hidden')?.getConfig()).toEqual(configHidden);
  });

  it('getCameraIDs', async () => {
    const store = setupStore();
    expect(store.getCameraIDs()).toEqual(new Set(['camera-visible', 'camera-hidden']));
  });

  it('reset', async () => {
    const store = setupStore();
    const cameras = [...store.getCameras().values()];

    await store.reset();

    expect(store.getCameraCount()).toBe(0);
    for (const camera of cameras) {
      expect(camera.destroy).toBeCalled();
    }
  });

  describe('getCameraConfigForMedia', () => {
    it('should return the camera config for media with a camera ID', async () => {
      const store = setupStore();

      const media_1 = new TestViewMedia({ cameraID: 'camera-visible' });
      expect(store.getCameraConfigForMedia(media_1)).toBe(configVisible);

      const media_2 = new TestViewMedia({ cameraID: 'camera-not-exist' });
      expect(store.getCameraConfigForMedia(media_2)).toBeNull();
    });

    it('should return null as the camera config for media without a camera ID', async () => {
      const store = setupStore();
      const media = new TestViewMedia({ cameraID: null });
      expect(store.getCameraConfigForMedia(media)).toBeNull();
    });
  });

  it('getEngineOfType', async () => {
    const store = setupStore();
    expect(store.getEngineOfType(Engine.Generic)).toBe(engineGeneric);
    expect(store.getEngineOfType(Engine.Frigate)).toBe(engineFrigate);
    expect(store.getEngineOfType(Engine.MotionEye)).toBeNull();
  });

  it('getEngineForCameraID', async () => {
    const store = setupStore();
    expect(store.getEngineForCameraID('camera-visible')).toBe(engineGeneric);
    expect(store.getEngineForCameraID('camera-hidden')).toBe(engineFrigate);
    expect(store.getEngineForCameraID('camera-not-exist')).toBeNull();
  });

  describe('getEnginesForCameraIDs', async () => {
    it('empty input', async () => {
      const store = setupStore();
      expect(store.getEnginesForCameraIDs(new Set())).toBeNull();
    });

    it('multiple cameras', async () => {
      const store = setupStore();
      store.addCamera(
        new Camera(
          {
            ...configVisible,
            id: 'camera-visible2',
          },
          engineGeneric,
        ),
      );

      expect(
        store.getEnginesForCameraIDs(
          new Set([
            'camera-visible',
            'camera-visible2',
            'camera-hidden',
            'camera-not-exist',
          ]),
        ),
      ).toEqual(
        new Map([
          [engineGeneric, new Set(['camera-visible', 'camera-visible2'])],
          [engineFrigate, new Set(['camera-hidden'])],
        ]),
      );
    });
  });

  describe('getEngineForMedia', () => {
    it('should return the engine for media with a camera ID', async () => {
      const store = setupStore();
      const media = new TestViewMedia({ cameraID: 'camera-visible' });
      expect(store.getEngineForMedia(media)).toBe(engineGeneric);
    });

    it('should return null as the engine for media without a camera ID', async () => {
      const store = setupStore();
      const media = new TestViewMedia({ cameraID: null });
      expect(store.getEngineForMedia(media)).toBeNull();
    });
  });

  describe('getAllDependentCameras', () => {
    it('should return dependent cameras', () => {
      const store = new CameraManagerStore();
      store.addCamera(
        new Camera(
          createCameraConfig({
            id: 'one',
            dependencies: {
              cameras: ['two', 'three'],
            },
          }),
          engineGeneric,
        ),
      );
      store.addCamera(
        new Camera(
          createCameraConfig({
            id: 'two',
          }),
          engineGeneric,
        ),
      );
      expect(store.getAllDependentCameras('one')).toEqual(new Set(['one', 'two']));
    });
    it('should return all cameras', () => {
      const store = new CameraManagerStore();
      store.addCamera(
        new Camera(
          createCameraConfig({
            id: 'one',
            dependencies: {
              all_cameras: true,
            },
          }),
          engineGeneric,
        ),
      );
      store.addCamera(
        new Camera(
          createCameraConfig({
            id: 'two',
          }),
          engineGeneric,
        ),
      );
      expect(store.getAllDependentCameras('one')).toEqual(new Set(['one', 'two']));
    });

    it('should return cameras with specific capabilities', () => {
      const store = new CameraManagerStore();
      store.addCamera(
        new Camera(
          createCameraConfig({
            id: 'one',
            dependencies: {
              all_cameras: true,
            },
          }),
          engineGeneric,
        ),
      );
      store.addCamera(
        new Camera(
          createCameraConfig({
            id: 'two',
          }),
          engineGeneric,
          {
            capabilities: new Capabilities({
              clips: true,
            }),
          },
        ),
      );
      expect(store.getAllDependentCameras('one', 'clips')).toEqual(new Set(['two']));
    });
  });

  it('getCameraIDsWithCapability', () => {
    const store = new CameraManagerStore();
    store.addCamera(
      new Camera(
        createCameraConfig({
          id: 'one',
        }),
        engineGeneric,
        {
          capabilities: new Capabilities({
            clips: true,
          }),
        },
      ),
    );
    store.addCamera(
      new Camera(
        createCameraConfig({
          id: 'two',
        }),
        engineGeneric,
      ),
    );
    expect(store.getCameraIDsWithCapability('clips')).toEqual(new Set(['one']));
  });

  it('setCameras', async () => {
    const store = new CameraManagerStore();
    const camera_1 = new Camera(createCameraConfig({ id: 'camera-1' }), engineGeneric);
    camera_1.destroy = vi.fn();

    const camera_2 = new Camera(createCameraConfig({ id: 'camera-2' }), engineGeneric);
    camera_2.destroy = vi.fn();

    const camera_3 = new Camera(createCameraConfig({ id: 'camera-3' }), engineGeneric);
    camera_3.destroy = vi.fn();

    const camera_3_new = new Camera(
      createCameraConfig({ id: 'camera-3' }),
      engineGeneric,
    );
    camera_3_new.destroy = vi.fn();

    const camera_4 = new Camera(createCameraConfig({ id: 'camera-4' }), engineGeneric);
    camera_4.destroy = vi.fn();

    await store.setCameras([camera_1, camera_2, camera_3]);
    await store.setCameras([camera_2, camera_3_new, camera_4]);

    expect(store.getCamera('camera-1')).toBeNull();
    expect(store.getCamera('camera-2')).toBe(camera_2);
    expect(store.getCamera('camera-3')).toBe(camera_3_new);
    expect(store.getCamera('camera-4')).toBe(camera_4);

    expect(camera_1.destroy).toBeCalled();
    expect(camera_2.destroy).not.toBeCalled();
    expect(camera_3.destroy).toBeCalled();
    expect(camera_3_new.destroy).not.toBeCalled();
    expect(camera_4.destroy).not.toBeCalled();
  });
});



================================================
FILE: tests/camera-manager/browse-media/camera.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { BrowseMediaCamera } from '../../../src/camera-manager/browse-media/camera';
import { CameraManagerEngine } from '../../../src/camera-manager/engine';
import { StateWatcherSubscriptionInterface } from '../../../src/card-controller/hass/state-watcher';
import { Entity, EntityRegistryManager } from '../../../src/ha/registry/entity/types';
import { createCameraConfig, createHASS } from '../../test-utils';

describe('BrowseMediaCamera', () => {
  describe('should initialize', () => {
    it('without a camera_entity', async () => {
      const camera = new BrowseMediaCamera(
        createCameraConfig(),
        mock<CameraManagerEngine>(),
      );

      expect(
        async () =>
          await camera.initialize({
            hass: createHASS(),
            stateWatcher: mock<StateWatcherSubscriptionInterface>(),
            entityRegistryManager: mock<EntityRegistryManager>(),
          }),
      ).rejects.toThrowError(/Could not find camera entity/);
    });

    it('with a camera_entity', async () => {
      const camera = new BrowseMediaCamera(
        createCameraConfig({
          camera_entity: 'camera.foo',
        }),
        mock<CameraManagerEngine>(),
      );
      const entityRegistryManager = mock<EntityRegistryManager>();
      const entity = mock<Entity>();
      entityRegistryManager.getEntity.mockResolvedValue(entity);

      expect(
        await camera.initialize({
          hass: createHASS(),
          stateWatcher: mock<StateWatcherSubscriptionInterface>(),
          entityRegistryManager: entityRegistryManager,
        }),
      ).toBe(camera);
      expect(camera.getEntity()).toBe(entity);
    });
  });
});



================================================
FILE: tests/camera-manager/frigate/camera.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CameraManagerEngine } from '../../../src/camera-manager/engine';
import { FrigateCamera } from '../../../src/camera-manager/frigate/camera';
import { FrigateEventWatcher } from '../../../src/camera-manager/frigate/event-watcher';
import { getPTZInfo } from '../../../src/camera-manager/frigate/requests';
import { FrigateEventChange } from '../../../src/camera-manager/frigate/types';
import { ActionsExecutor } from '../../../src/card-controller/actions/types';
import { StateWatcher } from '../../../src/card-controller/hass/state-watcher';
import { PTZAction } from '../../../src/config/schema/actions/custom/ptz';
import { CameraTriggerEventType } from '../../../src/config/schema/cameras';
import { Entity, EntityRegistryManager } from '../../../src/ha/registry/entity/types';
import { EntityRegistryManagerMock } from '../../ha/registry/entity/mock';
import { createCameraConfig, createHASS, createRegistryEntity } from '../../test-utils';

vi.mock('../../../src/camera-manager/frigate/requests');

const callEventWatcherCallback = (
  eventWatcher: FrigateEventWatcher,
  event: FrigateEventChange,
  n = 0,
): void => {
  const mock = vi.mocked(eventWatcher.subscribe).mock;
  expect(mock.calls.length).greaterThan(n);
  mock.calls[n][1].callback(event);
};

describe('FrigateCamera', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(getPTZInfo).mockResolvedValue({});
  });

  describe('should initialize config', () => {
    describe('should detect camera name', () => {
      it('without a camera_entity', async () => {
        const config = createCameraConfig();
        const camera = new FrigateCamera(config, mock<CameraManagerEngine>());
        const beforeConfig = { ...config };

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: mock<EntityRegistryManager>(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(beforeConfig).toEqual(camera.getConfig());
      });

      it('with a missing camera_entity', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.not_here',
          }),
          mock<CameraManagerEngine>(),
        );
        const entityRegistryManager = new EntityRegistryManagerMock();

        expect(
          async () =>
            await camera.initialize({
              hass: createHASS(),
              entityRegistryManager: entityRegistryManager,
              stateWatcher: mock<StateWatcher>(),
              frigateEventWatcher: mock<FrigateEventWatcher>(),
            }),
        ).rejects.toThrowError(/Could not find camera entity/);
      });

      it('with a valid camera_entity', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.front_door',
          }),
          mock<CameraManagerEngine>(),
        );
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.front_door',
            unique_id: '8c4e19d258359e82bc0cf9d47b021c46:camera:fnt_dr',
            platform: 'frigate',
          }),
        ]);

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });
        expect(camera.getConfig().frigate.camera_name).toBe('fnt_dr');
      });

      it('with a camera_entity without camera_name match', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.front_door',
          }),
          mock<CameraManagerEngine>(),
        );
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.front_door',
            unique_id: '8c4e19d258359e82bc0cf9d47b021c46:WRONG:fnt_dr',
            platform: 'frigate',
          }),
        ]);

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });
        expect(camera.getConfig().frigate.camera_name).toBeUndefined();
      });

      it('with a camera_entity without platform match', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.front_door',
          }),
          mock<CameraManagerEngine>(),
        );
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.front_door',
            unique_id: '8c4e19d258359e82bc0cf9d47b021c46:camera:fnt_dr',
            platform: 'something_else',
          }),
        ]);

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });
        expect(camera.getConfig().frigate.camera_name).toBeUndefined();
      });
    });
  });

  describe('should detect capabilities', () => {
    it('basic non-birdseye', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: {
            camera_name: 'front_door',
          },
        }),
        mock<CameraManagerEngine>(),
      );

      await camera.initialize({
        hass: createHASS(),
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: mock<FrigateEventWatcher>(),
      });
      expect(camera.getCapabilities()?.has('favorite-events')).toBeTruthy();
      expect(camera.getCapabilities()?.has('favorite-recordings')).toBeFalsy();
      expect(camera.getCapabilities()?.has('seek')).toBeTruthy();
      expect(camera.getCapabilities()?.has('clips')).toBeTruthy();
      expect(camera.getCapabilities()?.has('live')).toBeTruthy();
      expect(camera.getCapabilities()?.has('snapshots')).toBeTruthy();
      expect(camera.getCapabilities()?.has('recordings')).toBeTruthy();
      expect(camera.getCapabilities()?.has('trigger')).toBeTruthy();
      expect(vi.mocked(getPTZInfo)).toBeCalled();
    });

    it('basic birdseye', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: {
            camera_name: 'birdseye',
          },
        }),
        mock<CameraManagerEngine>(),
      );

      await camera.initialize({
        hass: createHASS(),
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: mock<FrigateEventWatcher>(),
      });
      expect(camera.getCapabilities()?.has('favorite-events')).toBeFalsy();
      expect(camera.getCapabilities()?.has('favorite-recordings')).toBeFalsy();
      expect(camera.getCapabilities()?.has('seek')).toBeFalsy();
      expect(camera.getCapabilities()?.has('clips')).toBeFalsy();
      expect(camera.getCapabilities()?.has('live')).toBeTruthy();
      expect(camera.getCapabilities()?.has('snapshots')).toBeFalsy();
      expect(camera.getCapabilities()?.has('recordings')).toBeFalsy();
      expect(camera.getCapabilities()?.has('trigger')).toBeTruthy();
      expect(vi.mocked(getPTZInfo)).not.toBeCalled();
    });

    describe('with ptz', () => {
      it('when getPTZInfo call fails', async () => {
        const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

        const camera = new FrigateCamera(
          createCameraConfig({
            frigate: {
              camera_name: 'front_door',
            },
          }),
          mock<CameraManagerEngine>(),
        );
        vi.mocked(getPTZInfo).mockRejectedValue(new Error());

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: mock<EntityRegistryManager>(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getCapabilities()?.has('ptz')).toBeFalsy();
        expect(camera.getCapabilities()?.hasPTZCapability()).toBeFalsy();
        expect(consoleSpy).toBeCalled();
      });

      it('when getPTZInfo call succeeds with continuous motion', async () => {
        vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

        const camera = new FrigateCamera(
          createCameraConfig({
            frigate: {
              camera_name: 'front_door',
            },
          }),
          mock<CameraManagerEngine>(),
        );
        vi.mocked(getPTZInfo).mockResolvedValue({
          features: ['pt', 'zoom'],
          name: 'front_door',
          presets: ['preset01'],
        });

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: mock<EntityRegistryManager>(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });
        expect(camera.getCapabilities()?.has('ptz')).toBeTruthy();
        expect(camera.getCapabilities()?.getPTZCapabilities()).toEqual({
          left: ['continuous'],
          right: ['continuous'],
          up: ['continuous'],
          down: ['continuous'],
          zoomIn: ['continuous'],
          zoomOut: ['continuous'],
          presets: ['preset01'],
        });
        expect(camera.getCapabilities()?.hasPTZCapability()).toBeTruthy();
      });

      it('when getPTZInfo call succeeds with relative motion', async () => {
        vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

        const camera = new FrigateCamera(
          createCameraConfig({
            frigate: {
              camera_name: 'front_door',
            },
          }),
          mock<CameraManagerEngine>(),
        );
        vi.mocked(getPTZInfo).mockResolvedValue({
          features: ['pt-r', 'zoom-r'],
          name: 'front_door',
          presets: ['preset01'],
        });

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: mock<EntityRegistryManager>(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });
        expect(camera.getCapabilities()?.has('ptz')).toBeTruthy();
        expect(camera.getCapabilities()?.getPTZCapabilities()).toEqual({
          left: [],
          right: [],
          up: [],
          down: [],
          zoomIn: [],
          zoomOut: [],
          presets: ['preset01'],
        });
        expect(camera.getCapabilities()?.hasPTZCapability()).toBeTruthy();
      });
    });
  });

  describe('should handle events', () => {
    it('should subscribe', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: {
            client_id: 'CLIENT_ID',
            camera_name: 'CAMERA',
          },
        }),
        mock<CameraManagerEngine>(),
      );
      const hass = createHASS();

      const eventWatcher = mock<FrigateEventWatcher>();
      await camera.initialize({
        hass: hass,
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: eventWatcher,
      });
      expect(eventWatcher.subscribe).toBeCalledWith(
        hass,
        expect.objectContaining({
          instanceID: 'CLIENT_ID',
        }),
      );
    });

    it('should not subscribe with no trigger events', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: {
            client_id: 'CLIENT_ID',
            camera_name: 'CAMERA',
          },
          triggers: {
            events: [],
          },
        }),
        mock<CameraManagerEngine>(),
      );
      const hass = createHASS();

      const eventWatcher = mock<FrigateEventWatcher>();
      await camera.initialize({
        hass: hass,
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: eventWatcher,
      });
      expect(eventWatcher.subscribe).not.toBeCalled();
    });

    it('should not subscribe without trigger capability', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: {
            client_id: 'CLIENT_ID',
            camera_name: 'CAMERA',
          },
          capabilities: {
            disable: ['trigger'],
          },
        }),
        mock<CameraManagerEngine>(),
      );
      const hass = createHASS();

      const eventWatcher = mock<FrigateEventWatcher>();
      await camera.initialize({
        hass: hass,
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: eventWatcher,
      });
      expect(eventWatcher.subscribe).not.toBeCalled();
    });

    it('should not subscribe with no camera name', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: {
            client_id: 'CLIENT_ID',
          },
        }),
        mock<CameraManagerEngine>(),
      );
      const hass = createHASS();

      const eventWatcher = mock<FrigateEventWatcher>();
      await camera.initialize({
        hass: hass,
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: eventWatcher,
      });
      expect(eventWatcher.subscribe).not.toBeCalled();
    });

    it('should unsubscribe on destroy', async () => {
      const camera = new FrigateCamera(
        createCameraConfig({
          frigate: { camera_name: 'front_door' },
        }),
        mock<CameraManagerEngine>(),
      );
      const hass = createHASS();
      const unsubscribeCallback = vi.fn();
      vi.mocked(hass.connection.subscribeMessage).mockResolvedValue(unsubscribeCallback);

      const eventWatcher = mock<FrigateEventWatcher>();
      await camera.initialize({
        hass: hass,
        entityRegistryManager: mock<EntityRegistryManager>(),
        stateWatcher: mock<StateWatcher>(),
        frigateEventWatcher: eventWatcher,
      });
      expect(eventWatcher.unsubscribe).not.toBeCalled();

      await camera.destroy();
      expect(eventWatcher.unsubscribe).toBeCalled();
    });

    describe('should call handler correctly', () => {
      describe('should handle event type correctly', () => {
        it.each([
          [
            ['events' as const, 'snapshots' as const, 'clips' as const],
            false,
            false,
            true,
          ],
          [
            ['events' as const, 'snapshots' as const, 'clips' as const],
            false,
            true,
            true,
          ],
          [
            ['events' as const, 'snapshots' as const, 'clips' as const],
            true,
            false,
            true,
          ],
          [
            ['events' as const, 'snapshots' as const, 'clips' as const],
            true,
            true,
            true,
          ],

          [['events' as const, 'snapshots' as const], false, false, true],
          [['events' as const, 'snapshots' as const], false, true, true],
          [['events' as const, 'snapshots' as const], true, false, true],
          [['events' as const, 'snapshots' as const], true, true, true],

          [['events' as const, 'clips' as const], false, false, true],
          [['events' as const, 'clips' as const], false, true, true],
          [['events' as const, 'clips' as const], true, false, true],
          [['events' as const, 'clips' as const], true, true, true],

          [['events' as const], false, false, true],
          [['events' as const], false, true, true],
          [['events' as const], true, false, true],
          [['events' as const], true, true, true],

          [['snapshots' as const, 'clips' as const], false, false, false],
          [['snapshots' as const, 'clips' as const], false, true, true],
          [['snapshots' as const, 'clips' as const], true, false, true],
          [['snapshots' as const, 'clips' as const], true, true, true],

          [['snapshots' as const], false, false, false],
          [['snapshots' as const], false, true, false],
          [['snapshots' as const], true, false, true],
          [['snapshots' as const], true, true, true],

          [['clips' as const], false, false, false],
          [['clips' as const], false, true, true],
          [['clips' as const], true, false, false],
          [['clips' as const], true, true, true],
        ])(
          'with events %s when snapshot %s and clip %s',
          async (
            events: CameraTriggerEventType[],
            hasSnapshot: boolean,
            hasClip: boolean,
            call: boolean,
          ) => {
            const eventCallback = vi.fn();
            const camera = new FrigateCamera(
              createCameraConfig({
                id: 'CAMERA_1',
                frigate: {
                  camera_name: 'camera.front_door',
                },
                triggers: {
                  events: events,
                },
              }),
              mock<CameraManagerEngine>(),
              {
                eventCallback: eventCallback,
              },
            );

            const hass = createHASS();
            const eventWatcher = mock<FrigateEventWatcher>();
            await camera.initialize({
              hass: hass,
              entityRegistryManager: mock<EntityRegistryManager>(),
              stateWatcher: mock<StateWatcher>(),
              frigateEventWatcher: eventWatcher,
            });

            callEventWatcherCallback(eventWatcher, {
              type: 'new',
              before: {
                camera: 'camera.front_door',
                snapshot: null,
                has_clip: false,
                has_snapshot: false,
                label: 'person',
                current_zones: [],
              },
              after: {
                camera: 'camera.front_door',
                snapshot: null,
                has_clip: hasClip,
                has_snapshot: hasSnapshot,
                label: 'person',
                current_zones: [],
              },
            });

            if (call) {
              expect(eventCallback).toBeCalledWith({
                type: 'new',
                cameraID: 'CAMERA_1',
                clip: hasClip && events.includes('clips'),
                snapshot: hasSnapshot && events.includes('snapshots'),
                fidelity: 'high',
              });
            } else {
              expect(eventCallback).not.toBeCalled();
            }
          },
        );
      });

      describe('should handle zones correctly', () => {
        it.each([
          ['has no zone', [], false],
          ['has mismatched zone', ['fence'], false],
          ['has matching zone', ['front_steps'], true],
        ])('%s', async (_name: string, zones: string[], call: boolean) => {
          const eventCallback = vi.fn();
          const camera = new FrigateCamera(
            createCameraConfig({
              id: 'CAMERA_1',
              frigate: {
                camera_name: 'camera.front_door',
                zones: ['front_steps'],
              },
            }),
            mock<CameraManagerEngine>(),
            {
              eventCallback: eventCallback,
            },
          );

          const hass = createHASS();
          const eventWatcher = mock<FrigateEventWatcher>();
          await camera.initialize({
            hass: hass,
            entityRegistryManager: mock<EntityRegistryManager>(),
            stateWatcher: mock<StateWatcher>(),
            frigateEventWatcher: eventWatcher,
          });

          callEventWatcherCallback(eventWatcher, {
            type: 'new',
            before: {
              camera: 'camera.front_door',
              snapshot: null,
              has_clip: false,
              has_snapshot: false,
              label: 'person',
              current_zones: [],
            },
            after: {
              camera: 'camera.front_door',
              snapshot: null,
              has_clip: false,
              has_snapshot: true,
              label: 'person',
              current_zones: zones,
            },
          });

          expect(eventCallback).toHaveBeenCalledTimes(call ? 1 : 0);
        });
      });

      describe('should handle labels correctly', () => {
        it.each([
          ['has mismatched label', 'car', false],
          ['has matching label', 'person', true],
        ])('%s', async (_name: string, label: string, call: boolean) => {
          const eventCallback = vi.fn();
          const camera = new FrigateCamera(
            createCameraConfig({
              id: 'CAMERA_1',
              frigate: {
                camera_name: 'camera.front_door',
                labels: ['person'],
              },
            }),
            mock<CameraManagerEngine>(),
            {
              eventCallback: eventCallback,
            },
          );

          const hass = createHASS();
          const eventWatcher = mock<FrigateEventWatcher>();
          await camera.initialize({
            hass: hass,
            entityRegistryManager: mock<EntityRegistryManager>(),
            stateWatcher: mock<StateWatcher>(),
            frigateEventWatcher: eventWatcher,
          });

          callEventWatcherCallback(eventWatcher, {
            type: 'new',
            before: {
              camera: 'camera.front_door',
              snapshot: null,
              has_clip: false,
              has_snapshot: false,
              // Even new events appear to have the event label in the
              // 'before' dictionary.
              label: label,
              current_zones: [],
            },
            after: {
              camera: 'camera.front_door',
              snapshot: null,
              has_clip: false,
              has_snapshot: true,
              label: label,
              current_zones: [],
            },
          });

          expect(eventCallback).toHaveBeenCalledTimes(call ? 1 : 0);
        });
      });
    });
  });

  describe('should handle triggers', () => {
    const cameraEntity: Partial<Entity> = {
      config_entry_id: 'config_entry_id',
      entity_id: 'camera.front_door',
    };

    const occupancySensorEntityAll: Partial<Entity> = {
      config_entry_id: 'config_entry_id',
      disabled_by: null,
      entity_id: 'binary_sensor.foo',
      unique_id: '8c4e19d258359e82bc0cf9d47b021c46:occupancy_sensor:front_door_all',
    };

    const motionSensorEntity: Partial<Entity> = {
      config_entry_id: 'config_entry_id',
      disabled_by: null,
      entity_id: 'binary_sensor.foo',
      unique_id: '8c4e19d258359e82bc0cf9d47b021c46:motion_sensor:front_door',
    };

    describe('should detect motion sensor', () => {
      it('without a camera name', async () => {
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity(cameraEntity),
          createRegistryEntity(motionSensorEntity),
        ]);
        const camera = new FrigateCamera(
          createCameraConfig({
            triggers: {
              motion: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );

        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual([]);
      });

      it('with camera entity and name', async () => {
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity(cameraEntity),
          createRegistryEntity(motionSensorEntity),
        ]);
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.front_door',
            frigate: {
              camera_name: 'front_door',
            },
            triggers: {
              motion: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );

        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual(['binary_sensor.foo']);
      });

      it('without matching entity', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            frigate: {
              camera_name: 'front_door',
            },
            triggers: {
              motion: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );
        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: new EntityRegistryManagerMock(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual([]);
      });
    });

    describe('should detect occupancy sensor', () => {
      it('without a camera name', async () => {
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity(cameraEntity),
          createRegistryEntity(occupancySensorEntityAll),
        ]);
        const camera = new FrigateCamera(
          createCameraConfig({
            triggers: {
              occupancy: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );
        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual([]);
      });

      it('without a camera name but with occupancy trigger', async () => {
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity(cameraEntity),
          createRegistryEntity(occupancySensorEntityAll),
        ]);
        const camera = new FrigateCamera(
          createCameraConfig({
            triggers: {
              occupancy: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );
        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual([]);
      });

      it('without matching entity', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            frigate: {
              camera_name: 'front_door',
            },
            triggers: {
              occupancy: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );
        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: new EntityRegistryManagerMock(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual([]);
      });

      it('with zones', async () => {
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity(cameraEntity),
          createRegistryEntity({
            ...occupancySensorEntityAll,
            unique_id: '8c4e19d258359e82bc0cf9d47b021c46:occupancy_sensor:zone_all',
          }),
        ]);
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.front_door',
            frigate: {
              camera_name: 'front_door',
              zones: ['zone'],
            },
            triggers: {
              occupancy: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );
        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual(['binary_sensor.foo']);
      });

      it('with labels', async () => {
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity(cameraEntity),
          createRegistryEntity({
            ...occupancySensorEntityAll,
            unique_id:
              '8c4e19d258359e82bc0cf9d47b021c46:occupancy_sensor:front_door_car',
          }),
        ]);

        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.front_door',
            frigate: {
              camera_name: 'front_door',
              labels: ['car'],
            },
            triggers: {
              occupancy: true,
            },
          }),
          mock<CameraManagerEngine>(),
        );
        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        expect(camera.getConfig().triggers.entities).toEqual(['binary_sensor.foo']);
      });
    });

    describe('should execute PTZ action', () => {
      it('should ignore preset action without a preset', async () => {
        const camera = new FrigateCamera(
          createCameraConfig(),
          mock<CameraManagerEngine>(),
        );

        const hass = createHASS();
        await camera.initialize({
          hass: hass,
          entityRegistryManager: mock<EntityRegistryManager>(),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        const executor = mock<ActionsExecutor>();
        await camera.executePTZAction(executor, 'preset');

        expect(executor.executeActions).not.toBeCalled();
      });

      it('should ignore actions with configured action', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.office_frigate',
            ptz: {
              actions_left_start: {
                action: 'perform-action',
                perform_action: 'button.press',
                target: {
                  entity_id: 'button.foo',
                },
              },
            },
          }),
          mock<CameraManagerEngine>(),
        );

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: new EntityRegistryManagerMock([
            createRegistryEntity({ entity_id: 'camera.office_frigate' }),
          ]),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        const executor = mock<ActionsExecutor>();
        await camera.executePTZAction(executor, 'left', { phase: 'start' });

        expect(executor.executeActions).toBeCalledTimes(1);
        expect(executor.executeActions).toHaveBeenLastCalledWith({
          actions: {
            action: 'perform-action',
            perform_action: 'button.press',
            target: {
              entity_id: 'button.foo',
            },
          },
        });
      });

      it.each([
        ['left' as const],
        ['right' as const],
        ['up' as const],
        ['down' as const],
      ])('should execute action %s', async (action: PTZAction) => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.office_frigate',
          }),
          mock<CameraManagerEngine>(),
        );

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: new EntityRegistryManagerMock([
            createRegistryEntity({ entity_id: 'camera.office_frigate' }),
          ]),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        const executor = mock<ActionsExecutor>();

        await camera.executePTZAction(executor, action, { phase: 'start' });
        expect(executor.executeActions).toHaveBeenLastCalledWith({
          actions: {
            action: 'perform-action',
            data: {
              action: 'move',
              argument: action,
            },
            perform_action: 'frigate.ptz',
            target: {
              entity_id: 'camera.office_frigate',
            },
          },
        });

        await camera.executePTZAction(executor, action, { phase: 'stop' });
        expect(executor.executeActions).toHaveBeenLastCalledWith({
          actions: {
            action: 'perform-action',
            data: {
              action: 'stop',
            },
            perform_action: 'frigate.ptz',
            target: {
              entity_id: 'camera.office_frigate',
            },
          },
        });
      });

      it.each([
        ['zoom_in' as const, 'in' as const],
        ['zoom_out' as const, 'out' as const],
      ])('should execute action %s', async (action: PTZAction, zoom: 'in' | 'out') => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.office_frigate',
          }),
          mock<CameraManagerEngine>(),
        );

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: new EntityRegistryManagerMock([
            createRegistryEntity({ entity_id: 'camera.office_frigate' }),
          ]),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        const executor = mock<ActionsExecutor>();

        await camera.executePTZAction(executor, action, { phase: 'start' });
        expect(executor.executeActions).toHaveBeenLastCalledWith({
          actions: {
            action: 'perform-action',
            data: {
              action: 'zoom',
              argument: zoom,
            },
            perform_action: 'frigate.ptz',
            target: {
              entity_id: 'camera.office_frigate',
            },
          },
        });
      });

      it('should execute preset', async () => {
        const camera = new FrigateCamera(
          createCameraConfig({
            camera_entity: 'camera.office_frigate',
          }),
          mock<CameraManagerEngine>(),
        );

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: new EntityRegistryManagerMock([
            createRegistryEntity({ entity_id: 'camera.office_frigate' }),
          ]),
          stateWatcher: mock<StateWatcher>(),
          frigateEventWatcher: mock<FrigateEventWatcher>(),
        });

        const executor = mock<ActionsExecutor>();

        await camera.executePTZAction(executor, 'preset', { preset: 'foo' });
        expect(executor.executeActions).toHaveBeenLastCalledWith({
          actions: {
            action: 'perform-action',
            data: {
              action: 'preset',
              argument: 'foo',
            },
            perform_action: 'frigate.ptz',
            target: {
              entity_id: 'camera.office_frigate',
            },
          },
        });
      });
    });
  });
});



================================================
FILE: tests/camera-manager/frigate/engine-frigate.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { RecordingSegmentsCache } from '../../../src/camera-manager/cache';
import { FrigateCameraManagerEngine } from '../../../src/camera-manager/frigate/engine-frigate';
import {
  FrigateEventViewMedia,
  FrigateRecordingViewMedia,
} from '../../../src/camera-manager/frigate/media';
import { FrigateEvent, eventSchema } from '../../../src/camera-manager/frigate/types.js';
import { CameraManagerRequestCache } from '../../../src/camera-manager/types';
import { StateWatcher } from '../../../src/card-controller/hass/state-watcher';
import { CameraConfig } from '../../../src/config/schema/cameras';
import { AdvancedCameraCardView } from '../../../src/config/schema/common/const';
import { RawAdvancedCameraCardConfig } from '../../../src/config/types';
import { ViewMedia, ViewMediaType } from '../../../src/view/item';
import { EntityRegistryManagerMock } from '../../ha/registry/entity/mock';
import { TestViewMedia, createCameraConfig, createHASS } from '../../test-utils';

const createEngine = (): FrigateCameraManagerEngine => {
  return new FrigateCameraManagerEngine(
    new EntityRegistryManagerMock(),
    new StateWatcher(),
    new RecordingSegmentsCache(),
    new CameraManagerRequestCache(),
  );
};

const createRecordingMedia = (): FrigateRecordingViewMedia => {
  return new FrigateRecordingViewMedia(
    ViewMediaType.Recording,
    'camera-1',
    {
      cameraID: 'camera-1',
      startTime: new Date('2023-06-16T20:00:00Z'),
      endTime: new Date('2023-06-16T20:59:59Z'),
      events: 1,
    },
    'recording-id',
    'recording-content-id',
    'recording-title',
  );
};

const createEvent = (): FrigateEvent => {
  return eventSchema.parse({
    camera: 'camera-1',
    end_time: 1686974399,
    false_positive: false,
    has_clip: true,
    has_snapshot: true,
    id: 'event-id',
    label: 'person',
    sub_label: null,
    start_time: 1686970800,
    top_score: 0.8,
    zones: [],
    retain_indefinitely: true,
  });
};

const createClipMedia = (): FrigateEventViewMedia => {
  return new FrigateEventViewMedia(
    ViewMediaType.Clip,
    'camera-1',
    createEvent(),
    'event-clip-content-id',
    'event-clip-thumbnail',
  );
};

const createSnapshotMedia = (): FrigateEventViewMedia => {
  return new FrigateEventViewMedia(
    ViewMediaType.Snapshot,
    'camera-1',
    createEvent(),
    'event-snapshot-content-id',
    'event-snapshot-thumbnail',
  );
};

const createFrigateCameraConfig = (
  config?: RawAdvancedCameraCardConfig,
): CameraConfig => {
  return createCameraConfig({
    frigate: {
      camera_name: 'camera-1',
    },
    camera_entity: 'camera.office',
    ...config,
  });
};

describe('getMediaDownloadPath', () => {
  it('should get event with clip download path', async () => {
    const endpoint = await createEngine().getMediaDownloadPath(
      createHASS(),
      createFrigateCameraConfig(),
      createClipMedia(),
    );

    expect(endpoint).toEqual({
      endpoint: '/api/frigate/frigate/notifications/event-id/clip.mp4?download=true',
      sign: true,
    });
  });

  it('should get event with snapshot download path', async () => {
    const endpoint = await createEngine().getMediaDownloadPath(
      createHASS(),
      createFrigateCameraConfig(),
      createSnapshotMedia(),
    );

    expect(endpoint).toEqual({
      endpoint: '/api/frigate/frigate/notifications/event-id/snapshot.jpg?download=true',
      sign: true,
    });
  });

  it('should get recording download path', async () => {
    const endpoint = await createEngine().getMediaDownloadPath(
      createHASS(),
      createFrigateCameraConfig(),
      createRecordingMedia(),
    );

    expect(endpoint).toEqual({
      endpoint:
        '/api/frigate/frigate/recording/camera-1/start/1686945600/end/1686949199?download=true',
      sign: true,
    });
  });

  it('should get no path for unknown type', async () => {
    const endpoint = await createEngine().getMediaDownloadPath(
      createHASS(),
      createFrigateCameraConfig(),
      new ViewMedia(ViewMediaType.Clip, {
        cameraID: 'camera-1',
      }),
    );
    expect(endpoint).toBeNull();
  });
});

describe('getCameraEndpoints', () => {
  it('should get basic endpoints', () => {
    const endpoints = createEngine().getCameraEndpoints(createFrigateCameraConfig());

    expect(endpoints).toEqual({
      go2rtc: {
        endpoint: '/api/frigate/frigate/mse/api/ws?src=camera-1',
        sign: true,
      },
      jsmpeg: {
        endpoint: '/api/frigate/frigate/jsmpeg/camera-1',
        sign: true,
      },
      webrtcCard: {
        endpoint: 'camera.office',
      },
    });
  });

  describe('should get overridden go2rtc url', () => {
    it('when local HA path', () => {
      const endpoints = createEngine().getCameraEndpoints(
        createFrigateCameraConfig({
          go2rtc: {
            url: '/local/path',
          },
        }),
      );

      expect(endpoints).toEqual(
        expect.objectContaining({
          go2rtc: {
            endpoint: '/local/path/api/ws?src=camera-1',
            sign: true,
          },
        }),
      );
    });

    it('when remote', () => {
      const endpoints = createEngine().getCameraEndpoints(
        createFrigateCameraConfig({
          go2rtc: {
            url: 'https://my.custom.go2rtc',
          },
        }),
      );

      expect(endpoints).toEqual(
        expect.objectContaining({
          go2rtc: {
            endpoint: 'https://my.custom.go2rtc/api/ws?src=camera-1',
            sign: false,
          },
        }),
      );
    });
  });

  it('should not set webrtc_card endpoint without camera name', () => {
    const endpoints = createEngine().getCameraEndpoints(createCameraConfig());

    expect(endpoints).not.toEqual(
      expect.objectContaining({
        webrtcCard: expect.anything(),
      }),
    );
  });

  describe('should include UI endpoint', () => {
    it('with basic url', () => {
      const endpoints = createEngine().getCameraEndpoints(
        createCameraConfig({
          frigate: {
            url: 'http://my.frigate',
          },
        }),
      );

      expect(endpoints).not.toEqual(
        expect.objectContaining({
          ui: {
            url: 'http://my.frigate',
          },
        }),
      );
    });

    it('with camera name', () => {
      const endpoints = createEngine().getCameraEndpoints(
        createCameraConfig({
          frigate: {
            url: 'http://my.frigate',
            camera_name: 'my-camera',
          },
        }),
      );

      expect(endpoints).not.toEqual(
        expect.objectContaining({
          ui: {
            url: 'http://my.frigate/cameras/my-camera',
          },
        }),
      );
    });

    describe('with event media type', () => {
      it.each([[ViewMediaType.Clip], [ViewMediaType.Snapshot]])(
        '%s',
        (mediaType: ViewMediaType) => {
          const endpoints = createEngine().getCameraEndpoints(
            createCameraConfig({
              frigate: {
                url: 'http://my.frigate',
                camera_name: 'my-camera',
              },
            }),
            {
              media: new TestViewMedia({ mediaType: mediaType }),
            },
          );

          expect(endpoints).not.toEqual(
            expect.objectContaining({
              ui: {
                url: 'http://my.frigate/events?camera=my-camera',
              },
            }),
          );
        },
      );
    });

    describe('with recording media type', () => {
      it('with start time', () => {
        const startTime = new Date('2023-10-07T16:42:00');
        const endpoints = createEngine().getCameraEndpoints(
          createCameraConfig({
            frigate: {
              url: 'http://my.frigate',
              camera_name: 'my-camera',
            },
          }),
          {
            media: new TestViewMedia({
              mediaType: ViewMediaType.Recording,
              startTime: startTime,
            }),
          },
        );

        expect(endpoints).not.toEqual(
          expect.objectContaining({
            ui: {
              url: 'http://my.frigate/recording/my-camera/2023-10-07/16',
            },
          }),
        );
      });

      it('without start time', () => {
        const endpoints = createEngine().getCameraEndpoints(
          createCameraConfig({
            frigate: {
              url: 'http://my.frigate',
              camera_name: 'my-camera',
            },
          }),
          {
            media: new TestViewMedia({ mediaType: ViewMediaType.Recording }),
          },
        );

        expect(endpoints).not.toEqual(
          expect.objectContaining({
            ui: {
              url: 'http://my.frigate/recording/my-camera/',
            },
          }),
        );
      });
    });

    describe('with view', () => {
      it('live', () => {
        const endpoints = createEngine().getCameraEndpoints(
          createCameraConfig({
            frigate: {
              url: 'http://my.frigate',
              camera_name: 'my-camera',
            },
          }),
          {
            view: 'live',
          },
        );

        expect(endpoints).not.toEqual(
          expect.objectContaining({
            ui: {
              url: 'http://my.frigate/cameras/my-camera',
            },
          }),
        );
      });

      it.each([
        ['clip' as const],
        ['clips' as const],
        ['snapshot' as const],
        ['snapshots' as const],
      ])('%s', (viewName: AdvancedCameraCardView) => {
        const endpoints = createEngine().getCameraEndpoints(
          createCameraConfig({
            frigate: {
              url: 'http://my.frigate',
              camera_name: 'my-camera',
            },
          }),
          {
            view: viewName,
          },
        );

        expect(endpoints).not.toEqual(
          expect.objectContaining({
            ui: {
              url: 'http://my.frigate/events?camera=my-camera',
            },
          }),
        );
      });

      it.each([['recording' as const], ['recordings' as const]])(
        '%s',
        (viewName: AdvancedCameraCardView) => {
          const endpoints = createEngine().getCameraEndpoints(
            createCameraConfig({
              frigate: {
                url: 'http://my.frigate',
                camera_name: 'my-camera',
              },
            }),
            {
              view: viewName,
            },
          );

          expect(endpoints).not.toEqual(
            expect.objectContaining({
              ui: {
                url: 'http://my.frigate/recording/my-camera/',
              },
            }),
          );
        },
      );
    });
  });
});



================================================
FILE: tests/camera-manager/frigate/event-watcher.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { FrigateEventWatcher } from '../../../src/camera-manager/frigate/event-watcher.js';
import { FrigateEventChange } from '../../../src/camera-manager/frigate/types.js';
import { HomeAssistant } from '../../../src/ha/types.js';
import { createHASS } from '../../test-utils.js';

const createEventChange = (): FrigateEventChange => {
  return {
    type: 'new',
    before: {
      camera: 'front_door',
      snapshot: null,
      has_clip: false,
      has_snapshot: false,
      label: 'person',
      current_zones: [],
    },
    after: {
      camera: 'front_door',
      snapshot: null,
      has_clip: true,
      has_snapshot: true,
      label: 'person',
      current_zones: [],
    },
  };
};

const callHASubscribeMessageCallback = (
  hass: HomeAssistant,
  data: unknown,
  n = 0,
): void => {
  const mock = vi.mocked(hass.connection.subscribeMessage).mock;
  expect(mock.calls.length).greaterThan(n);
  mock.calls[n][0](data);
};

describe('FrigateEventWatcher', () => {
  it('should subscribe to a given topic once', async () => {
    const stateWatcher = new FrigateEventWatcher();
    const hass = createHASS();

    await stateWatcher.subscribe(hass, {
      instanceID: 'frigate',
      callback: vi.fn(),
    });

    await stateWatcher.subscribe(hass, {
      instanceID: 'frigate',
      callback: vi.fn(),
    });

    expect(hass.connection.subscribeMessage).toBeCalledTimes(1);
  });

  it('should only subscribe from a given topic once', async () => {
    const stateWatcher = new FrigateEventWatcher();
    const hass = createHASS();

    const unsubscribeCallback = vi.fn();
    vi.mocked(hass.connection.subscribeMessage).mockResolvedValue(unsubscribeCallback);

    const request_1 = {
      instanceID: 'frigate',
      callback: vi.fn(),
    };
    const request_2 = { ...request_1 };

    await stateWatcher.subscribe(hass, request_1);
    await stateWatcher.subscribe(hass, request_2);

    await stateWatcher.unsubscribe(request_1);
    expect(unsubscribeCallback).not.toBeCalled();

    await stateWatcher.unsubscribe(request_2);
    expect(unsubscribeCallback).toBeCalledTimes(1);
  });

  describe('should call handler', () => {
    afterEach(() => {
      vi.resetAllMocks();
    });

    it('with invalid JSON', async () => {
      const spy = vi.spyOn(global.console, 'warn').mockImplementation(() => true);

      const stateWatcher = new FrigateEventWatcher();
      const hass = createHASS();

      const callback = vi.fn();
      const request = {
        instanceID: 'frigate',
        callback: callback,
      };

      await stateWatcher.subscribe(hass, request);
      callHASubscribeMessageCallback(hass, 'NOT_JSON');

      expect(callback).not.toBeCalled();
      expect(spy).toBeCalledWith(
        'Received non-JSON payload as Frigate event',
        'NOT_JSON',
      );
    });

    it('with malformed event', async () => {
      const spy = vi.spyOn(global.console, 'warn').mockImplementation(() => true);

      const stateWatcher = new FrigateEventWatcher();
      const hass = createHASS();

      const callback = vi.fn();
      const request = {
        instanceID: 'frigate',
        callback: callback,
      };

      await stateWatcher.subscribe(hass, request);
      const data = JSON.stringify({});
      callHASubscribeMessageCallback(hass, data);

      expect(callback).not.toBeCalled();
      expect(spy).toBeCalledWith(
        'Received malformed Frigate event from Home Assistant',
        data,
      );
    });

    it('without a matcher', async () => {
      const stateWatcher = new FrigateEventWatcher();
      const hass = createHASS();

      const callback = vi.fn();
      const request = {
        instanceID: 'frigate',
        callback: callback,
      };

      await stateWatcher.subscribe(hass, request);
      const eventChange = createEventChange();
      callHASubscribeMessageCallback(hass, JSON.stringify(eventChange));

      expect(callback).toBeCalledWith(eventChange);
    });

    it('with a non-matching instance_id', async () => {
      const stateWatcher = new FrigateEventWatcher();
      const hass = createHASS();

      const callback_1 = vi.fn();
      const request_1 = {
        instanceID: 'frigate_1',
        callback: callback_1,
      };

      const callback_2 = vi.fn();
      const request_2 = {
        instanceID: 'frigate_2',
        callback: callback_2,
      };

      await stateWatcher.subscribe(hass, request_1);
      await stateWatcher.subscribe(hass, request_2);

      const eventChange = createEventChange();
      callHASubscribeMessageCallback(hass, JSON.stringify(eventChange), 1);

      expect(callback_1).not.toBeCalledWith(eventChange);
      expect(callback_2).toBeCalledWith(eventChange);
    });

    it('with a matcher', async () => {
      const stateWatcher = new FrigateEventWatcher();
      const hass = createHASS();

      const matching_callback = vi.fn();
      const matching_request = {
        instanceID: 'frigate',
        callback: matching_callback,
        matcher: (event: FrigateEventChange) => event.after.camera === 'front_door',
      };

      const non_matching_callback = vi.fn();
      const non_matching_request = {
        instanceID: 'frigate',
        callback: non_matching_callback,
        matcher: (event: FrigateEventChange) => event.after.camera === 'back_door',
      };

      await stateWatcher.subscribe(hass, matching_request);
      await stateWatcher.subscribe(hass, non_matching_request);

      const eventChange = createEventChange();
      callHASubscribeMessageCallback(hass, JSON.stringify(eventChange));

      expect(non_matching_callback).not.toBeCalledWith(eventChange);
      expect(matching_callback).toBeCalledWith(eventChange);
    });
  });
});



================================================
FILE: tests/camera-manager/frigate/requests.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import {
  getEvents,
  getEventSummary,
  getPTZInfo,
  getRecordingSegments,
  getRecordingsSummary,
  retainEvent,
} from '../../../src/camera-manager/frigate/requests';
import {
  EventSummary,
  eventSummarySchema,
  FrigateEvent,
  frigateEventsSchema,
  ptzInfoSchema,
  recordingSegmentsSchema,
  recordingSummarySchema,
  retainResultSchema,
} from '../../../src/camera-manager/frigate/types';
import { RecordingSegment } from '../../../src/camera-manager/types';
import { homeAssistantWSRequest } from '../../../src/ha/ws-request';
import { createFrigateEvent, createHASS } from '../../test-utils';

vi.mock('../../../src/ha/ws-request');

describe('frigate requests', () => {
  afterEach(() => {
    vi.resetAllMocks();
  });
  it('should get recordings summary', async () => {
    const recordingSummary = {
      events: 0,
      hours: [],
      day: new Date(),
    };
    const hass = createHASS();
    hass.config.time_zone = 'Europe/Dublin';

    vi.mocked(homeAssistantWSRequest).mockResolvedValue(recordingSummary);
    expect(await getRecordingsSummary(hass, 'clientID', 'camera.office')).toBe(
      recordingSummary,
    );
    expect(homeAssistantWSRequest).toBeCalledWith(
      hass,
      recordingSummarySchema,
      expect.objectContaining({
        type: 'frigate/recordings/summary',
        instance_id: 'clientID',
        camera: 'camera.office',
        timezone: 'Europe/Dublin',
      }),
      true,
    );
  });

  it('should get recordings segments', async () => {
    const recordingSegments: RecordingSegment[] = [
      {
        start_time: 0,
        end_time: 1,
        id: 'foo',
      },
    ];
    const hass = createHASS();
    vi.mocked(homeAssistantWSRequest).mockResolvedValue(recordingSegments);
    expect(
      await getRecordingSegments(hass, {
        instance_id: 'clientID',
        camera: 'camera.office',
        after: 1,
        before: 0,
      }),
    ).toBe(recordingSegments);
    expect(homeAssistantWSRequest).toBeCalledWith(
      hass,
      recordingSegmentsSchema,
      expect.objectContaining({
        type: 'frigate/recordings/get',
        instance_id: 'clientID',
        camera: 'camera.office',
        after: 1,
        before: 0,
      }),
      true,
    );
  });

  describe('should retain event', async () => {
    it('successfully', async () => {
      vi.mocked(homeAssistantWSRequest).mockResolvedValue({
        success: true,
        message: 'success',
      });

      const hass = createHASS();
      retainEvent(hass, 'clientID', 'eventID', true);

      expect(homeAssistantWSRequest).toBeCalledWith(
        hass,
        retainResultSchema,
        expect.objectContaining({
          type: 'frigate/event/retain',
          instance_id: 'clientID',
          event_id: 'eventID',
          retain: true,
        }),
        true,
      );
    });

    it('unsuccessfully', async () => {
      vi.mocked(homeAssistantWSRequest).mockResolvedValue({
        success: false,
        message: 'failed',
      });

      const hass = createHASS();
      await expect(retainEvent(hass, 'clientID', 'eventID', true)).rejects.toThrowError(
        /Could not retain event/,
      );
      expect(homeAssistantWSRequest).toBeCalledWith(
        hass,
        retainResultSchema,
        expect.objectContaining({
          type: 'frigate/event/retain',
          instance_id: 'clientID',
          event_id: 'eventID',
          retain: true,
        }),
        true,
      );
    });
  });

  it('should get events', async () => {
    const events: FrigateEvent[] = [createFrigateEvent()];
    const hass = createHASS();
    vi.mocked(homeAssistantWSRequest).mockResolvedValue(events);
    expect(
      await getEvents(hass, {
        instance_id: 'clientID',
        cameras: ['camera.office'],
        labels: ['person'],
        zones: ['zone'],
        after: 0,
        before: 1,
        limit: 10,
        has_clip: true,
        has_snapshot: true,
        favorites: true,
      }),
    ).toBe(events);
    expect(homeAssistantWSRequest).toBeCalledWith(
      hass,
      frigateEventsSchema,
      expect.objectContaining({
        type: 'frigate/events/get',
        instance_id: 'clientID',
        cameras: ['camera.office'],
        labels: ['person'],
        zones: ['zone'],
        after: 0,
        before: 1,
        limit: 10,
        has_clip: true,
        has_snapshot: true,
        favorites: true,
      }),
      true,
    );
  });

  it('should get event summary', async () => {
    const eventSummary: EventSummary = [
      {
        camera: 'camera.office',
        day: '2023-10-29',
        label: 'person',
        sub_label: null,
        zones: ['door'],
      },
    ];
    const hass = createHASS();
    hass.config.time_zone = 'Europe/Dublin';

    vi.mocked(homeAssistantWSRequest).mockResolvedValue(eventSummary);
    expect(await getEventSummary(hass, 'clientID')).toBe(eventSummary);
    expect(homeAssistantWSRequest).toBeCalledWith(
      hass,
      eventSummarySchema,
      expect.objectContaining({
        type: 'frigate/events/summary',
        instance_id: 'clientID',
        timezone: 'Europe/Dublin',
      }),
      true,
    );
  });

  it('should get PTZ info', async () => {
    const ptzInfo = [
      {
        name: 'camera.office',
        features: ['zoom', 'zoom-r'],
        presets: ['preset01', 'preset02'],
      },
    ];
    const hass = createHASS();
    vi.mocked(homeAssistantWSRequest).mockResolvedValue(ptzInfo);
    expect(await getPTZInfo(hass, 'clientID', 'camera.office')).toBe(ptzInfo);
    expect(homeAssistantWSRequest).toBeCalledWith(
      hass,
      ptzInfoSchema,
      expect.objectContaining({
        type: 'frigate/ptz/info',
        instance_id: 'clientID',
        camera: 'camera.office',
      }),
      true,
    );
  });
});



================================================
FILE: tests/camera-manager/frigate/util.test.ts
================================================
import { add } from 'date-fns';
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import {
  getEventMediaContentID,
  getEventThumbnailURL,
  getEventTitle,
  getRecordingID,
  getRecordingMediaContentID,
  getRecordingTitle,
} from '../../../src/camera-manager/frigate/util';
import { CameraConfig } from '../../../src/config/schema/cameras';
import {
  createCameraConfig,
  createFrigateEvent,
  createFrigateRecording,
} from '../../test-utils';

describe('getEventTitle', () => {
  const start = new Date('2023-05-06T10:43:00');
  const end = new Date('2023-05-06T10:44:12');
  afterEach(() => {
    vi.useRealTimers();
  });
  it('should get finished event title', () => {
    expect(
      getEventTitle(
        createFrigateEvent({
          start_time: start.getTime() / 1000,
          end_time: end.getTime() / 1000,
          top_score: 0.841796875,
          label: 'person',
        }),
      ),
    ).toBe('2023-05-06 10:43 [72s, Person 84%]');
  });
  it('should get in-progress event title', () => {
    vi.useFakeTimers();
    vi.setSystemTime(add(start, { seconds: 60 }));

    expect(
      getEventTitle(
        createFrigateEvent({
          start_time: start.getTime() / 1000,
          end_time: null,
          top_score: 0.841796875,
          label: 'person',
        }),
      ),
    ).toBe('2023-05-06 10:43 [60s, Person 84%]');
  });
  it('should get scoreless event title', () => {
    expect(
      getEventTitle(
        createFrigateEvent({
          start_time: start.getTime() / 1000,
          end_time: end.getTime() / 1000,
          top_score: null,
          label: 'person',
        }),
      ),
    ).toBe('2023-05-06 10:43 [72s, Person]');
  });
});

describe('getRecordingTitle', () => {
  it('should get recording title', () => {
    expect(
      getRecordingTitle(
        'Kitchen',
        createFrigateRecording({
          startTime: new Date('2023-04-29T14:00:00'),
        }),
      ),
    ).toBe('Kitchen 2023-04-29 14:00');
  });
});

describe('getEventThumbnailURL', () => {
  it('should get thumbnail URL', () => {
    expect(
      getEventThumbnailURL(
        'clientid',
        createFrigateEvent({
          id: '1683396875.643998-hmzrh5',
        }),
      ),
    ).toBe('/api/frigate/clientid/thumbnail/1683396875.643998-hmzrh5');
  });
});

describe('getEventMediaContentID', () => {
  it('should get event content ID', () => {
    expect(
      getEventMediaContentID(
        'clientid',
        'kitchen',
        createFrigateEvent({
          id: '1683396875.643998-hmzrh5',
        }),
        'clips',
      ),
    ).toBe(
      'media-source://frigate/clientid/event/clips/kitchen/1683396875.643998-hmzrh5',
    );
  });
});

describe('getRecordingMediaContentID', () => {
  it('should get recording content ID', () => {
    expect(
      getRecordingMediaContentID(
        'clientid',
        'kitchen',
        createFrigateRecording({
          startTime: new Date('2023-04-29T14:00:00'),
        }),
      ),
    ).toBe('media-source://frigate/clientid/recordings/kitchen/2023-04-29/14');
  });
});

describe('getRecordingID', () => {
  it('should get recording ID', () => {
    expect(
      getRecordingID(
        createCameraConfig({
          frigate: {
            client_id: 'unique_client_id',
            camera_name: 'kitchen',
          },
        }),
        createFrigateRecording({
          startTime: new Date('2023-04-29T14:00:00Z'),
          endTime: new Date('2023-04-29T14:59:59Z'),
        }),
      ),
    ).toBe('unique_client_id/kitchen/1682776800000/1682780399000');
  });
  it('should get recording ID without client_id or camera_name', () => {
    // Note: This path is defended against in the code but should not happen in
    // practice as this would be a malformed (not-zod-parsed) camera config.
    const cameraConfig = mock<CameraConfig>();
    expect(
      getRecordingID(
        cameraConfig,
        createFrigateRecording({
          startTime: new Date('2023-04-29T14:00:00Z'),
          endTime: new Date('2023-04-29T14:59:59Z'),
        }),
      ),
    ).toBe('//1682776800000/1682780399000');
  });
});



================================================
FILE: tests/camera-manager/generic/engine-generic.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { GenericCameraManagerEngine } from '../../../src/camera-manager/generic/engine-generic';
import { Engine, QueryResultsType, QueryType } from '../../../src/camera-manager/types';
import { StateWatcherSubscriptionInterface } from '../../../src/card-controller/hass/state-watcher';
import { CameraConfig } from '../../../src/config/schema/cameras';
import { RawAdvancedCameraCardConfig } from '../../../src/config/types';
import {
  TestViewMedia,
  createCameraConfig,
  createHASS,
  createStateEntity,
  createStore,
} from '../../test-utils';

const createEngine = (): GenericCameraManagerEngine => {
  return new GenericCameraManagerEngine(mock<StateWatcherSubscriptionInterface>());
};

const createGenericCameraConfig = (
  config?: RawAdvancedCameraCardConfig,
): CameraConfig => {
  return createCameraConfig(config);
};

describe('GenericCameraManagerEngine', () => {
  it('should get engine type', () => {
    expect(createEngine().getEngineType()).toBe(Engine.Generic);
  });

  it('should initialize camera', async () => {
    const config = createGenericCameraConfig();
    const camera = await createEngine().createCamera(createHASS(), config);

    expect(camera.getConfig()).toEqual(config);
    expect(camera.getCapabilities()).toBeTruthy();
    expect(camera.getCapabilities()?.has('favorite-events')).toBeFalsy();
    expect(camera.getCapabilities()?.has('favorite-recordings')).toBeFalsy();
    expect(camera.getCapabilities()?.has('seek')).toBeFalsy();
    expect(camera.getCapabilities()?.has('clips')).toBeFalsy();
    expect(camera.getCapabilities()?.has('recordings')).toBeFalsy();
    expect(camera.getCapabilities()?.has('snapshots')).toBeFalsy();
    expect(camera.getCapabilities()?.has('trigger')).toBeTruthy();
  });

  it('should generate default event query', () => {
    const engine = createEngine();
    expect(
      engine.generateDefaultEventQuery(
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        new Set(['camera-1']),
        {},
      ),
    ).toBeNull();
  });

  it('should generate default recording query', () => {
    const engine = createEngine();
    expect(
      engine.generateDefaultRecordingQuery(
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        new Set(['camera-1']),
        {},
      ),
    ).toBeNull();
  });

  it('should generate default recording segments query', () => {
    const engine = createEngine();
    expect(
      engine.generateDefaultRecordingSegmentsQuery(
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        new Set(['camera-1']),
        {},
      ),
    ).toBeNull();
  });

  it('should get events', async () => {
    const engine = createEngine();
    expect(
      await engine.getEvents(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        { type: QueryType.Event, cameraIDs: new Set(['camera-1']) },
      ),
    ).toBeNull();
  });

  it('should get recordings', async () => {
    const engine = createEngine();
    expect(
      await engine.getRecordings(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        { type: QueryType.Recording, cameraIDs: new Set(['camera-1']) },
      ),
    ).toBeNull();
  });

  it('should get recording segments', async () => {
    const engine = createEngine();
    expect(
      await engine.getRecordingSegments(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        {
          type: QueryType.RecordingSegments,
          cameraIDs: new Set(['camera-1']),
          start: new Date(),
          end: new Date(),
        },
      ),
    ).toBeNull();
  });

  it('should generate media from events', async () => {
    const engine = createEngine();
    expect(
      engine.generateMediaFromEvents(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        {
          type: QueryType.Event,
          cameraIDs: new Set(['camera-1']),
        },
        {
          type: QueryResultsType.Event,
          engine: Engine.Generic,
        },
      ),
    ).toBeNull();
  });

  it('should generate media from recordings', async () => {
    const engine = createEngine();
    expect(
      engine.generateMediaFromRecordings(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        {
          type: QueryType.Recording,
          cameraIDs: new Set(['camera-1']),
          start: new Date(),
          end: new Date(),
        },
        {
          type: QueryResultsType.Recording,
          engine: Engine.Generic,
        },
      ),
    ).toBeNull();
  });

  it('should get media download path', async () => {
    expect(
      await createEngine().getMediaDownloadPath(
        createHASS(),
        createGenericCameraConfig(),
        new TestViewMedia(),
      ),
    ).toBeNull();
  });

  it('should favorite media', async () => {
    expect(
      await createEngine().favoriteMedia(
        createHASS(),
        createGenericCameraConfig(),
        new TestViewMedia(),
        true,
      ),
    ).toBeUndefined();
  });

  it('should get query result max age', () => {
    expect(
      createEngine().getQueryResultMaxAge({
        type: QueryType.Event,
        cameraIDs: new Set(['camera-1']),
      }),
    ).toBeNull();
  });

  it('should get media seek time', async () => {
    const engine = createEngine();
    expect(
      await engine.getMediaSeekTime(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        new TestViewMedia(),
        new Date(),
      ),
    ).toBeNull();
  });

  it('should get media metadata', async () => {
    const engine = createEngine();
    expect(
      await engine.getMediaMetadata(
        createHASS(),
        createStore([{ cameraID: 'camera-1', engine: engine }]),
        { type: QueryType.MediaMetadata, cameraIDs: new Set(['camera-1']) },
      ),
    ).toBeNull();
  });

  describe('should get camera metadata', () => {
    it('with empty config', async () => {
      expect(
        createEngine().getCameraMetadata(createHASS(), createGenericCameraConfig()),
      ).toEqual({
        icon: {
          entity: undefined,
          icon: undefined,
          fallback: 'mdi:video',
        },
        title: '',
      });
    });

    it('with id', async () => {
      expect(
        createEngine().getCameraMetadata(
          createHASS(),
          createGenericCameraConfig({ id: 'https://go2rtc#stream' }),
        ),
      ).toEqual(
        expect.objectContaining({
          title: 'https://go2rtc#stream',
        }),
      );
    });

    it('with configured title', async () => {
      expect(
        createEngine().getCameraMetadata(
          createHASS(),
          createGenericCameraConfig({
            title: 'My Camera',
          }),
        ),
      ).toEqual(
        expect.objectContaining({
          title: 'My Camera',
        }),
      );
    });

    describe('with entity title', () => {
      it('camera_entity', async () => {
        expect(
          createEngine().getCameraMetadata(
            createHASS({
              'camera.test': createStateEntity({
                attributes: { friendly_name: 'My Entity Camera' },
              }),
            }),
            createGenericCameraConfig({
              camera_entity: 'camera.test',
            }),
          ),
        ).toEqual(
          expect.objectContaining({
            title: 'My Entity Camera',
          }),
        );
      });

      it('webrtc_card.entity', async () => {
        expect(
          createEngine().getCameraMetadata(
            createHASS({
              'camera.test': createStateEntity({
                attributes: { friendly_name: 'My Entity Camera' },
              }),
            }),
            createGenericCameraConfig({
              webrtc_card: {
                entity: 'camera.test',
              },
            }),
          ),
        ).toEqual(
          expect.objectContaining({
            title: 'My Entity Camera',
          }),
        );
      });
    });
  });

  it('should get media capabilities', () => {
    expect(createEngine().getMediaCapabilities(new TestViewMedia())).toBeNull();
  });

  describe('should get camera endpoints', () => {
    it('default', () => {
      expect(createEngine().getCameraEndpoints(createGenericCameraConfig())).toBeNull();
    });

    it('for go2rtc', () => {
      expect(
        createEngine().getCameraEndpoints(
          createGenericCameraConfig({
            go2rtc: {
              stream: 'stream',
              url: '/local/path',
            },
          }),
        ),
      ).toEqual({
        go2rtc: {
          endpoint: '/local/path/api/ws?src=stream',
          sign: true,
        },
      });
    });

    it('for webrtc-card', () => {
      expect(
        createEngine().getCameraEndpoints(
          createGenericCameraConfig({
            camera_entity: 'camera.office',
          }),
        ),
      ).toEqual({
        webrtcCard: {
          endpoint: 'camera.office',
        },
      });
    });
  });
});



================================================
FILE: tests/camera-manager/reolink/camera.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CameraManagerEngine } from '../../../src/camera-manager/engine';
import { ReolinkCamera } from '../../../src/camera-manager/reolink/camera';
import { CameraProxyConfig } from '../../../src/camera-manager/types';
import { ActionsExecutor } from '../../../src/card-controller/actions/types';
import { StateWatcher } from '../../../src/card-controller/hass/state-watcher';
import { ProxyConfig } from '../../../src/config/schema/cameras';
import { EntityRegistryManagerLive } from '../../../src/ha/registry/entity';
import { EntityRegistryManagerMock } from '../../ha/registry/entity/mock';
import {
  createCameraConfig,
  createHASS,
  createRegistryEntity,
  createStateEntity,
} from '../../test-utils';

describe('ReolinkCamera', () => {
  const cameraEntity = createRegistryEntity({
    entity_id: 'camera.office_reolink',
    unique_id: '85270002TS7D4RUP_0_main',
    platform: 'reolink',
  });
  const buttonEntityPTZLeft = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_left',
    unique_id: '85270002TS7D4RUP_0_ptz_left',
    platform: 'reolink',
  });
  const buttonEntityPTZRight = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_right',
    unique_id: '85270002TS7D4RUP_0_ptz_right',
    platform: 'reolink',
  });
  const buttonEntityPTZUp = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_up',
    unique_id: '85270002TS7D4RUP_0_ptz_up',
    platform: 'reolink',
  });
  const buttonEntityPTZDown = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_down',
    unique_id: '85270002TS7D4RUP_0_ptz_down',
    platform: 'reolink',
  });
  const buttonEntityPTZZoomIn = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_zoom_in',
    unique_id: '85270002TS7D4RUP_0_ptz_zoom_in',
    platform: 'reolink',
  });
  const buttonEntityPTZZoomOut = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_zoom_out',
    unique_id: '85270002TS7D4RUP_0_ptz_zoom_out',
    platform: 'reolink',
  });
  const buttonEntityPTZStop = createRegistryEntity({
    entity_id: 'button.office_reolink_ptz_stop',
    unique_id: '85270002TS7D4RUP_0_ptz_stop',
    platform: 'reolink',
  });
  const selectEntityPTZ = createRegistryEntity({
    entity_id: 'select.office_reolink_ptz_preset',
    unique_id: '85270002TS7D4RUP_0_ptz_preset',
    platform: 'reolink',
  });

  const ptzPopulatedEntityRegistryManager = new EntityRegistryManagerMock([
    cameraEntity,
    buttonEntityPTZLeft,
    buttonEntityPTZRight,
    buttonEntityPTZUp,
    buttonEntityPTZDown,
    buttonEntityPTZZoomIn,
    buttonEntityPTZZoomOut,
    buttonEntityPTZStop,
    selectEntityPTZ,

    // Unrelated button.
    createRegistryEntity({
      entity_id: 'button.office_reolink_ptz_foo',
      unique_id: '85270002TS7D4RUP_0_ptz_foo',
      platform: 'reolink',
    }),

    // Unrelated button without unique_id.
    createRegistryEntity({
      entity_id: 'button.office_reolink_ptz_bar',
      platform: 'reolink',
    }),
  ]);

  describe('should initialize config', () => {
    describe('should detect channel', () => {
      it('without a camera_entity', async () => {
        const config = createCameraConfig();
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        expect(
          async () =>
            await camera.initialize({
              hass: createHASS(),
              entityRegistryManager: mock<EntityRegistryManagerLive>(),
              stateWatcher: mock<StateWatcher>(),
            }),
        ).rejects.toThrowError('Could not find camera entity');
      });

      it('without a unique_id', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.office_reolink',
            platform: 'reolink',
          }),
        ]);

        expect(
          async () =>
            await camera.initialize({
              hass: createHASS(),
              entityRegistryManager,
              stateWatcher: mock<StateWatcher>(),
            }),
        ).rejects.toThrowError('Could not initialize Reolink camera');
      });

      it('without a valid unique_id', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.office_reolink',
            unique_id: 'invalid',
            platform: 'reolink',
          }),
        ]);

        expect(
          async () =>
            await camera.initialize({
              hass: createHASS(),
              entityRegistryManager,
              stateWatcher: mock<StateWatcher>(),
            }),
        ).rejects.toThrowError('Could not initialize Reolink camera');
      });

      // See: https://github.com/dermotduffy/advanced-camera-card/issues/1964
      it('successfully with an NVR-connected camera with user-specified channel', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
          reolink: {
            channel: 42,
          },
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.office_reolink',
            unique_id: '9527000HXU4V1VHZ_9527000I7E5F1GYU_main',
            platform: 'reolink',
          }),
        ]);

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getChannel()).toBe(42);
      });

      it('successfully with an NVR-connected camera without user-specified channel', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());
        const entityRegistryManager = new EntityRegistryManagerMock([
          createRegistryEntity({
            entity_id: 'camera.office_reolink',
            unique_id: '9527000HXU4V1VHZ_9527000I7E5F1GYU_main',
            platform: 'reolink',
          }),
        ]);

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getChannel()).toBe(0);
      });

      it('successfully with a directly connected camera', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());
        const entityRegistryManager = new EntityRegistryManagerMock([cameraEntity]);

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getChannel()).toBe(0);
      });
    });

    describe('successfully with PTZ', () => {
      it('should find PTZ button entities with a directly connected camera', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: ptzPopulatedEntityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getCapabilities()?.getPTZCapabilities()).toEqual({
          left: ['continuous'],
          right: ['continuous'],
          up: ['continuous'],
          down: ['continuous'],
          zoomIn: ['continuous'],
          zoomOut: ['continuous'],
        });
      });

      it('should find PTZ button entities with NVR-connected camera', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: new EntityRegistryManagerMock([
            createRegistryEntity({
              entity_id: 'camera.office_reolink',
              unique_id: '9527000HXU4V1VHZ_9527000I7E5F1GYU_main',
              platform: 'reolink',
            }),
            createRegistryEntity({
              entity_id: 'button.office_reolink_ptz_zoom_in',
              unique_id: '9527000HXU4V1VHZ_9527000I7E5F1GYU_ptz_zoom_in',
              platform: 'reolink',
            }),
            createRegistryEntity({
              entity_id: 'button.office_reolink_ptz_zoom_out',
              unique_id: '9527000HXU4V1VHZ_9527000I7E5F1GYU_ptz_zoom_out',
              platform: 'reolink',
            }),
          ]),
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getCapabilities()?.getPTZCapabilities()).toEqual({
          zoomIn: ['continuous'],
          zoomOut: ['continuous'],
        });
      });

      it('should find PTZ select entity', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        await camera.initialize({
          hass: createHASS({
            'select.office_reolink_ptz_preset': createStateEntity({
              state: 'foo',
              attributes: {
                options: ['preset-one', 'preset-two'],
              },
            }),
          }),
          entityRegistryManager: ptzPopulatedEntityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getCapabilities()?.getPTZCapabilities()).toEqual({
          left: ['continuous'],
          right: ['continuous'],
          up: ['continuous'],
          down: ['continuous'],
          zoomIn: ['continuous'],
          zoomOut: ['continuous'],
          presets: ['preset-one', 'preset-two'],
        });
      });

      it('should allow configured PTZ actions to override', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
          ptz: {
            actions_left: {
              action: 'perform-action',
              perform_action: 'homeassistant.toggle',
              target: {
                entity_id: 'switch.camera_move_left',
              },
            },
          },
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: ptzPopulatedEntityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });

        expect(camera.getCapabilities()?.getPTZCapabilities()).toEqual({
          left: ['relative'],
          right: ['continuous'],
          up: ['continuous'],
          down: ['continuous'],
          zoomIn: ['continuous'],
          zoomOut: ['continuous'],
        });
      });
    });
  });

  describe('should get proxy config', () => {
    it.each([
      [
        'when unspecified',
        {},
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when media set to on',
        { media: true },
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when media set to off',
        { media: false },
        {
          dynamic: true,
          media: false,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when media set to auto',
        { media: 'auto' as const },
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when ssl_verification is set to auto',
        { ssl_verification: 'auto' as const },
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when ssl_verification is set to true',
        { ssl_verification: true },
        {
          dynamic: true,
          media: true,
          ssl_verification: true,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when ssl_verification is set to false',
        { ssl_verification: false },
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when ssl_ciphers is set to auto',
        { ssl_ciphers: 'auto' as const },
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
      [
        'when ssl_ciphers is set to modern',
        { ssl_ciphers: 'modern' as const },
        {
          dynamic: true,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'modern' as const,
        },
      ],
      [
        'when dynamic is set to false',
        { dynamic: false },
        {
          dynamic: false,
          media: true,
          ssl_verification: false,
          ssl_ciphers: 'intermediate' as const,
        },
      ],
    ])(
      '%s',
      (
        _name: string,
        proxyConfig: Partial<ProxyConfig>,
        expectedResult: CameraProxyConfig,
      ) => {
        const camera = new ReolinkCamera(
          createCameraConfig({
            proxy: proxyConfig,
          }),
          mock<CameraManagerEngine>(),
        );
        expect(camera.getProxyConfig()).toEqual(expectedResult);
      },
    );
  });

  describe('should execute PTZ action', () => {
    it('should ignore actions without matching button', async () => {
      const config = createCameraConfig({
        camera_entity: 'camera.office_reolink',
      });
      const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

      await camera.initialize({
        hass: createHASS(),
        entityRegistryManager: new EntityRegistryManagerMock([cameraEntity]),
        stateWatcher: mock<StateWatcher>(),
      });
      const executor = mock<ActionsExecutor>();

      await camera.executePTZAction(executor, 'left');
      await camera.executePTZAction(executor, 'left', { phase: 'start' });

      expect(executor.executeActions).not.toBeCalled();
    });

    it('should ignore actions with configured action', async () => {
      const config = createCameraConfig({
        camera_entity: 'camera.office_reolink',
        ptz: {
          actions_left_start: {
            action: 'perform-action',
            perform_action: 'button.press',
            target: {
              entity_id: 'button.foo',
            },
          },
        },
      });
      const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

      await camera.initialize({
        hass: createHASS(),
        entityRegistryManager: new EntityRegistryManagerMock([
          cameraEntity,
          buttonEntityPTZLeft,
        ]),
        stateWatcher: mock<StateWatcher>(),
      });
      const executor = mock<ActionsExecutor>();
      await camera.executePTZAction(executor, 'left', { phase: 'start' });

      expect(executor.executeActions).toBeCalledTimes(1);
      expect(executor.executeActions).toHaveBeenLastCalledWith({
        actions: {
          action: 'perform-action',
          perform_action: 'button.press',
          target: {
            entity_id: 'button.foo',
          },
        },
      });
    });

    it('should execute action with matching button', async () => {
      const config = createCameraConfig({
        camera_entity: 'camera.office_reolink',
      });
      const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

      await camera.initialize({
        hass: createHASS(),
        entityRegistryManager: ptzPopulatedEntityRegistryManager,
        stateWatcher: mock<StateWatcher>(),
      });
      const executor = mock<ActionsExecutor>();

      await camera.executePTZAction(executor, 'left', { phase: 'start' });
      expect(executor.executeActions).toHaveBeenLastCalledWith({
        actions: [
          {
            action: 'perform-action',
            perform_action: 'button.press',
            target: {
              entity_id: 'button.office_reolink_ptz_left',
            },
          },
        ],
      });

      await camera.executePTZAction(executor, 'left', { phase: 'stop' });
      expect(executor.executeActions).toHaveBeenLastCalledWith({
        actions: [
          {
            action: 'perform-action',
            perform_action: 'button.press',
            target: {
              entity_id: 'button.office_reolink_ptz_stop',
            },
          },
        ],
      });
    });

    it('should ignore relative actions', async () => {
      const config = createCameraConfig({
        camera_entity: 'camera.office_reolink',
      });
      const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

      await camera.initialize({
        hass: createHASS(),
        entityRegistryManager: ptzPopulatedEntityRegistryManager,
        stateWatcher: mock<StateWatcher>(),
      });
      const executor = mock<ActionsExecutor>();

      await camera.executePTZAction(executor, 'left');
      expect(executor.executeActions).not.toHaveBeenCalled();
    });

    describe('should execute preset', () => {
      it('for existing preset', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        await camera.initialize({
          hass: createHASS({
            'select.office_reolink_ptz_preset': createStateEntity({
              state: 'foo',
              attributes: {
                options: ['preset-one', 'preset-two'],
              },
            }),
          }),
          entityRegistryManager: ptzPopulatedEntityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });
        const executor = mock<ActionsExecutor>();

        await camera.executePTZAction(executor, 'preset', { preset: 'preset-two' });
        expect(executor.executeActions).toHaveBeenLastCalledWith({
          actions: [
            {
              action: 'perform-action',
              perform_action: 'select.select_option',
              target: {
                entity_id: 'select.office_reolink_ptz_preset',
              },
              data: {
                option: 'preset-two',
              },
            },
          ],
        });
      });

      it('for non-existant preset', async () => {
        const config = createCameraConfig({
          camera_entity: 'camera.office_reolink',
        });
        const camera = new ReolinkCamera(config, mock<CameraManagerEngine>());

        await camera.initialize({
          hass: createHASS(),
          entityRegistryManager: ptzPopulatedEntityRegistryManager,
          stateWatcher: mock<StateWatcher>(),
        });
        const executor = mock<ActionsExecutor>();

        await camera.executePTZAction(executor, 'preset');
        expect(executor.executeActions).not.toHaveBeenCalled();
      });
    });
  });
});



================================================
FILE: tests/camera-manager/reolink/engine-reolink.test.ts
================================================
import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
  vi,
} from 'vitest';
import { mock } from 'vitest-mock-extended';
import {
  ReolinkCameraManagerEngine,
  ReolinkQueryResultsClassifier,
} from '../../../src/camera-manager/reolink/engine-reolink';
import { ReolinkEventQueryResults } from '../../../src/camera-manager/reolink/types';
import { CameraManagerStore } from '../../../src/camera-manager/store';
import {
  CameraManagerRequestCache,
  Engine,
  EventQuery,
  QueryResultsType,
  QueryReturnType,
  QueryType,
} from '../../../src/camera-manager/types';
import { StateWatcher } from '../../../src/card-controller/hass/state-watcher';
import { BrowseMedia, browseMediaSchema } from '../../../src/ha/browse-media/types';
import { BrowseMediaWalker } from '../../../src/ha/browse-media/walker';
import { EntityRegistryManager } from '../../../src/ha/registry/entity/types';
import { ResolvedMediaCache } from '../../../src/ha/resolved-media';
import { homeAssistantWSRequest } from '../../../src/ha/ws-request';
import { EntityRegistryManagerMock } from '../../ha/registry/entity/mock';
import {
  createCamera,
  createCameraConfig,
  createHASS,
  createRegistryEntity,
  createStore,
} from '../../test-utils';

vi.mock('../../../src/ha/ws-request');

const TEST_CAMERAS: BrowseMedia = {
  title: 'Reolink',
  media_class: 'channel',
  media_content_type: 'playlist',
  media_content_id: 'media-source://reolink',
  children_media_class: 'directory',
  can_play: false,
  can_expand: true,
  thumbnail: null,
  children: [
    {
      title: 'Back Yard',
      media_class: 'directory',
      media_content_type: 'playlist',
      media_content_id: 'media-source://reolink/CAM|01J8XHYTNH77WE3C654K03KX1F|0',
      children_media_class: null,
      can_play: false,
      can_expand: true,
      thumbnail: null,
    },
  ],
};

const TEST_DIRECTORIES: BrowseMedia = {
  title: 'Back Yard Low res.',
  media_class: 'channel',
  media_content_type: 'playlist',
  media_content_id: 'media-source://reolink/DAYS|01J8XHYTNH77WE3C654K03KX1F|0|sub',
  children_media_class: 'directory',
  can_play: false,
  can_expand: true,
  thumbnail: null,
  children: [
    {
      title: '2024/11/4',
      media_class: 'directory',
      media_content_type: 'playlist',
      media_content_id:
        'media-source://reolink/DAY|01J8XHYTNH77WE3C654K03KX1F|0|sub|2024|11|4',
      children_media_class: null,
      can_play: false,
      can_expand: true,
      thumbnail: null,
    },
    {
      title: '2024/11/5',
      media_class: 'directory',
      media_content_type: 'playlist',
      media_content_id:
        'media-source://reolink/DAY|01J8XHYTNH77WE3C654K03KX1F|0|sub|2024|11|5',
      children_media_class: null,
      can_play: false,
      can_expand: true,
      thumbnail: null,
    },
    {
      title: '2024/11/6',
      media_class: 'directory',
      media_content_type: 'playlist',
      media_content_id:
        'media-source://reolink/DAY|01J8XHYTNH77WE3C654K03KX1F|0|sub|2024|11|6',
      children_media_class: null,
      can_play: false,
      can_expand: true,
      thumbnail: null,
    },
  ],
};

const TEST_FILES: BrowseMedia = {
  title: 'Back Yard Low res. 2024/11/4',
  media_class: 'channel',
  media_content_type: 'playlist',
  media_content_id: 'media-source://reolink/FILES|01J8XHYTNH77WE3C654K03KX1F|0|sub',
  children_media_class: 'video',
  can_play: false,
  can_expand: true,
  thumbnail: null,
  children: [
    {
      title: '21:23:53 0:00:34',
      media_class: 'video',
      media_content_type: 'video',
      media_content_id:
        'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
      children_media_class: null,
      can_play: true,
      can_expand: false,
      thumbnail: null,
    },
    {
      title: '21:29:05 0:00:41',
      media_class: 'video',
      media_content_type: 'video',
      media_content_id:
        'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052905_211_S.mp4',
      children_media_class: null,
      can_play: true,
      can_expand: false,
      thumbnail: null,
    },
    {
      title: '21:35:05 0:00:41 Zebra Person Vehicle',
      media_class: 'video',
      media_content_type: 'video',
      media_content_id:
        'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052905_211_S.mp4',
      children_media_class: null,
      can_play: true,
      can_expand: false,
      thumbnail: null,
    },
    {
      title: '21:37:00',
      media_class: 'video',
      media_content_type: 'video',
      media_content_id:
        'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052905_211_S.mp4',
      children_media_class: null,
      can_play: true,
      can_expand: false,
      thumbnail: null,
    },
    {
      title: '22:04:49 0:00:35',
      media_class: 'video',
      media_content_type: 'video',
      media_content_id:
        'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_060449_211_S.mp4',
      children_media_class: null,
      can_play: true,
      can_expand: false,
      thumbnail: null,
    },
  ],
};

const createEngine = (options?: {
  browseMediaManager?: BrowseMediaWalker;
  entityRegistryManager?: EntityRegistryManager;
}): ReolinkCameraManagerEngine => {
  return new ReolinkCameraManagerEngine(
    options?.entityRegistryManager ?? new EntityRegistryManagerMock(),
    mock<StateWatcher>(),
    options?.browseMediaManager ?? new BrowseMediaWalker(),
    new ResolvedMediaCache(),
    new CameraManagerRequestCache(),
  );
};

const cameraEntity = createRegistryEntity({
  entity_id: 'camera.office',
  unique_id: '85270002TS7D4RUP_0_main',
  platform: 'reolink',
  config_entry_id: '01J8XHYTNH77WE3C654K03KX1F',
});

const createPopulatedEngine = (): ReolinkCameraManagerEngine => {
  const entityRegistryManager = new EntityRegistryManagerMock([cameraEntity]);
  return createEngine({ entityRegistryManager });
};

const createStoreWithReolinkCamera = async (
  engine: ReolinkCameraManagerEngine,
): Promise<CameraManagerStore> => {
  const store = new CameraManagerStore();
  const camera = await engine.createCamera(
    createHASS(),
    createCameraConfig({ camera_entity: 'camera.office', id: 'office' }),
  );
  store.addCamera(camera);
  return store;
};

describe('ReolinkQueryResultsClassifier', () => {
  it('should correctly identify matching results', () => {
    expect(
      ReolinkQueryResultsClassifier.isReolinkEventQueryResults({
        type: QueryResultsType.Event,
        engine: Engine.Reolink,
      }),
    ).toBeTruthy();
  });

  it('should correctly identify non-matching results', () => {
    expect(
      ReolinkQueryResultsClassifier.isReolinkEventQueryResults({
        type: QueryResultsType.Event,
        engine: Engine.MotionEye,
      }),
    ).toBeFalsy();
  });
});

describe('ReolinkCameraManagerEngine', () => {
  it('should get correct engine type', () => {
    const engine = createEngine();
    expect(engine.getEngineType()).toBe('reolink');
  });

  it('should create camera', async () => {
    const engine = createPopulatedEngine();
    const config = createCameraConfig({
      camera_entity: 'camera.office',
      unique_id: 'office',
    });

    const camera = await engine.createCamera(createHASS(), config);

    expect(camera.getConfig()).toBe(config);
    expect(camera.getEngine()).toBe(engine);
    expect(camera.getCapabilities()?.getRawCapabilities()).toEqual({
      'favorite-events': false,
      'favorite-recordings': false,
      clips: true,
      'remote-control-entity': true,
      live: true,
      menu: true,
      recordings: false,
      seek: false,
      snapshots: false,
      substream: true,
      trigger: true,
    });
  });

  it('should get camera metadata', () => {
    const cameraConfig = createCameraConfig({
      title: 'Office',
      camera_entity: 'camera.office',
      icon: 'mdi:camera',
    });
    const engine = createEngine();
    expect(engine.getCameraMetadata(createHASS(), cameraConfig)).toEqual({
      engineIcon: 'reolink',
      icon: {
        icon: 'mdi:camera',
        entity: 'camera.office',
        fallback: 'mdi:video',
      },
      title: 'Office',
    });
  });

  describe('should get camera endpoints', () => {
    it('should return ui endpoint', () => {
      const cameraConfig = createCameraConfig({
        reolink: {
          url: 'http://path-to-reolink',
        },
      });

      const engine = createEngine();
      expect(engine.getCameraEndpoints(cameraConfig)).toEqual(
        expect.objectContaining({
          ui: { endpoint: 'http://path-to-reolink' },
        }),
      );
    });

    it('should return go2rtc endpoint', () => {
      const cameraConfig = createCameraConfig({
        go2rtc: {
          url: 'http://path-to-go2rtc',
          stream: 'stream',
        },
      });

      const engine = createEngine();

      expect(engine.getCameraEndpoints(cameraConfig)).toEqual(
        expect.objectContaining({
          go2rtc: { endpoint: 'http://path-to-go2rtc/api/ws?src=stream', sign: false },
        }),
      );
    });
  });

  describe('should get events', () => {
    afterEach(() => {
      vi.clearAllMocks();
    });

    describe('should get no event for unsupported features', () => {
      it.each([
        ['with favorite', { favorite: true }],
        ['with tags', { tags: new Set(['gate']) }],
        ['with what', { what: new Set(['car']) }],
        ['with where', { where: new Set(['office']) }],
        ['with hasSnapshot', { hasSnapshot: true }],
      ])('%s', async (_name: string, query: Partial<EventQuery>) => {
        const engine = createEngine();
        expect(
          await engine.getEvents(createHASS(), createStore(), {
            ...query,
            cameraIDs: new Set(['office']),
            type: QueryType.Event,
          }),
        ).toBeNull();
      });
    });

    it('should get events successfully without cache', async () => {
      const engine = createPopulatedEngine();
      const store = await createStoreWithReolinkCamera(engine);

      vi.mocked(homeAssistantWSRequest)
        .mockResolvedValueOnce(TEST_CAMERAS)
        .mockResolvedValueOnce(TEST_DIRECTORIES)
        .mockResolvedValueOnce(TEST_FILES);

      const events = await engine.getEvents(
        createHASS(),
        store,
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        },
        {
          useCache: false,
        },
      );

      expect(events).toEqual(
        new Map([
          [
            {
              cameraIDs: new Set(['office']),
              end: new Date('2024-11-04T22:00:00'),
              start: new Date('2024-11-04T21:00:00'),
              type: 'event-query',
            },
            {
              browseMedia: [
                {
                  _metadata: {
                    cameraID: 'office',
                    startDate: new Date('2024-11-04T21:37:00.000Z'),
                    endDate: new Date('2024-11-04T21:37:00.000Z'),
                  },
                  can_expand: false,
                  can_play: true,
                  children_media_class: null,
                  media_class: 'video',
                  media_content_id:
                    'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052905_211_S.mp4',
                  media_content_type: 'video',
                  thumbnail: null,
                  title: '21:37:00',
                },
                {
                  _metadata: {
                    cameraID: 'office',
                    endDate: new Date('2024-11-04T21:35:46.000Z'),
                    startDate: new Date('2024-11-04T21:35:05.000Z'),
                    what: ['person', 'vehicle', 'zebra'],
                  },
                  can_expand: false,
                  can_play: true,
                  children_media_class: null,
                  media_class: 'video',
                  media_content_id:
                    'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052905_211_S.mp4',
                  media_content_type: 'video',
                  thumbnail: null,
                  title: '21:35:05 0:00:41 Zebra Person Vehicle',
                },
                {
                  _metadata: {
                    cameraID: 'office',
                    endDate: new Date('2024-11-04T21:29:46'),
                    startDate: new Date('2024-11-04T21:29:05'),
                  },
                  can_expand: false,
                  can_play: true,
                  children_media_class: null,
                  media_class: 'video',
                  media_content_id:
                    'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052905_211_S.mp4',
                  media_content_type: 'video',
                  thumbnail: null,
                  title: '21:29:05 0:00:41',
                },
                {
                  _metadata: {
                    cameraID: 'office',
                    endDate: new Date('2024-11-04T21:24:27'),
                    startDate: new Date('2024-11-04T21:23:53'),
                  },
                  can_expand: false,
                  can_play: true,
                  children_media_class: null,
                  media_class: 'video',
                  media_content_id:
                    'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
                  media_content_type: 'video',
                  thumbnail: null,
                  title: '21:23:53 0:00:34',
                },
              ],
              engine: 'reolink',
              type: 'event-results',
            },
          ],
        ]),
      );
    });

    it('should cache event requests', async () => {
      const engine = createPopulatedEngine();
      const store = await createStoreWithReolinkCamera(engine);

      vi.mocked(homeAssistantWSRequest)
        .mockResolvedValueOnce(TEST_CAMERAS)
        .mockResolvedValueOnce(TEST_DIRECTORIES)
        .mockResolvedValueOnce(TEST_FILES);

      for (let i = 0; i < 10; i++) {
        await engine.getEvents(
          createHASS(),
          store,
          {
            type: QueryType.Event,
            cameraIDs: new Set(['office']),
            start: new Date('2024-11-04T21:00:00'),
            end: new Date('2024-11-04T22:00:00'),
          },
          {
            useCache: true,
          },
        );
      }

      expect(homeAssistantWSRequest).toHaveBeenCalledTimes(3);
    });

    it('should request high resolution if configured', async () => {
      const engine = createPopulatedEngine();
      const camera = await engine.createCamera(
        createHASS(),
        createCameraConfig({
          camera_entity: 'camera.office',
          id: 'office',
          reolink: {
            media_resolution: 'high',
          },
        }),
      );

      const store = new CameraManagerStore();
      store.addCamera(camera);

      vi.mocked(homeAssistantWSRequest)
        .mockResolvedValueOnce(TEST_CAMERAS)
        .mockResolvedValueOnce(TEST_DIRECTORIES)
        .mockResolvedValueOnce(TEST_FILES);

      const hass = createHASS();
      await engine.getEvents(hass, store, {
        type: QueryType.Event,
        cameraIDs: new Set(['office']),
        start: new Date('2024-11-04T21:00:00'),
        end: new Date('2024-11-04T22:00:00'),
      });

      expect(homeAssistantWSRequest).toHaveBeenCalledWith(
        hass,
        browseMediaSchema,
        expect.objectContaining({
          media_content_id:
            // Media source request will refer to 'main' not 'sub'.
            'media-source://reolink/RES|01J8XHYTNH77WE3C654K03KX1F|0|main',
        }),
      );
    });

    describe('should ignore malformed directories', () => {
      it('malformed directory title', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest)
          .mockResolvedValueOnce(TEST_CAMERAS)
          .mockResolvedValueOnce({
            title: 'Back Yard Low res.',
            media_class: 'channel',
            media_content_type: 'playlist',
            media_content_id:
              'media-source://reolink/DAYS|01J8XHYTNH77WE3C654K03KX1F|0|sub',
            children_media_class: 'directory',
            can_play: false,
            can_expand: true,
            thumbnail: null,
            children: [
              {
                // Malformed date.
                title: '__MALFORMED__',
                media_class: 'directory',
                media_content_type: 'playlist',
                media_content_id:
                  'media-source://reolink/DAY|01J8XHYTNH77WE3C654K03KX1F|0|sub|2024|11|4',
                children_media_class: null,
                can_play: false,
                can_expand: true,
                thumbnail: null,
              },
            ],
          });

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });
    });

    describe('should ignore invalid cameras', () => {
      it('camera without a config entry id', async () => {
        const entity = createRegistryEntity({
          entity_id: 'camera.office',
          unique_id: '85270002TS7D4RUP_0_main',
          platform: 'reolink',

          // Cannot fetch events without a config_entry_id.
          config_entry_id: null,
        });
        const entityRegistryManager = new EntityRegistryManagerMock([entity]);

        const engine = createEngine({ entityRegistryManager });
        const store = await createStoreWithReolinkCamera(engine);

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });

      it('should reject requests for non-reolink cameras', async () => {
        const engine = createPopulatedEngine();

        const store = new CameraManagerStore();
        store.addCamera(createCamera(createCameraConfig({ id: 'office' }), engine));

        const hass = createHASS();
        const events = await engine.getEvents(hass, store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });

      it('should ignore no cameras', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce({
          title: 'Reolink',
          media_class: 'channel',
          media_content_type: 'playlist',
          media_content_id: 'media-source://reolink',
          children_media_class: 'directory',
          can_play: false,
          can_expand: true,
          thumbnail: null,
          children: [
            // No cameras.
          ],
        });

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });

      it('should ignore malformed camera', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce({
          title: 'Reolink',
          media_class: 'channel',
          media_content_type: 'playlist',
          media_content_id: 'media-source://reolink',
          children_media_class: 'directory',
          can_play: false,
          can_expand: true,
          thumbnail: null,
          children: [
            {
              title: 'Back Yard',
              media_class: 'directory',
              media_content_type: 'playlist',
              media_content_id: 'media-source://reolink/__MALFORMED__',
              children_media_class: null,
              can_play: false,
              can_expand: true,
              thumbnail: null,
            },
          ],
        });

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });
    });

    describe('should ignore malformed media', () => {
      it('malformed file title', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest)
          .mockResolvedValueOnce(TEST_CAMERAS)
          .mockResolvedValueOnce(TEST_DIRECTORIES)
          .mockResolvedValueOnce({
            title: 'Back Yard Low res. 2024/11/4',
            media_class: 'channel',
            media_content_type: 'playlist',
            media_content_id:
              'media-source://reolink/FILES|01J8XHYTNH77WE3C654K03KX1F|0|sub',
            children_media_class: 'video',
            can_play: false,
            can_expand: true,
            thumbnail: null,
            children: [
              {
                // Title has invalid title (should be timestamp).
                title: 'AA:BB:CC',
                media_class: 'video',
                media_content_type: 'video',
                media_content_id:
                  'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
                children_media_class: null,
                can_play: true,
                can_expand: false,
                thumbnail: null,
              },
            ],
          });

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });

      it('malformed start time', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest)
          .mockResolvedValueOnce(TEST_CAMERAS)
          .mockResolvedValueOnce(TEST_DIRECTORIES)
          .mockResolvedValueOnce({
            title: 'Back Yard Low res. 2024/11/4',
            media_class: 'channel',
            media_content_type: 'playlist',
            media_content_id:
              'media-source://reolink/FILES|01J8XHYTNH77WE3C654K03KX1F|0|sub',
            children_media_class: 'video',
            can_play: false,
            can_expand: true,
            thumbnail: null,
            children: [
              {
                // Invalid hour.
                title: '29:23:53 0:00:34',
                media_class: 'video',
                media_content_type: 'video',
                media_content_id:
                  'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
                children_media_class: null,
                can_play: true,
                can_expand: false,
                thumbnail: null,
              },
            ],
          });

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });

      it('malformed duration', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest)
          .mockResolvedValueOnce(TEST_CAMERAS)
          .mockResolvedValueOnce(TEST_DIRECTORIES)
          .mockResolvedValueOnce({
            title: 'Back Yard Low res. 2024/11/4',
            media_class: 'channel',
            media_content_type: 'playlist',
            media_content_id:
              'media-source://reolink/FILES|01J8XHYTNH77WE3C654K03KX1F|0|sub',
            children_media_class: 'video',
            can_play: false,
            can_expand: true,
            thumbnail: null,
            children: [
              {
                // Invalid duration.
                title: '21:23:53 INVALID_DURATION',
                media_class: 'video',
                media_content_type: 'video',
                media_content_id:
                  'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
                children_media_class: null,
                can_play: true,
                can_expand: false,
                thumbnail: null,
              },
            ],
          });

        const events = await engine.getEvents(createHASS(), store, {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2024-11-04T21:00:00'),
          end: new Date('2024-11-04T22:00:00'),
        });

        expect(events).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                end: new Date('2024-11-04T22:00:00'),
                start: new Date('2024-11-04T21:00:00'),
                type: 'event-query',
              },
              {
                browseMedia: [
                  {
                    _metadata: {
                      cameraID: 'office',
                      // End time and start time will match.
                      endDate: new Date('2024-11-04T21:23:53'),
                      startDate: new Date('2024-11-04T21:23:53'),
                    },
                    can_expand: false,
                    can_play: true,
                    children_media_class: null,
                    media_class: 'video',
                    media_content_id:
                      'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
                    media_content_type: 'video',
                    thumbnail: null,
                    title: '21:23:53 INVALID_DURATION',
                  },
                ],
                engine: 'reolink',
                type: 'event-results',
              },
            ],
          ]),
        );
      });
    });
  });

  describe('should generate media from events', () => {
    it('should generate media successfully', () => {
      const query: EventQuery = {
        type: QueryType.Event,
        cameraIDs: new Set(['office']),
        start: new Date('2024-11-04T21:00:00'),
        end: new Date('2024-11-04T22:00:00'),
      };

      const results: ReolinkEventQueryResults = {
        browseMedia: [
          {
            _metadata: {
              cameraID: 'office',
              endDate: new Date('2024-11-04T22:00:00'),
              startDate: new Date('2024-11-04T21:00:00'),
            },
            can_expand: false,
            can_play: true,
            children_media_class: null,
            media_class: 'video',
            media_content_id:
              'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
            media_content_type: 'video',
            thumbnail: null,
            title: '21:23:53 1:00:00',
          },
        ],
        engine: Engine.Reolink,
        type: QueryResultsType.Event,
      };

      const store = new CameraManagerStore();
      const engine = createEngine();
      const media = engine.generateMediaFromEvents(createHASS(), store, query, results);
      expect(media?.length).toBe(1);
      expect(media?.[0].getCameraID()).toBe('office');
      expect(media?.[0].getStartTime()).toEqual(new Date('2024-11-04T21:00:00'));
      expect(media?.[0].getEndTime()).toEqual(new Date('2024-11-04T22:00:00'));
      expect(media?.[0].getVideoContentType()).toBe('mp4');
      expect(media?.[0].getID()).toBe('office/2024-11-04 21:00:00');
      expect(media?.[0].getContentID()).toBe(
        'media-source://reolink/FILE|01J8XHYTNH77WE3C654K03KX1F|0|sub|Rec_20241105_052353_211_S.mp4',
      );
      expect(media?.[0].getTitle()).toBe('2024-11-04 21:00');
    });

    it('should reject non-reolink results', () => {
      const query: EventQuery = {
        type: QueryType.Event,
        cameraIDs: new Set(['office']),
        start: new Date('2024-11-04T21:00:00'),
        end: new Date('2024-11-04T22:00:00'),
      };

      const results: QueryReturnType<EventQuery> = {
        engine: Engine.Frigate,
        type: QueryResultsType.Event,
      };

      const store = new CameraManagerStore();
      const engine = createEngine();
      const media = engine.generateMediaFromEvents(createHASS(), store, query, results);
      expect(media).toBeNull();
    });
  });

  describe('should get media metadata', () => {
    beforeAll(() => {
      vi.useFakeTimers();
      vi.setSystemTime(new Date('2024-11-17T15:06:00'));
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should get media metadata successfully', async () => {
      const engine = createPopulatedEngine();
      const store = await createStoreWithReolinkCamera(engine);

      vi.mocked(homeAssistantWSRequest)
        .mockResolvedValueOnce(TEST_CAMERAS)
        .mockResolvedValueOnce(TEST_DIRECTORIES);

      const metadata = await engine.getMediaMetadata(
        createHASS(),
        store,
        {
          type: QueryType.MediaMetadata,
          cameraIDs: new Set(['office']),
        },
        { useCache: false },
      );

      expect(metadata).toEqual(
        new Map([
          [
            {
              cameraIDs: new Set(['office']),
              type: 'media-metadata',
            },
            {
              cached: false,
              engine: 'reolink',
              expiry: new Date('2024-11-17T15:07:00'),
              metadata: {
                days: new Set(['2024-11-06', '2024-11-05', '2024-11-04']),
              },
              type: 'media-metadata-results',
            },
          ],
        ]),
      );
    });

    it('should cache media metadata', async () => {
      const engine = createPopulatedEngine();
      const store = await createStoreWithReolinkCamera(engine);

      vi.mocked(homeAssistantWSRequest)
        .mockResolvedValueOnce(TEST_CAMERAS)
        .mockResolvedValueOnce(TEST_DIRECTORIES);

      for (let i = 0; i < 10; i++) {
        await engine.getMediaMetadata(
          createHASS(),
          store,
          {
            type: QueryType.MediaMetadata,
            cameraIDs: new Set(['office']),
          },
          { useCache: true },
        );
      }

      expect(homeAssistantWSRequest).toHaveBeenCalledTimes(2);
    });

    describe('should ignore invalid cameras', () => {
      it('should get no metdata for camera without a config entry id', async () => {
        const entity = createRegistryEntity({
          entity_id: 'camera.office',
          unique_id: '85270002TS7D4RUP_0_main',
          platform: 'reolink',

          // Cannot fetch events without a config_entry_id.
          config_entry_id: null,
        });
        const entityRegistryManager = new EntityRegistryManagerMock([entity]);

        const engine = createEngine({ entityRegistryManager });
        const store = await createStoreWithReolinkCamera(engine);

        const metadata = await engine.getMediaMetadata(createHASS(), store, {
          type: QueryType.MediaMetadata,
          cameraIDs: new Set(['office']),
        });

        expect(metadata).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                type: 'media-metadata',
              },
              {
                cached: false,
                engine: 'reolink',
                expiry: new Date('2024-11-17T15:07:00'),
                metadata: {},
                type: 'media-metadata-results',
              },
            ],
          ]),
        );
      });

      it('should get no metdata for non-reolink camera', async () => {
        const engine = createPopulatedEngine();

        const store = new CameraManagerStore();
        store.addCamera(createCamera(createCameraConfig({ id: 'office' }), engine));

        const metadata = await engine.getMediaMetadata(createHASS(), store, {
          type: QueryType.MediaMetadata,
          cameraIDs: new Set(['office']),
        });

        expect(metadata).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                type: 'media-metadata',
              },
              {
                cached: false,
                engine: 'reolink',
                expiry: new Date('2024-11-17T15:07:00'),
                metadata: {},
                type: 'media-metadata-results',
              },
            ],
          ]),
        );
      });
    });

    describe('should ignore malformed directories', () => {
      it('malformed directory title', async () => {
        const engine = createPopulatedEngine();
        const store = await createStoreWithReolinkCamera(engine);

        vi.mocked(homeAssistantWSRequest)
          .mockResolvedValueOnce(TEST_CAMERAS)
          .mockResolvedValueOnce({
            title: 'Back Yard Low res.',
            media_class: 'channel',
            media_content_type: 'playlist',
            media_content_id:
              'media-source://reolink/DAYS|01J8XHYTNH77WE3C654K03KX1F|0|sub',
            children_media_class: 'directory',
            can_play: false,
            can_expand: true,
            thumbnail: null,
            children: [
              {
                // Malformed date.
                title: '__MALFORMED__',
                media_class: 'directory',
                media_content_type: 'playlist',
                media_content_id:
                  'media-source://reolink/DAY|01J8XHYTNH77WE3C654K03KX1F|0|sub|2024|11|4',
                children_media_class: null,
                can_play: false,
                can_expand: true,
                thumbnail: null,
              },
            ],
          });

        const metadata = await engine.getMediaMetadata(createHASS(), store, {
          type: QueryType.MediaMetadata,
          cameraIDs: new Set(['office']),
        });

        expect(metadata).toEqual(
          new Map([
            [
              {
                cameraIDs: new Set(['office']),
                type: 'media-metadata',
              },
              {
                cached: false,
                engine: 'reolink',
                expiry: new Date('2024-11-17T15:07:00'),
                metadata: {},
                type: 'media-metadata-results',
              },
            ],
          ]),
        );
      });
    });
  });
});



================================================
FILE: tests/camera-manager/utils/camera-entity-from-config.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getCameraEntityFromConfig } from '../../../src/camera-manager/utils/camera-entity-from-config.js';
import { CameraConfig, cameraConfigSchema } from '../../../src/config/schema/cameras.js';

describe('getCameraEntityFromConfig', () => {
  const createCameraConfig = (config: Partial<CameraConfig>): CameraConfig => {
    return cameraConfigSchema.parse(config);
  };

  it('should get camera_entity', () => {
    expect(getCameraEntityFromConfig(createCameraConfig({ camera_entity: 'foo' }))).toBe(
      'foo',
    );
  });
  it('should get camera_entity from webrtc_card config', () => {
    expect(
      getCameraEntityFromConfig(createCameraConfig({ webrtc_card: { entity: 'bar' } })),
    ).toBe('bar');
  });
  it('should get no camera_entity', () => {
    expect(getCameraEntityFromConfig(createCameraConfig({}))).toBeNull();
  });
});



================================================
FILE: tests/camera-manager/utils/cap-end-date.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { capEndDate } from '../../../src/camera-manager/utils/cap-end-date';

describe('capEndDate', () => {
  it('should cap end date', () => {
    const fakeNow = new Date('2023-04-29T14:25');
    vi.useFakeTimers();
    vi.setSystemTime(fakeNow);

    expect(capEndDate(new Date('2023-04-29T15:02'))).toEqual(fakeNow);

    vi.useRealTimers();
  });

  it('should not cap end date', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2023-04-29T14:25'));

    const testDate = new Date('2023-04-29T14:24');
    expect(capEndDate(testDate)).toEqual(testDate);

    vi.useRealTimers();
  });
});



================================================
FILE: tests/camera-manager/utils/go2rtc-endpoint.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getDefaultGo2RTCEndpoint } from '../../../src/camera-manager/utils/go2rtc-endpoint.js';
import { createCameraConfig } from '../../test-utils.js';

describe('getDefaultGo2RTCEndpoint', () => {
  it('with local configuration', () => {
    expect(
      getDefaultGo2RTCEndpoint(
        createCameraConfig({
          go2rtc: {
            stream: 'stream',
            url: '/local/path',
          },
        }),
      ),
    ).toEqual({
      endpoint: '/local/path/api/ws?src=stream',
      sign: true,
    });
  });

  it('with remote configuration', () => {
    expect(
      getDefaultGo2RTCEndpoint(
        createCameraConfig({
          go2rtc: {
            stream: 'stream',
            url: 'https://my-custom-go2rtc',
          },
        }),
      ),
    ).toEqual({
      endpoint: 'https://my-custom-go2rtc/api/ws?src=stream',
      sign: false,
    });
  });

  it('without configuration', () => {
    expect(getDefaultGo2RTCEndpoint(createCameraConfig())).toBeNull();
  });
});



================================================
FILE: tests/camera-manager/utils/ptz.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  getConfiguredPTZAction,
  getConfiguredPTZMovementType,
  getPTZCapabilitiesFromCameraConfig,
} from '../../../src/camera-manager/utils/ptz';
import { PTZAction } from '../../../src/config/ptz';
import { createCameraConfig } from '../../test-utils';

const action = {
  action: 'perform-action' as const,
  perform_action: 'action',
  data: {
    device: '048123',
    cmd: 'preset',
    preset: 'window',
  },
};

describe('getConfiguredPTZAction', () => {
  describe('should return preset', () => {
    it('with preset', () => {
      expect(
        getConfiguredPTZAction(
          createCameraConfig({
            ptz: {
              presets: {
                window: action,
              },
            },
          }),
          'preset',
          {
            preset: 'window',
          },
        ),
      ).toEqual(action);
    });

    it('without preset', () => {
      expect(
        getConfiguredPTZAction(
          createCameraConfig({
            ptz: {
              presets: {
                window: action,
              },
            },
          }),
          'preset',
        ),
      ).toBeNull();
    });
  });

  describe('should return continuous action', () => {
    it('with action', () => {
      expect(
        getConfiguredPTZAction(
          createCameraConfig({
            ptz: {
              actions_left_start: action,
            },
          }),
          'left',
          {
            phase: 'start',
          },
        ),
      ).toEqual(action);
    });

    it('without action', () => {
      expect(
        getConfiguredPTZAction(
          createCameraConfig({
            ptz: {},
          }),
          'left',
          {
            phase: 'start',
          },
        ),
      ).toBeNull();
    });
  });
});

describe('getConfiguredPTZMovementType', () => {
  it('with continuous', () => {
    expect(
      getConfiguredPTZMovementType(
        createCameraConfig({
          ptz: {
            actions_left_start: action,
            actions_left_stop: action,
          },
        }),
        'left',
      ),
    )?.toEqual(['continuous']);
  });

  it('with relative', () => {
    expect(
      getConfiguredPTZMovementType(
        createCameraConfig({
          ptz: {
            actions_left: action,
          },
        }),
        'left',
      ),
    )?.toEqual(['relative']);
  });

  it('with continuous and relative', () => {
    expect(
      getConfiguredPTZMovementType(
        createCameraConfig({
          ptz: {
            actions_left: action,
            actions_left_start: action,
            actions_left_stop: action,
          },
        }),
        'left',
      ),
    )?.toEqual(['continuous', 'relative']);
  });

  it('with no actions', () => {
    expect(
      getConfiguredPTZMovementType(
        createCameraConfig({
          ptz: {},
        }),
        'left',
      ),
    )?.toBeNull();
  });
});

describe('getPTZCapabilitiesFromCameraConfig', () => {
  it('with nothing', () => {
    expect(getPTZCapabilitiesFromCameraConfig(createCameraConfig()))?.toBeNull();
  });

  describe('with individual actions', () => {
    it.each([
      ['left' as const, 'left'],
      ['right' as const, 'right'],
      ['up' as const, 'up'],
      ['down' as const, 'down'],
      ['zoom_in' as const, 'zoomIn'],
      ['zoom_out' as const, 'zoomOut'],
    ])('%s', async (actionName: PTZAction, capabilityName: string) => {
      expect(
        getPTZCapabilitiesFromCameraConfig(
          createCameraConfig({
            ptz: {
              ['actions_' + actionName]: action,
            },
          }),
        ),
      )?.toEqual({
        [capabilityName]: ['relative'],
      });
    });
  });

  it('with preset', () => {
    expect(
      getPTZCapabilitiesFromCameraConfig(
        createCameraConfig({
          ptz: {
            presets: {
              window: action,
            },
          },
        }),
      ),
    )?.toEqual({
      presets: ['window'],
    });
  });
});



================================================
FILE: tests/camera-manager/utils/range-to-cache-friendly.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { convertRangeToCacheFriendlyTimes } from '../../../src/camera-manager/utils/range-to-cache-friendly';

describe('convertRangeToCacheFriendlyTimes', () => {
  it('should return cache friendly within hour range', () => {
    expect(
      convertRangeToCacheFriendlyTimes({
        start: new Date('2023-04-29T14:01:02'),
        end: new Date('2023-04-29T14:11:03'),
      }),
    ).toEqual({
      start: new Date('2023-04-29T14:00:00'),
      end: new Date('2023-04-29T14:59:59.999'),
    });
  });

  it('should return cache friendly within day range', () => {
    expect(
      convertRangeToCacheFriendlyTimes({
        start: new Date('2023-04-29T14:01:02'),
        end: new Date('2023-04-29T15:11:03'),
      }),
    ).toEqual({
      start: new Date('2023-04-29T00:00:00'),
      end: new Date('2023-04-29T23:59:59.999'),
    });
  });

  it('should cap end date', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2023-04-29T14:25'));
    expect(
      convertRangeToCacheFriendlyTimes(
        {
          start: new Date('2023-04-29T14:01:02'),
          end: new Date('2023-04-29T14:11:03'),
        },
        { endCap: true },
      ),
    ).toEqual({
      start: new Date('2023-04-29T14:00:00'),
      end: new Date('2023-04-29T14:25:59.999'),
    });
    vi.useRealTimers();
  });
});



================================================
FILE: tests/card-controller/automations-manager.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { ActionsExecutionRequest } from '../../src/card-controller/actions/types.js';
import { AutomationsManager } from '../../src/card-controller/automations-manager.js';
import { ConditionStateManager } from '../../src/conditions/state-manager.js';
import { createCardAPI } from '../test-utils.js';

describe('AutomationsManager', () => {
  const actions = [
    {
      action: 'fire-dom-event' as const,
      advanced_camera_card_action: 'clips',
    },
  ];
  const conditions = [{ condition: 'fullscreen' as const, fullscreen: true }];
  const automation = {
    conditions: conditions,
    actions: actions,
  };
  const not_automation = {
    conditions: conditions,
    actions_not: actions,
  };

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('should not execute actions', () => {
    it('should do nothing without hass', () => {
      const api = createCardAPI();
      const stateManager = new ConditionStateManager();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

      const automationsManager = new AutomationsManager(api);
      automationsManager.addAutomations([automation]);

      stateManager.setState({ fullscreen: true });

      expect(api.getActionsManager().executeActions).not.toBeCalled();
    });

    it('should do nothing without being initialized', () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().hasHASS).mockReturnValue(true);
      vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
        false,
      );
      const stateManager = new ConditionStateManager();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

      const automationsManager = new AutomationsManager(api);
      automationsManager.addAutomations([automation]);

      stateManager.setState({ fullscreen: true });

      expect(api.getActionsManager().executeActions).not.toBeCalled();
    });

    it('should do nothing with an error message present', () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().hasHASS).mockReturnValue(true);
      vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
        true,
      );
      vi.mocked(api.getMessageManager().hasErrorMessage).mockReturnValue(true);

      const stateManager = new ConditionStateManager();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

      const automationsManager = new AutomationsManager(api);
      automationsManager.addAutomations([automation]);

      stateManager.setState({ fullscreen: true });

      expect(api.getActionsManager().executeActions).not.toBeCalled();
    });
  });

  it('should execute actions', () => {
    const api = createCardAPI();
    vi.mocked(api.getHASSManager().hasHASS).mockReturnValue(true);
    vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
      true,
    );
    const stateManager = new ConditionStateManager();
    vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

    const automationsManager = new AutomationsManager(api);
    automationsManager.addAutomations([automation]);

    stateManager.setState({ fullscreen: true });

    expect(api.getActionsManager().executeActions).toBeCalledTimes(1);

    // Automation will not re-fire when condition continues to evaluate the
    // same.
    stateManager.setState({ fullscreen: true });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(1);

    stateManager.setState({ fullscreen: false });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(1);

    stateManager.setState({ fullscreen: true });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(2);
  });

  it('should execute actions_not', () => {
    const api = createCardAPI();
    vi.mocked(api.getHASSManager().hasHASS).mockReturnValue(true);
    vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
      true,
    );
    const stateManager = new ConditionStateManager();
    vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

    const automationsManager = new AutomationsManager(api);
    automationsManager.addAutomations([not_automation]);

    stateManager.setState({ fullscreen: true });
    expect(api.getActionsManager().executeActions).not.toBeCalled();

    stateManager.setState({ fullscreen: false });
    expect(api.getActionsManager().executeActions).toBeCalled();
  });

  it('should prevent automation loops', () => {
    const api = createCardAPI();
    vi.mocked(api.getHASSManager().hasHASS).mockReturnValue(true);
    vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
      true,
    );
    const stateManager = new ConditionStateManager();
    vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

    const automationsManager = new AutomationsManager(api);
    automationsManager.addAutomations([
      {
        conditions: [{ condition: 'fullscreen' as const, fullscreen: true }],
        actions: actions,
      },
      {
        conditions: [{ condition: 'fullscreen' as const, fullscreen: false }],
        actions_not: actions,
      },
    ]);

    // Create a setup where one automation action causes another...
    let fullscreen = true;

    vi.mocked(api.getActionsManager().executeActions).mockImplementation(
      async (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _request: ActionsExecutionRequest,
      ): Promise<void> => {
        fullscreen = !fullscreen;
        stateManager.setState({ fullscreen: fullscreen });
      },
    );

    stateManager.setState({ fullscreen: fullscreen });

    expect(api.getMessageManager().setMessageIfHigherPriority).toBeCalledWith(
      expect.objectContaining({
        type: 'error',
        message:
          'Too many nested automation calls, please check your configuration for loops',
      }),
    );

    expect(api.getActionsManager().executeActions).toBeCalledTimes(10);
  });

  it('should delete automations', () => {
    const api = createCardAPI();
    vi.mocked(api.getHASSManager().hasHASS).mockReturnValue(true);
    vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
      true,
    );
    const stateManager = new ConditionStateManager();
    vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

    const automationsManager = new AutomationsManager(api);
    automationsManager.addAutomations([
      {
        conditions: [{ condition: 'expand' as const, expand: true }],
        actions: actions,
      },
      {
        conditions: [{ condition: 'fullscreen' as const, fullscreen: true }],
        actions: actions,
        tag: 'fullscreen',
      },
    ]);

    stateManager.setState({ fullscreen: true });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(1);

    // Delete the fullscreen automation.
    automationsManager.deleteAutomations('fullscreen');

    stateManager.setState({ fullscreen: false });
    stateManager.setState({ fullscreen: true });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(1);

    stateManager.setState({ expand: true });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(2);

    // Delete all automations.
    automationsManager.deleteAutomations();

    stateManager.setState({ fullscreen: false });
    stateManager.setState({ fullscreen: true });
    expect(api.getActionsManager().executeActions).toBeCalledTimes(2);
  });
});



================================================
FILE: tests/card-controller/camera-url-manager.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { CameraURLManager } from '../../src/card-controller/camera-url-manager';
import { CardCameraURLAPI } from '../../src/card-controller/types';
import { Endpoint } from '../../src/types';
import { createCardAPI, createViewWithMedia } from '../test-utils';

const createAPIWithMedia = (): CardCameraURLAPI => {
  const api = createCardAPI();
  vi.mocked(api.getViewManager().getView).mockReturnValue(createViewWithMedia());
  return api;
};

// @vitest-environment jsdom
describe('CameraURLManager', () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  it('should get URL', () => {
    const api = createAPIWithMedia();
    const manager = new CameraURLManager(api);

    const endpoint: Endpoint = {
      endpoint: 'http://frigate',
    };

    vi.mocked(api.getCameraManager().getCameraEndpoints)?.mockReturnValue({
      ui: endpoint,
    });

    expect(manager.getCameraURL()).toBe('http://frigate');
    expect(manager.hasCameraURL()).toBeTruthy();

    const windowSpy = vi.spyOn(window, 'open').mockReturnValue(null);
    manager.openURL();
    expect(windowSpy).toBeCalledWith('http://frigate');
  });

  it('should not get URL without view', () => {
    const manager = new CameraURLManager(createCardAPI());
    expect(manager.getCameraURL()).toBeNull();

    const windowSpy = vi.spyOn(window, 'open').mockReturnValue(null);
    manager.openURL();
    expect(windowSpy).not.toBeCalled();
  });

  it('should not get URL without cameraManager endpoints', () => {
    const api = createAPIWithMedia();
    vi.mocked(api.getCameraManager().getCameraEndpoints)?.mockReturnValue(null);
    const manager = new CameraURLManager(api);
    expect(manager.getCameraURL()).toBeNull();
  });
});



================================================
FILE: tests/card-controller/card-element-manager.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CardElementManager } from '../../src/card-controller/card-element-manager';
import { StateWatcher } from '../../src/card-controller/hass/state-watcher';
import {
  callStateWatcherCallback,
  createCardAPI,
  createConfig,
  createLitElement,
  createStateEntity,
} from '../test-utils';

// @vitest-environment jsdom
describe('CardElementManager', () => {
  afterEach(() => {
    vi.unstubAllGlobals();
  });

  it('should get element', () => {
    const element = createLitElement();
    const manager = new CardElementManager(
      createCardAPI(),
      element,
      () => undefined,
      () => undefined,
    );

    expect(manager.getElement()).toBe(element);
  });

  it('should reset scroll', () => {
    const callback = vi.fn();
    const manager = new CardElementManager(
      createCardAPI(),
      createLitElement(),
      callback,
      () => undefined,
    );

    manager.scrollReset();

    expect(callback).toBeCalled();
  });

  it('should toggle menu', () => {
    const callback = vi.fn();
    const manager = new CardElementManager(
      createCardAPI(),
      createLitElement(),
      () => undefined,
      callback,
    );

    manager.toggleMenu();

    expect(callback).toBeCalled();
  });

  it('should update', () => {
    const element = createLitElement();
    const manager = new CardElementManager(
      createCardAPI(),
      element,
      () => undefined,
      () => undefined,
    );

    manager.update();
    expect(element.requestUpdate).toBeCalled();
  });

  it('should get hasUpdated', () => {
    const element = createLitElement();
    element.hasUpdated = true;
    const manager = new CardElementManager(
      createCardAPI(),
      element,
      () => undefined,
      () => undefined,
    );

    expect(manager.hasUpdated()).toBeTruthy();
  });

  it('should connect', () => {
    const windowAddEventListener = vi.spyOn(global.window, 'addEventListener');

    const addEventListener = vi.fn();
    const element = createLitElement();
    element.addEventListener = addEventListener;

    const api = createCardAPI();
    const manager = new CardElementManager(
      api,
      element,
      () => undefined,
      () => undefined,
    );

    manager.elementConnected();

    expect(element.getAttribute('panel')).toBeNull();
    expect(element.getAttribute('casted')).toBeNull();
    expect(api.getFullscreenManager().connect).toBeCalled();

    expect(addEventListener).toBeCalledWith(
      'mousemove',
      api.getInteractionManager().reportInteraction,
    );
    expect(addEventListener).toBeCalledWith(
      'll-custom',
      api.getActionsManager().handleCustomActionEvent,
    );
    expect(addEventListener).toBeCalledWith(
      'action',
      api.getActionsManager().handleInteractionEvent,
    );
    expect(addEventListener).toBeCalledWith(
      'action',
      api.getInteractionManager().reportInteraction,
    );
    expect(windowAddEventListener).toBeCalledWith('location-changed', expect.anything());
    expect(windowAddEventListener).toBeCalledWith('popstate', expect.anything());

    expect(api.getInteractionManager().initialize).toBeCalled();
    expect(api.getFullscreenManager().initialize).toBeCalled();
    expect(api.getExpandManager().initialize).toBeCalled();
    expect(api.getMediaLoadedInfoManager().initialize).toBeCalled();
    expect(api.getMicrophoneManager().initialize).toBeCalled();
  });

  it('should disconnect', () => {
    const windowRemoveEventListener = vi.spyOn(global.window, 'removeEventListener');

    const element = createLitElement();
    element.setAttribute('panel', '');
    element.setAttribute('casted', '');

    const removeEventListener = vi.fn();
    element.removeEventListener = removeEventListener;

    const api = createCardAPI();

    const manager = new CardElementManager(
      api,
      element,
      () => undefined,
      () => undefined,
    );

    manager.elementDisconnected();

    expect(element.getAttribute('panel')).toBeNull();
    expect(element.getAttribute('casted')).toBeNull();
    expect(api.getMediaLoadedInfoManager().clear).toBeCalled();
    expect(api.getFullscreenManager().disconnect).toBeCalled();

    expect(removeEventListener).toBeCalledWith(
      'mousemove',
      api.getInteractionManager().reportInteraction,
    );
    expect(removeEventListener).toBeCalledWith(
      'll-custom',
      api.getActionsManager().handleCustomActionEvent,
    );
    expect(removeEventListener).toBeCalledWith(
      'action',
      api.getActionsManager().handleInteractionEvent,
    );
    expect(removeEventListener).toBeCalledWith(
      'action',
      api.getInteractionManager().reportInteraction,
    );
    expect(windowRemoveEventListener).toBeCalledWith(
      'location-changed',
      expect.anything(),
    );
    expect(windowRemoveEventListener).toBeCalledWith('popstate', expect.anything());

    expect(api.getMediaLoadedInfoManager().clear).toBeCalled();
    expect(api.getFullscreenManager().disconnect).toBeCalled();
    expect(api.getKeyboardStateManager().uninitialize).toBeCalled();
    expect(api.getActionsManager().uninitialize).toBeCalled();
    expect(api.getInitializationManager().uninitialize).toBeCalledWith('cameras');
  });

  describe('should update card when', () => {
    it('render entity changes', () => {
      const api = createCardAPI();
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            render_entities: ['sensor.force_update'],
          },
        }),
      );

      const stateWatcher = mock<StateWatcher>();
      vi.mocked(api.getHASSManager().getStateWatcher).mockReturnValue(stateWatcher);

      const element = createLitElement();
      const manager = new CardElementManager(
        api,
        element,
        () => undefined,
        () => undefined,
      );

      manager.elementConnected();

      const diff = {
        entityID: 'sensor.force_update',
        newState: createStateEntity({ state: 'off' }),
      };
      callStateWatcherCallback(stateWatcher, diff);

      expect(element.requestUpdate).toBeCalled();
    });

    it('media player entity changes', () => {
      const api = createCardAPI();
      vi.mocked(api.getMediaPlayerManager().getMediaPlayers).mockReturnValue([
        'media_player.foo',
      ]);

      const stateWatcher = mock<StateWatcher>();
      vi.mocked(api.getHASSManager().getStateWatcher).mockReturnValue(stateWatcher);

      const element = createLitElement();
      const manager = new CardElementManager(
        api,
        element,
        () => undefined,
        () => undefined,
      );

      manager.elementConnected();

      const diff = {
        entityID: 'sensor.force_update',
        newState: createStateEntity({ state: 'off' }),
      };
      callStateWatcherCallback(stateWatcher, diff);

      expect(element.requestUpdate).toBeCalled();
    });
  });
});



================================================
FILE: tests/card-controller/controller.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { CameraManager } from '../../src/camera-manager/manager';
import { ActionsManager } from '../../src/card-controller/actions/actions-manager';
import { AutomationsManager } from '../../src/card-controller/automations-manager';
import { CameraURLManager } from '../../src/card-controller/camera-url-manager';
import {
  CardElementManager,
  CardHTMLElement,
} from '../../src/card-controller/card-element-manager';
import { ConfigManager } from '../../src/card-controller/config/config-manager';
import { CardController } from '../../src/card-controller/controller';
import { DefaultManager } from '../../src/card-controller/default-manager';
import { ExpandManager } from '../../src/card-controller/expand-manager';
import { FoldersManager } from '../../src/card-controller/folders/manager';
import { FullscreenManager } from '../../src/card-controller/fullscreen/fullscreen-manager';
import { HASSManager } from '../../src/card-controller/hass/hass-manager';
import { InitializationManager } from '../../src/card-controller/initialization-manager';
import { InteractionManager } from '../../src/card-controller/interaction-manager';
import { KeyboardStateManager } from '../../src/card-controller/keyboard-state-manager';
import { MediaLoadedInfoManager } from '../../src/card-controller/media-info-manager';
import { MediaPlayerManager } from '../../src/card-controller/media-player-manager';
import { MessageManager } from '../../src/card-controller/message-manager';
import { MicrophoneManager } from '../../src/card-controller/microphone-manager';
import { QueryStringManager } from '../../src/card-controller/query-string-manager';
import { StatusBarItemManager } from '../../src/card-controller/status-bar-item-manager';
import { StyleManager } from '../../src/card-controller/style-manager';
import { TriggersManager } from '../../src/card-controller/triggers-manager';
import { ViewItemManager } from '../../src/card-controller/view/item-manager';
import { ViewManager } from '../../src/card-controller/view/view-manager';
import { ConditionStateManager } from '../../src/conditions/state-manager';
import { AdvancedCameraCardEditor } from '../../src/editor';
import { DeviceRegistryManager } from '../../src/ha/registry/device';
import { EntityRegistryManagerLive } from '../../src/ha/registry/entity';
import { ResolvedMediaCache } from '../../src/ha/resolved-media';

vi.mock('../../src/camera-manager/manager');
vi.mock('../../src/card-controller/actions/actions-manager');
vi.mock('../../src/card-controller/automations-manager');
vi.mock('../../src/card-controller/camera-url-manager');
vi.mock('../../src/card-controller/card-element-manager');
vi.mock('../../src/card-controller/config/config-manager');
vi.mock('../../src/card-controller/default-manager');
vi.mock('../../src/card-controller/download-manager');
vi.mock('../../src/card-controller/expand-manager');
vi.mock('../../src/card-controller/folders/manager');
vi.mock('../../src/card-controller/fullscreen/fullscreen-manager');
vi.mock('../../src/card-controller/hass/hass-manager');
vi.mock('../../src/card-controller/initialization-manager');
vi.mock('../../src/card-controller/interaction-manager');
vi.mock('../../src/card-controller/keyboard-state-manager');
vi.mock('../../src/card-controller/media-info-manager');
vi.mock('../../src/card-controller/media-player-manager');
vi.mock('../../src/card-controller/message-manager');
vi.mock('../../src/card-controller/microphone-manager');
vi.mock('../../src/card-controller/query-string-manager');
vi.mock('../../src/card-controller/status-bar-item-manager');
vi.mock('../../src/card-controller/style-manager');
vi.mock('../../src/card-controller/triggers-manager');
vi.mock('../../src/card-controller/view/item-manager');
vi.mock('../../src/card-controller/view/view-manager');
vi.mock('../../src/conditions/state-manager');
vi.mock('../../src/ha/registry/device');
vi.mock('../../src/ha/registry/entity');
vi.mock('../../src/ha/resolved-media');

const createCardElement = (): CardHTMLElement => {
  const element = document.createElement('div') as unknown as CardHTMLElement;
  element.addController = vi.fn();
  return element;
};

const createController = (): CardController => {
  return new CardController(createCardElement(), vi.fn(), vi.fn());
};

// @vitest-environment jsdom
describe('CardController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should construct correctly', () => {
    const element = createCardElement();
    const scrollCallback = vi.fn();
    const menuToggleCallback = vi.fn();

    const manager = new CardController(element, scrollCallback, menuToggleCallback);

    expect(CardElementManager).toBeCalledWith(
      manager,
      element,
      scrollCallback,
      menuToggleCallback,
    );
  });

  describe('accessors', () => {
    it('getActionsManager', () => {
      expect(createController().getActionsManager()).toBe(
        vi.mocked(ActionsManager).mock.instances[0],
      );
    });

    it('getAutomationsManager', () => {
      expect(createController().getAutomationsManager()).toBe(
        vi.mocked(AutomationsManager).mock.instances[0],
      );
    });

    it('getDefaultManager', () => {
      expect(createController().getDefaultManager()).toBe(
        vi.mocked(DefaultManager).mock.instances[0],
      );
    });

    it('getCameraManager', () => {
      expect(createController().getCameraManager()).toBe(
        vi.mocked(CameraManager).mock.instances[0],
      );
    });

    it('getCameraURLManager', () => {
      expect(createController().getCameraURLManager()).toBe(
        vi.mocked(CameraURLManager).mock.instances[0],
      );
    });

    it('getCardElementManager', () => {
      expect(createController().getCardElementManager()).toBe(
        vi.mocked(CardElementManager).mock.instances[0],
      );
    });

    it('ConditionStateManager', () => {
      expect(createController().getConditionStateManager()).toBe(
        vi.mocked(ConditionStateManager).mock.instances[0],
      );
    });

    it('getConfigElement', async () => {
      expect(
        (await CardController.getConfigElement()) instanceof AdvancedCameraCardEditor,
      );
    });

    it('getConfigManager', () => {
      expect(createController().getConfigManager()).toBe(
        vi.mocked(ConfigManager).mock.instances[0],
      );
    });

    it('getDeviceRegistryManager', () => {
      expect(createController().getDeviceRegistryManager()).toBe(
        vi.mocked(DeviceRegistryManager).mock.instances[0],
      );
    });

    it('getEntityRegistryManager', () => {
      expect(createController().getEntityRegistryManager()).toBe(
        vi.mocked(EntityRegistryManagerLive).mock.instances[0],
      );
    });

    it('getExpandManager', () => {
      expect(createController().getExpandManager()).toBe(
        vi.mocked(ExpandManager).mock.instances[0],
      );
    });

    it('getFoldersManager', () => {
      expect(createController().getFoldersManager()).toBe(
        vi.mocked(FoldersManager).mock.instances[0],
      );
    });

    it('getFullscreenManager', () => {
      expect(createController().getFullscreenManager()).toBe(
        vi.mocked(FullscreenManager).mock.instances[0],
      );
    });

    it('getHASSManager', () => {
      expect(createController().getHASSManager()).toBe(
        vi.mocked(HASSManager).mock.instances[0],
      );
    });

    it('getInitializationManager', () => {
      expect(createController().getInitializationManager()).toBe(
        vi.mocked(InitializationManager).mock.instances[0],
      );
    });

    it('getInteractionManager', () => {
      expect(createController().getInteractionManager()).toBe(
        vi.mocked(InteractionManager).mock.instances[0],
      );
    });

    it('getKeyboardStateManager', () => {
      expect(createController().getKeyboardStateManager()).toBe(
        vi.mocked(KeyboardStateManager).mock.instances[0],
      );
    });

    it('getMediaLoadedInfoManager', () => {
      expect(createController().getMediaLoadedInfoManager()).toBe(
        vi.mocked(MediaLoadedInfoManager).mock.instances[0],
      );
    });

    it('getMediaPlayerManager', () => {
      expect(createController().getMediaPlayerManager()).toBe(
        vi.mocked(MediaPlayerManager).mock.instances[0],
      );
    });

    it('getMessageManager', () => {
      expect(createController().getMessageManager()).toBe(
        vi.mocked(MessageManager).mock.instances[0],
      );
    });

    it('getMicrophoneManager', () => {
      expect(createController().getMicrophoneManager()).toBe(
        vi.mocked(MicrophoneManager).mock.instances[0],
      );
    });

    it('getResolvedMediaCache', () => {
      expect(createController().getResolvedMediaCache()).toBe(
        vi.mocked(ResolvedMediaCache).mock.instances[0],
      );
    });

    describe('getStubConfig', () => {
      it('with camera entities', () => {
        expect(
          CardController.getStubConfig(['camera.office', 'binary_sensor.motion']),
        ).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
        });
      });

      it('without camera entities', () => {
        expect(CardController.getStubConfig(['binary_sensor.motion'])).toEqual({
          cameras: [{ camera_entity: 'camera.demo' }],
        });
      });
    });

    it('getQueryStringManager', () => {
      expect(createController().getQueryStringManager()).toBe(
        vi.mocked(QueryStringManager).mock.instances[0],
      );
    });

    it('getStatusBarItemManager', () => {
      expect(createController().getStatusBarItemManager()).toBe(
        vi.mocked(StatusBarItemManager).mock.instances[0],
      );
    });

    it('getStyleManager', () => {
      expect(createController().getStyleManager()).toBe(
        vi.mocked(StyleManager).mock.instances[0],
      );
    });

    it('getTriggersManager', () => {
      expect(createController().getTriggersManager()).toBe(
        vi.mocked(TriggersManager).mock.instances[0],
      );
    });

    it('getViewItemManager', () => {
      expect(createController().getViewItemManager()).toBe(
        vi.mocked(ViewItemManager).mock.instances[0],
      );
    });

    it('getViewManager', () => {
      expect(createController().getViewManager()).toBe(
        vi.mocked(ViewManager).mock.instances[0],
      );
    });
  });

  describe('creaters ', () => {
    it('createCameraManager', () => {
      const controller = createController();
      const original = controller.getCameraManager();

      controller.createCameraManager();

      expect(controller.getCameraManager()).not.toBe(original);
    });

    it('createMicrophoneManager', () => {
      const controller = createController();
      const original = controller.getMicrophoneManager();

      controller.createMicrophoneManager();

      expect(controller.getMicrophoneManager()).not.toBe(original);
    });
  });

  describe('handlers', () => {
    it('hostConnected', () => {
      createController().hostConnected();
      expect(
        vi.mocked(CardElementManager).mock.instances[0].elementConnected,
      ).toBeCalled();
    });

    it('hostDisconnected', () => {
      createController().hostDisconnected();
      expect(
        vi.mocked(CardElementManager).mock.instances[0].elementDisconnected,
      ).toBeCalled();
    });
  });
});



================================================
FILE: tests/card-controller/default-manager.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CardController } from '../../src/card-controller/controller';
import { DefaultManager } from '../../src/card-controller/default-manager';
import { StateWatcherSubscriptionInterface } from '../../src/card-controller/hass/state-watcher';
import {
  callStateWatcherCallback,
  createCardAPI,
  createConfig,
  createHASS,
  createStateEntity,
} from '../test-utils';

const createCardAPIWithStateWatcher = (): CardController => {
  const api = createCardAPI();
  vi.mocked(api.getHASSManager().getStateWatcher).mockReturnValue(
    mock<StateWatcherSubscriptionInterface>(),
  );
  return api;
};

// @vitest-environment jsdom
describe('DefaultManager', () => {
  afterEach(() => {
    vi.useRealTimers();
  });

  describe('time based', () => {
    it('should set default view when allowed', async () => {
      const api = createCardAPIWithStateWatcher();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            default_reset: {
              every_seconds: 10,
            },
          },
        }),
      );
      vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(true);

      vi.useFakeTimers();

      const manager = new DefaultManager(api);
      await manager.initialize();

      expect(api.getViewManager().setViewDefault).not.toBeCalled();

      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewDefault).not.toBeCalled();

      vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(false);
      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewDefault).toBeCalledTimes(1);

      manager.uninitialize();
      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewDefault).toBeCalledTimes(1);
    });

    it('should not set default view when not configured', () => {
      const api = createCardAPIWithStateWatcher();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            default_reset: {
              every_seconds: 0,
            },
          },
        }),
      );
      vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(false);

      vi.useFakeTimers();

      const manager = new DefaultManager(api);
      manager.initialize();

      expect(api.getViewManager().setViewDefault).not.toBeCalled();

      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewDefault).not.toBeCalled();
    });

    it('should restart timer when reconfigured', async () => {
      const api = createCardAPIWithStateWatcher();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            default_reset: {
              every_seconds: 10,
            },
          },
        }),
      );
      vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(false);

      vi.useFakeTimers();

      const manager = new DefaultManager(api);

      await manager.initialize();
      expect(api.getViewManager().setViewDefault).not.toBeCalled();

      await manager.initialize();
      expect(api.getViewManager().setViewDefault).not.toBeCalled();

      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewDefault).toBeCalled();
    });
  });

  it('should set default view when state changed', async () => {
    const api = createCardAPIWithStateWatcher();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        view: {
          default_reset: {
            entities: ['binary_sensor.foo'],
            every_seconds: 10,
          },
        },
      }),
    );
    vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(false);

    const hass = createHASS();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

    const manager = new DefaultManager(api);
    await manager.initialize();

    callStateWatcherCallback(api.getHASSManager().getStateWatcher(), {
      entityID: 'binary_sensor.foo',
      oldState: createStateEntity({ state: 'off' }),
      newState: createStateEntity({ state: 'on' }),
    });

    expect(api.getViewManager().setViewDefault).toBeCalled();
  });

  describe('interaction based', () => {
    it('should not register automation on initialization', async () => {
      const api = createCardAPIWithStateWatcher();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            default_reset: {
              after_interaction: false,
            },
          },
        }),
      );

      const manager = new DefaultManager(api);
      await manager.initialize();

      expect(api.getAutomationsManager().addAutomations).not.toBeCalled();
    });

    it('should register automation on initialization', async () => {
      const api = createCardAPIWithStateWatcher();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            default_reset: {
              after_interaction: true,
            },
          },
        }),
      );

      const manager = new DefaultManager(api);
      await manager.initialize();

      expect(api.getAutomationsManager().addAutomations).toBeCalledWith([
        {
          actions: [
            {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'default',
            },
          ],
          conditions: [
            {
              condition: 'interaction',
              interaction: false,
            },
          ],
          tag: expect.anything(),
        },
      ]);
    });

    it('should remove automation on uninitalize', () => {
      const api = createCardAPIWithStateWatcher();
      const manager = new DefaultManager(api);
      manager.uninitialize();

      expect(api.getAutomationsManager().deleteAutomations).toBeCalledWith(manager);
    });
  });

  it('should reinitialize when there is a config change', async () => {
    const configOn = createConfig({
      view: {
        default_reset: {
          every_seconds: 10,
        },
      },
    });
    const configOff = createConfig({
      view: {
        default_reset: {
          every_seconds: 0,
        },
      },
    });

    const api = createCardAPIWithStateWatcher();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
    vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(false);

    vi.useFakeTimers();

    const manager = new DefaultManager(api);

    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(configOn);
    await manager.initializeIfNecessary(null);

    vi.runOnlyPendingTimers();
    expect(api.getViewManager().setViewDefault).toBeCalledTimes(1);

    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(configOff);
    await manager.initializeIfNecessary(configOn);

    vi.runOnlyPendingTimers();
    expect(api.getViewManager().setViewDefault).toBeCalledTimes(1);

    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(configOff);
    await manager.initializeIfNecessary(configOff);

    vi.runOnlyPendingTimers();
    expect(api.getViewManager().setViewDefault).toBeCalledTimes(1);
  });
});



================================================
FILE: tests/card-controller/expand-manager.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { ExpandManager } from '../../src/card-controller/expand-manager';
import { createCardAPI } from '../test-utils';

describe('ExpandManager', () => {
  it('should construct', () => {
    const api = createCardAPI();
    const manager = new ExpandManager(api);
    expect(manager.isExpanded()).toBeFalsy();
  });

  it('should initialize', () => {
    const api = createCardAPI();
    const manager = new ExpandManager(api);

    manager.initialize();
    expect(api.getConditionStateManager().setState).toBeCalledWith({ expand: false });
  });

  it('should set expanded', () => {
    const api = createCardAPI();
    vi.mocked(api.getFullscreenManager().isInFullscreen).mockReturnValue(true);
    const manager = new ExpandManager(api);

    manager.setExpanded(true);

    expect(manager.isExpanded()).toBeTruthy();
    expect(api.getFullscreenManager().setFullscreen).toBeCalledWith(false);
    expect(api.getConditionStateManager().setState).toBeCalledWith({ expand: true });
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should not exit fullscreen when not in fullscreen', () => {
    const api = createCardAPI();
    vi.mocked(api.getFullscreenManager().isInFullscreen).mockReturnValue(false);
    const manager = new ExpandManager(api);

    manager.setExpanded(true);

    expect(api.getFullscreenManager().setFullscreen).not.toBeCalled();
  });

  it('should toggle expanded', () => {
    const api = createCardAPI();
    vi.mocked(api.getFullscreenManager().isInFullscreen).mockReturnValue(false);
    const manager = new ExpandManager(api);

    manager.toggleExpanded();
    expect(manager.isExpanded()).toBeTruthy();

    manager.toggleExpanded();
    expect(manager.isExpanded()).toBeFalsy();
  });
});



================================================
FILE: tests/card-controller/initialization-manager.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import {
  InitializationAspect,
  InitializationManager,
} from '../../src/card-controller/initialization-manager';
import { ConditionStateManager } from '../../src/conditions/state-manager';
import { sideLoadHomeAssistantElements } from '../../src/ha/side-load-ha-elements.js';
import { loadLanguages } from '../../src/localize/localize';
import { Initializer } from '../../src/utils/initializer/initializer';
import { createCardAPI, createConfig, createHASS } from '../test-utils';

vi.mock('../../src/localize/localize.js');
vi.mock('../../src/ha/side-load-ha-elements.js');

// @vitest-environment jsdom
describe('InitializationManager', () => {
  beforeEach(async () => {
    vi.resetAllMocks();
  });

  describe('should correctly determine when mandatory initialization is required', () => {
    it('without config', () => {
      const api = createCardAPI();
      const manager = new InitializationManager(api);

      expect(manager.isInitializedMandatory()).toBeFalsy();
    });

    it('without aspects', () => {
      const api = createCardAPI();
      const manager = new InitializationManager(api);

      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

      expect(manager.isInitializedMandatory()).toBeFalsy();
    });

    it('with microphone if configured', () => {
      const api = createCardAPI();
      const manager = new InitializationManager(api);

      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(
        api.getMicrophoneManager().shouldConnectOnInitialization,
      ).mockReturnValue(true);

      expect(manager.isInitializedMandatory()).toBeFalsy();
    });
  });

  describe('should initialize mandatory', () => {
    it('without hass', async () => {
      const manager = new InitializationManager(createCardAPI());
      await manager.initializeMandatory();
      expect(manager.wasEverInitialized()).toBeFalsy();
    });

    it('without config', async () => {
      const api = createCardAPI();
      const manager = new InitializationManager(api);
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(loadLanguages).mockResolvedValue(true);
      vi.mocked(sideLoadHomeAssistantElements).mockResolvedValue(true);

      await manager.initializeMandatory();
      expect(manager.wasEverInitialized()).toBeFalsy();
    });

    it('successfully', async () => {
      const stateListener = vi.fn();
      const stateMananger = new ConditionStateManager();
      stateMananger.addListener(stateListener);

      const api = createCardAPI();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateMananger);
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      const config = createConfig();
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(config);
      vi.mocked(api.getMessageManager().hasMessage).mockReturnValue(false);
      vi.mocked(api.getQueryStringManager().hasViewRelatedActionsToRun).mockReturnValue(
        false,
      );
      vi.mocked(loadLanguages).mockResolvedValue(true);
      vi.mocked(sideLoadHomeAssistantElements).mockResolvedValue(true);
      vi.mocked(api.getCameraManager().initializeCamerasFromConfig).mockResolvedValue(
        true,
      );
      vi.mocked(api.getViewManager().initialize).mockResolvedValue(true);

      const manager = new InitializationManager(api);

      expect(manager.isInitialized(InitializationAspect.LANGUAGES)).toBeFalsy();
      expect(manager.isInitialized(InitializationAspect.SIDE_LOAD_ELEMENTS)).toBeFalsy();
      expect(manager.isInitialized(InitializationAspect.CAMERAS)).toBeFalsy();
      expect(manager.isInitialized(InitializationAspect.MICROPHONE_CONNECT)).toBeFalsy();
      expect(manager.isInitialized(InitializationAspect.VIEW)).toBeFalsy();

      await manager.initializeMandatory();

      expect(loadLanguages).toBeCalled();
      expect(sideLoadHomeAssistantElements).toBeCalled();
      expect(api.getCameraManager().initializeCamerasFromConfig).toBeCalled();
      expect(api.getViewManager().initialize).toBeCalled();
      expect(api.getMicrophoneManager().connect).not.toBeCalled();
      expect(api.getCardElementManager().update).toBeCalled();

      expect(manager.wasEverInitialized()).toBeTruthy();

      expect(stateListener).toBeCalledWith(
        expect.objectContaining({
          change: {
            initialized: true,
            config,
          },
        }),
      );

      expect(manager.isInitialized(InitializationAspect.LANGUAGES)).toBeTruthy();
      expect(
        manager.isInitialized(InitializationAspect.SIDE_LOAD_ELEMENTS),
      ).toBeTruthy();
      expect(manager.isInitialized(InitializationAspect.CAMERAS)).toBeTruthy();
      expect(manager.isInitialized(InitializationAspect.MICROPHONE_CONNECT)).toBeFalsy();
      expect(manager.isInitialized(InitializationAspect.VIEW)).toBeTruthy();
      expect(manager.isInitialized(InitializationAspect.INITIAL_TRIGGER)).toBeTruthy();
    });

    it('successfully with microphone if configured', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(
        api.getMicrophoneManager().shouldConnectOnInitialization,
      ).mockReturnValue(true);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(loadLanguages).mockResolvedValue(true);
      vi.mocked(sideLoadHomeAssistantElements).mockResolvedValue(true);
      vi.mocked(api.getCameraManager().initializeCamerasFromConfig).mockResolvedValue(
        true,
      );

      const manager = new InitializationManager(api);

      await manager.initializeMandatory();

      expect(api.getMicrophoneManager().connect).toBeCalled();
    });

    it('with message set during initialization', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(api.getMessageManager().hasMessage).mockReturnValue(true);
      vi.mocked(api.getQueryStringManager().hasViewRelatedActionsToRun).mockReturnValue(
        false,
      );
      vi.mocked(loadLanguages).mockResolvedValue(true);
      vi.mocked(sideLoadHomeAssistantElements).mockResolvedValue(true);
      vi.mocked(api.getCameraManager().initializeCamerasFromConfig).mockResolvedValue(
        true,
      );

      const manager = new InitializationManager(api);

      await manager.initializeMandatory();

      expect(api.getViewManager().initialize).not.toBeCalled();
    });

    it('with languages and side load elements in progress', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      const initializer = mock<Initializer>();
      const manager = new InitializationManager(api, initializer);
      initializer.initializeMultipleIfNecessary.mockResolvedValue(false);

      await manager.initializeMandatory();

      expect(manager.wasEverInitialized()).toBeFalsy();
    });

    it('with cameras in progress', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

      const initializer = mock<Initializer>();
      const manager = new InitializationManager(api, initializer);
      initializer.initializeMultipleIfNecessary
        .mockResolvedValueOnce(true)
        .mockResolvedValueOnce(false);

      await manager.initializeMandatory();

      expect(manager.wasEverInitialized()).toBeFalsy();
    });

    it('with triggers in progress', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

      const initializer = mock<Initializer>();
      const manager = new InitializationManager(api, initializer);
      initializer.initializeMultipleIfNecessary
        .mockResolvedValueOnce(true)
        .mockResolvedValueOnce(true);
      initializer.initializeIfNecessary
        .mockResolvedValueOnce(true)
        .mockResolvedValueOnce(false);

      await manager.initializeMandatory();

      expect(manager.wasEverInitialized()).toBeFalsy();
    });
  });

  it('should uninitialize', () => {
    const initializer = mock<Initializer>();
    const manager = new InitializationManager(createCardAPI(), initializer);

    manager.uninitialize(InitializationAspect.CAMERAS);

    expect(initializer.uninitialize).toBeCalledWith(InitializationAspect.CAMERAS);
  });
});



================================================
FILE: tests/card-controller/interaction-manager.test.ts
================================================
import { add } from 'date-fns';
import { afterEach, describe, expect, it, vi } from 'vitest';
import { InteractionManager } from '../../src/card-controller/interaction-manager';
import { createCardAPI, createConfig, createLitElement } from '../test-utils';

vi.mock('lodash-es', () => ({
  throttle: vi.fn((fn) => fn),
}));

// @vitest-environment jsdom
describe('InteractionManager', () => {
  const start = new Date('2023-09-24T20:20:00');

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should initialize', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

    const manager = new InteractionManager(api);

    manager.initialize();
    expect(api.getConditionStateManager().setState).toBeCalledWith({
      interaction: false,
    });
    expect(element.getAttribute('interaction')).toBeNull();
  });

  it('should still report interaction without an interaction timeout', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        view: {
          interaction_seconds: 0,
        },
      }),
    );
    const manager = new InteractionManager(api);

    manager.reportInteraction();

    expect(element.getAttribute('interaction')).not.toBeNull();
    expect(manager.hasInteraction()).toBeTruthy();
  });

  it('should set condition state', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        view: {
          interaction_seconds: 10,
        },
      }),
    );
    const manager = new InteractionManager(api);
    vi.useFakeTimers();
    vi.setSystemTime(start);

    expect(api.getConditionStateManager().setState).not.toBeCalled();

    manager.reportInteraction();

    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith(
      expect.objectContaining({
        interaction: true,
      }),
    );
    expect(manager.hasInteraction()).toBeTruthy();
    expect(element.getAttribute('interaction')).not.toBeNull();

    vi.setSystemTime(add(start, { seconds: 10 }));
    vi.runOnlyPendingTimers();

    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith(
      expect.objectContaining({
        interaction: false,
      }),
    );
    expect(manager.hasInteraction()).toBeFalsy();
    expect(element.getAttribute('interaction')).toBeNull();
  });
});



================================================
FILE: tests/card-controller/keyboard-state-manager.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { KeyboardStateManager } from '../../src/card-controller/keyboard-state-manager';
import { createCardAPI, createLitElement } from '../test-utils';

// @vitest-environment jsdom
describe('KeyboardStateManager', () => {
  it('should construct', () => {
    expect(new KeyboardStateManager(createCardAPI())).toBeTruthy();
  });

  it('should set state on keydown', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
    const manager = new KeyboardStateManager(api);
    manager.initialize();

    element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));

    expect(api.getConditionStateManager().setState).toHaveBeenCalledWith({
      keys: {
        a: { state: 'down', ctrl: false, alt: false, meta: false, shift: false },
      },
    });

    element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));

    // Duplicate keydown should not re-set the state.
    expect(api.getConditionStateManager().setState).toBeCalledTimes(1);
  });

  it('should set state on keyup', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
    const manager = new KeyboardStateManager(api);
    manager.initialize();

    element.dispatchEvent(new KeyboardEvent('keyup', { key: 'a' }));

    // Key not held down in the first place should not update the state.
    expect(api.getConditionStateManager().setState).not.toBeCalled();

    element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));
    element.dispatchEvent(new KeyboardEvent('keyup', { key: 'a' }));

    expect(api.getConditionStateManager().setState).toBeCalledTimes(2);
    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith({
      keys: {
        a: { state: 'up', ctrl: false, alt: false, meta: false, shift: false },
      },
    });
  });

  it('should set state on focus loss', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
    const manager = new KeyboardStateManager(api);
    manager.initialize();

    element.dispatchEvent(new FocusEvent('blur'));
    expect(api.getConditionStateManager().setState).not.toBeCalled();

    element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));
    element.dispatchEvent(new FocusEvent('blur'));

    expect(api.getConditionStateManager().setState).toBeCalledTimes(2);
    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith({
      keys: {},
    });
  });

  it('should not act after uninitialization', () => {
    const api = createCardAPI();
    const element = createLitElement();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
    const manager = new KeyboardStateManager(api);
    manager.initialize();
    manager.uninitialize();

    element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));

    expect(api.getConditionStateManager().setState).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/media-info-manager.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { MediaLoadedInfoManager } from '../../src/card-controller/media-info-manager';
import { createCardAPI, createMediaLoadedInfo } from '../test-utils.js';

describe('MediaLoadedInfoManager', () => {
  it('should initialize', () => {
    const api = createCardAPI();
    const manager = new MediaLoadedInfoManager(api);

    manager.initialize();
    expect(api.getConditionStateManager().setState).toBeCalledWith({
      mediaLoadedInfo: null,
    });
  });

  it('should set', () => {
    const api = createCardAPI();
    const manager = new MediaLoadedInfoManager(api);
    const mediaInfo = createMediaLoadedInfo();

    manager.set(mediaInfo);

    expect(manager.has()).toBeTruthy();
    expect(manager.get()).toBe(mediaInfo);
    expect(api.getConditionStateManager().setState).toBeCalledWith(
      expect.objectContaining({ mediaLoadedInfo: mediaInfo }),
    );
    expect(api.getStyleManager().setExpandedMode).toBeCalled();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should not set invalid media info', () => {
    const api = createCardAPI();
    const manager = new MediaLoadedInfoManager(api);
    const mediaLoadedInfo = createMediaLoadedInfo({ width: 0, height: 0 });

    manager.set(mediaLoadedInfo);

    expect(manager.has()).toBeFalsy();
    expect(manager.get()).toBeNull();
    expect(api.getConditionStateManager().setState).not.toBeCalled();
  });

  it('should get last known', () => {
    const api = createCardAPI();
    const manager = new MediaLoadedInfoManager(api);
    const mediaLoadedInfo = createMediaLoadedInfo();

    manager.set(mediaLoadedInfo);

    expect(manager.has()).toBeTruthy();

    manager.clear();

    expect(manager.has()).toBeFalsy();
    expect(manager.getLastKnown()).toBe(mediaLoadedInfo);
    expect(api.getConditionStateManager().setState).toBeCalledWith(
      expect.objectContaining({ mediaLoadedInfo }),
    );
  });
});



================================================
FILE: tests/card-controller/media-player-manager.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { MediaPlayerManager } from '../../src/card-controller/media-player-manager.js';
import {
  MEDIA_PLAYER_SUPPORT_BROWSE_MEDIA,
  MEDIA_PLAYER_SUPPORT_STOP,
  MEDIA_PLAYER_SUPPORT_TURN_OFF,
} from '../../src/const';
import { EntityRegistryManager } from '../../src/ha/registry/entity/types.js';
import { HomeAssistant } from '../../src/ha/types.js';
import { ViewMediaType } from '../../src/view/item.js';
import { EntityRegistryManagerMock } from '../ha/registry/entity/mock.js';
import {
  createCameraConfig,
  createCameraManager,
  createCardAPI,
  createConfig,
  createHASS,
  createRegistryEntity,
  createStateEntity,
  createStore,
  TestViewMedia,
} from '../test-utils.js';

const createHASSWithMediaPlayers = (): HomeAssistant => {
  const attributesSupported = {
    supported_features: MEDIA_PLAYER_SUPPORT_BROWSE_MEDIA,
  };
  const attributesUnsupported = {
    supported_features: 0,
  };

  return createHASS({
    'media_player.ok1': createStateEntity({
      entity_id: 'media_player.ok1',
      state: 'on',
      attributes: attributesSupported,
    }),
    'media_player.ok2': createStateEntity({
      entity_id: 'media_player.ok2',
      state: 'on',
      attributes: attributesSupported,
    }),
    'media_player.ok3': createStateEntity({
      entity_id: 'media_player.ok3',
      state: 'on',
      attributes: attributesSupported,
    }),
    'media_player.unavailable': createStateEntity({
      entity_id: 'media_player.sitting_room',
      state: 'unavailable',
      attributes: attributesSupported,
    }),
    'media_player.unsupported': createStateEntity({
      entity_id: 'media_player.sitting_room',
      state: 'on',
      attributes: attributesUnsupported,
    }),
    'switch.unrelated': createStateEntity({
      entity_id: 'switch.unrelated',
      state: 'on',
    }),
  });
};

describe('MediaPlayerManager', () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  describe('should initialize', () => {
    it('correctly', async () => {
      const entityRegistryManager = new EntityRegistryManagerMock([
        createRegistryEntity({
          entity_id: 'media_player.ok1',
          hidden_by: '',
        }),
        createRegistryEntity({
          entity_id: 'media_player.ok2',
          hidden_by: 'user',
        }),
      ]);

      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
        createHASSWithMediaPlayers(),
      );
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          menu: {
            buttons: {
              media_player: {
                enabled: true,
              },
            },
          },
        }),
      );
      vi.mocked(api.getEntityRegistryManager).mockReturnValue(entityRegistryManager);
      const manager = new MediaPlayerManager(api);

      await manager.initialize();

      expect(manager.getMediaPlayers()).toEqual([
        'media_player.ok1',
        'media_player.ok3',
      ]);
      expect(manager.hasMediaPlayers()).toBeTruthy();
    });

    it('without hass', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(null);
      const manager = new MediaPlayerManager(api);

      await manager.initialize();

      expect(manager.getMediaPlayers()).toEqual([]);
      expect(manager.hasMediaPlayers()).toBeFalsy();
    });

    it('even if entity registry call fails', async () => {
      const spy = vi.spyOn(global.console, 'warn').mockImplementation(() => true);

      const entityRegistryManager = mock<EntityRegistryManager>();
      entityRegistryManager.getEntities.mockRejectedValue(new Error('message'));

      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
        createHASSWithMediaPlayers(),
      );
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          menu: {
            buttons: {
              media_player: {
                enabled: true,
              },
            },
          },
        }),
      );
      vi.mocked(api.getEntityRegistryManager).mockReturnValue(entityRegistryManager);
      const manager = new MediaPlayerManager(api);

      await manager.initialize();

      expect(manager.getMediaPlayers()).toEqual([
        'media_player.ok1',
        'media_player.ok2',
        'media_player.ok3',
      ]);
      expect(manager.hasMediaPlayers()).toBeTruthy();
      expect(spy).toBeCalled();
    });

    it('should reinitialize when there is a config change', async () => {
      const entityRegistryManager = new EntityRegistryManagerMock([
        createRegistryEntity({
          entity_id: 'media_player.ok1',
          hidden_by: '',
        }),
        createRegistryEntity({
          entity_id: 'media_player.ok2',
          hidden_by: 'user',
        }),
      ]);

      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
        createHASSWithMediaPlayers(),
      );
      const config = createConfig({
        menu: {
          buttons: {
            media_player: {
              enabled: true,
            },
          },
        },
      });
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(config);
      vi.mocked(api.getEntityRegistryManager).mockReturnValue(entityRegistryManager);
      const manager = new MediaPlayerManager(api);

      await manager.initializeIfNecessary(null);
      expect(manager.hasMediaPlayers()).toBeTruthy();

      await manager.initializeIfNecessary(config);
      expect(manager.hasMediaPlayers()).toBeTruthy();
    });
  });

  describe('should stop', () => {
    it('should call media_stop when device supports it', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
        createHASS({
          'media_player.foo': createStateEntity({
            entity_id: 'media_player.foo',
            attributes: {
              supported_features: MEDIA_PLAYER_SUPPORT_STOP,
            },
          }),
        }),
      );

      const manager = new MediaPlayerManager(api);

      await manager.stop('media_player.foo');

      expect(api.getHASSManager().getHASS()?.callService).toBeCalledWith(
        'media_player',
        'media_stop',
        {
          entity_id: 'media_player.foo',
        },
      );
    });

    it('should call turn_off when device does supports it', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
        createHASS({
          'media_player.foo': createStateEntity({
            entity_id: 'media_player.foo',
            attributes: {
              supported_features: MEDIA_PLAYER_SUPPORT_TURN_OFF,
            },
          }),
        }),
      );

      const manager = new MediaPlayerManager(api);

      await manager.stop('media_player.foo');

      expect(api.getHASSManager().getHASS()?.callService).toBeCalledWith(
        'media_player',
        'turn_off',
        {
          entity_id: 'media_player.foo',
        },
      );
    });

    it('should do nothing without some supported feature', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
        createHASS({
          'media_player.foo': createStateEntity({
            entity_id: 'media_player.foo',
          }),
        }),
      );
      const manager = new MediaPlayerManager(api);

      await manager.stop('media_player.foo');

      expect(api.getHASSManager().getHASS()?.callService).not.toBeCalled();
    });

    it('should do nothing without hass state', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
      const manager = new MediaPlayerManager(api);

      await manager.stop('media_player.foo');

      expect(api.getHASSManager().getHASS()?.callService).not.toBeCalled();
    });
  });

  describe('should play', () => {
    describe('live', () => {
      it('without camera config', async () => {
        const api = createCardAPI();
        vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
        const manager = new MediaPlayerManager(api);

        await manager.playLive('media_player.foo', 'camera');

        expect(api.getHASSManager().getHASS()?.callService).not.toBeCalled();
      });

      describe('using standard method', () => {
        it('successfully', async () => {
          const api = createCardAPI();
          vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
          vi.mocked(api.getCameraManager().getStore).mockReturnValue(
            createStore([
              {
                cameraID: 'camera.foo',
                config: createCameraConfig({
                  camera_entity: 'camera.foo',
                }),
              },
            ]),
          );
          vi.mocked(api.getCameraManager().getCameraMetadata).mockReturnValue({
            title: 'camera title',
            icon: { icon: 'icon' },
          });
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(
            createHASS({
              'camera.foo': createStateEntity({
                attributes: {
                  entity_picture: 'http://thumbnail',
                },
              }),
            }),
          );
          const manager = new MediaPlayerManager(api);

          await manager.playLive('media_player.foo', 'camera.foo');

          expect(api.getHASSManager().getHASS()?.callService).toBeCalledWith(
            'media_player',
            'play_media',
            {
              entity_id: 'media_player.foo',
              media_content_id: 'media-source://camera/camera.foo',
              media_content_type: 'application/vnd.apple.mpegurl',
              extra: {
                title: 'camera title',
                thumb: 'http://thumbnail',
              },
            },
          );
        });

        it('without camera_entity', async () => {
          const api = createCardAPI();
          vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());

          vi.mocked(api.getCameraManager().getStore).mockReturnValue(
            createStore([
              {
                cameraID: 'camera.foo',
                config: createCameraConfig(),
              },
            ]),
          );
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
          const manager = new MediaPlayerManager(api);

          await manager.playLive('media_player.foo', 'camera.foo');

          expect(api.getHASSManager().getHASS()?.callService).not.toBeCalled();
        });

        it('without title and thumbnail', async () => {
          const api = createCardAPI();
          vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
          vi.mocked(api.getCameraManager().getStore).mockReturnValue(
            createStore([
              {
                cameraID: 'camera.foo',
                config: createCameraConfig({
                  camera_entity: 'camera.foo',
                }),
              },
            ]),
          );
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
          const manager = new MediaPlayerManager(api);

          await manager.playLive('media_player.foo', 'camera.foo');

          expect(api.getHASSManager().getHASS()?.callService).toBeCalledWith(
            'media_player',
            'play_media',
            {
              entity_id: 'media_player.foo',
              media_content_id: 'media-source://camera/camera.foo',
              media_content_type: 'application/vnd.apple.mpegurl',
              extra: {},
            },
          );
        });
      });

      describe('using dashboard method', () => {
        it('successfully', async () => {
          const api = createCardAPI();
          vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
          vi.mocked(api.getCameraManager().getStore).mockReturnValue(
            createStore([
              {
                cameraID: 'camera.foo',
                config: createCameraConfig({
                  camera_entity: 'camera.foo',
                  cast: {
                    method: 'dashboard',
                    dashboard: {
                      dashboard_path: 'dashboard_path',
                      view_path: 'view_path',
                    },
                  },
                }),
              },
            ]),
          );
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
          const manager = new MediaPlayerManager(api);

          await manager.playLive('media_player.foo', 'camera.foo');

          expect(api.getHASSManager().getHASS()?.callService).toBeCalledWith(
            'cast',
            'show_lovelace_view',
            {
              entity_id: 'media_player.foo',
              dashboard_path: 'dashboard_path',
              view_path: 'view_path',
            },
          );
        });

        it('without hass', async () => {
          const api = createCardAPI();
          vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
          vi.mocked(api.getCameraManager().getStore).mockReturnValue(
            createStore([
              {
                cameraID: 'camera.foo',
                config: createCameraConfig({
                  camera_entity: 'camera.foo',
                  cast: {
                    method: 'dashboard',
                    dashboard: {
                      dashboard_path: 'dashboard_path',
                      view_path: 'view_path',
                    },
                  },
                }),
              },
            ]),
          );
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(null);
          const manager = new MediaPlayerManager(api);

          await manager.playLive('media_player.foo', 'camera.foo');

          // No actual test can be performed here as nothing observable happens.
          // This test serves only as code-coverage long-tail.
        });
      });

      it('without required configuration', async () => {
        const api = createCardAPI();
        vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
        vi.mocked(api.getCameraManager().getStore).mockReturnValue(
          createStore([
            {
              cameraID: 'camera.foo',
              config: createCameraConfig({
                camera_entity: 'camera.foo',
                cast: {
                  method: 'dashboard',
                },
              }),
            },
          ]),
        );
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = new MediaPlayerManager(api);

        await manager.playLive('media_player.foo', 'camera.foo');

        expect(
          vi.mocked(api.getMessageManager().setMessageIfHigherPriority),
        ).toBeCalledWith({
          type: 'error',
          icon: 'mdi:cast',
          message:
            "Both 'dashboard_path' and 'view_path' parameters are required " +
            "for the 'dashboard' cast method",
        });
      });
    });

    describe('media', () => {
      describe('successfully with', () => {
        it.each([
          [ViewMediaType.Clip, 'video' as const],
          [ViewMediaType.Snapshot, 'image' as const],
        ])('%s', async (mediaType: ViewMediaType, contentType: 'video' | 'image') => {
          const media = new TestViewMedia({
            title: 'media title',
            thumbnail: 'http://thumbnail',
            contentID: 'media-source://contentid',
            mediaType,
          });
          const api = createCardAPI();
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());
          const manager = new MediaPlayerManager(api);

          await manager.playMedia('media_player.foo', media);

          expect(api.getHASSManager().getHASS()?.callService).toBeCalledWith(
            'media_player',
            'play_media',
            {
              entity_id: 'media_player.foo',
              media_content_id: 'media-source://contentid',
              media_content_type: contentType,
              extra: {
                title: 'media title',
                thumb: 'http://thumbnail',
              },
            },
          );
        });
      });

      it('without hass', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(null);
        const manager = new MediaPlayerManager(api);
        const media = new TestViewMedia();

        await manager.playMedia('media_player.foo', media);

        // No actual test can be performed here as nothing observable happens.
        // This test serves only as code-coverage long-tail.
      });
    });
  });
});



================================================
FILE: tests/card-controller/message-manager.test.ts
================================================
import { afterAll, describe, expect, it, vi } from 'vitest';
import { MessageManager } from '../../src/card-controller/message-manager';
import { AdvancedCameraCardError, Message } from '../../src/types';
import { createCardAPI } from '../test-utils';

const createMessage = (options?: Partial<Message>): Message => {
  return {
    message: options?.message ?? 'message',
    ...(!!options?.type && { type: options.type }),
    ...(!!options?.icon && { icon: options.icon }),
    ...(!!options?.context && { context: options.context }),
    ...(!!options?.dotdotdot && { dotdotdot: options.dotdotdot }),
  };
};

describe('MessageManager', () => {
  afterAll(() => {
    vi.restoreAllMocks();
  });

  it('should construct', () => {
    const manager = new MessageManager(createCardAPI());
    expect(manager.hasMessage()).toBeFalsy();
    expect(manager.getMessage()).toBeNull();
    expect(manager.hasErrorMessage()).toBeFalsy();
  });

  it('should set info message', () => {
    const api = createCardAPI();
    const manager = new MessageManager(api);
    const message = createMessage();
    manager.setMessageIfHigherPriority(message);
    expect(manager.hasMessage()).toBeTruthy();
    expect(manager.getMessage()).toBe(message);
    expect(manager.hasErrorMessage()).toBeFalsy();

    expect(api.getMediaLoadedInfoManager().clear).toBeCalled();
    expect(api.getCardElementManager().scrollReset).toBeCalled();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should set error message', () => {
    const api = createCardAPI();
    const manager = new MessageManager(api);
    const message = createMessage({ type: 'error' });
    manager.setMessageIfHigherPriority(message);
    expect(manager.hasMessage()).toBeTruthy();
    expect(manager.getMessage()).toBe(message);
    expect(manager.hasErrorMessage()).toBeTruthy();

    expect(api.getMediaLoadedInfoManager().clear).toBeCalled();
    expect(api.getCardElementManager().scrollReset).toBeCalled();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should reset message', () => {
    const api = createCardAPI();
    const manager = new MessageManager(api);

    manager.reset();
    expect(manager.hasMessage()).toBeFalsy();

    const message = createMessage({ type: 'error' });
    manager.setMessageIfHigherPriority(message);
    expect(manager.hasMessage()).toBeTruthy();

    vi.mocked(api.getCardElementManager().update).mockClear();
    manager.reset();

    expect(manager.hasMessage()).toBeFalsy();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should reset message that matches type', () => {
    const api = createCardAPI();
    const manager = new MessageManager(api);

    const message = createMessage({ type: 'connection' });
    manager.setMessageIfHigherPriority(message);
    expect(manager.getMessage()).toBe(message);

    manager.resetType('error');
    expect(manager.getMessage()).toBe(message);

    manager.resetType('connection');
    expect(manager.getMessage()).toBeNull();
    expect(manager.hasMessage()).toBeFalsy();
  });

  it('should respect priority', () => {
    const api = createCardAPI();
    const manager = new MessageManager(api);

    manager.reset();
    expect(manager.hasMessage()).toBeFalsy();

    const errorMessage = createMessage({ type: 'error' });
    manager.setMessageIfHigherPriority(errorMessage);

    const explicitInfoMessage = createMessage({ type: 'info' });
    manager.setMessageIfHigherPriority(explicitInfoMessage);

    const implicitInfoMessage = createMessage();
    manager.setMessageIfHigherPriority(implicitInfoMessage);

    expect(manager.getMessage()).toBe(errorMessage);

    const connectionMessage = createMessage({ type: 'connection' });
    manager.setMessageIfHigherPriority(connectionMessage);

    expect(manager.getMessage()).toBe(connectionMessage);
  });

  it('should set AdvancedCameraCardError object', () => {
    const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

    const api = createCardAPI();
    const manager = new MessageManager(api);
    const context = { foo: 'bar' };

    manager.setErrorIfHigherPriority(
      new AdvancedCameraCardError('advanced camera card message', context),
    );
    expect(manager.hasMessage()).toBeTruthy();
    expect(manager.getMessage()).toEqual({
      message: 'advanced camera card message',
      type: 'error',
      context: context,
    });

    expect(consoleSpy).toBeCalled();
  });

  it('should set Error object', () => {
    const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

    const api = createCardAPI();
    const manager = new MessageManager(api);

    manager.setErrorIfHigherPriority(new Error('generic error message'));
    expect(manager.hasMessage()).toBeTruthy();
    expect(manager.getMessage()).toEqual({
      message: 'generic error message',
      type: 'error',
    });

    expect(consoleSpy).toBeCalled();
  });

  it('should set error with prefix', () => {
    const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

    const api = createCardAPI();
    const manager = new MessageManager(api);

    manager.setErrorIfHigherPriority(new Error('generic error message'), 'PREFIX');
    expect(manager.hasMessage()).toBeTruthy();
    expect(manager.getMessage()).toEqual({
      message: 'PREFIX: generic error message',
      type: 'error',
    });

    expect(consoleSpy).toBeCalled();
  });

  it('should not set unknown error type', () => {
    const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

    const api = createCardAPI();
    const manager = new MessageManager(api);

    manager.setErrorIfHigherPriority('not_an_error_object');
    expect(manager.hasMessage()).toBeFalsy();
    expect(consoleSpy).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/microphone-manager.test.ts
================================================
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { MicrophoneManager } from '../../src/card-controller/microphone-manager';
import { MicrophoneState } from '../../src/card-controller/types';
import { createCardAPI, createConfig } from '../test-utils';

const navigatorMock: Navigator = {
  ...mock<Navigator>(),
  mediaDevices: {
    ...mock<MediaDevices>(),
    getUserMedia: vi.fn(),
  },
};

const medialessNavigatorMock: Navigator = {
  ...navigatorMock,

  // Some browser will set mediaDevices to undefined when access over http.
  mediaDevices: undefined as unknown as MediaDevices,
};

// @vitest-environment jsdom
describe('MicrophoneManager', () => {
  beforeEach(() => {
    vi.stubGlobal('navigator', navigatorMock);
    vi.useRealTimers();
  });

  afterEach(() => {
    vi.resetAllMocks();
    vi.unstubAllGlobals();
  });

  const createMockStream = (mute?: boolean): MediaStream => {
    const stream = mock<MediaStream>();
    const track = mock<MediaStreamTrack>();
    track.enabled = !mute;
    stream.getTracks.mockImplementation(() => [track]);
    return stream;
  };

  it('should be muted on creation', () => {
    const manager = new MicrophoneManager(createCardAPI());
    expect(manager).toBeTruthy();
    expect(manager.isMuted()).toBeTruthy();
  });

  it('should be undefined without creation', () => {
    const manager = new MicrophoneManager(createCardAPI());
    expect(manager.getStream()).toBeUndefined();
  });

  it('should connect', async () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);

    const stream = createMockStream();
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(stream);

    await manager.connect();

    expect(manager.isConnected()).toBeTruthy();
    expect(manager.getStream()).toBe(stream);
    expect(manager.isMuted()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should be unsupported without browser support', () => {
    vi.stubGlobal('navigator', medialessNavigatorMock);

    const manager = new MicrophoneManager(createCardAPI());

    expect(manager.isSupported()).toBeFalsy();
  });

  it('should not connect when not supported', async () => {
    vi.stubGlobal('navigator', medialessNavigatorMock);

    const api = createCardAPI();
    const manager = new MicrophoneManager(api);

    const stream = createMockStream();
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(stream);

    await manager.connect();

    expect(manager.isConnected()).toBeFalsy();
  });

  it('should be forbidden when permission denied', async () => {
    // Don't actually log messages to the console during the test.
    vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockRejectedValue(new Error());

    expect(await manager.connect()).toBeFalsy();

    expect(manager.isConnected()).toBeFalsy();
    expect(manager.isForbidden()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should mute and unmute', async () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(
      createMockStream(),
    );

    await manager.connect();
    expect(manager.isMuted()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);

    manager.mute();
    expect(manager.isMuted()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(2);

    await manager.unmute();
    expect(manager.isMuted()).toBeFalsy();
    expect(api.getCardElementManager().update).toBeCalledTimes(3);
  });

  it('should not unmute when microphone forbidden', async () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockRejectedValue(new Error());

    await manager.connect();

    expect(manager.isMuted()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);

    await manager.unmute();
    expect(manager.isMuted()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);
  });

  it('should not unmute when not supported', async () => {
    vi.stubGlobal('navigator', medialessNavigatorMock);

    const manager = new MicrophoneManager(createCardAPI());

    await manager.unmute();

    expect(manager.isConnected()).toBeFalsy();
    expect(manager.isMuted()).toBeTruthy();
  });

  it('should connect on unmute', async () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(
      createMockStream(),
    );

    expect(manager.isConnected()).toBeFalsy();

    await manager.unmute();

    expect(manager.isConnected()).toBeTruthy();
    expect(manager.isMuted()).toBeFalsy();

    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should disconnect', async () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);

    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(
      createMockStream(),
    );

    await manager.connect();
    expect(manager.isConnected()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);

    manager.disconnect();
    expect(manager.isConnected()).toBeFalsy();
    expect(api.getCardElementManager().update).toBeCalledTimes(2);
  });

  it('should automatically disconnect', async () => {
    vi.useFakeTimers();

    const disconnectSeconds = 10;
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(
      createMockStream(),
    );

    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        live: {
          microphone: {
            always_connected: false,
            disconnect_seconds: disconnectSeconds,
          },
        },
      }),
    );

    await manager.connect();
    expect(manager.isConnected()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);

    vi.advanceTimersByTime(disconnectSeconds * 1000);

    expect(manager.isConnected()).toBeFalsy();
    expect(api.getCardElementManager().update).toBeCalledTimes(2);
  });

  it('should not automatically disconnect when always connected', async () => {
    vi.useFakeTimers();

    const disconnectSeconds = 10;
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(
      createMockStream(),
    );

    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        live: {
          microphone: {
            always_connected: true,
            disconnect_seconds: disconnectSeconds,
          },
        },
      }),
    );

    await manager.connect();
    expect(manager.isConnected()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);

    vi.advanceTimersByTime(disconnectSeconds * 1000);

    expect(manager.isConnected()).toBeTruthy();
    expect(api.getCardElementManager().update).toBeCalledTimes(1);
  });

  describe('should require initialization', async () => {
    it('when configured and supported', async () => {
      const api = createCardAPI();
      const manager = new MicrophoneManager(api);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          live: {
            microphone: {
              always_connected: true,
            },
          },
        }),
      );

      await manager.connect();

      expect(manager.shouldConnectOnInitialization()).toBeTruthy();
    });

    it('when configured but not supported', async () => {
      vi.stubGlobal('navigator', medialessNavigatorMock);

      const api = createCardAPI();
      const manager = new MicrophoneManager(api);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          live: {
            microphone: {
              always_connected: true,
            },
          },
        }),
      );

      await manager.connect();

      expect(manager.shouldConnectOnInitialization()).toBeFalsy();
    });

    it('when neither configured nor supported', async () => {
      vi.stubGlobal('navigator', medialessNavigatorMock);

      const api = createCardAPI();
      const manager = new MicrophoneManager(api);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

      await manager.connect();

      expect(manager.shouldConnectOnInitialization()).toBeFalsy();
    });
  });

  it('should initialize', () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);

    manager.initialize();
    expect(api.getConditionStateManager().setState).toBeCalledWith({
      microphone: { connected: false, muted: true, forbidden: false, stream: undefined },
    });
  });

  it('should set state', async () => {
    const api = createCardAPI();
    const manager = new MicrophoneManager(api);
    const stream = createMockStream();
    vi.mocked(navigatorMock.mediaDevices.getUserMedia).mockResolvedValue(stream);

    expect(api.getConditionStateManager().setState).not.toBeCalled();

    await manager.connect();

    let expectedState: MicrophoneState = {
      forbidden: false,
      stream: stream,
      connected: true,
      muted: true,
    };

    expect(manager.getState()).toEqual(expectedState);
    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith(
      expect.objectContaining({
        microphone: expectedState,
      }),
    );

    await manager.unmute();

    expectedState = {
      forbidden: false,
      stream: stream,
      connected: true,
      muted: false,
    };
    expect(manager.getState()).toEqual(expectedState);
    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith(
      expect.objectContaining({
        microphone: expectedState,
      }),
    );

    manager.mute();

    expectedState = {
      forbidden: false,
      stream: stream,
      connected: true,
      muted: true,
    };
    expect(manager.getState()).toEqual(expectedState);
    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith(
      expect.objectContaining({
        microphone: expectedState,
      }),
    );

    manager.disconnect();

    expectedState = {
      forbidden: false,
      stream: undefined,
      connected: false,
      muted: true,
    };
    expect(manager.getState()).toEqual(expectedState);
    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith(
      expect.objectContaining({
        microphone: expectedState,
      }),
    );
  });
});



================================================
FILE: tests/card-controller/query-string-manager.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { QueryStringManager } from '../../src/card-controller/query-string-manager';
import { SubstreamSelectViewModifier } from '../../src/card-controller/view/modifiers/substream-select';
import { createCardAPI } from '../test-utils';

const setQueryString = (qs: string): void => {
  const location: Location = mock<Location>();
  location.search = qs;

  vi.spyOn(window, 'location', 'get').mockReturnValue(location);
};

// @vitest-environment jsdom
describe('QueryStringManager', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should reject malformed query string', async () => {
    setQueryString('BOGUS_KEY=BOGUS_VALUE');
    const api = createCardAPI();
    vi.mocked(api.getMessageManager().hasMessage).mockReturnValue(true);
    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
    await manager.executeIfNecessary();

    expect(api.getActionsManager().executeActions).not.toBeCalled();
    expect(api.getViewManager().setViewByParameters).not.toBeCalled();
  });

  describe('should execute view name action from query string', () => {
    it.each([
      ['clip' as const],
      ['clips' as const],
      ['diagnostics' as const],
      ['image' as const],
      ['live' as const],
      ['recording' as const],
      ['recordings' as const],
      ['snapshot' as const],
      ['snapshots' as const],
      ['timeline' as const],
    ])('%s', async (viewName: string) => {
      setQueryString(`?advanced-camera-card-action.id.${viewName}=`);
      const api = createCardAPI();

      // View actions do not need the card to have been updated.
      vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(false);
      const manager = new QueryStringManager(api);

      expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
      await manager.executeIfNecessary();
      expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();

      expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
        params: {
          view: viewName,
        },
      });
    });
  });

  describe('should execute non-view action from query string', () => {
    it.each([
      ['camera_ui' as const],
      ['download' as const],
      ['expand' as const],
      ['menu_toggle' as const],
    ])('%s', async (action: string) => {
      setQueryString(`?advanced-camera-card-action.id.${action}=`);
      const api = createCardAPI();
      vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
      const manager = new QueryStringManager(api);

      expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
      await manager.executeIfNecessary();

      expect(api.getActionsManager().executeActions).toBeCalledWith({
        actions: [
          {
            action: 'fire-dom-event',
            card_id: 'id',
            advanced_camera_card_action: action,
          },
        ],
      });
    });
  });

  it('should execute view default action', async () => {
    setQueryString('?advanced-camera-card-action.id.default=');
    const api = createCardAPI();
    // View actions do not need the card to have been updated.
    vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(false);

    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();

    expect(api.getViewManager().setViewDefaultWithNewQuery).toBeCalled();
    expect(api.getActionsManager().executeActions).not.toBeCalled();
    expect(api.getViewManager().setViewByParameters).not.toBeCalled();
  });

  it('should execute camera_select action', async () => {
    setQueryString('?advanced-camera-card-action.id.camera_select=camera.office');
    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
      params: {
        camera: 'camera.office',
      },
    });
    expect(api.getActionsManager().executeActions).not.toBeCalled();
    expect(api.getViewManager().setViewDefault).not.toBeCalled();
  });

  it('should execute live_substream_select action', async () => {
    setQueryString(
      '?advanced-camera-card-action.id.live_substream_select=camera.office_hd',
    );
    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
      modifiers: [expect.any(SubstreamSelectViewModifier)],
      params: {},
    });

    expect(api.getActionsManager().executeActions).not.toBeCalled();
    expect(api.getViewManager().setViewDefault).not.toBeCalled();
  });

  describe('should ignore action without value', () => {
    it.each([['camera_select' as const], ['live_substream_select' as const]])(
      '%s',
      async (action: string) => {
        setQueryString(`?advanced-camera-card-action.id.${action}=`);
        const api = createCardAPI();
        vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
        const manager = new QueryStringManager(api);

        expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
        await manager.executeIfNecessary();

        expect(api.getActionsManager().executeActions).not.toBeCalled();
        expect(api.getViewManager().setViewDefault).not.toBeCalled();
        expect(api.getViewManager().setViewByParameters).not.toBeCalled();
      },
    );
  });

  it('should handle unknown action', async () => {
    const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

    setQueryString('?advanced-camera-card-action.id.not_an_action=value');
    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
    await manager.executeIfNecessary();

    expect(api.getActionsManager().executeActions).not.toBeCalled();
    expect(api.getViewManager().setViewDefault).not.toBeCalled();
    expect(api.getViewManager().setViewByParameters).not.toBeCalled();
    expect(consoleSpy).toBeCalled();
  });

  describe('should execute view name action from query string', () => {
    it.each([
      ['clip' as const],
      ['clips' as const],
      ['diagnostics' as const],
      ['image' as const],
      ['live' as const],
      ['recording' as const],
      ['recordings' as const],
      ['snapshot' as const],
      ['snapshots' as const],
      ['timeline' as const],
    ])('%s', async (viewName: string) => {
      setQueryString(`?advanced-camera-card-action.id.${viewName}=`);
      const api = createCardAPI();
      vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
      const manager = new QueryStringManager(api);

      expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
      await manager.executeIfNecessary();
      expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();

      expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
        params: {
          view: viewName,
        },
      });
    });
  });

  describe('should handle conflicting but valid actions', () => {
    it('view and default with camera and substream specified', async () => {
      setQueryString(
        '?advanced-camera-card-action.id.clips=' +
          '&advanced-camera-card-action.id.live_substream_select=camera.kitchen_hd' +
          '&advanced-camera-card-action.id.default=' +
          '&advanced-camera-card-action.id.camera_select=camera.kitchen',
      );
      const api = createCardAPI();
      vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
      const manager = new QueryStringManager(api);

      await manager.executeIfNecessary();

      expect(api.getViewManager().setViewDefaultWithNewQuery).toBeCalledWith({
        params: {
          camera: 'camera.kitchen',
        },
        modifiers: [expect.any(SubstreamSelectViewModifier)],
      });
      expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
    });

    it('multiple cameras specified', async () => {
      setQueryString(
        '?advanced-camera-card-action.id.camera_select=camera.kitchen' +
          '&advanced-camera-card-action.id.camera_select=camera.office',
      );
      const api = createCardAPI();
      vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
      const manager = new QueryStringManager(api);

      await manager.executeIfNecessary();

      expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
        params: {
          camera: 'camera.office',
        },
      });
    });
  });

  it('should only execute when needed', async () => {
    setQueryString(
      '?advanced-camera-card-action.id.live_substream_select=camera.office_hd',
    );
    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(true);
    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledTimes(1);

    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledTimes(1);

    manager.requestExecution();

    expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();
    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledTimes(2);
  });

  it('should execute actions with old frigate-card-action key', async () => {
    setQueryString(`?frigate-card-action.id.clips=`);
    const api = createCardAPI();

    // View actions do not need the card to have been updated.
    vi.mocked(api.getCardElementManager().hasUpdated).mockReturnValue(false);
    const manager = new QueryStringManager(api);

    expect(manager.hasViewRelatedActionsToRun()).toBeTruthy();
    await manager.executeIfNecessary();
    expect(manager.hasViewRelatedActionsToRun()).toBeFalsy();

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
      params: {
        view: 'clips',
      },
    });
  });
});



================================================
FILE: tests/card-controller/status-bar-item-manager.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { StatusBarItemManager } from '../../src/card-controller/status-bar-item-manager';
import { StatusBarString } from '../../src/config/schema/actions/types';
import { QueryResults } from '../../src/view/query-results';
import {
  TestViewMedia,
  createCameraManager,
  createCardAPI,
  createStore,
  createView,
} from '../test-utils';

describe('StatusBarItemManager', () => {
  const testItem: StatusBarString = {
    type: 'custom:advanced-camera-card-status-bar-string' as const,
    string: 'test',
  };

  it('should add', () => {
    const manager = new StatusBarItemManager(createCardAPI());
    manager.addDynamicStatusBarItem(testItem);
    manager.addDynamicStatusBarItem(testItem);

    expect(manager.calculateItems()).toEqual([testItem]);
  });

  it('should remove', () => {
    const manager = new StatusBarItemManager(createCardAPI());
    manager.addDynamicStatusBarItem(testItem);

    manager.removeDynamicStatusBarItem({ ...testItem });
    expect(manager.calculateItems()).not.toContain(testItem);

    manager.removeDynamicStatusBarItem({ ...testItem, string: 'not-present' });
    expect(manager.calculateItems()).not.toContain({
      ...testItem,
      string: 'not-present',
    });
  });

  it('should remove all', () => {
    const manager = new StatusBarItemManager(createCardAPI());
    manager.addDynamicStatusBarItem(testItem);
    manager.removeAllDynamicStatusBarItems();
    expect(manager.calculateItems()).not.toContain(testItem);
  });

  describe('should have standard status bar items', () => {
    describe('should have title', () => {
      describe('live', () => {
        it('with metadata', () => {
          const manager = new StatusBarItemManager(createCardAPI());
          const store = createStore([
            {
              cameraID: 'camera-1',
            },
          ]);
          const cameraManager = createCameraManager(store);
          vi.mocked(cameraManager.getCameraMetadata).mockReturnValue({
            title: 'Camera Title',
            icon: { icon: 'mdi:camera' },
          });

          expect(
            manager.calculateItems({
              cameraManager: cameraManager,
              view: createView({ view: 'live', camera: 'camera-1' }),
            }),
          ).toContainEqual({
            type: 'custom:advanced-camera-card-status-bar-string' as const,
            string: 'Camera Title',
            expand: true,
            sufficient: true,
          });
        });

        it('without metadata', () => {
          const manager = new StatusBarItemManager(createCardAPI());
          const cameraManager = createCameraManager();
          expect(
            manager.calculateItems({
              cameraManager: cameraManager,
              view: createView({ view: 'live', camera: 'MISSING-CAMERA' }),
            }),
          ).not.toContainEqual(expect.objectContaining({ sufficient: true }));
        });
      });

      describe('media', () => {
        it('with a title', () => {
          const manager = new StatusBarItemManager(createCardAPI());
          const cameraManager = createCameraManager();

          const media = [new TestViewMedia({ title: 'Media Title' })];
          const queryResults = new QueryResults({
            results: media,
          });

          const view = createView({
            view: 'media',
            queryResults: queryResults,
          });

          expect(
            manager.calculateItems({
              cameraManager: cameraManager,
              view: view,
            }),
          ).toContainEqual({
            type: 'custom:advanced-camera-card-status-bar-string' as const,
            string: 'Media Title',
            expand: true,
            sufficient: true,
          });
        });

        it('without a title', () => {
          const manager = new StatusBarItemManager(createCardAPI());
          const cameraManager = createCameraManager();

          const media = [new TestViewMedia()];
          const queryResults = new QueryResults({
            results: media,
          });

          const view = createView({
            view: 'media',
            queryResults: queryResults,
          });

          expect(
            manager.calculateItems({
              cameraManager: cameraManager,
              view: view,
            }),
          ).not.toContainEqual(expect.objectContaining({ sufficient: true }));
        });
      });
    });

    describe('should have resolution', () => {
      it.each([
        ['1080p landscape', '1080p', 1920, 1080],
        ['1080p portrait', '1080p', 1080, 1920],
        ['1080p approximate', '1080p', 1922, 1082],

        ['720p landscape', '720p', 1280, 720],
        ['720p portrait', '720p', 720, 1280],
        ['720p approximate', '720p', 1282, 722],

        ['VGA landscape', 'VGA', 640, 480],
        ['VGA portrait', 'VGA', 480, 640],
        ['VGA approximate', 'VGA', 642, 482],

        ['4K landscape', '4K', 3840, 2160],
        ['4K portrait', '4K', 2160, 3840],
        ['4K approximate', '4K', 3842, 2162],

        ['480p landscape', '480p', 720, 480],
        ['480p portrait', '480p', 480, 720],
        ['480p approximate', '480p', 722, 482],

        ['576p landscape', '576p', 720, 576],
        ['576p portrait', '576p', 576, 720],
        ['576p approximate', '576p', 722, 578],

        ['8K landscape', '8K', 7680, 4320],
        ['8K portrait', '8K', 4320, 7680],
        ['8K approximate', '8K', 7682, 4322],

        ['random', '123x456', 123, 456],
      ])(
        '%s',
        (_testName: string, expectedName: string, width: number, height: number) => {
          const manager = new StatusBarItemManager(createCardAPI());

          expect(
            manager.calculateItems({
              mediaLoadedInfo: { width, height },
            }),
          ).toContainEqual({
            type: 'custom:advanced-camera-card-status-bar-string' as const,
            string: expectedName,
          });
        },
      );
    });

    describe('should have technology', () => {
      it('webrtc', () => {
        const manager = new StatusBarItemManager(createCardAPI());

        expect(
          manager.calculateItems({
            mediaLoadedInfo: { width: 640, height: 480, technology: ['webrtc'] },
          }),
        ).toContainEqual({
          type: 'custom:advanced-camera-card-status-bar-icon' as const,
          icon: 'mdi:webrtc',
        });
      });

      it('non-webrtc', () => {
        const manager = new StatusBarItemManager(createCardAPI());

        expect(
          manager.calculateItems({
            mediaLoadedInfo: { width: 640, height: 480, technology: ['hls'] },
          }),
        ).toContainEqual({
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'HLS',
        });
      });
    });

    it('should have engine', () => {
      const manager = new StatusBarItemManager(createCardAPI());
      const store = createStore([
        {
          cameraID: 'camera-1',
        },
      ]);
      const cameraManager = createCameraManager(store);
      vi.mocked(cameraManager.getCameraMetadata).mockReturnValue({
        title: 'Camera Title',
        icon: {
          icon: 'mdi:camera',
        },
        engineIcon: 'ENGINE_ICON',
      });

      expect(
        manager.calculateItems({
          cameraManager: cameraManager,
          view: createView({ view: 'live', camera: 'camera-1' }),
        }),
      ).toContainEqual({
        type: 'custom:advanced-camera-card-status-bar-icon' as const,
        icon: 'ENGINE_ICON',
      });
    });
  });
});



================================================
FILE: tests/card-controller/style-manager.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { StyleManager } from '../../src/card-controller/style-manager';
import { AdvancedCameraCardView } from '../../src/config/schema/common/const';
import { ThemeName } from '../../src/config/schema/view';
import { createCardAPI, createConfig, createView } from '../test-utils';

// @vitest-environment jsdom
describe('StyleManager', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('should set dimmable', () => {
    it('should be dimmable when dim is true', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            dim: true,
          },
        }),
      );
      const manager = new StyleManager(api);

      manager.updateFromConfig();

      expect(element.getAttribute('dimmable')).not.toBeNull();
    });

    it('should not be dimmable when dim is false', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            dim: false,
          },
        }),
      );
      const manager = new StyleManager(api);

      manager.updateFromConfig();

      expect(element.getAttribute('dimmable')).toBeNull();
    });
  });

  describe('should set expanded mode', () => {
    it('with no view or known media', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getMediaLoadedInfoManager().getLastKnown).mockReturnValue(null);
      const manager = new StyleManager(api);

      manager.setExpandedMode();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-aspect-ratio'),
      ).toBe('unset');
      expect(element.style.getPropertyValue('--advanced-camera-card-expand-width')).toBe(
        'var(--advanced-camera-card-expand-max-width)',
      );
      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-height'),
      ).toBe('var(--advanced-camera-card-expand-max-height)');
    });

    it('with view but without media', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      const view = createView({ view: 'media', displayMode: 'single' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getMediaLoadedInfoManager().getLastKnown).mockReturnValue(null);
      const manager = new StyleManager(api);

      manager.setExpandedMode();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-aspect-ratio'),
      ).toBe('unset');
      expect(element.style.getPropertyValue('--advanced-camera-card-expand-width')).toBe(
        'none',
      );
      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-height'),
      ).toBe('none');
    });

    it('with view and media', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      const view = createView({ view: 'media', displayMode: 'single' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getMediaLoadedInfoManager().getLastKnown).mockReturnValue({
        width: 800,
        height: 600,
      });
      const manager = new StyleManager(api);

      manager.setExpandedMode();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-aspect-ratio'),
      ).toBe('800 / 600');
      expect(element.style.getPropertyValue('--advanced-camera-card-expand-width')).toBe(
        'none',
      );
      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-height'),
      ).toBe('none');
    });

    it('with view and grid display mode', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      const view = createView({ view: 'media', displayMode: 'grid' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getMediaLoadedInfoManager().getLastKnown).mockReturnValue({
        width: 800,
        height: 600,
      });
      const manager = new StyleManager(api);

      manager.setExpandedMode();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-aspect-ratio'),
      ).toBe('800 / 600');
      expect(element.style.getPropertyValue('--advanced-camera-card-expand-width')).toBe(
        'var(--advanced-camera-card-expand-max-width)',
      );
      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-height'),
      ).toBe('var(--advanced-camera-card-expand-max-height)');
    });
  });

  describe('should set min and max height', () => {
    it('without a config', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      const manager = new StyleManager(api);

      manager.updateFromConfig();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-max-height'),
      ).toBeFalsy();
      expect(
        element.style.getPropertyValue('--advanced-camera-card-expand-height'),
      ).toBeFalsy();
    });

    it('with a config', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          dimensions: {
            height: '800px',
          },
        }),
      );
      const manager = new StyleManager(api);

      manager.updateFromConfig();

      expect(element.style.getPropertyValue('--advanced-camera-card-height')).toBe(
        '800px',
      );
    });
  });

  describe('should set performance', () => {
    it('no styles set', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getCardWideConfig).mockReturnValue({});
      const manager = new StyleManager(api);

      manager.updateFromConfig();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-css-box-shadow'),
      ).toBeFalsy();
      expect(
        element.style.getPropertyValue('--advanced-camera-card-css-border-radius'),
      ).toBeFalsy();
    });

    it('valid styles set', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getCardWideConfig).mockReturnValue(
        createConfig({
          performance: {
            style: {
              box_shadow: false,
              border_radius: true,
            },
          },
        }),
      );
      const manager = new StyleManager(api);

      manager.updateFromConfig();

      expect(
        element.style.getPropertyValue('--advanced-camera-card-css-box-shadow'),
      ).toEqual('none');
      expect(
        element.style.getPropertyValue('--advanced-camera-card-css-border-radius'),
      ).toBeFalsy();
    });
  });

  describe('getAspectRatioStyle', () => {
    it('without config or view', () => {
      const api = createCardAPI();
      const manager = new StyleManager(api);
      expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': '16 / 9' });
    });

    it('should be auto with unconstrained aspect ratio', () => {
      const api = createCardAPI();
      const view = createView({ view: 'media' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          dimensions: {
            aspect_ratio_mode: 'unconstrained',
          },
        }),
      );
      const manager = new StyleManager(api);
      expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': 'auto' });
    });

    it('should be auto in fullscreen', () => {
      const api = createCardAPI();
      const view = createView({ view: 'media' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(api.getFullscreenManager().isInFullscreen).mockReturnValue(true);
      const manager = new StyleManager(api);

      expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': 'auto' });
    });

    it('should be auto when expanded', () => {
      const api = createCardAPI();
      const view = createView({ view: 'media' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(api.getExpandManager().isExpanded).mockReturnValue(true);
      const manager = new StyleManager(api);

      expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': 'auto' });
    });

    it('should be auto when there is yet to be a view', () => {
      const api = createCardAPI();
      vi.mocked(api.getViewManager().getView).mockReturnValue(null);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      const manager = new StyleManager(api);

      expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': 'auto' });
    });

    describe('should be auto when dynamic in certain views', () => {
      it.each([
        ['clip' as const],
        ['diagnostics' as const],
        ['image' as const],
        ['media' as const],
        ['live' as const],
        ['recording' as const],
        ['snapshot' as const],
        ['timeline' as const],
      ])('%s', (viewName: AdvancedCameraCardView) => {
        const api = createCardAPI();
        const view = createView({ view: viewName });
        vi.mocked(api.getViewManager().getView).mockReturnValue(view);
        vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
          createConfig({
            dimensions: {
              aspect_ratio_mode: 'dynamic',
            },
          }),
        );
        const manager = new StyleManager(api);

        expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': 'auto' });
      });
    });

    describe('should be enforced when dynamic in certain views', () => {
      it.each([['clips' as const], ['recordings' as const], ['snapshots' as const]])(
        '%s',
        (viewName: AdvancedCameraCardView) => {
          const api = createCardAPI();
          const view = createView({ view: viewName });
          vi.mocked(api.getViewManager().getView).mockReturnValue(view);
          vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
            createConfig({
              dimensions: {
                aspect_ratio_mode: 'dynamic',
              },
            }),
          );
          const manager = new StyleManager(api);

          expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': '16 / 9' });
        },
      );
    });

    describe('should use media dimensions in dynamic', () => {
      it.each([['clips' as const], ['recordings' as const], ['snapshots' as const]])(
        '%s',
        (viewName: AdvancedCameraCardView) => {
          const api = createCardAPI();
          const view = createView({ view: viewName });
          vi.mocked(api.getViewManager().getView).mockReturnValue(view);
          vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
            createConfig({
              dimensions: {
                aspect_ratio_mode: 'dynamic',
              },
            }),
          );
          vi.mocked(api.getMediaLoadedInfoManager().getLastKnown).mockReturnValue({
            width: 800,
            height: 600,
          });
          const manager = new StyleManager(api);

          expect(manager.getAspectRatioStyle()).toEqual({
            'aspect-ratio': '800 / 600',
          });
        },
      );
    });

    it('should respect default aspect ratio', () => {
      const api = createCardAPI();
      const view = createView({ view: 'clips' });
      vi.mocked(api.getViewManager().getView).mockReturnValue(view);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          dimensions: {
            aspect_ratio_mode: 'dynamic',
            aspect_ratio: '4:3',
          },
        }),
      );
      const manager = new StyleManager(api);

      expect(manager.getAspectRatioStyle()).toEqual({ 'aspect-ratio': '4 / 3' });
    });
  });

  describe('should apply themes', () => {
    it('should not apply themes without a config', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

      const manager = new StyleManager(api);

      manager.applyTheme();

      expect(element.getAttribute('themes')).toBeNull();
    });

    describe('should apply named theme', () => {
      it.each([
        ['light' as const],
        ['dark' as const],
        ['traditional' as const],
        ['ha' as const],
      ])('%s', (theme: ThemeName) => {
        const api = createCardAPI();
        const element = document.createElement('div');
        vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
        vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
          createConfig({
            view: {
              theme: {
                themes: [theme],
              },
            },
          }),
        );

        const manager = new StyleManager(api);

        manager.applyTheme();

        expect(element.getAttribute('themes')).toBe(theme);
      });
    });

    it('should apply multiple themes', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            theme: {
              themes: ['light', 'traditional'],
            },
          },
        }),
      );

      const manager = new StyleManager(api);

      manager.applyTheme();

      expect(element.getAttribute('themes')).toBe('light traditional');
    });

    it('should treat empty themes list as default', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            theme: {
              themes: [],
            },
          },
        }),
      );

      const manager = new StyleManager(api);

      manager.applyTheme();

      expect(element.getAttribute('themes')).toBe('traditional');
    });

    it('should apply overrides', () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            theme: {
              overrides: {
                '--test-key': 'test-value',
              },
            },
          },
        }),
      );

      const manager = new StyleManager(api);

      manager.applyTheme();

      expect(element.style.getPropertyValue('--test-key')).toBe('test-value');
    });
  });
});



================================================
FILE: tests/card-controller/triggers-manager.test.ts
================================================
import { add } from 'date-fns';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { CardController } from '../../src/card-controller/controller';
import { TriggersManager } from '../../src/card-controller/triggers-manager';
import { AdvancedCameraCardView } from '../../src/config/schema/common/const';
import { TriggersOptions, triggersSchema } from '../../src/config/schema/view';
import {
  createCameraConfig,
  createCameraManager,
  createCardAPI,
  createConfig,
  createHASS,
  createStateEntity,
  createStore,
  createView,
  flushPromises,
} from '../test-utils';

vi.mock('lodash-es', async () => ({
  ...(await vi.importActual('lodash-es')),
  throttle: vi.fn((fn) => fn),
}));

const baseTriggersConfig: TriggersOptions = {
  untrigger_seconds: 10,
  filter_selected_camera: false,
  show_trigger_status: false,
  actions: {
    trigger: 'update' as const,
    untrigger: 'default' as const,
    interaction_mode: 'inactive' as const,
  },
};

// Creating and mocking a trigger API is a lot of boilerplate, this convenience
// function reduces it.
const createTriggerAPI = (options?: {
  config?: Partial<TriggersOptions>;
  default?: AdvancedCameraCardView;
  interaction?: boolean;
}): CardController => {
  const api = createCardAPI();
  vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
    createConfig({
      view: {
        triggers: options?.config
          ? triggersSchema.parse(options.config)
          : baseTriggersConfig,
        ...(options?.default && { default: options.default }),
      },
    }),
  );
  vi.mocked(api.getConditionStateManager().getState).mockReturnValue({});
  vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
  vi.mocked(api.getCameraManager().getStore).mockReturnValue(
    createStore([
      {
        cameraID: 'camera_1',
        config: createCameraConfig({
          triggers: {
            entities: ['binary_sensor.motion'],
          },
        }),
      },
    ]),
  );
  vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(
    options?.interaction ?? false,
  );
  vi.mocked(api.getViewManager().getView).mockReturnValue(
    createView({
      camera: 'camera_1' as const,
    }),
  );

  return api;
};

// @vitest-environment jsdom
describe('TriggersManager', () => {
  const start = new Date('2023-10-01T17:14');

  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(start);
  });

  it('should not be triggered by default', () => {
    const manager = new TriggersManager(createCardAPI());
    expect(manager.isTriggered()).toBeFalsy();
  });

  it('should not trigger without a triggers config', () => {
    const api = createTriggerAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        camera: 'camera_1' as const,
      }),
    );
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(null);

    const manager = new TriggersManager(api);

    manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'new',
    });

    expect(manager.isTriggered()).toBeFalsy();
  });

  describe('trigger actions', () => {
    it('update', async () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'update',
          },
        },
      });

      const manager = new TriggersManager(api);

      await manager.handleCameraEvent({
        cameraID: 'camera_1',
        type: 'new',
      });

      expect(manager.isTriggered()).toBeTruthy();
      expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
        queryExecutorOptions: { useCache: false },
      });
    });

    it('default', async () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'default',
          },
        },
      });

      const manager = new TriggersManager(api);

      await manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new' });

      expect(manager.isTriggered()).toBeTruthy();
      expect(api.getViewManager().setViewDefaultWithNewQuery).toBeCalledWith({
        params: {
          camera: 'camera_1',
        },
      });
    });

    it('live', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'live',
          },
        },
      });

      const manager = new TriggersManager(api);

      manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new' });

      expect(manager.isTriggered()).toBeTruthy();
      expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
        params: {
          view: 'live',
          camera: 'camera_1',
        },
      });
    });

    describe('media', () => {
      it.each([
        [false, false, null],
        [false, true, 'clip' as const],
        [true, false, 'snapshot' as const],
        [true, true, 'clip' as const],
      ])(
        'with snapshot %s and clip %s',
        async (
          hasSnapshot: boolean,
          hasClip: boolean,
          viewName: 'clip' | 'snapshot' | null,
        ) => {
          const api = createTriggerAPI({
            config: {
              actions: {
                interaction_mode: 'all',
                trigger: 'media',
                untrigger: 'none',
              },
            },
          });
          const manager = new TriggersManager(api);

          manager.handleCameraEvent({
            cameraID: 'camera_1',
            type: 'new',
            fidelity: 'high',
            snapshot: hasSnapshot,
            clip: hasClip,
          });

          if (!viewName) {
            expect(
              api.getViewManager().setViewByParametersWithNewQuery,
            ).not.toBeCalled();
          } else {
            expect(manager.isTriggered()).toBeTruthy();
            expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
              params: {
                camera: 'camera_1',
                view: viewName,
              },
            });
          }
        },
      );
    });

    it('none', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'none',
          },
        },
      });

      const manager = new TriggersManager(api);

      manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new' });

      expect(manager.isTriggered()).toBeTruthy();
      expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
      expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
    });
  });

  describe('untrigger actions', () => {
    it('none', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'none',
            untrigger: 'none',
          },
        },
      });

      const manager = new TriggersManager(api);
      manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new' });
      manager.handleCameraEvent({ cameraID: 'camera_1', type: 'end' });

      vi.setSystemTime(add(start, { seconds: 10 }));
      vi.runOnlyPendingTimers();

      expect(manager.isTriggered()).toBeFalsy();

      expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
      expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
    });

    it('default', async () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'none',
            untrigger: 'default',
          },
        },
      });

      const manager = new TriggersManager(api);
      await manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new' });
      await manager.handleCameraEvent({ cameraID: 'camera_1', type: 'end' });

      vi.setSystemTime(add(start, { seconds: 10 }));
      vi.runOnlyPendingTimers();
      await flushPromises();

      expect(manager.isTriggered()).toBeFalsy();

      expect(api.getViewManager().setViewDefaultWithNewQuery).toBeCalled();
    });
  });

  it('should manage condition state', () => {
    const api = createTriggerAPI({
      config: {
        ...baseTriggersConfig,
        actions: {
          ...baseTriggersConfig.actions,
          trigger: 'none',
          untrigger: 'none',
        },
      },
    });

    const manager = new TriggersManager(api);

    manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new' });

    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith({
      triggered: new Set(['camera_1']),
    });
    vi.mocked(api.getConditionStateManager().getState).mockReturnValue({
      triggered: new Set(['camera_1']),
    });

    manager.handleCameraEvent({ cameraID: 'camera_1', type: 'end' });

    vi.setSystemTime(add(start, { seconds: 10 }));
    vi.runOnlyPendingTimers();

    expect(api.getConditionStateManager().setState).toHaveBeenLastCalledWith({
      triggered: undefined,
    });
  });

  describe('should take no actions with high-fidelity event', () => {
    it('with non-live action', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'media',
          },
        },
        default: 'live',
      });

      const manager = new TriggersManager(api);

      manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new', fidelity: 'high' });

      expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
      expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
    });

    it('with non-live default', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          actions: {
            ...baseTriggersConfig.actions,
            trigger: 'default',
          },
        },
        default: 'clips',
      });

      const manager = new TriggersManager(api);

      manager.handleCameraEvent({ cameraID: 'camera_1', type: 'new', fidelity: 'high' });

      expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
      expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
    });
  });

  it('should take no actions with human interactions', () => {
    const api = createTriggerAPI({
      // Interaction present.
      interaction: true,
    });
    const manager = new TriggersManager(api);

    manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'new',
    });

    expect(manager.isTriggered()).toBeTruthy();

    expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();

    manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'end',
    });

    vi.setSystemTime(add(start, { seconds: 10 }));
    vi.runOnlyPendingTimers();

    expect(manager.isTriggered()).toBeFalsy();

    expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
  });

  it('should take no actions when actions are set to none', () => {
    const api = createTriggerAPI({
      config: {
        actions: {
          interaction_mode: 'all',
          trigger: 'none',
          untrigger: 'none',
        },
      },
    });
    const manager = new TriggersManager(api);
    manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'new',
    });
    expect(manager.isTriggered()).toBeTruthy();
    expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();

    manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'end',
    });

    vi.setSystemTime(add(start, { seconds: 10 }));
    vi.runOnlyPendingTimers();

    expect(manager.isTriggered()).toBeFalsy();
    expect(api.getViewManager().setViewDefaultWithNewQuery).not.toBeCalled();
    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
  });

  it('should take actions with human interactions when interaction mode is active', async () => {
    const api = createTriggerAPI({
      // Interaction present.
      interaction: true,
      config: {
        ...baseTriggersConfig,
        actions: {
          trigger: 'live' as const,
          untrigger: 'default' as const,
          interaction_mode: 'active',
        },
      },
    });
    const manager = new TriggersManager(api);
    await manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'new',
    });

    expect(manager.isTriggered()).toBeTruthy();
    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
      params: {
        view: 'live' as const,
        camera: 'camera_1' as const,
      },
    });

    await manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'end',
    });

    vi.setSystemTime(add(start, { seconds: 10 }));
    vi.runOnlyPendingTimers();
    await flushPromises();

    expect(manager.isTriggered()).toBeFalsy();

    expect(api.getViewManager().setViewDefaultWithNewQuery).toBeCalled();
  });

  it('should report multiple triggered cameras', async () => {
    const api = createTriggerAPI();
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(
      createStore([
        {
          cameraID: 'camera_1',
          config: createCameraConfig({
            triggers: {
              entities: ['binary_sensor.one'],
            },
          }),
        },
        {
          cameraID: 'camera_2',
          config: createCameraConfig({
            triggers: {
              entities: ['binary_sensor.two'],
            },
          }),
        },
      ]),
    );

    const manager = new TriggersManager(api);

    expect(manager.isTriggered()).toBeFalsy();
    expect(manager.getMostRecentlyTriggeredCameraID()).toBeNull();
    expect(manager.getTriggeredCameraIDs()).toEqual(new Set());

    await manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'new',
    });
    await manager.handleCameraEvent({
      cameraID: 'camera_2',
      type: 'new',
    });

    expect(manager.isTriggered()).toBeTruthy();
    expect(manager.getTriggeredCameraIDs()).toEqual(new Set(['camera_1', 'camera_2']));

    // Either is the most recently triggered.
    expect(['camera_1', 'camera_2']).toContain(
      manager.getMostRecentlyTriggeredCameraID(),
    );

    await manager.handleCameraEvent({
      cameraID: 'camera_1',
      type: 'end',
    });

    vi.setSystemTime(add(start, { seconds: 10 }));
    vi.runOnlyPendingTimers();

    await flushPromises();

    expect(manager.getTriggeredCameraIDs()).toEqual(new Set(['camera_2']));
    expect(manager.getMostRecentlyTriggeredCameraID()).toBe('camera_2');
  });

  describe('should filter triggers by camera', () => {
    it('no dependencies', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          // Filter triggers to selected camera only.
          filter_selected_camera: true,
        },
      });
      const manager = new TriggersManager(api);
      expect(manager.isTriggered()).toBeFalsy();

      const otherCameraSelected = createView({
        camera: 'camera_SOME_OTHER_CAMERA' as const,
      });
      vi.mocked(api.getViewManager().getView).mockReturnValue(otherCameraSelected);

      manager.handleCameraEvent({
        cameraID: 'camera_1',
        type: 'new',
      });
      expect(manager.isTriggered()).toBeFalsy();

      const thisCameraSelected = createView({
        camera: 'camera_1' as const,
      });
      vi.mocked(api.getViewManager().getView).mockReturnValue(thisCameraSelected);

      manager.handleCameraEvent({
        cameraID: 'camera_1',
        type: 'new',
      });
      expect(manager.isTriggered()).toBeTruthy();
    });

    it('dependencies', () => {
      const api = createTriggerAPI({
        config: {
          ...baseTriggersConfig,
          // Filter triggers to selected camera only.
          filter_selected_camera: true,
        },
      });
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera_primary',
            config: createCameraConfig({
              triggers: {
                entities: ['binary_sensor.motion'],
              },
              dependencies: {
                all_cameras: true,
              },
            }),
          },
          {
            cameraID: 'camera_secondary',
            config: createCameraConfig({
              triggers: {
                entities: ['binary_sensor.motion'],
              },
            }),
          },
        ]),
      );

      const manager = new TriggersManager(api);

      const primaryCameraView = createView({
        camera: 'camera_primary' as const,
      });
      vi.mocked(api.getViewManager().getView).mockReturnValue(primaryCameraView);

      // Events for the secondary will still trigger when filter_selected_camera
      // is true.
      manager.handleCameraEvent({
        cameraID: 'camera_secondary',
        type: 'new',
      });
      expect(manager.isTriggered()).toBeTruthy();
    });
  });

  describe('should handle initial camera triggers', () => {
    it('should not trigger if no cameras have trigger entities', async () => {
      const api = createTriggerAPI();
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera_1',
            config: createCameraConfig({
              triggers: {
                entities: [],
              },
            }),
          },
        ]),
      );

      const manager = new TriggersManager(api);
      const result = await manager.handleInitialCameraTriggers();

      expect(result).toBeFalsy();
      expect(manager.isTriggered()).toBeFalsy();
    });

    it('should not trigger if no cameras have trigger state', async () => {
      const api = createTriggerAPI();
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera_1',
            config: createCameraConfig({
              triggers: {
                entities: ['binary_sensor.motion', 'binary_sensor.occupancy'],
              },
            }),
          },
        ]),
      );

      const hass = createHASS({
        'binary_sensor.motion': createStateEntity({
          state: 'off',
        }),
        'binary_sensor.occupancy': createStateEntity({
          state: 'off',
        }),
      });
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const manager = new TriggersManager(api);
      const result = await manager.handleInitialCameraTriggers();

      expect(result).toBeFalsy();
      expect(manager.isTriggered()).toBeFalsy();
    });

    it('should trigger if cameras are triggered', async () => {
      const api = createTriggerAPI();
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera_1',
            config: createCameraConfig({
              triggers: {
                entities: ['binary_sensor.motion', 'binary_sensor.occupancy'],
              },
            }),
          },
        ]),
      );

      const hass = createHASS({
        'binary_sensor.motion': createStateEntity({
          state: 'off',
        }),
        'binary_sensor.occupancy': createStateEntity({
          state: 'on',
        }),
      });
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const manager = new TriggersManager(api);
      const result = await manager.handleInitialCameraTriggers();

      expect(result).toBeTruthy();
      expect(manager.isTriggered()).toBeTruthy();
    });
  });
});



================================================
FILE: tests/card-controller/actions/actions-manager.test.ts
================================================
import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
  vi,
} from 'vitest';
import { mock } from 'vitest-mock-extended';
import {
  ActionsManager,
  Interaction,
  InteractionName,
} from '../../../src/card-controller/actions/actions-manager';
import { TemplateRenderer } from '../../../src/card-controller/templates';
import { AdvancedCameraCardView } from '../../../src/config/schema/common/const';
import { createLogAction } from '../../../src/utils/action';
import { createCardAPI, createConfig, createHASS, createView } from '../../test-utils';

describe('ActionsManager', () => {
  describe('getMergedActions', () => {
    const config = {
      view: {
        actions: {
          tap_action: {
            action: 'navigate',
            navigation_path: '1',
          },
        },
      },
      live: {
        actions: {
          tap_action: {
            action: 'navigate',
            navigation_path: '2',
          },
        },
      },
      media_gallery: {
        actions: {
          tap_action: {
            action: 'navigate',
            navigation_path: '3',
          },
        },
      },
      media_viewer: {
        actions: {
          tap_action: {
            action: 'navigate',
            navigation_path: '4',
          },
        },
      },
      image: {
        actions: {
          tap_action: {
            action: 'navigate',
            navigation_path: '5',
          },
        },
      },
    };

    afterAll(() => {
      vi.restoreAllMocks();
    });

    it('should get no merged actions with a message', () => {
      const api = createCardAPI();
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ view: 'live' }),
      );
      vi.mocked(api.getMessageManager().hasMessage).mockReturnValue(true);

      const manager = new ActionsManager(api);

      expect(manager.getMergedActions()).toEqual({});
    });

    describe('should get merged actions with view', () => {
      it.each([
        [
          'live' as const,
          {
            tap_action: {
              action: 'navigate',
              navigation_path: '2',
            },
          },
        ],
        [
          'clips' as const,
          {
            tap_action: {
              action: 'navigate',
              navigation_path: '3',
            },
          },
        ],
        [
          'folder' as const,
          {
            tap_action: {
              action: 'navigate',
              // Folders also uses the media viewer.
              navigation_path: '4',
            },
          },
        ],
        [
          'folders' as const,
          {
            tap_action: {
              action: 'navigate',
              // Folders also uses the media gallery.
              navigation_path: '3',
            },
          },
        ],
        [
          'clip' as const,
          {
            tap_action: {
              action: 'navigate',
              navigation_path: '4',
            },
          },
        ],
        [
          'image' as const,
          {
            tap_action: {
              action: 'navigate',
              navigation_path: '5',
            },
          },
        ],
        ['timeline' as const, {}],
      ])('%s', (viewName: AdvancedCameraCardView, result: Record<string, unknown>) => {
        const api = createCardAPI();
        vi.mocked(api.getViewManager().getView).mockReturnValue(
          createView({ view: viewName }),
        );
        vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
          createConfig(config),
        );

        const manager = new ActionsManager(api);

        expect(manager.getMergedActions()).toEqual(result);
      });
    });
  });

  // @vitest-environment jsdom
  describe('handleInteractionEvent', () => {
    beforeEach(() => {
      vi.restoreAllMocks();
    });

    it('should handle interaction', async () => {
      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      vi.mocked(api.getViewManager().getView).mockReturnValue(createView());
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            actions: {
              tap_action: createLogAction('Hello, world!'),
            },
          },
        }),
      );
      const manager = new ActionsManager(api);

      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      await manager.handleInteractionEvent(
        new CustomEvent<Interaction>('event', { detail: { action: 'tap' } }),
      );
      expect(consoleSpy).toBeCalled();
    });

    describe('should handle unexpected interactions', () => {
      it.each([['malformed_type_of_tap' as const], ['double_tap' as const]])(
        '%s',
        (interaction: string) => {
          const api = createCardAPI();
          const element = document.createElement('div');
          vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
          vi.mocked(api.getViewManager().getView).mockReturnValue(createView());
          vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
            createConfig({
              view: {
                actions: {
                  tap_action: createLogAction('Hello, world!'),
                },
              },
            }),
          );
          const manager = new ActionsManager(api);

          const hass = createHASS();
          vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

          const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
          manager.handleInteractionEvent(
            new CustomEvent<Interaction>('event', {
              detail: { action: interaction as unknown as InteractionName },
            }),
          );
          expect(consoleSpy).not.toBeCalled();
        },
      );
    });
  });

  describe('handleCustomActionEvent', () => {
    beforeEach(() => {
      vi.restoreAllMocks();
    });

    it('should handle advanced camera card event', async () => {
      const action = createLogAction('Hello, world!');
      const event = new CustomEvent('ll-custom', {
        detail: action,
      });

      const api = createCardAPI();
      const manager = new ActionsManager(api);

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      await manager.handleCustomActionEvent(event);
      expect(consoleSpy).toBeCalled();
    });

    it('should not handle generic event', async () => {
      const event = new CustomEvent('ll-custom', {
        detail: {
          type: 'fire-dom-event',
          foo: 'bar',
        },
      });

      const card = document.createElement('div');
      const handler = vi.fn();
      card.addEventListener('ll-custom', handler);

      const api = createCardAPI();
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(card);
      const manager = new ActionsManager(api);

      await manager.handleCustomActionEvent(event);

      expect(handler).not.toBeCalled();
    });

    it('should not handle event without detail', async () => {
      const manager = new ActionsManager(createCardAPI());

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      await manager.handleCustomActionEvent(new Event('ll-custom'));
      expect(consoleSpy).not.toBeCalled();
    });
  });

  describe('handleActionExecutionRequestEvent', () => {
    it('should execute actions', async () => {
      const api = createCardAPI();
      const manager = new ActionsManager(api);

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      await manager.handleActionExecutionRequestEvent(
        new CustomEvent('advanced-camera-card:action:execution-request', {
          detail: { actions: createLogAction('Hello, world!') },
        }),
      );
      expect(consoleSpy).toBeCalled();
    });
  });

  describe('executeAction', () => {
    it('should execute actions', async () => {
      const api = createCardAPI();
      const manager = new ActionsManager(api);

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      await manager.executeActions({ actions: createLogAction('Hello, world!') });
      expect(consoleSpy).toBeCalled();
    });

    it('should execute actions', async () => {
      const api = createCardAPI();
      const manager = new ActionsManager(api);

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      await manager.executeActions({ actions: createLogAction('Hello, world!') });
      expect(consoleSpy).toBeCalled();
    });

    it('should render templates', async () => {
      const action = createLogAction('{{ acc.camera }}');

      const templateRenderer = mock<TemplateRenderer>();
      templateRenderer.renderRecursively.mockReturnValue(action);

      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const conditionState = {
        camera: 'camera',
      };
      vi.mocked(api.getConditionStateManager().getState).mockReturnValue(conditionState);

      const manager = new ActionsManager(api, templateRenderer);
      const config = { entity: 'light.office' };
      const triggerData = { view: { from: 'previous-view', to: 'view' } };

      await manager.executeActions({ actions: action, config, triggerData });

      expect(templateRenderer.renderRecursively).toBeCalledWith(hass, action, {
        conditionState,
        triggerData,
      });
    });

    describe('should forward haptics', () => {
      afterEach(() => {
        vi.restoreAllMocks();
        vi.unstubAllGlobals();
      });

      it('should forward success haptic', async () => {
        const handler = vi.fn();
        window.addEventListener('haptic', handler);

        const api = createCardAPI();
        const manager = new ActionsManager(api);

        await manager.executeActions({ actions: { action: 'none' } });

        expect(handler).toBeCalledWith(expect.objectContaining({ detail: 'success' }));
      });

      it('should forward warning haptic', async () => {
        vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

        const handler = vi.fn();
        window.addEventListener('haptic', handler);

        const api = createCardAPI();
        const manager = new ActionsManager(api);

        vi.stubGlobal('confirm', vi.fn().mockReturnValue(false));

        await manager.executeActions({
          actions: { action: 'none', confirmation: true },
        });

        expect(handler).toBeCalledWith(expect.objectContaining({ detail: 'warning' }));
      });
    });
  });

  describe('uninitialize', () => {
    beforeAll(() => {
      vi.useFakeTimers();
    });
    afterAll(() => {
      vi.useRealTimers();
    });

    it('should stop actions', async () => {
      const api = createCardAPI();
      const manager = new ActionsManager(api);

      const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
      const promise = manager.executeActions({
        actions: [
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'sleep',
            duration: {
              m: 1,
            },
          },
          createLogAction('Hello, world!'),
        ],
      });

      // Stop inflight actions.
      await manager.uninitialize();

      // Advance timers (causes the sleep to end).
      vi.runOnlyPendingTimers();

      await promise;

      // Action set will not continue.
      expect(consoleSpy).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/card-controller/actions/factory.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { CallServiceAction } from '../../../src/card-controller/actions/actions/call-service';
import { CameraSelectAction } from '../../../src/card-controller/actions/actions/camera-select';
import { CameraUIAction } from '../../../src/card-controller/actions/actions/camera-ui';
import { CustomAction } from '../../../src/card-controller/actions/actions/custom';
import { DefaultAction } from '../../../src/card-controller/actions/actions/default';
import { DisplayModeSelectAction } from '../../../src/card-controller/actions/actions/display-mode-select';
import { DownloadAction } from '../../../src/card-controller/actions/actions/download';
import { ExpandAction } from '../../../src/card-controller/actions/actions/expand';
import { FoldersViewAction } from '../../../src/card-controller/actions/actions/folders-view';
import { FullscreenAction } from '../../../src/card-controller/actions/actions/fullscreen';
import { InternalCallbackAction } from '../../../src/card-controller/actions/actions/internal-callback';
import { LogAction } from '../../../src/card-controller/actions/actions/log';
import { MediaPlayerAction } from '../../../src/card-controller/actions/actions/media-player';
import { MenuToggleAction } from '../../../src/card-controller/actions/actions/menu-toggle';
import { MicrophoneConnectAction } from '../../../src/card-controller/actions/actions/microphone-connect';
import { MicrophoneDisconnectAction } from '../../../src/card-controller/actions/actions/microphone-disconnect';
import { MicrophoneMuteAction } from '../../../src/card-controller/actions/actions/microphone-mute';
import { MicrophoneUnmuteAction } from '../../../src/card-controller/actions/actions/microphone-unmute';
import { MoreInfoAction } from '../../../src/card-controller/actions/actions/more-info';
import { MuteAction } from '../../../src/card-controller/actions/actions/mute';
import { NavigateAction } from '../../../src/card-controller/actions/actions/navigate';
import { NoneAction } from '../../../src/card-controller/actions/actions/none';
import { PauseAction } from '../../../src/card-controller/actions/actions/pause';
import { PerformActionAction } from '../../../src/card-controller/actions/actions/perform-action';
import { PlayAction } from '../../../src/card-controller/actions/actions/play';
import { PTZAction } from '../../../src/card-controller/actions/actions/ptz';
import { PTZControlsAction } from '../../../src/card-controller/actions/actions/ptz-controls';
import { PTZDigitalAction } from '../../../src/card-controller/actions/actions/ptz-digital';
import { PTZMultiAction } from '../../../src/card-controller/actions/actions/ptz-multi';
import { ScreenshotAction } from '../../../src/card-controller/actions/actions/screenshot';
import { SleepAction } from '../../../src/card-controller/actions/actions/sleep';
import { StatusBarAction } from '../../../src/card-controller/actions/actions/status-bar';
import { SubstreamOffAction } from '../../../src/card-controller/actions/actions/substream-off';
import { SubstreamOnAction } from '../../../src/card-controller/actions/actions/substream-on';
import { SubstreamSelectAction } from '../../../src/card-controller/actions/actions/substream-select';
import { ToggleAction } from '../../../src/card-controller/actions/actions/toggle';
import { UnmuteAction } from '../../../src/card-controller/actions/actions/unmute';
import { URLAction } from '../../../src/card-controller/actions/actions/url';
import { ViewAction } from '../../../src/card-controller/actions/actions/view';
import { ActionFactory } from '../../../src/card-controller/actions/factory';
import { INTERNAL_CALLBACK_ACTION } from '../../../src/config/schema/actions/custom/internal';
import { ActionConfig } from '../../../src/config/schema/actions/types';

// @vitest-environment jsdom
describe('ActionFactory', () => {
  it('mismatched card-id', () => {
    const factory = new ActionFactory();
    expect(
      factory.createAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'clip',
          card_id: 'card_id',
        },
        {
          cardID: 'different_card_id',
        },
      ),
    ).toBeNull();
  });

  describe('stock actions', () => {
    it.each([
      [{ action: 'more-info' as const }, MoreInfoAction],
      [{ action: 'toggle' as const }, ToggleAction],
      [{ action: 'navigate' as const, navigation_path: '/foo' }, NavigateAction],
      [{ action: 'url' as const, url_path: 'https://card.camera' }, URLAction],
      [
        { action: 'perform-action' as const, perform_action: 'action' },
        PerformActionAction,
      ],
      [{ action: 'call-service' as const, service: 'service' }, CallServiceAction],
      [{ action: 'none' as const }, NoneAction],
      [{ action: 'fire-dom-event' as const }, CustomAction],
    ])('action: $action', (action: ActionConfig, classObject: object) => {
      const factory = new ActionFactory();
      expect(factory.createAction({}, action)).toBeInstanceOf(classObject);
    });
  });

  describe('custom actions', () => {
    it.each([
      [{ advanced_camera_card_action: 'camera_select' as const }, CameraSelectAction],
      [{ advanced_camera_card_action: 'camera_ui' as const }, CameraUIAction],
      [{ advanced_camera_card_action: 'clip' as const }, ViewAction],
      [{ advanced_camera_card_action: 'clips' as const }, ViewAction],
      [{ advanced_camera_card_action: 'default' as const }, DefaultAction],
      [{ advanced_camera_card_action: 'diagnostics' as const }, ViewAction],
      [
        {
          advanced_camera_card_action: 'display_mode_select' as const,
          display_mode: 'single' as const,
        },
        DisplayModeSelectAction,
      ],
      [{ advanced_camera_card_action: 'download' as const }, DownloadAction],
      [{ advanced_camera_card_action: 'expand' as const }, ExpandAction],
      [{ advanced_camera_card_action: 'fullscreen' as const }, FullscreenAction],
      [{ advanced_camera_card_action: 'image' as const }, ViewAction],
      [
        { advanced_camera_card_action: 'live_substream_off' as const },
        SubstreamOffAction,
      ],
      [{ advanced_camera_card_action: 'live_substream_on' as const }, SubstreamOnAction],
      [
        {
          advanced_camera_card_action: 'live_substream_select' as const,
          camera: 'camera.office',
        },
        SubstreamSelectAction,
      ],
      [{ advanced_camera_card_action: 'live' as const }, ViewAction],
      [
        {
          advanced_camera_card_action: 'log' as const,
          message: 'Hello, world!' as const,
        },
        LogAction,
      ],
      [
        {
          advanced_camera_card_action: 'media_player' as const,
          media_player: 'media_player.foo' as const,
          media_player_action: 'play' as const,
        },
        MediaPlayerAction,
      ],
      [{ advanced_camera_card_action: 'menu_toggle' as const }, MenuToggleAction],
      [
        { advanced_camera_card_action: 'microphone_connect' as const },
        MicrophoneConnectAction,
      ],
      [
        { advanced_camera_card_action: 'microphone_disconnect' as const },
        MicrophoneDisconnectAction,
      ],
      [
        { advanced_camera_card_action: 'microphone_mute' as const },
        MicrophoneMuteAction,
      ],
      [
        { advanced_camera_card_action: 'microphone_unmute' as const },
        MicrophoneUnmuteAction,
      ],
      [{ advanced_camera_card_action: 'mute' as const }, MuteAction],
      [{ advanced_camera_card_action: 'pause' as const }, PauseAction],
      [{ advanced_camera_card_action: 'play' as const }, PlayAction],
      [{ advanced_camera_card_action: 'ptz_digital' as const }, PTZDigitalAction],
      [
        {
          advanced_camera_card_action: 'ptz_multi' as const,
          ptz_action: 'right' as const,
        },
        PTZMultiAction,
      ],
      [
        { advanced_camera_card_action: 'ptz' as const, ptz_action: 'right' as const },
        PTZAction,
      ],
      [{ advanced_camera_card_action: 'recording' as const }, ViewAction],
      [{ advanced_camera_card_action: 'recordings' as const }, ViewAction],
      [{ advanced_camera_card_action: 'screenshot' as const }, ScreenshotAction],
      [
        { advanced_camera_card_action: 'ptz_controls' as const, enabled: true },
        PTZControlsAction,
      ],
      [{ advanced_camera_card_action: 'sleep' as const }, SleepAction],
      [{ advanced_camera_card_action: 'snapshot' as const }, ViewAction],
      [{ advanced_camera_card_action: 'snapshots' as const }, ViewAction],
      [{ advanced_camera_card_action: 'timeline' as const }, ViewAction],
      [{ advanced_camera_card_action: 'unmute' as const }, UnmuteAction],
      [
        {
          advanced_camera_card_action: 'status_bar' as const,
          status_bar_action: 'reset',
        },
        StatusBarAction,
      ],
      [
        {
          advanced_camera_card_action: INTERNAL_CALLBACK_ACTION,
          callback: vi.fn(),
        },
        InternalCallbackAction,
      ],
      [{ advanced_camera_card_action: 'folder' as const }, FoldersViewAction],
      [{ advanced_camera_card_action: 'folders' as const }, FoldersViewAction],
    ])(
      'advanced_camera_card_action: $advanced_camera_card_action',
      (action: Partial<ActionConfig>, classObject: object) => {
        const factory = new ActionFactory();
        expect(
          factory.createAction({}, { ...action, action: 'fire-dom-event' }),
        ).toBeInstanceOf(classObject);
      },
    );
  });
});



================================================
FILE: tests/card-controller/actions/actions/base.test.ts
================================================
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { BaseAction } from '../../../../src/card-controller/actions/actions/base';
import { createViewAction } from '../../../../src/utils/action';
import { createCardAPI, createHASS, createUser } from '../../../test-utils';

describe('should handle base action', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  beforeAll(() => {
    vi.stubGlobal('confirm', vi.fn());
  });

  afterAll(() => {
    vi.unstubAllGlobals();
  });

  it('should construct', async () => {
    const api = createCardAPI();
    const action = new BaseAction(
      {},
      {
        action: 'fire-dom-event',
      },
    );

    await action.execute(api);
    await action.stop();

    // These methods have no observable effect on the base class, so this test is
    // currently only providing coverage and proof of no exceptions!
  });

  it('should not confirm when not necessary', async () => {
    const api = createCardAPI();
    const action = new BaseAction(
      {},
      {
        action: 'fire-dom-event',
      },
    );

    await action.execute(api);

    expect(confirm).not.toBeCalled();
  });

  it('should continue execution when confirmed', async () => {
    const api = createCardAPI();
    const action = new BaseAction(
      {},
      {
        action: 'fire-dom-event',
        confirmation: true,
      },
    );

    vi.mocked(confirm).mockReturnValue(true);

    await action.execute(api);

    expect(confirm).toBeCalled();
  });

  it('should abort execution when not confirmed', async () => {
    const api = createCardAPI();
    const action = new BaseAction(
      {},
      {
        action: 'fire-dom-event',
        confirmation: true,
      },
    );

    vi.mocked(confirm).mockReturnValue(false);

    expect(async () => await action.execute(api)).rejects.toThrowError(/Aborted action/);
  });

  it('should not confirm when exempted', async () => {
    const api = createCardAPI();
    const hass = createHASS({}, createUser({ id: 'user-id' }));
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

    const action = new BaseAction(
      {},
      {
        action: 'fire-dom-event',
        confirmation: {
          exemptions: [
            {
              user: 'user-id',
            },
          ],
        },
      },
    );

    await action.execute(api);

    expect(confirm).not.toBeCalled();
  });

  describe('should show correct confirmation text', () => {
    it('should show action name in confirmation text', async () => {
      const api = createCardAPI();
      const hass = createHASS({}, createUser({ id: 'user-id' }));
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const action = new BaseAction(
        {},
        {
          action: 'more-info',
          confirmation: true,
        },
      );

      vi.mocked(confirm).mockReturnValue(true);

      await action.execute(api);

      expect(confirm).toBeCalledWith(
        'Are you sure you want to perform this action: more-info',
      );
    });

    it('should show advanced camera card action name in confirmation text', async () => {
      const api = createCardAPI();
      const hass = createHASS({}, createUser({ id: 'user-id' }));
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const action = new BaseAction(
        {},
        {
          ...createViewAction('clips'),
          confirmation: true,
        },
      );

      vi.mocked(confirm).mockReturnValue(true);

      await action.execute(api);

      expect(confirm).toBeCalledWith(
        'Are you sure you want to perform this action: clips',
      );
    });

    it('should show configured confirmation text', async () => {
      const api = createCardAPI();
      const hass = createHASS({}, createUser({ id: 'user-id' }));
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const action = new BaseAction(
        {},
        {
          action: 'more-info',
          confirmation: {
            text: 'Test text',
          },
        },
      );

      vi.mocked(confirm).mockReturnValue(true);

      await action.execute(api);

      expect(confirm).toBeCalledWith('Test text');
    });
  });
});



================================================
FILE: tests/card-controller/actions/actions/call-service.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { CallServiceAction } from '../../../../src/card-controller/actions/actions/call-service';
import { createCardAPI, createHASS } from '../../../test-utils';

describe('CallServiceAction', () => {
  it('should call service', async () => {
    const api = createCardAPI();
    const hass = createHASS();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

    const action = new CallServiceAction(
      {},
      {
        action: 'call-service',
        service: 'light.turn_on',
        data: { brightness_pct: 80 },
        target: { entity_id: 'light.office' },
      },
    );
    await action.execute(api);

    expect(hass.callService).toBeCalledWith(
      'light',
      'turn_on',
      {
        brightness_pct: 80,
      },
      { entity_id: 'light.office' },
    );
  });

  it('should not call service without hass', async () => {
    const api = createCardAPI();

    const action = new CallServiceAction(
      {},
      {
        action: 'call-service',
        service: 'light.turn_on',
        data: { brightness_pct: 80 },
        target: { entity_id: 'light.office' },
      },
    );
    await action.execute(api);

    // No observable effect.
  });
});



================================================
FILE: tests/card-controller/actions/actions/camera-select.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { CameraSelectAction } from '../../../../src/card-controller/actions/actions/camera-select';
import { createCardAPI, createConfig, createView } from '../../../test-utils';

describe('should handle camera_select action', () => {
  it('with valid camera and view', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(createView());
    vi.mocked(api.getViewManager().isViewSupportedByCamera).mockReturnValue(true);

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
        camera: 'camera.office',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith(
      expect.objectContaining({
        params: {
          view: 'live',
          camera: 'camera.office',
        },
        failSafe: true,
      }),
    );
  });

  it('should ignore requests to change to the current camera', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        camera: 'camera.office',
      }),
    );
    vi.mocked(api.getViewManager().isViewSupportedByCamera).mockReturnValue(true);

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
        camera: 'camera.office',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
  });

  it('without config', async () => {
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(null);
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        view: 'timeline',
      }),
    );
    vi.mocked(api.getViewManager().isViewSupportedByCamera).mockReturnValue(true);

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
        camera: 'camera.office',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith(
      expect.objectContaining({
        params: {
          view: 'timeline',
          camera: 'camera.office',
        },
        failSafe: true,
      }),
    );
  });

  it('with target view', async () => {
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        view: {
          // Change to clips view when the camera changes.
          camera_select: 'clips',
        },
      }),
    );
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        view: 'live',
      }),
    );
    vi.mocked(api.getViewManager().isViewSupportedByCamera).mockReturnValue(true);

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
        camera: 'camera.office',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith(
      expect.objectContaining({
        params: {
          view: 'clips',
          camera: 'camera.office',
        },
        failSafe: true,
      }),
    );
  });

  it('with triggered camera', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(createView());
    vi.mocked(api.getViewManager().isViewSupportedByCamera).mockReturnValue(true);
    vi.mocked(api.getTriggersManager().getMostRecentlyTriggeredCameraID).mockReturnValue(
      'camera.office',
    );

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
        triggered: true,
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith(
      expect.objectContaining({
        params: {
          view: 'live',
          camera: 'camera.office',
        },
        failSafe: true,
      }),
    );
  });

  it('without camera or triggered camera', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(createView());
    vi.mocked(api.getViewManager().isViewSupportedByCamera).mockReturnValue(true);
    vi.mocked(api.getTriggersManager().getMostRecentlyTriggeredCameraID).mockReturnValue(
      'camera.office',
    );

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
  });

  it('without a current view', async () => {
    const api = createCardAPI();

    const action = new CameraSelectAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'camera_select',
        camera: 'camera',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/camera-ui.test.ts
================================================
import { expect, it } from 'vitest';
import { CameraUIAction } from '../../../../src/card-controller/actions/actions/camera-ui';
import { createCardAPI } from '../../../test-utils';

it('should handle camera_ui action', async () => {
  const api = createCardAPI();
  const action = new CameraUIAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'camera_ui',
    },
  );

  await action.execute(api);

  expect(api.getCameraURLManager().openURL).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/custom.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { CustomAction } from '../../../../src/card-controller/actions/actions/custom';
import { createCardAPI } from '../../../test-utils';

// @vitest-environment jsdom
describe('CustomAction', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should open the URL in a new window', async () => {
    const handler = vi.fn();
    const element = document.createElement('div');
    element.addEventListener('ll-custom', handler);

    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

    const action = new CustomAction(
      {},
      {
        action: 'fire-dom-event' as const,
        foo: 'bar',
        1: 2,
      },
      {},
    );

    await action.execute(api);

    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: { action: 'fire-dom-event', foo: 'bar', 1: 2 },
      }),
    );
  });
});



================================================
FILE: tests/card-controller/actions/actions/default.test.ts
================================================
import { expect, it } from 'vitest';
import { DefaultAction } from '../../../../src/card-controller/actions/actions/default';
import { createCardAPI } from '../../../test-utils';

it('should handle default action', async () => {
  const api = createCardAPI();
  const action = new DefaultAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'default',
    },
  );

  await action.execute(api);

  expect(api.getViewManager().setViewDefaultWithNewQuery).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/display-mode-select.test.ts
================================================
import { expect, it } from 'vitest';
import { DisplayModeSelectAction } from '../../../../src/card-controller/actions/actions/display-mode-select';
import { createCardAPI } from '../../../test-utils';

it('should handle default action', async () => {
  const api = createCardAPI();
  const action = new DisplayModeSelectAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'display_mode_select',
      display_mode: 'grid',
    },
  );

  await action.execute(api);

  expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith({
    params: {
      displayMode: 'grid',
    },
  });
});



================================================
FILE: tests/card-controller/actions/actions/download.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { DownloadAction } from '../../../../src/card-controller/actions/actions/download';
import { QueryResults } from '../../../../src/view/query-results';
import { createCardAPI, createView, TestViewMedia } from '../../../test-utils';

it('should handle download action with selected media', async () => {
  const api = createCardAPI();
  const selectedMedia = new TestViewMedia();
  vi.mocked(api.getViewManager().getView).mockReturnValue(
    createView({
      queryResults: new QueryResults({ results: [selectedMedia], selectedIndex: 0 }),
    }),
  );

  const action = new DownloadAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'download',
    },
  );

  await action.execute(api);

  expect(api.getViewItemManager().download).toBeCalledWith(selectedMedia);
});

it('should handle download action without selected media', async () => {
  const api = createCardAPI();
  vi.mocked(api.getViewManager().getView).mockReturnValue(createView());

  const action = new DownloadAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'download',
    },
  );

  await action.execute(api);

  expect(api.getViewItemManager().download).not.toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/expand.test.ts
================================================
import { expect, it } from 'vitest';
import { ExpandAction } from '../../../../src/card-controller/actions/actions/expand';
import { createCardAPI } from '../../../test-utils';

it('should handle expand action', async () => {
  const api = createCardAPI();
  const action = new ExpandAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'expand',
    },
  );

  await action.execute(api);

  expect(api.getExpandManager().toggleExpanded).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/folder.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { FoldersViewAction } from '../../../../src/card-controller/actions/actions/folders-view';
import { FolderQuery } from '../../../../src/card-controller/folders/types';
import { FolderViewQuery } from '../../../../src/view/query';
import { createCardAPI, createFolder } from '../../../test-utils';

describe('should handle folder action', async () => {
  it('should handle folder action successfully', async () => {
    const api = createCardAPI();
    const action = new FoldersViewAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'folder',
      },
    );

    const folder = createFolder();
    vi.mocked(api.getFoldersManager().getFolder).mockReturnValue(folder);

    const query: FolderQuery = {
      folder,
      path: [{ ha: { id: 'path' } }],
    };
    vi.mocked(api.getFoldersManager().generateDefaultFolderQuery).mockReturnValue(query);

    await action.execute(api);

    expect(
      api.getViewManager().setViewByParametersWithExistingQuery,
    ).toHaveBeenCalledWith({
      params: {
        view: 'folder',
        query: expect.any(FolderViewQuery),
      },
    });

    expect(
      vi
        .mocked(api.getViewManager().setViewByParametersWithExistingQuery)
        .mock.calls[0][0]?.params?.query?.getQuery(),
    ).toBe(query);
  });

  it('should do nothing with non-existent folder', async () => {
    const api = createCardAPI();
    const action = new FoldersViewAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'folder',
        folder: 'NON-EXISTENT-FOLDER',
      },
    );

    vi.mocked(api.getFoldersManager().getFolder).mockReturnValue(null);

    await action.execute(api);

    expect(
      api.getViewManager().setViewByParametersWithExistingQuery,
    ).not.toHaveBeenCalled();
  });

  it('should do nothing with non-existent default query', async () => {
    const api = createCardAPI();
    const action = new FoldersViewAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'folder',
      },
    );

    const folder = createFolder();
    vi.mocked(api.getFoldersManager().getFolder).mockReturnValue(folder);

    vi.mocked(api.getFoldersManager().generateDefaultFolderQuery).mockReturnValue(null);

    await action.execute(api);

    expect(
      api.getViewManager().setViewByParametersWithExistingQuery,
    ).not.toHaveBeenCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/fullscreen.test.ts
================================================
import { expect, it } from 'vitest';
import { FullscreenAction } from '../../../../src/card-controller/actions/actions/fullscreen';
import { createCardAPI } from '../../../test-utils';

it('should handle fullscreen action', async () => {
  const api = createCardAPI();
  const action = new FullscreenAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'fullscreen',
    },
  );

  await action.execute(api);

  expect(api.getFullscreenManager().toggleFullscreen).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/internal-callback.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { InternalCallbackAction } from '../../../../src/card-controller/actions/actions/internal-callback';
import { INTERNAL_CALLBACK_ACTION } from '../../../../src/config/schema/actions/custom/internal';
import { createCardAPI } from '../../../test-utils';

it('should handle internal callback action', async () => {
  const api = createCardAPI();
  const callback = vi.fn();
  const action = new InternalCallbackAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: INTERNAL_CALLBACK_ACTION,
      callback: callback,
    },
  );

  await action.execute(api);

  expect(callback).toBeCalledWith(api);
});



================================================
FILE: tests/card-controller/actions/actions/log.test.ts
================================================
import { afterEach, expect, it, vi } from 'vitest';
import { LogAction } from '../../../../src/card-controller/actions/actions/log';
import { createCardAPI } from '../../../test-utils';

afterEach(() => {
  vi.resetAllMocks();
});

it('should handle log action', async () => {
  const api = createCardAPI();
  const action = new LogAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'log',
      message: 'Hello, world!',
      level: 'warn',
    },
  );

  const spy = vi.spyOn(global.console, 'warn').mockImplementation(() => true);
  await action.execute(api);
  expect(spy).toBeCalledWith('Hello, world!');
});



================================================
FILE: tests/card-controller/actions/actions/media-player.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { MediaPlayerAction } from '../../../../src/card-controller/actions/actions/media-player';
import { createCardAPI, createView, createViewWithMedia } from '../../../test-utils';

afterEach(() => {
  vi.resetAllMocks();
});

describe('should handle media_player action', () => {
  it('to stop', async () => {
    const api = createCardAPI();

    const action = new MediaPlayerAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'media_player',
        media_player_action: 'stop',
        media_player: 'this_is_a_media_player',
      },
    );

    await action.execute(api);

    expect(api.getMediaPlayerManager().stop).toBeCalledWith('this_is_a_media_player');
  });

  it('to play live', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        camera: 'camera',
        view: 'live',
      }),
    );

    const action = new MediaPlayerAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'media_player',
        media_player_action: 'play',
        media_player: 'this_is_a_media_player',
      },
    );

    await action.execute(api);

    expect(api.getMediaPlayerManager().playLive).toBeCalledWith(
      'this_is_a_media_player',
      'camera',
    );
  });

  it('to play media', async () => {
    const api = createCardAPI();
    const view = createViewWithMedia({
      camera: 'camera',
      view: 'media',
    });

    vi.mocked(api.getViewManager().getView).mockReturnValue(view);

    const action = new MediaPlayerAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'media_player',
        media_player_action: 'play',
        media_player: 'this_is_a_media_player',
      },
    );

    await action.execute(api);

    expect(api.getMediaPlayerManager().playMedia).toBeCalledWith(
      'this_is_a_media_player',
      view.queryResults?.getSelectedResult(),
    );
  });

  it('to play media without selected media', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        view: 'media',
      }),
    );

    const action = new MediaPlayerAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'media_player',
        media_player_action: 'play',
        media_player: 'this_is_a_media_player',
      },
    );

    await action.execute(api);

    expect(api.getMediaPlayerManager().playMedia).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/menu-toggle.test.ts
================================================
import { expect, it } from 'vitest';
import { MenuToggleAction } from '../../../../src/card-controller/actions/actions/menu-toggle';
import { createCardAPI } from '../../../test-utils';

it('should handle menu toggle action', async () => {
  const api = createCardAPI();
  const action = new MenuToggleAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'menu_toggle',
    },
  );

  await action.execute(api);

  expect(api.getCardElementManager().toggleMenu).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/microphone-connect.test.ts
================================================
import { expect, it } from 'vitest';
import { MicrophoneConnectAction } from '../../../../src/card-controller/actions/actions/microphone-connect';
import { createCardAPI } from '../../../test-utils';

it('should handle microphone_connect action', async () => {
  const api = createCardAPI();
  const action = new MicrophoneConnectAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'microphone_connect',
    },
  );

  await action.execute(api);

  expect(api.getMicrophoneManager().connect).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/microphone-disconnect.test.ts
================================================
import { expect, it } from 'vitest';
import { MicrophoneDisconnectAction } from '../../../../src/card-controller/actions/actions/microphone-disconnect';
import { createCardAPI } from '../../../test-utils';

it('should handle microphone_disconnect action', async () => {
  const api = createCardAPI();
  const action = new MicrophoneDisconnectAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'microphone_disconnect',
    },
  );

  await action.execute(api);

  expect(api.getMicrophoneManager().disconnect).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/microphone-mute.test.ts
================================================
import { expect, it } from 'vitest';
import { MicrophoneMuteAction } from '../../../../src/card-controller/actions/actions/microphone-mute';
import { createCardAPI } from '../../../test-utils';

it('should handle microphone_mute action', async () => {
  const api = createCardAPI();
  const action = new MicrophoneMuteAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'microphone_mute',
    },
  );

  await action.execute(api);

  expect(api.getMicrophoneManager().mute).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/microphone-unmute.test.ts
================================================
import { expect, it } from 'vitest';
import { createCardAPI } from '../../../test-utils';
import { MicrophoneUnmuteAction } from '../../../../src/card-controller/actions/actions/microphone-unmute';

it('should handle microphone_unmute action', async () => {
  const api = createCardAPI();
  const action = new MicrophoneUnmuteAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'microphone_unmute',
    },
  );

  await action.execute(api);

  expect(api.getMicrophoneManager().unmute).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/more-info.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { MoreInfoAction } from '../../../../src/card-controller/actions/actions/more-info';
import { createCardAPI } from '../../../test-utils';

// @vitest-environment jsdom
describe('should handle more-info action', () => {
  it('should handle more-info with entity in action', async () => {
    const handler = vi.fn();
    const element = document.createElement('div');
    element.addEventListener('hass-more-info', handler);

    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

    const action = new MoreInfoAction(
      {},
      {
        action: 'more-info',
        entity: 'light.office',
      },
      {},
    );

    await action.execute(api);

    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: { entityId: 'light.office' },
      }),
    );
  });

  it('should handle more-info with entity in auxilliary config', async () => {
    const handler = vi.fn();
    const element = document.createElement('div');
    element.addEventListener('hass-more-info', handler);

    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

    const action = new MoreInfoAction(
      {},
      {
        action: 'more-info',
      },
      {
        entity: 'light.office',
      },
    );

    await action.execute(api);

    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: { entityId: 'light.office' },
      }),
    );
  });

  it('should take no action with any entity', async () => {
    const handler = vi.fn();
    const element = document.createElement('div');
    element.addEventListener('hass-more-info', handler);

    const api = createCardAPI();
    vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);

    const action = new MoreInfoAction(
      {},
      {
        action: 'more-info',
      },
      {},
    );

    await action.execute(api);

    expect(handler).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/mute.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { MuteAction } from '../../../../src/card-controller/actions/actions/mute';
import { MediaPlayerController } from '../../../../src/types';
import { createCardAPI, createMediaLoadedInfo } from '../../../test-utils';

it('should handle mute action', async () => {
  const api = createCardAPI();
  const mediaPlayerController = mock<MediaPlayerController>();
  vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
    createMediaLoadedInfo({
      mediaPlayerController,
    }),
  );
  const action = new MuteAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'mute',
    },
  );

  await action.execute(api);

  expect(mediaPlayerController.mute).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/navigate.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { NavigateAction } from '../../../../src/card-controller/actions/actions/navigate';
import { createCardAPI } from '../../../test-utils';

// @vitest-environment jsdom
describe('should handle navigate action', () => {
  it('should handle navigate action', async () => {
    const handler = vi.fn();
    window.addEventListener('location-changed', handler);

    const action = new NavigateAction(
      {},
      {
        action: 'navigate',
        navigation_path: '/path',
      },
      {},
    );

    const historyLength = history.length;

    await action.execute(createCardAPI());

    expect(history.length).toBe(historyLength + 1);
    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: { replace: false },
      }),
    );
  });

  it('should handle navigate action that replaces', async () => {
    const handler = vi.fn();
    window.addEventListener('location-changed', handler);

    const action = new NavigateAction(
      {},
      {
        action: 'navigate',
        navigation_path: '/path',
        navigation_replace: true,
      },
      {},
    );

    const historyLength = history.length;

    await action.execute(createCardAPI());

    expect(history.length).toBe(historyLength);
    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: { replace: true },
      }),
    );
  });
});



================================================
FILE: tests/card-controller/actions/actions/none.test.ts
================================================
import { it } from 'vitest';
import { NoneAction } from '../../../../src/card-controller/actions/actions/none';
import { createCardAPI } from '../../../test-utils';

it('should handle none action', async () => {
  const api = createCardAPI();
  const action = new NoneAction(
    {},
    {
      action: 'none' as const,
    },
  );

  await action.execute(api);

  // No observable side effects.
});



================================================
FILE: tests/card-controller/actions/actions/pause.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { PauseAction } from '../../../../src/card-controller/actions/actions/pause';
import { MediaPlayerController } from '../../../../src/types';
import { createCardAPI, createMediaLoadedInfo } from '../../../test-utils';

it('should handle pause action', async () => {
  const api = createCardAPI();
  const mediaPlayerController = mock<MediaPlayerController>();
  vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
    createMediaLoadedInfo({
      mediaPlayerController,
    }),
  );
  const action = new PauseAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'pause',
    },
  );

  await action.execute(api);

  expect(mediaPlayerController.pause).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/perform-action.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { createCardAPI, createHASS } from '../../../test-utils';
import { PerformActionAction } from '../../../../src/card-controller/actions/actions/perform-action';

describe('PerformActionAction', () => {
  it('should perform action', async () => {
    const api = createCardAPI();
    const hass = createHASS();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

    const action = new PerformActionAction(
      {},
      {
        action: 'perform-action',
        perform_action: 'light.turn_on',
        data: { brightness_pct: 80 },
        target: { entity_id: 'light.office' },
      },
    );
    await action.execute(api);

    expect(hass.callService).toBeCalledWith(
      'light',
      'turn_on',
      {
        brightness_pct: 80,
      },
      { entity_id: 'light.office' },
    );
  });

  it('should not perform action without hass', async () => {
    const api = createCardAPI();

    const action = new PerformActionAction(
      {},
      {
        action: 'perform-action',
        perform_action: 'light.turn_on',
        data: { brightness_pct: 80 },
        target: { entity_id: 'light.office' },
      },
    );
    await action.execute(api);

    // No observable effect.
  });
});



================================================
FILE: tests/card-controller/actions/actions/play.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { PlayAction } from '../../../../src/card-controller/actions/actions/play';
import { MediaPlayerController } from '../../../../src/types';
import { createCardAPI, createMediaLoadedInfo } from '../../../test-utils';

it('should handle play action', async () => {
  const api = createCardAPI();
  const mediaPlayerController = mock<MediaPlayerController>();
  vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
    createMediaLoadedInfo({
      mediaPlayerController,
    }),
  );
  const action = new PlayAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'play',
    },
  );

  await action.execute(api);

  expect(mediaPlayerController.play).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/ptz-controls.test.ts
================================================
import { expect, it } from 'vitest';
import { createCardAPI } from '../../../test-utils';
import { PTZControlsAction } from '../../../../src/card-controller/actions/actions/ptz-controls';

it('should handle ptz_controls action', async () => {
  const api = createCardAPI();
  const action = new PTZControlsAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz_controls',
      enabled: true,
    },
  );

  await action.execute(api);

  expect(api.getViewManager().setViewWithMergedContext).toBeCalledWith(
    expect.objectContaining({ ptzControls: { enabled: true } }),
  );
});



================================================
FILE: tests/card-controller/actions/actions/ptz-digital.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { PTZDigitalAction } from '../../../../src/card-controller/actions/actions/ptz-digital';
import {
  PartialZoomSettings,
  ZoomSettingsObserved,
} from '../../../../src/components-lib/zoom/types';
import { PTZAction } from '../../../../src/config/ptz';
import { createCardAPI, createView } from '../../../test-utils';

describe('should handle ptz digital action', () => {
  const defaultSettings = {
    pan: {
      x: 50,
      y: 50,
    },
    zoom: 1,
  };

  const createObserved = (
    observed?: Partial<ZoomSettingsObserved>,
  ): ZoomSettingsObserved => ({
    ...defaultSettings,
    isDefault: true,
    unzoomed: true,
    ...observed,
  });

  it('should honor absolute parameters', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(createView());

    const action = new PTZDigitalAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_digital',
        absolute: {
          zoom: 2,
          pan: {
            x: 3,
            y: 4,
          },
        },
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewWithMergedContext).toBeCalledWith({
      zoom: {
        camera: {
          observed: undefined,
          requested: {
            pan: {
              x: 3,
              y: 4,
            },
            zoom: 2,
          },
        },
      },
    });
  });

  it('should return to default without absolute parameters or action', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(createView());

    const action = new PTZDigitalAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_digital',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewWithMergedContext).toBeCalledWith({
      zoom: {
        camera: {
          observed: undefined,
          requested: {},
        },
      },
    });
  });

  it('should do nothing without a view', async () => {
    const api = createCardAPI();

    const action = new PTZDigitalAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_digital',
        ptz_action: 'left',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewWithMergedContext).not.toBeCalledWith();
  });

  it('should do nothing without a camera', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        // There is no media associated with a timeline, so there's no camera to
        // change the PTZ settings for.
        view: 'timeline',
      }),
    );

    const action = new PTZDigitalAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_digital',
        ptz_action: 'left',
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewWithMergedContext).not.toBeCalled();
  });

  describe('should honor ptz_action', () => {
    it.each([
      [
        'zoom_in',
        'zoom_in' as const,
        {
          zoom: 1.1,
        },
        createObserved(),
      ],
      [
        'zoom_in at maximum zoom',
        'zoom_in' as const,
        {
          zoom: 10,
        },
        createObserved({
          zoom: 10,
        }),
      ],
      [
        'zoom_out',
        'zoom_out' as const,
        {
          zoom: 1.9,
        },
        createObserved({
          zoom: 2,
        }),
      ],
      [
        'zoom_out at minimum zoom',
        'zoom_out' as const,
        {
          zoom: 1,
        },
        createObserved({
          zoom: 1,
        }),
      ],
      [
        'left',
        'left' as const,
        {
          pan: {
            x: 45,
            y: 50,
          },
        },
        createObserved({
          pan: {
            x: 50,
            y: 50,
          },
        }),
      ],
      [
        'left at left edge',
        'left' as const,
        {
          pan: {
            x: 0,
            y: 50,
          },
        },
        createObserved({
          pan: {
            x: 0,
            y: 50,
          },
        }),
      ],
      [
        'right',
        'right' as const,
        {
          pan: {
            x: 55,
            y: 50,
          },
        },
        createObserved({
          pan: {
            x: 50,
            y: 50,
          },
        }),
      ],
      [
        'right at right edge',
        'right' as const,
        {
          pan: {
            x: 100,
            y: 50,
          },
        },
        createObserved({
          pan: {
            x: 100,
            y: 50,
          },
        }),
      ],
      [
        'up',
        'up' as const,
        {
          pan: {
            x: 50,
            y: 45,
          },
        },
        createObserved({
          pan: {
            x: 50,
            y: 50,
          },
        }),
      ],
      [
        'up at top edge',
        'up' as const,
        {
          pan: {
            x: 50,
            y: 0,
          },
        },
        createObserved({
          pan: {
            x: 50,
            y: 0,
          },
        }),
      ],
      [
        'down',
        'down' as const,
        {
          pan: {
            x: 50,
            y: 55,
          },
        },
        createObserved({
          pan: {
            x: 50,
            y: 50,
          },
        }),
      ],
      [
        'down at bottom edge',
        'down' as const,
        {
          pan: {
            x: 50,
            y: 100,
          },
        },
        createObserved({
          pan: {
            x: 50,
            y: 100,
          },
        }),
      ],
      [
        'action with undefined observed',
        'down' as const,
        {
          pan: {
            x: 50,
            y: 55,
          },
        },
      ],
    ])(
      '%s',
      async (
        _testTitle: string,
        ptzAction: PTZAction,
        expectedSettings: PartialZoomSettings,
        current?: ZoomSettingsObserved,
      ) => {
        const api = createCardAPI();
        vi.mocked(api.getViewManager().getView).mockReturnValue(
          createView({
            context: {
              zoom: {
                camera: {
                  observed: current,
                },
              },
            },
          }),
        );

        const action = new PTZDigitalAction(
          {},
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_digital',
            ptz_action: ptzAction,
          },
        );

        await action.execute(api);

        expect(api.getViewManager().setViewWithMergedContext).toBeCalledWith({
          zoom: {
            camera: {
              observed: undefined,
              requested: {
                ...defaultSettings,
                ...expectedSettings,
              },
            },
          },
        });
      },
    );
  });

  // @vitest-environment jsdom
  describe('should honor ptz_phase', () => {
    beforeAll(() => {
      vi.useFakeTimers();
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    it('start', async () => {
      const api = createCardAPI();
      vi.mocked(api.getViewManager().getView).mockReturnValue(createView());

      const action = new PTZDigitalAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_digital',
          ptz_action: 'right',
          ptz_phase: 'start',
        },
      );

      await action.execute(api);

      expect(api.getViewManager().setViewWithMergedContext).toHaveBeenLastCalledWith({
        zoom: {
          camera: {
            observed: undefined,
            requested: {
              ...defaultSettings,
              pan: {
                x: 55,
                y: 50,
              },
            },
          },
        },
      });

      // Update the context to reflect the first step.
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({
          context: {
            zoom: {
              camera: {
                observed: createObserved({
                  pan: {
                    x: 55,
                    y: 50,
                  },
                }),
              },
            },
          },
        }),
      );

      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewWithMergedContext).toHaveBeenLastCalledWith({
        zoom: {
          camera: {
            observed: undefined,
            requested: {
              ...defaultSettings,
              pan: {
                x: 60,
                y: 50,
              },
            },
          },
        },
      });
      expect(api.getViewManager().setViewWithMergedContext).toBeCalledTimes(2);

      action.stop();
      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewWithMergedContext).toBeCalledTimes(2);
    });

    it('stop', async () => {
      const api = createCardAPI();
      const context = {};
      vi.mocked(api.getViewManager().getView).mockReturnValue(createView());

      const startAction = new PTZDigitalAction(context, {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_digital',
        ptz_action: 'right',
        ptz_phase: 'start',
      });
      await startAction.execute(api);

      expect(api.getViewManager().setViewWithMergedContext).toHaveBeenLastCalledWith({
        zoom: {
          camera: {
            observed: undefined,
            requested: {
              ...defaultSettings,
              pan: {
                x: 55,
                y: 50,
              },
            },
          },
        },
      });
      expect(api.getViewManager().setViewWithMergedContext).toBeCalledTimes(1);

      const stopAction = new PTZDigitalAction(context, {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_digital',
        ptz_phase: 'stop',
      });
      await stopAction.execute(api);

      vi.runOnlyPendingTimers();

      expect(api.getViewManager().setViewWithMergedContext).toBeCalledTimes(1);
    });
  });
});



================================================
FILE: tests/card-controller/actions/actions/ptz-multi.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { Capabilities } from '../../../../src/camera-manager/capabilities';
import { PTZMultiAction } from '../../../../src/card-controller/actions/actions/ptz-multi';
import {
  createCameraManager,
  createCardAPI,
  createStore,
  createView,
} from '../../../test-utils';

describe('should handle ptz multi action', () => {
  describe.each([
    ['with explicit target_id', 'camera.office'],
    ['without explicit target_id', null],
  ])('%s', async (_testTitle: string, targetID: string | null) => {
    it('should use real ptz when camera has ptz support', async () => {
      const api = createCardAPI();
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({
          camera: 'camera.office',
        }),
      );
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({ ptz: { left: ['relative'] } }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));

      const action = new PTZMultiAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_multi',
          ptz_action: 'left',
          ...(targetID && { target_id: targetID }),
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office',
        'left',
        {
          phase: undefined,
          preset: undefined,
        },
      );
      expect(api.getViewManager().setViewWithMergedContext).not.toBeCalled();
    });

    it('should use digital ptz when camera does not have ptz support', async () => {
      const api = createCardAPI();
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({
          camera: 'camera.office',
        }),
      );
      const store = createStore([
        {
          cameraID: 'camera.office',
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));

      const action = new PTZMultiAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_multi',
          ptz_action: 'right',
          ...(targetID && { target_id: targetID }),
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).not.toBeCalled();
      expect(api.getViewManager().setViewWithMergedContext).toHaveBeenLastCalledWith({
        zoom: {
          'camera.office': {
            observed: undefined,
            requested: expect.objectContaining({
              pan: {
                x: 55,
                y: 50,
              },
              zoom: 1,
            }),
          },
        },
      });
    });
  });

  it('should do nothing without a view or explicit target_id', async () => {
    const api = createCardAPI();
    const store = createStore([
      {
        cameraID: 'camera.office',
      },
    ]);
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));

    const action = new PTZMultiAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_multi',
        ptz_action: 'right',
      },
    );

    await action.execute(api);

    expect(api.getCameraManager().executePTZAction).not.toBeCalled();
    expect(api.getViewManager().setViewWithMergedContext).not.toBeCalled();
  });

  it('should do nothing with a media-less view without an explicit target_id', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        view: 'timeline',
      }),
    );
    const store = createStore([
      {
        cameraID: 'camera.office',
      },
    ]);
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));

    const action = new PTZMultiAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz_multi',
        ptz_action: 'right',
      },
    );

    await action.execute(api);

    expect(api.getCameraManager().executePTZAction).not.toBeCalled();
    expect(api.getViewManager().setViewWithMergedContext).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/ptz.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { Capabilities } from '../../../../src/camera-manager/capabilities';
import { PTZAction } from '../../../../src/card-controller/actions/actions/ptz';
import { PTZMovementType } from '../../../../src/types';
import {
  createCameraConfig,
  createCameraManager,
  createCardAPI,
  createStore,
  createView,
} from '../../../test-utils';

describe('should handle ptz action', () => {
  it('should execute simple action', async () => {
    const api = createCardAPI();
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({
        camera: 'camera.office',
      }),
    );
    const store = createStore([
      {
        cameraID: 'camera.office',
        capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
      },
    ]);
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));

    const action = new PTZAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
        camera: 'camera.office',
      },
    );

    await action.execute(api);

    expect(api.getCameraManager().executePTZAction).toBeCalledWith(
      'camera.office',
      'left',
      {
        phase: undefined,
        preset: undefined,
      },
    );
  });

  describe('without explicit camera', () => {
    it('when current camera supports PTZ', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const action = new PTZAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz',
          ptz_action: 'left',
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office',
        'left',
        {
          phase: undefined,
          preset: undefined,
        },
      );
    });

    it('when substream supports PTZ', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          config: createCameraConfig({
            dependencies: { cameras: ['camera.office_hd'] },
          }),
        },
        {
          cameraID: 'camera.office_hd',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({
          camera: 'camera.office',
          context: {
            live: {
              overrides: new Map([['camera.office', 'camera.office_hd']]),
            },
          },
        }),
      );

      const action = new PTZAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz',
          ptz_action: 'left',
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office_hd',
        'left',
        {
          phase: undefined,
          preset: undefined,
        },
      );
    });

    it('when no camera supports PTZ', async () => {
      const api = createCardAPI();
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const action = new PTZAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz',
          ptz_action: 'left',
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).not.toBeCalled();
    });
  });

  it('when there is no view', async () => {
    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());

    const action = new PTZAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
      },
    );

    await action.execute(api);

    expect(api.getCameraManager().executePTZAction).not.toBeCalled();
  });

  describe('when there is no action', () => {
    it('should call first preset', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({ ptz: { presets: ['home'] } }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const action = new PTZAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz',
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office',
        'preset',
        {
          phase: undefined,
          preset: 'home',
        },
      );
    });

    it('should not call preset when there are no presets', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Relative],
              presets: [],
            },
          }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const action = new PTZAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz',
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).not.toBeCalled();
    });
  });

  it('should execute preset', async () => {
    const api = createCardAPI();
    const store = createStore([
      {
        cameraID: 'camera.office',
        capabilities: new Capabilities({
          ptz: {
            presets: ['window'],
          },
        }),
      },
    ]);
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({ camera: 'camera.office' }),
    );

    const action = new PTZAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'preset',
        ptz_preset: 'window',
      },
    );

    await action.execute(api);

    expect(api.getCameraManager().executePTZAction).toBeCalledWith(
      'camera.office',
      'preset',
      {
        phase: undefined,
        preset: 'window',
      },
    );
  });

  it('should execute action with phase', async () => {
    const api = createCardAPI();
    const store = createStore([
      {
        cameraID: 'camera.office',
        capabilities: new Capabilities({
          ptz: {
            left: [PTZMovementType.Continuous],
          },
        }),
      },
    ]);
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
    vi.mocked(api.getViewManager().getView).mockReturnValue(
      createView({ camera: 'camera.office' }),
    );

    const action = new PTZAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
        ptz_phase: 'start',
      },
    );

    await action.execute(api);

    expect(api.getCameraManager().executePTZAction).toBeCalledWith(
      'camera.office',
      'left',
      {
        phase: 'start',
      },
    );
  });

  // @vitest-environment jsdom
  describe('when relative is requested but unsupported', () => {
    beforeAll(() => {
      vi.useFakeTimers();
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    it('should emulate relative', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Continuous],
            },
          }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const action = new PTZAction(
        {},
        {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz',
          ptz_action: 'left',
        },
      );

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office',
        'left',
        {
          phase: 'start',
        },
      );

      vi.runOnlyPendingTimers();
      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office',
        'left',
        {
          phase: 'stop',
        },
      );
    });

    it('should honor stop', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Continuous],
            },
          }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const context = {};
      const action = new PTZAction(context, {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
      });

      await action.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(1);

      action.stop();
      vi.runOnlyPendingTimers();

      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(1);
    });
  });

  describe('when continuous is requested but unsupported', () => {
    beforeAll(() => {
      vi.useFakeTimers();
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    it('should emulate continuous', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Relative],
            },
          }),
        },
      ]);
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager(store));
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const context = {};
      const startAction = new PTZAction(context, {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
        ptz_phase: 'start',
      });
      await startAction.execute(api);

      expect(api.getCameraManager().executePTZAction).toBeCalledWith(
        'camera.office',
        'left',
        {
          phase: undefined,
        },
      );
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(1);

      await vi.runOnlyPendingTimersAsync();
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(2);

      await vi.runOnlyPendingTimersAsync();
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(3);

      const stopAction = new PTZAction(context, {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
        ptz_phase: 'stop',
      });
      await stopAction.execute(api);

      // There should be no additional calls.
      await vi.runOnlyPendingTimersAsync();
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(3);
    });

    it('should honor stop', async () => {
      const api = createCardAPI();
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Relative],
            },
          }),
        },
      ]);
      const cameraManager = createCameraManager(store);
      vi.mocked(api.getCameraManager).mockReturnValue(cameraManager);
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({ camera: 'camera.office' }),
      );

      const context = {};
      const action = new PTZAction(context, {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'left',
        ptz_phase: 'start',
      });

      await action.execute(api);
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(1);

      await vi.runOnlyPendingTimersAsync();
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(2);

      // Emulate the stop being called while the action is running, but before
      // the *next* timer is scheduled.
      let resolve: () => void;
      const promise: Promise<void> = new Promise((_resolve) => {
        resolve = _resolve;
      });
      vi.mocked(cameraManager.executePTZAction).mockReturnValueOnce(promise);

      await vi.runOnlyPendingTimersAsync();
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(3);

      action.stop();

      resolve!();
      await vi.runOnlyPendingTimersAsync();

      // There should be no additional calls.
      expect(api.getCameraManager().executePTZAction).toBeCalledTimes(3);
    });
  });
});



================================================
FILE: tests/card-controller/actions/actions/screenshot.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { ScreenshotAction } from '../../../../src/card-controller/actions/actions/screenshot';
import { MediaPlayerController } from '../../../../src/types';
import { downloadURL } from '../../../../src/utils/download';
import { createCardAPI, createMediaLoadedInfo } from '../../../test-utils';

vi.mock('../../../../src/utils/download');

describe('should handle screenshot action', async () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should handle screenshot action with screenshot URL', async () => {
    const api = createCardAPI();
    const action = new ScreenshotAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'screenshot',
      },
    );

    const mediaPlayerController = mock<MediaPlayerController>();
    mediaPlayerController.getScreenshotURL.mockResolvedValue('screenshot-url');

    vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
      createMediaLoadedInfo({
        mediaPlayerController,
      }),
    );

    await action.execute(api);

    expect(downloadURL).toBeCalledWith('screenshot-url', 'screenshot.jpg');
  });

  it('should handle screenshot action without screenshot URL', async () => {
    const api = createCardAPI();
    const action = new ScreenshotAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'screenshot',
      },
    );

    const mediaPlayerController = mock<MediaPlayerController>();
    mediaPlayerController.getScreenshotURL.mockResolvedValue(null);

    vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
      createMediaLoadedInfo({
        mediaPlayerController,
      }),
    );

    await action.execute(api);

    expect(downloadURL).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/set.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { ActionSet } from '../../../../src/card-controller/actions/actions/set';
import { createLogAction } from '../../../../src/utils/action';
import { createCardAPI } from '../../../test-utils';

describe('ActionSet', () => {
  it('should execute single action', async () => {
    const api = createCardAPI();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const set = new ActionSet({}, createLogAction('Hello, world!'));

    const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
    await set.execute(api);
    expect(consoleSpy).toBeCalled();
  });

  it('should not execute invalid action', async () => {
    const api = createCardAPI();
    const set = new ActionSet(
      {},
      createLogAction('Hello, world!', {
        cardID: 'another-card',
      }),
    );

    const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
    await set.execute(api);
    expect(consoleSpy).not.toBeCalled();
  });

  it('should stop execution', async () => {
    const api = createCardAPI();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const set = new ActionSet({}, createLogAction('Hello, world!'));

    const consoleSpy = vi.spyOn(global.console, 'info').mockReturnValue(undefined);
    await set.stop();
    await set.execute(api);
    expect(consoleSpy).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/sleep.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { SleepAction } from '../../../../src/card-controller/actions/actions/sleep';
import { sleep } from '../../../../src/utils/sleep';
import { createCardAPI } from '../../../test-utils';

vi.mock('../../../../src/utils/sleep');

it('should handle sleep action', async () => {
  const api = createCardAPI();
  const action = new SleepAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'sleep',
      duration: {
        s: 5,
        ms: 200,
      },
    },
  );

  await action.execute(api);

  expect(sleep).toBeCalledWith(5.2);
});



================================================
FILE: tests/card-controller/actions/actions/status-bar.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { StatusBarAction } from '../../../../src/card-controller/actions/actions/status-bar';
import { createCardAPI } from '../../../test-utils';

describe('should handle status bar action', () => {
  it('reset', async () => {
    const api = createCardAPI();
    const action = new StatusBarAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'status_bar',
        status_bar_action: 'reset',
      },
    );

    await action.execute(api);

    expect(api.getStatusBarItemManager().removeAllDynamicStatusBarItems).toBeCalled();
  });

  it('add', async () => {
    const api = createCardAPI();
    const item = {
      type: 'custom:advanced-camera-card-status-bar-string',
      string: 'Item',
    };

    const action = new StatusBarAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'status_bar',
        status_bar_action: 'add',
        items: [item],
      },
    );

    await action.execute(api);

    expect(api.getStatusBarItemManager().addDynamicStatusBarItem).toBeCalledWith(item);
  });

  it('remove', async () => {
    const api = createCardAPI();
    const item = {
      type: 'custom:advanced-camera-card-status-bar-string',
      string: 'Item',
    };

    const action = new StatusBarAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'status_bar',
        status_bar_action: 'remove',
        items: [item],
      },
    );

    await action.execute(api);

    expect(api.getStatusBarItemManager().removeDynamicStatusBarItem).toBeCalledWith(
      item,
    );
  });
});



================================================
FILE: tests/card-controller/actions/actions/substream-off.test.ts
================================================
import { expect, it } from 'vitest';
import { SubstreamOffAction } from '../../../../src/card-controller/actions/actions/substream-off';
import { createCardAPI } from '../../../test-utils';
import { SubstreamOffViewModifier } from '../../../../src/card-controller/view/modifiers/substream-off';

it('should handle live_substream_off action', async () => {
  const api = createCardAPI();
  const action = new SubstreamOffAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'live_substream_off',
    },
  );

  await action.execute(api);

  expect(api.getViewManager().setViewByParameters).toBeCalledWith({
    modifiers: [expect.any(SubstreamOffViewModifier)],
  });
});



================================================
FILE: tests/card-controller/actions/actions/substream-on.test.ts
================================================
import { expect, it } from 'vitest';
import { SubstreamOnAction } from '../../../../src/card-controller/actions/actions/substream-on';
import { createCardAPI } from '../../../test-utils';
import { SubstreamOnViewModifier } from '../../../../src/card-controller/view/modifiers/substream-on';

it('should handle live_substream_on action', async () => {
  const api = createCardAPI();
  const action = new SubstreamOnAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'live_substream_on',
    },
  );

  await action.execute(api);

  expect(api.getViewManager().setViewByParameters).toBeCalledWith({
    modifiers: [expect.any(SubstreamOnViewModifier)],
  });
});



================================================
FILE: tests/card-controller/actions/actions/substream-select.test.ts
================================================
import { expect, it } from 'vitest';
import { SubstreamSelectAction } from '../../../../src/card-controller/actions/actions/substream-select';
import { createCardAPI } from '../../../test-utils';
import { SubstreamSelectViewModifier } from '../../../../src/card-controller/view/modifiers/substream-select';

it('should handle live_substream_select action', async () => {
  const api = createCardAPI();
  const action = new SubstreamSelectAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'live_substream_select',
      camera: 'substream',
    },
  );

  await action.execute(api);

  expect(api.getViewManager().setViewByParameters).toBeCalledWith(
    expect.objectContaining({
      modifiers: expect.arrayContaining([expect.any(SubstreamSelectViewModifier)]),
    }),
  );
});



================================================
FILE: tests/card-controller/actions/actions/toggle.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { ToggleAction } from '../../../../src/card-controller/actions/actions/toggle';
import { createCardAPI, createHASS, createStateEntity } from '../../../test-utils';

describe('ToggleAction', () => {
  describe('should toggle entities', () => {
    it.each([
      ['light.office' as const, 'off' as const, 'light' as const, 'turn_on' as const],
      ['light.office' as const, 'on' as const, 'light' as const, 'turn_off' as const],
      [
        'cover.door' as const,
        'closed' as const,
        'cover' as const,
        'open_cover' as const,
      ],
      ['cover.door' as const, 'open' as const, 'cover' as const, 'close_cover' as const],
      ['lock.door' as const, 'locked' as const, 'lock' as const, 'unlock' as const],
      ['lock.door' as const, 'unlocked' as const, 'lock' as const, 'lock' as const],
      [
        'group.foo' as const,
        'off' as const,
        'homeassistant' as const,
        'turn_on' as const,
      ],
      [
        'group.foo' as const,
        'on' as const,
        'homeassistant' as const,
        'turn_off' as const,
      ],
    ])(
      '%s %s',
      async (
        entityID: string,
        state: string,
        expectedServiceDomain: string,
        expectedService: string,
      ) => {
        const api = createCardAPI();
        const hass = createHASS({
          [entityID]: createStateEntity({ entity_id: entityID, state: state }),
        });
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

        const action = new ToggleAction({}, { action: 'toggle' }, { entity: entityID });
        await action.execute(api);

        expect(hass.callService).toBeCalledWith(expectedServiceDomain, expectedService, {
          entity_id: entityID,
        });
      },
    );
  });

  it('should do nothing without an entity ID', async () => {
    const api = createCardAPI();
    const hass = createHASS();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

    const action = new ToggleAction({}, { action: 'toggle' }, {});

    await action.execute(api);

    expect(hass.callService).not.toBeCalled();
  });

  it('should do nothing without an entity state', async () => {
    const api = createCardAPI();
    const hass = createHASS();
    vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

    const action = new ToggleAction(
      {},
      { action: 'toggle' },
      { entity: 'light.NOT_FOUND' },
    );
    await action.execute(api);

    expect(hass.callService).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/actions/actions/unmute.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { UnmuteAction } from '../../../../src/card-controller/actions/actions/unmute';
import { MediaPlayerController } from '../../../../src/types';
import { createCardAPI, createMediaLoadedInfo } from '../../../test-utils';

it('should handle unmute action', async () => {
  const api = createCardAPI();
  const mediaPlayerController = mock<MediaPlayerController>();
  vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
    createMediaLoadedInfo({
      mediaPlayerController,
    }),
  );
  const action = new UnmuteAction(
    {},
    {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'unmute',
    },
  );

  await action.execute(api);

  expect(mediaPlayerController.unmute).toBeCalled();
});



================================================
FILE: tests/card-controller/actions/actions/url.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { URLAction } from '../../../../src/card-controller/actions/actions/url';
import { createCardAPI } from '../../../test-utils';

// @vitest-environment jsdom
describe('URLAction', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should open the URL in a new window', async () => {
    const urlAction = new URLAction(
      {},
      {
        action: 'url',
        url_path: 'https://example.com',
      },
    );
    const windowOpenSpy = vi.spyOn(window, 'open').mockImplementation(() => null);

    await urlAction.execute(createCardAPI());

    expect(windowOpenSpy).toHaveBeenCalledWith('https://example.com');
  });
});



================================================
FILE: tests/card-controller/actions/actions/view.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { ViewAction } from '../../../../src/card-controller/actions/actions/view';
import { createCardAPI } from '../../../test-utils';

describe('should handle view action', () => {
  it.each([
    ['clip' as const],
    ['clips' as const],
    ['diagnostics' as const],
    ['image' as const],
    ['live' as const],
    ['recording' as const],
    ['recordings' as const],
    ['snapshot' as const],
    ['snapshots' as const],
    ['timeline' as const],
  ])('%s', async (viewName) => {
    const api = createCardAPI();

    const action = new ViewAction(
      {},
      {
        action: 'fire-dom-event',
        advanced_camera_card_action: viewName,
      },
    );

    await action.execute(api);

    expect(api.getViewManager().setViewByParametersWithNewQuery).toBeCalledWith(
      expect.objectContaining({
        params: {
          view: viewName,
        },
      }),
    );
  });
});



================================================
FILE: tests/card-controller/actions/utils/time-delta.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { timeDeltaToSeconds } from '../../../../src/card-controller/actions/utils/time-delta';

describe('timeDeltaToSeconds', () => {
  it('hours', () => {
    expect(timeDeltaToSeconds({ h: 1 })).toBe(3600);
  });
  it('minutes', () => {
    expect(timeDeltaToSeconds({ m: 1 })).toBe(60);
  });
  it('seconds', () => {
    expect(timeDeltaToSeconds({ s: 1 })).toBe(1);
  });
  it('milliseconds', () => {
    expect(timeDeltaToSeconds({ ms: 1 })).toBe(0.001);
  });
  it('combination', () => {
    expect(timeDeltaToSeconds({ h: 1, m: 2, s: 3, ms: 4 })).toBe(3723.004);
  });
});



================================================
FILE: tests/card-controller/config/config-manager.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { ZodError } from 'zod';
import { ConfigManager } from '../../../src/card-controller/config/config-manager';
import { InitializationAspect } from '../../../src/card-controller/initialization-manager';
import { ConditionStateManager } from '../../../src/conditions/state-manager';
import { advancedCameraCardConfigSchema } from '../../../src/config/schema/types';
import { createCardAPI, createConfig, flushPromises } from '../../test-utils';

describe('ConfigManager', () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  describe('should handle error when', () => {
    it('no input', () => {
      const manager = new ConfigManager(createCardAPI());
      expect(() => manager.setConfig()).toThrowError(/Invalid configuration/);
    });

    it('invalid configuration', () => {
      const spy = vi.spyOn(advancedCameraCardConfigSchema, 'safeParse').mockReturnValue({
        success: false,
        error: new ZodError([]),
      });

      const manager = new ConfigManager(createCardAPI());
      expect(() => manager.setConfig({})).toThrowError(
        'Invalid configuration: No location hint available (bad or missing type?)',
      );

      spy.mockRestore();
    });

    it('invalid configuration with hint', () => {
      const manager = new ConfigManager(createCardAPI());
      expect(() => manager.setConfig({})).toThrowError(
        'Invalid configuration: [\n "cameras",\n "type"\n]',
      );
    });

    it('upgradeable', () => {
      const manager = new ConfigManager(createCardAPI());
      expect(() =>
        manager.setConfig({
          // This key needs to be upgradeable in `management.ts` .
          type: 'custom:frigate-card',
          cameras: 'WILL_NOT_PARSE',
        }),
      ).toThrowError(
        'An automated card configuration upgrade is ' +
          'available, please visit the visual card editor. ' +
          'Invalid configuration: [\n "cameras"\n]',
      );
    });
  });

  it('should have initial state', () => {
    const manager = new ConfigManager(createCardAPI());

    expect(manager.getConfig()).toBeNull();
    expect(manager.getNonOverriddenConfig()).toBeNull();
    expect(manager.getRawConfig()).toBeNull();
  });

  it('should successfully parse basic config', () => {
    const api = createCardAPI();
    const manager = new ConfigManager(api);
    const config = {
      type: 'custom:advanced-camera-card',
      cameras: [{ camera_entity: 'camera.office' }],
    };

    manager.setConfig(config);

    expect(manager.hasConfig()).toBeTruthy();
    expect(manager.getRawConfig()).toBe(config);

    // Verify at least the camera is set.
    expect(manager.getConfig()?.cameras[0].camera_entity).toBe('camera.office');

    // Verify at least one default was set.
    expect(manager.getConfig()?.menu.alignment).toBe('left');

    // Verify appropriate API calls are made.
    expect(api.getConditionStateManager().setState).toBeCalledWith({
      view: undefined,
      displayMode: undefined,
      camera: undefined,
    });
    expect(api.getMediaLoadedInfoManager().clear).toBeCalled();
    expect(api.getViewManager().reset).toBeCalled();
    expect(api.getMessageManager().reset).toBeCalled();
    expect(api.getAutomationsManager().addAutomations).toBeCalled();
    expect(api.getStyleManager().updateFromConfig).toBeCalled();
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('should apply profiles', () => {
    const manager = new ConfigManager(createCardAPI());
    const config = {
      type: 'custom:advanced-camera-card',
      cameras: [{ camera_entity: 'camera.office' }],
      profiles: ['low-performance'],
    };

    manager.setConfig(config);

    // Verify at least one low performance default.
    expect(manager.getConfig()?.live.draggable).toBeFalsy();
  });

  it('should skip identical configs', () => {
    const api = createCardAPI();
    const manager = new ConfigManager(api);
    const config = {
      type: 'custom:advanced-camera-card',
      cameras: [{ camera_entity: 'camera.office' }],
    };

    manager.setConfig(config);
    expect(api.getViewManager().reset).toBeCalled();

    vi.mocked(api.getViewManager().reset).mockClear();

    manager.setConfig(config);
    expect(api.getViewManager().reset).not.toBeCalled();
  });

  it('should get card wide config', () => {
    const api = createCardAPI();
    const manager = new ConfigManager(api);
    const config = {
      type: 'custom:advanced-camera-card',
      cameras: [{ camera_entity: 'camera.office' }],
      debug: {
        logging: true,
      },
      performance: {
        style: {
          box_shadow: false,
        },
      },
    };

    manager.setConfig(config);

    expect(manager.getCardWideConfig()).toEqual({
      debug: {
        logging: true,
      },
      performance: {
        features: {
          animated_progress_indicator: true,
          card_loading_indicator: true,
          media_chunk_size: 50,
        },
        style: {
          border_radius: true,
          box_shadow: false,
        },
      },
    });
  });

  describe('should override', () => {
    it('should ignore overrides with same config', () => {
      const api = createCardAPI();
      const stateManager = new ConditionStateManager();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

      const manager = new ConfigManager(api);
      const cameras = [{ camera_entity: 'camera.office' }];
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: cameras,
        overrides: [
          {
            conditions: [{ condition: 'fullscreen', fullscreen: true }],
            set: {
              // Override with the same.
              cameras: cameras,
            },
          },
        ],
      };

      manager.setConfig(config);

      expect(api.getStyleManager().updateFromConfig).toBeCalledTimes(1);

      stateManager.setState({ fullscreen: true });

      expect(api.getStyleManager().updateFromConfig).toBeCalledTimes(1);
    });

    it('should honor override', () => {
      const api = createCardAPI();
      const stateManager = new ConditionStateManager();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

      const manager = new ConfigManager(api);
      const config = createConfig({
        menu: {
          style: 'hidden',
        },
        overrides: [
          {
            conditions: [{ condition: 'fullscreen', fullscreen: true }],
            set: { 'menu.style': 'none' },
          },
        ],
      });

      manager.setConfig(config);
      expect(manager.getConfig()?.menu?.style).toBe('hidden');

      stateManager.setState({ fullscreen: true });
      expect(manager.getConfig()?.menu?.style).toBe('none');
      expect(manager.getConfig()).not.toEqual(manager.getNonOverriddenConfig());
    });

    it('should set error on invalid override', () => {
      const api = createCardAPI();
      const stateManager = new ConditionStateManager();
      vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

      const manager = new ConfigManager(api);
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        overrides: [
          {
            conditions: [{ condition: 'fullscreen', fullscreen: true }],
            delete: ['cameras'],
          },
        ],
      };

      manager.setConfig(config);
      expect(manager.getConfig()).not.toBeNull();

      stateManager.setState({ fullscreen: true });
      expect(manager.getConfig()).not.toBeNull();
      expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(
        expect.objectContaining({ message: 'Invalid override configuration' }),
      );
    });

    describe('should uninitialize on override', () => {
      it('cameras', () => {
        const api = createCardAPI();
        const stateManager = new ConditionStateManager();
        vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

        const manager = new ConfigManager(api);
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          overrides: [
            {
              conditions: [{ condition: 'fullscreen', fullscreen: true }],
              set: {
                cameras: [{ camera_entity: 'camera.kitchen' }],
              },
            },
          ],
        };

        manager.setConfig(config);

        expect(api.getInitializationManager().uninitialize).not.toHaveBeenCalledWith(
          InitializationAspect.CAMERAS,
        );

        stateManager.setState({ fullscreen: true });

        expect(api.getInitializationManager().uninitialize).toHaveBeenCalledWith(
          InitializationAspect.CAMERAS,
        );
      });

      it('cameras_global', () => {
        const api = createCardAPI();
        const stateManager = new ConditionStateManager();
        vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

        const manager = new ConfigManager(api);
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          overrides: [
            {
              conditions: [{ condition: 'fullscreen', fullscreen: true }],
              set: {
                cameras_global: { live_provider: 'jsmpeg' },
              },
            },
          ],
        };

        manager.setConfig(config);

        expect(api.getInitializationManager().uninitialize).not.toHaveBeenCalledWith(
          InitializationAspect.CAMERAS,
        );

        stateManager.setState({ fullscreen: true });

        expect(api.getInitializationManager().uninitialize).toHaveBeenCalledWith(
          InitializationAspect.CAMERAS,
        );
      });

      it('live.microphone.always_connected', () => {
        const api = createCardAPI();
        const stateManager = new ConditionStateManager();
        vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

        const manager = new ConfigManager(api);
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          overrides: [
            {
              conditions: [{ condition: 'fullscreen', fullscreen: true }],
              set: {
                'live.microphone.always_connected': true,
              },
            },
          ],
        };

        manager.setConfig(config);

        expect(api.getInitializationManager().uninitialize).not.toHaveBeenCalledWith(
          InitializationAspect.MICROPHONE_CONNECT,
        );

        stateManager.setState({ fullscreen: true });

        expect(api.getInitializationManager().uninitialize).toHaveBeenCalledWith(
          InitializationAspect.MICROPHONE_CONNECT,
        );
      });
    });

    describe('should initialize on override', () => {
      it('should initialize background items', async () => {
        const api = createCardAPI();
        const stateManager = new ConditionStateManager();
        const listener = vi.fn();
        stateManager.addListener(listener);
        vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

        const manager = new ConfigManager(api);
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          overrides: [
            {
              conditions: [{ condition: 'fullscreen', fullscreen: true }],
              set: {
                cameras: [{ camera_entity: 'camera.kitchen' }],
              },
            },
          ],
        };

        manager.setConfig(config);

        await flushPromises();

        expect(api.getDefaultManager().initializeIfNecessary).toBeCalledTimes(1);
        expect(api.getMediaPlayerManager().initializeIfNecessary).toBeCalledTimes(1);
        expect(listener).not.toBeCalledWith(
          expect.objectContaining({ change: { config: expect.anything() } }),
        );

        vi.mocked(api.getInitializationManager().isInitializedMandatory).mockReturnValue(
          true,
        );
        stateManager.setState({ fullscreen: true });

        await flushPromises();

        expect(api.getDefaultManager().initializeIfNecessary).toBeCalledTimes(2);
        expect(api.getMediaPlayerManager().initializeIfNecessary).toBeCalledTimes(2);

        // Should set the config condition state.
        expect(listener).toBeCalledWith(
          expect.objectContaining({ change: { config: expect.anything() } }),
        );
      });
    });
  });
});



================================================
FILE: tests/card-controller/config/load-automations.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { createCardAPI, createConfig } from '../../test-utils';
import { setAutomationsFromConfig } from '../../../src/card-controller/config/load-automations';

describe('setAutomationsFromConfig', () => {
  it('without config', () => {
    const api = createCardAPI();
    setAutomationsFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalled();
    expect(api.getAutomationsManager().addAutomations).toBeCalledWith([]);
  });

  it('with config', () => {
    const automations = [
      {
        actions: [
          {
            action: 'fire-dom-event' as const,
            advanced_camera_card_action: 'clips',
          },
        ],
        conditions: [{ condition: 'fullscreen' as const, fullscreen: true }],
      },
    ];
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getNonOverriddenConfig).mockReturnValue(
      createConfig({
        automations: automations,
      }),
    );

    setAutomationsFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalled();
    expect(api.getAutomationsManager().addAutomations).toBeCalledWith(automations);
  });
});



================================================
FILE: tests/card-controller/config/load-control-entities.test.ts
================================================
import { assert, describe, expect, it, vi } from 'vitest';
import { setRemoteControlEntityFromConfig } from '../../../src/card-controller/config/load-control-entities';
import { INTERNAL_CALLBACK_ACTION } from '../../../src/config/schema/actions/custom/internal';
import { isAdvancedCameraCardCustomAction } from '../../../src/utils/action';
import {
  createCardAPI,
  createConfig,
  createHASS,
  createStateEntity,
  createStore,
} from '../../test-utils';

describe('setRemoteControlEntityFromConfig', () => {
  it('without control entity', () => {
    const api = createCardAPI();
    setRemoteControlEntityFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalled();
    expect(api.getAutomationsManager().addAutomations).not.toBeCalled();
  });

  it('with control entity and card priority', () => {
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        remote_control: {
          entities: {
            camera: 'input_select.camera',
            camera_priority: 'card',
          },
        },
      }),
    );

    setRemoteControlEntityFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalled();
    expect(api.getAutomationsManager().addAutomations).toBeCalledWith([
      {
        actions: [
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: '__INTERNAL_CALLBACK_ACTION__',
            callback: expect.any(Function),
          },
        ],
        conditions: [
          {
            condition: 'config',
            paths: ['cameras', 'remote_control.entities.camera'],
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
      {
        actions: [
          {
            action: 'perform-action',
            data: {
              option: '{{ advanced_camera_card.trigger.camera.to }}',
            },
            perform_action: 'input_select.select_option',
            target: {
              entity_id: 'input_select.camera',
            },
          },
        ],
        conditions: [
          {
            condition: 'camera',
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
      {
        actions: [
          {
            action: 'perform-action',
            data: {
              option: '{{ advanced_camera_card.camera }}',
            },
            perform_action: 'input_select.select_option',
            target: {
              entity_id: 'input_select.camera',
            },
          },
        ],
        conditions: [
          {
            condition: 'initialized',
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
      {
        actions: [
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'camera_select',
            camera: '{{ advanced_camera_card.trigger.state.to }}',
          },
        ],
        conditions: [
          {
            condition: 'state',
            entity: 'input_select.camera',
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
    ]);
  });

  it('with control entity and entity priority', () => {
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        remote_control: {
          entities: {
            camera: 'input_select.camera',
            camera_priority: 'entity',
          },
        },
      }),
    );

    setRemoteControlEntityFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalled();
    expect(api.getAutomationsManager().addAutomations).toBeCalledWith([
      {
        actions: [
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: '__INTERNAL_CALLBACK_ACTION__',
            callback: expect.any(Function),
          },
        ],
        conditions: [
          {
            condition: 'config',
            paths: ['cameras', 'remote_control.entities.camera'],
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
      {
        actions: [
          {
            action: 'perform-action',
            data: {
              option: '{{ advanced_camera_card.trigger.camera.to }}',
            },
            perform_action: 'input_select.select_option',
            target: {
              entity_id: 'input_select.camera',
            },
          },
        ],
        conditions: [
          {
            condition: 'camera',
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
      {
        actions: [
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'camera_select',
            camera: '{{ hass.states["input_select.camera"].state }}',
          },
        ],
        conditions: [
          {
            condition: 'initialized',
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
      {
        actions: [
          {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'camera_select',
            camera: '{{ advanced_camera_card.trigger.state.to }}',
          },
        ],
        conditions: [
          {
            condition: 'state',
            entity: 'input_select.camera',
          },
        ],
        tag: setRemoteControlEntityFromConfig,
      },
    ]);
  });

  describe('should set options', () => {
    it('should set options when they are incorrect', () => {
      const hass = createHASS();
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          remote_control: {
            entities: {
              camera: 'input_select.camera',
            },
          },
        }),
      );
      const store = createStore([
        {
          cameraID: 'camera.one',
        },
        {
          cameraID: 'camera.two',
        },
      ]);
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(store);

      setRemoteControlEntityFromConfig(api);

      const addOptionsAction = vi.mocked(api.getAutomationsManager().addAutomations).mock
        .calls[0][0][0].actions?.[0];
      assert(addOptionsAction && isAdvancedCameraCardCustomAction(addOptionsAction));
      assert(addOptionsAction.advanced_camera_card_action === INTERNAL_CALLBACK_ACTION);

      addOptionsAction.callback(api);
      expect(hass.callService).toBeCalledWith(
        'input_select',
        'set_options',
        {
          options: ['camera.one', 'camera.two'],
        },
        {
          entity_id: 'input_select.camera',
        },
      );
    });

    it('should not set options when they are already correct', () => {
      const hass = createHASS({
        'input_select.camera': createStateEntity({
          attributes: { options: ['camera.one', 'camera.two'] },
        }),
      });
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          remote_control: {
            entities: {
              camera: 'input_select.camera',
            },
          },
        }),
      );
      const store = createStore([
        {
          cameraID: 'camera.one',
        },
        {
          cameraID: 'camera.two',
        },
      ]);
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(store);

      setRemoteControlEntityFromConfig(api);

      const addOptionsAction = vi.mocked(api.getAutomationsManager().addAutomations).mock
        .calls[0][0][0].actions?.[0];
      assert(addOptionsAction && isAdvancedCameraCardCustomAction(addOptionsAction));
      assert(addOptionsAction.advanced_camera_card_action === INTERNAL_CALLBACK_ACTION);

      addOptionsAction.callback(api);
      expect(hass.callService).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/card-controller/config/load-folders.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { setFoldersFromConfig } from '../../../src/card-controller/config/load-folders';
import { FoldersManager } from '../../../src/card-controller/folders/manager';
import { createCardAPI, createConfig, createFolder } from '../../test-utils';

describe('setFoldersFromConfig', () => {
  it('should replace folders', () => {
    const api = createCardAPI();
    const foldersManager = mock<FoldersManager>();
    vi.mocked(api.getFoldersManager).mockReturnValue(foldersManager);

    const folders = [createFolder()];
    const config = createConfig({
      folders,
    });
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(config);

    setFoldersFromConfig(api);

    expect(foldersManager.deleteFolders).toBeCalled();
    expect(foldersManager.addFolders).toBeCalledWith(folders);
  });

  it('should handle exceptions', () => {
    const api = createCardAPI();
    const foldersManager = mock<FoldersManager>();
    vi.mocked(api.getFoldersManager).mockReturnValue(foldersManager);

    const error = new Error('test error');
    vi.mocked(foldersManager.addFolders).mockImplementation(() => {
      throw error;
    });

    const config = createConfig({
      folders: [createFolder()],
    });
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(config);

    setFoldersFromConfig(api);

    expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(error);
  });
});



================================================
FILE: tests/card-controller/config/load-keyboard-shortcuts.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { createCardAPI, createConfig } from '../../test-utils';
import { setKeyboardShortcutsFromConfig } from '../../../src/card-controller/config/load-keyboard-shortcuts';
import { PTZKeyboardShortcutName } from '../../../src/config/keyboard-shortcuts';
import { PTZAction } from '../../../src/config/ptz';

describe('setKeyboardShortcutsFromConfig', () => {
  it('without shortcuts', () => {
    const api = createCardAPI();
    setKeyboardShortcutsFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalledWith(
      setKeyboardShortcutsFromConfig,
    );
    expect(api.getAutomationsManager().addAutomations).not.toBeCalled();
  });

  it('with shortcuts disabled', () => {
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        view: {
          keyboard_shortcuts: {
            enabled: false,
          },
        },
      }),
    );
    setKeyboardShortcutsFromConfig(api);

    expect(api.getAutomationsManager().deleteAutomations).toBeCalledWith(
      setKeyboardShortcutsFromConfig,
    );
    expect(api.getAutomationsManager().addAutomations).not.toBeCalled();
  });

  describe('PTZ shortcuts', () => {
    describe('actions', () => {
      it.each([
        ['ptz_left' as const, 'left' as const],
        ['ptz_right' as const, 'right' as const],
        ['ptz_up' as const, 'up' as const],
        ['ptz_down' as const, 'down' as const],
        ['ptz_zoom_in' as const, 'zoom_in' as const],
        ['ptz_zoom_out' as const, 'zoom_out' as const],
      ])('%s', (name: PTZKeyboardShortcutName, ptzAction: PTZAction) => {
        const api = createCardAPI();
        vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
          createConfig({
            view: {
              keyboard_shortcuts: {
                enabled: true,
                ptz_home: null,
                ptz_left: null,
                ptz_right: null,
                ptz_up: null,
                ptz_down: null,
                ptz_zoom_in: null,
                ptz_zoom_out: null,
                [name]: { key: 'z' },
              },
            },
          }),
        );

        setKeyboardShortcutsFromConfig(api);

        expect(api.getAutomationsManager().deleteAutomations).toBeCalledWith(
          setKeyboardShortcutsFromConfig,
        );
        expect(api.getAutomationsManager().addAutomations).toBeCalledWith([
          {
            actions: [
              {
                action: 'fire-dom-event',
                advanced_camera_card_action: 'ptz_multi',
                ptz_action: ptzAction,
                ptz_phase: 'start',
              },
            ],
            conditions: [
              {
                alt: undefined,
                condition: 'key',
                ctrl: undefined,
                key: 'z',
                meta: undefined,
                shift: undefined,
                state: 'down',
              },
            ],
            tag: setKeyboardShortcutsFromConfig,
          },
          {
            actions: [
              {
                action: 'fire-dom-event',
                advanced_camera_card_action: 'ptz_multi',
                ptz_action: ptzAction,
                ptz_phase: 'stop',
              },
            ],
            conditions: [
              {
                condition: 'key',
                key: 'z',
                state: 'up',
              },
            ],
            tag: setKeyboardShortcutsFromConfig,
          },
        ]);
      });

      it('ptz_home', () => {
        const api = createCardAPI();
        vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

        setKeyboardShortcutsFromConfig(api);

        expect(api.getAutomationsManager().deleteAutomations).toBeCalledWith(
          setKeyboardShortcutsFromConfig,
        );
        expect(api.getAutomationsManager().addAutomations).toBeCalledWith(
          expect.arrayContaining([
            {
              actions: [
                {
                  action: 'fire-dom-event',
                  advanced_camera_card_action: 'ptz_multi',
                },
              ],
              conditions: [
                {
                  alt: undefined,
                  condition: 'key',
                  ctrl: undefined,
                  key: 'h',
                  meta: undefined,
                  shift: undefined,
                  state: 'down',
                },
              ],
              tag: setKeyboardShortcutsFromConfig,
            },
          ]),
        );
      });
    });
  });
});



================================================
FILE: tests/card-controller/config/overrides-manager.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { OverridesManager } from '../../../src/card-controller/config/overrides-manager';
import { ConditionStateManager } from '../../../src/conditions/state-manager';
import { createConfig } from '../../test-utils';

describe('OverridesManager', () => {
  it('should add overrides', () => {
    const config = createConfig({
      overrides: [
        {
          set: {
            'menu.style': 'overlay',
          },
          conditions: [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
        },
      ],
    });

    const manager = new OverridesManager(vi.fn());
    manager.set(new ConditionStateManager(), config.overrides);

    expect(manager.hasOverrides()).toBe(true);
  });

  it('should clear overrides', () => {
    const config = createConfig({
      overrides: [
        {
          set: {
            'menu.style': 'overlay',
          },
          conditions: [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
        },
      ],
    });

    const stateManager = new ConditionStateManager();
    const manager = new OverridesManager(vi.fn());
    manager.set(stateManager, config.overrides);

    expect(manager.getConfig(config).menu?.style).toBe('hidden');

    manager.set(stateManager, []);

    stateManager.setState({ fullscreen: true });
    expect(manager.getConfig(config).menu?.style).toBe('hidden');

    expect(manager.hasOverrides()).toBe(false);
  });

  it('should not override when conditions do not match', () => {
    const config = createConfig({
      overrides: [
        {
          set: {
            'menu.style': 'overlay',
          },
          conditions: [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
        },
      ],
    });

    const manager = new OverridesManager(vi.fn());
    manager.set(new ConditionStateManager(), config.overrides);

    expect(manager.getConfig(config)).toBe(config);
  });

  it('should callback on change', () => {
    const config = createConfig({
      overrides: [
        {
          set: {
            'menu.style': 'overlay',
          },
          conditions: [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
        },
      ],
    });

    const callback = vi.fn();
    const stateManager = new ConditionStateManager();
    const manager = new OverridesManager(callback);
    manager.set(stateManager, config.overrides);

    expect(manager.getConfig(config).menu?.style).toBe('hidden');

    expect(callback).not.toBeCalled();

    stateManager.setState({ fullscreen: true });

    expect(callback).toBeCalledTimes(1);
  });

  describe('should handle override merge', () => {
    it('with path', () => {
      const config = createConfig({
        overrides: [
          {
            merge: {
              'live.controls.thumbnails': {
                mode: 'none',
              },
            },
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
            ],
          },
        ],
      });

      const stateManager = new ConditionStateManager();
      stateManager.setState({ fullscreen: true });

      const manager = new OverridesManager(vi.fn());
      manager.set(stateManager, config.overrides);

      const overriddenConfig = manager.getConfig(config);

      expect(config.live.controls.thumbnails.mode).toBe('right');
      expect(overriddenConfig.live.controls.thumbnails.mode).toBe('none');
    });

    it('without path', () => {
      const config = createConfig({
        overrides: [
          {
            merge: {
              live: {
                controls: {
                  thumbnails: {
                    mode: 'none',
                  },
                },
              },
            },
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
            ],
          },
        ],
      });

      const stateManager = new ConditionStateManager();
      stateManager.setState({ fullscreen: true });

      const manager = new OverridesManager(vi.fn());
      manager.set(stateManager, config.overrides);

      const overriddenConfig = manager.getConfig(config);

      expect(config.live.controls.thumbnails.mode).toBe('right');
      expect(overriddenConfig.live.controls.thumbnails.mode).toBe('none');
    });
  });

  describe('should handle override set', () => {
    it('leaf node', () => {
      const config = createConfig({
        overrides: [
          {
            set: {
              'live.controls.thumbnails.mode': 'none',
            },
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
            ],
          },
        ],
      });

      const stateManager = new ConditionStateManager();
      stateManager.setState({ fullscreen: true });

      const manager = new OverridesManager(vi.fn());
      manager.set(stateManager, config.overrides);

      const overriddenConfig = manager.getConfig(config);

      expect(config.live.controls.thumbnails.mode).toBe('right');
      expect(overriddenConfig.live.controls.thumbnails.mode).toBe('none');
    });

    it('root node', () => {
      const config = createConfig({
        overrides: [
          {
            set: {
              live: {
                controls: {
                  thumbnails: {
                    mode: 'none',
                  },
                },
              },
            },
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
            ],
          },
        ],
      });

      const stateManager = new ConditionStateManager();
      stateManager.setState({ fullscreen: true });

      const manager = new OverridesManager(vi.fn());
      manager.set(stateManager, config.overrides);

      const overriddenConfig = manager.getConfig(config);

      expect(config.live.controls.thumbnails.mode).toBe('right');
      expect(overriddenConfig.live.controls.thumbnails.mode).toBe('none');
    });
  });

  describe('should handle override delete', () => {
    it('leaf node', () => {
      const config = createConfig({
        live: {
          controls: {
            thumbnails: {
              mode: 'left',
            },
          },
        },
        overrides: [
          {
            delete: ['live.controls.thumbnails.mode' as const],
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
            ],
          },
        ],
      });

      const stateManager = new ConditionStateManager();
      stateManager.setState({ fullscreen: true });

      const manager = new OverridesManager(vi.fn());
      manager.set(stateManager, config.overrides);

      const overriddenConfig = manager.getConfig(config);

      expect(config.live.controls.thumbnails.mode).toBe('left');
      expect(overriddenConfig.live.controls.thumbnails.mode).toBe('right');
    });

    it('root node', () => {
      const config = createConfig({
        live: {
          controls: {
            thumbnails: {
              mode: 'left',
            },
          },
        },
        overrides: [
          {
            delete: ['live' as const],
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
            ],
          },
        ],
      });

      const stateManager = new ConditionStateManager();
      stateManager.setState({ fullscreen: true });

      const manager = new OverridesManager(vi.fn());
      manager.set(stateManager, config.overrides);

      const overriddenConfig = manager.getConfig(config);

      expect(config.live.controls.thumbnails.mode).toBe('left');
      expect(overriddenConfig.live.controls.thumbnails.mode).toBe('right');
    });
  });

  it('should throw on invalid schema', () => {
    const config = createConfig({
      overrides: [
        {
          conditions: [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
        },
      ],
    });
    config.overrides![0].merge = 6 as unknown as Record<string, unknown>;

    const stateManager = new ConditionStateManager();
    stateManager.setState({ fullscreen: true });

    const manager = new OverridesManager(vi.fn());
    manager.set(stateManager, config.overrides);

    expect(() => manager.getConfig(config)).toThrowError(
      /Invalid override configuration/,
    );
  });

  // See: https://github.com/dermotduffy/advanced-camera-card/issues/1954
  it('should handle overrides separately', () => {
    const config = createConfig({
      live: {
        controls: {
          thumbnails: {
            mode: 'right',
          },
        },
      },
      overrides: [
        {
          set: { 'live.controls.thumbnails.mode': 'left' },
          conditions: [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
        },
        {
          set: { 'live.controls.thumbnails.mode': 'none' },
          conditions: [
            {
              condition: 'expand' as const,
              expand: true,
            },
          ],
        },
      ],
    });

    const stateManager = new ConditionStateManager();
    const manager = new OverridesManager(vi.fn());
    manager.set(stateManager, config.overrides);

    expect(manager.getConfig(config).live.controls.thumbnails.mode).toBe('right');

    stateManager.setState({ fullscreen: true });
    expect(manager.getConfig(config).live.controls.thumbnails.mode).toBe('left');

    stateManager.setState({ expand: true });
    expect(manager.getConfig(config).live.controls.thumbnails.mode).toBe('none');

    stateManager.setState({ fullscreen: false });
    expect(manager.getConfig(config).live.controls.thumbnails.mode).toBe('none');

    stateManager.setState({ expand: false });
    expect(manager.getConfig(config).live.controls.thumbnails.mode).toBe('right');
  });
});



================================================
FILE: tests/card-controller/folders/executor.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { FoldersExecutor } from '../../../src/card-controller/folders/executor';
import { HAFoldersEngine } from '../../../src/card-controller/folders/ha/engine';
import { FolderQuery } from '../../../src/card-controller/folders/types';
import { FolderConfig } from '../../../src/config/schema/folders';
import { Endpoint } from '../../../src/types';
import { ViewFolder } from '../../../src/view/item';
import { createFolder, createHASS, TestViewMedia } from '../../test-utils';

vi.mock('../../../src/card-controller/folders/ha/engine');
vi.mock('../../../../src/utils/ha/download');

describe('FoldersExecutor', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('getItemCapabilities', () => {
    it('should not get capabilities for non-folder media', () => {
      const item = new TestViewMedia({ folder: null });
      const executor = new FoldersExecutor();

      expect(executor.getItemCapabilities(item)).toBeNull();
    });

    it('should not get capabilities for non-existent folder engine', () => {
      const folder: FolderConfig = {
        type: 'UNKNOWN',
      } as unknown as FolderConfig;
      const item = new TestViewMedia({ folder });
      const executor = new FoldersExecutor();

      expect(executor.getItemCapabilities(item)).toBeNull();
    });

    it('should get capabilities for HA folder engine', () => {
      const folder = createFolder();
      const item = new TestViewMedia({ folder });

      const capabilities = {
        canFavorite: false,
        canDownload: true,
      };
      const haFolderEngine = mock<HAFoldersEngine>();
      haFolderEngine.getItemCapabilities.mockReturnValue(capabilities);

      const executor = new FoldersExecutor({
        ha: haFolderEngine,
      });

      expect(executor.getItemCapabilities(item)).toEqual(capabilities);
    });
  });

  describe('getDownloadPath', () => {
    it('should not get download path for non-existent folder engine', async () => {
      const folder: FolderConfig = {
        type: 'UNKNOWN',
      } as unknown as FolderConfig;
      const item = new TestViewMedia({ folder });
      const executor = new FoldersExecutor();

      expect(await executor.getDownloadPath(createHASS(), item)).toBeNull();
    });

    it('should get download path for HA folder engine', async () => {
      const endpoint: Endpoint = { endpoint: '/media', sign: false };
      const haFolderEngine = mock<HAFoldersEngine>();
      haFolderEngine.getDownloadPath.mockResolvedValue(endpoint);

      const executor = new FoldersExecutor({
        ha: haFolderEngine,
      });
      const item = new TestViewMedia({ folder: createFolder() });
      expect(await executor.getDownloadPath(createHASS(), item)).toEqual(endpoint);
    });
  });

  describe('favorite', () => {
    it('should not favorite non-existent folder engine', async () => {
      const folder: FolderConfig = {
        type: 'UNKNOWN',
      } as unknown as FolderConfig;
      const item = new TestViewMedia({ folder });
      const executor = new FoldersExecutor();

      await executor.favorite(createHASS(), item, true);

      // No observable effect.
    });

    it('should favorite', async () => {
      const haFolderEngine = mock<HAFoldersEngine>();
      const executor = new FoldersExecutor({
        ha: haFolderEngine,
      });

      const hass = createHASS();
      const item = new TestViewMedia({ folder: createFolder() });

      await executor.favorite(hass, item, true);

      expect(haFolderEngine.favorite).toBeCalledWith(hass, item, true);
    });
  });

  describe('generateDefaultFolderQuery', () => {
    it('should generate default folder query', () => {
      const folder: FolderConfig = createFolder();
      const query: FolderQuery = {
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      };

      const haFolderEngine = mock<HAFoldersEngine>();
      haFolderEngine.generateDefaultFolderQuery.mockReturnValue(query);
      const executor = new FoldersExecutor({ ha: haFolderEngine });

      expect(executor.generateDefaultFolderQuery(folder)).toEqual(query);
    });

    it('should return null for non-existent folder engine', () => {
      const folder: FolderConfig = {
        type: 'UNKNOWN',
      } as unknown as FolderConfig;
      const executor = new FoldersExecutor();

      expect(executor.generateDefaultFolderQuery(folder)).toBeNull();
    });
  });

  describe('expandFolder', () => {
    it('should reject folders of the wrong type', async () => {
      const query = {
        folder: { type: 'UNKNOWN' },
      } as unknown as FolderQuery;

      const executor = new FoldersExecutor();

      expect(await executor.expandFolder(createHASS(), query)).toBeNull();
    });

    it('should expand folder', async () => {
      const folder = createFolder();
      const query: FolderQuery = {
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      };

      const mediaItem = new TestViewMedia({
        folder,
        startTime: new Date('2023-04-29T14:27'),
      });
      const folderItem = new ViewFolder(folder);

      const haFolderEngine = mock<HAFoldersEngine>();
      haFolderEngine.expandFolder.mockResolvedValue([folderItem, mediaItem, folderItem]);

      const executor = new FoldersExecutor({
        ha: haFolderEngine,
      });
      const hass = createHASS();
      const results = await executor.expandFolder(hass, query);
      expect(results).toEqual([
        // Folder will have been sorted to the front and de-duped.
        folderItem,
        mediaItem,
      ]);
    });
  });
});



================================================
FILE: tests/card-controller/folders/manager.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { FoldersExecutor } from '../../../src/card-controller/folders/executor';
import { FoldersManager } from '../../../src/card-controller/folders/manager';
import { FolderQuery } from '../../../src/card-controller/folders/types';
import { FolderConfig } from '../../../src/config/schema/folders';
import { ResolvedMediaCache } from '../../../src/ha/resolved-media';
import { Endpoint } from '../../../src/types';
import { ViewItemCapabilities } from '../../../src/view/types';
import {
  createCardAPI,
  createFolder,
  createHASS,
  TestViewMedia,
} from '../../test-utils';

describe('FoldersManager', () => {
  it('should initialize with no folders', () => {
    const api = createCardAPI();
    const manager = new FoldersManager(api);
    expect(manager.getFolderCount()).toBe(0);
    expect(manager.hasFolders()).toBe(false);
  });

  describe('should add folders', () => {
    it('should add a folder correctly without a title', () => {
      const manager = new FoldersManager(createCardAPI());
      const folder = createFolder({ id: 'folder-1' });

      manager.addFolders([folder]);
      expect(manager.getFolderCount()).toBe(1);
      expect(manager.getFolder('folder-1')).toEqual({
        ...folder,
        title: 'Folder 0',
      });
      expect(manager.hasFolders()).toBe(true);
    });

    it('should add a folder correctly with a title', () => {
      const manager = new FoldersManager(createCardAPI());
      const folder = createFolder({ id: 'folder-1', title: 'Original Title' });

      manager.addFolders([folder]);
      expect(manager.getFolderCount()).toBe(1);
      expect(manager.getFolder('folder-1')).toEqual(folder);
    });

    it('should add a folder without an id', () => {
      const manager = new FoldersManager(createCardAPI());
      const folder = createFolder({ title: 'Title' });

      manager.addFolders([folder]);
      expect(manager.getFolderCount()).toBe(1);
      expect(manager.getFolder('folder/0')).toEqual({
        ...folder,
        id: 'folder/0',
      });
    });

    it('should reject duplicate folder IDs', () => {
      const manager = new FoldersManager(createCardAPI());
      const folder_1 = createFolder({ id: 'DUP' });
      const folder_2 = createFolder({ id: 'DUP' });

      expect(() => manager.addFolders([folder_1, folder_2])).toThrowError(
        /Duplicate folder id/,
      );
    });

    it('should preserve previous folders', () => {
      const manager = new FoldersManager(createCardAPI());

      const folder_original = createFolder();
      manager.addFolders([folder_original]);

      const folder_new = createFolder({ id: 'DUP' });
      manager.addFolders([folder_new]);

      expect(manager.getFolderCount()).toBe(2);
    });
  });

  it('should delete folders', () => {
    const manager = new FoldersManager(createCardAPI());
    const folder_1 = createFolder({ id: 'id-1' });
    const folder_2 = createFolder({ id: 'id-2' });

    manager.addFolders([folder_1, folder_2]);
    expect(manager.getFolderCount()).toBe(2);

    manager.deleteFolders();
    expect(manager.getFolderCount()).toBe(0);
  });

  describe('should get folders', () => {
    it('should get default folder', () => {
      const manager = new FoldersManager(createCardAPI());
      const folder = createFolder({ id: 'id', title: 'Title' });
      manager.addFolders([folder]);

      expect(manager.getFolder()).toEqual(folder);
    });

    it('should get default folders when there are none', () => {
      const manager = new FoldersManager(createCardAPI());
      expect(manager.getFolder()).toBeNull();
    });

    it('should get all folders', () => {
      const manager = new FoldersManager(createCardAPI());
      const folder_1 = createFolder({ id: 'id-1', title: 'Title' });
      const folder_2 = createFolder({ id: 'id-2', title: 'Title' });

      manager.addFolders([folder_1, folder_2]);

      expect([...manager.getFolders()]).toEqual([
        ['id-1', folder_1],
        ['id-2', folder_2],
      ]);
    });

    it('should get non-existent folder', () => {
      const manager = new FoldersManager(createCardAPI());
      expect(manager.getFolder('NON-EXISTENT')).toBeNull();
    });
  });

  describe('generateDefaultFolderQuery', () => {
    it('should generate default folder query with implicit folder', () => {
      const folder: FolderConfig = createFolder();
      const query: FolderQuery = {
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      };

      const executor = mock<FoldersExecutor>();
      vi.mocked(executor.generateDefaultFolderQuery).mockReturnValue(query);

      const manager = new FoldersManager(createCardAPI(), executor);
      manager.addFolders([folder]);

      expect(manager.generateDefaultFolderQuery()).toEqual(query);
    });

    it('should generate default folder query without any folder', () => {
      const folder: FolderConfig = createFolder();
      const query: FolderQuery = {
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      };

      const executor = mock<FoldersExecutor>();
      vi.mocked(executor.generateDefaultFolderQuery).mockReturnValue(query);

      const manager = new FoldersManager(createCardAPI(), executor);
      // Folder is not added to the manager.

      expect(manager.generateDefaultFolderQuery()).toBeNull();
    });

    it('should generate default folder query with explicit folder', () => {
      const folder: FolderConfig = createFolder();
      const query: FolderQuery = {
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      };

      const executor = mock<FoldersExecutor>();
      vi.mocked(executor.generateDefaultFolderQuery).mockReturnValue(query);

      const manager = new FoldersManager(createCardAPI(), executor);

      expect(manager.generateDefaultFolderQuery(folder)).toEqual(query);
    });
  });

  describe('should expand folder', () => {
    it('should expand folder with hass', async () => {
      const hass = createHASS();
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const media = new TestViewMedia();
      const executor = mock<FoldersExecutor>();
      executor.expandFolder.mockResolvedValue([media]);

      const manager = new FoldersManager(api, executor);

      const folder = createFolder({ id: 'folder-1' });
      const conditionState = {};
      const engineOptions = {};
      const query: FolderQuery = {
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      };

      expect(await manager.expandFolder(query, conditionState, engineOptions)).toEqual([
        media,
      ]);

      expect(executor.expandFolder).toBeCalledWith(
        hass,
        query,
        conditionState,
        engineOptions,
      );
    });

    it('should not expand folder with hass', async () => {
      const api = createCardAPI();
      const executor = mock<FoldersExecutor>();
      const manager = new FoldersManager(api, executor);
      const folder = createFolder({ id: 'folder-1' });

      expect(
        await manager.expandFolder({
          folder,
          path: [{ ha: { id: 'media-source://' } }],
        }),
      ).toBeNull();

      expect(executor.expandFolder).not.toBeCalled();
    });
  });

  describe('should get item capabilities', () => {
    it('should get item capabilities', () => {
      const api = createCardAPI();
      const executor = mock<FoldersExecutor>();
      const capabilities: ViewItemCapabilities = {
        canFavorite: true,
        canDownload: true,
      };
      executor.getItemCapabilities.mockReturnValue(capabilities);
      const item = new TestViewMedia();

      const manager = new FoldersManager(api, executor);

      expect(manager.getItemCapabilities(item)).toEqual(capabilities);
      expect(executor.getItemCapabilities).toBeCalledWith(item);
    });
  });

  describe('should get download path', () => {
    it('should get download path', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);
      const cache = new ResolvedMediaCache();
      vi.mocked(api.getResolvedMediaCache).mockReturnValue(cache);

      const executor = mock<FoldersExecutor>();
      const item = new TestViewMedia();
      const endpoint: Endpoint = { endpoint: 'endpoint' };
      executor.getDownloadPath.mockResolvedValue(endpoint);

      const manager = new FoldersManager(api, executor);
      expect(await manager.getDownloadPath(item)).toEqual(endpoint);
      expect(executor.getDownloadPath).toBeCalledWith(hass, item, {
        resolvedMediaCache: cache,
      });
    });
  });

  describe('should favorite item', () => {
    it('should favorite item', async () => {
      const api = createCardAPI();
      const hass = createHASS();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(hass);

      const executor = mock<FoldersExecutor>();
      const item = new TestViewMedia();

      const manager = new FoldersManager(api, executor);
      await manager.favorite(item, true);
      expect(executor.favorite).toBeCalledWith(hass, item, true);
    });
  });
});



================================================
FILE: tests/card-controller/folders/ha/engine.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { HAFoldersEngine } from '../../../../src/card-controller/folders/ha/engine';
import { FolderQuery } from '../../../../src/card-controller/folders/types';
import { FolderConfig, Matcher } from '../../../../src/config/schema/folders';
import { BrowseMediaViewFolder } from '../../../../src/ha/browse-media/item';
import { browseMediaSchema } from '../../../../src/ha/browse-media/types';
import { getMediaDownloadPath } from '../../../../src/ha/download';
import { homeAssistantWSRequest } from '../../../../src/ha/ws-request';
import { Endpoint } from '../../../../src/types';
import { ViewFolder, ViewMedia } from '../../../../src/view/item';
import {
  createBrowseMedia,
  createFolder,
  createHASS,
  TestViewMedia,
} from '../../../test-utils';

vi.mock('../../../../src/ha/download');
vi.mock('../../../../src/ha/ws-request');

describe('HAFoldersEngine', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('getItemCapabilities', () => {
    it('should not be able to download a folder', () => {
      const item = new ViewFolder(createFolder());
      const engine = new HAFoldersEngine();

      expect(engine.getItemCapabilities(item)).toEqual({
        canFavorite: false,
        canDownload: false,
      });
    });

    it('should be able to download a media item', () => {
      const item = new TestViewMedia({ folder: createFolder() });
      const engine = new HAFoldersEngine();

      expect(engine.getItemCapabilities(item)).toEqual({
        canFavorite: false,
        canDownload: true,
      });
    });
  });

  describe('getDownloadPath', () => {
    it('should return null if item is not a media item', async () => {
      const item = new ViewFolder(createFolder());
      const engine = new HAFoldersEngine();
      expect(await engine.getDownloadPath(createHASS(), item)).toBeNull();
    });

    it('should return a download path for a media item', async () => {
      const item = new TestViewMedia({ folder: createFolder() });
      const engine = new HAFoldersEngine();

      const endpoint: Endpoint = { endpoint: '/media', sign: false };
      vi.mocked(getMediaDownloadPath).mockResolvedValue(endpoint);

      expect(await engine.getDownloadPath(createHASS(), item)).toEqual(endpoint);
    });
  });

  describe('favorite', () => {
    it('should favorite', async () => {
      const engine = new HAFoldersEngine();
      const item = new TestViewMedia({ folder: createFolder() });

      await engine.favorite(createHASS(), item, true);

      // No observable effect.
    });
  });

  describe('should generate default folder query', () => {
    it('should generate default folder query', () => {
      const folder: FolderConfig = { type: 'ha' };
      const engine = new HAFoldersEngine();

      const query = engine.generateDefaultFolderQuery(folder);
      expect(query).toEqual({
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      });
    });

    it('should reject folders of the wrong type', async () => {
      const folder = createFolder({ type: 'UNKNOWN' } as unknown as FolderConfig);
      const engine = new HAFoldersEngine();

      expect(engine.generateDefaultFolderQuery(folder)).toBeNull();
    });

    it('should respect path_url as a priority', async () => {
      const folder = createFolder({
        ha: {
          url: [{ id: 'media-source://1' }],
          path: [{ id: 'media-source://2' }],
        },
      });
      const engine = new HAFoldersEngine();
      expect(engine.generateDefaultFolderQuery(folder)).toEqual({
        folder,
        path: [{ ha: { id: 'media-source://1' } }, { ha: { id: 'media-source://2' } }],
      });
    });

    it('should respect configured url', async () => {
      const folder = createFolder({ ha: { url: [{ id: 'media-source://' }] } });
      const engine = new HAFoldersEngine();
      expect(engine.generateDefaultFolderQuery(folder)).toEqual({
        folder,
        path: [{ ha: { id: 'media-source://' } }],
      });
    });

    it('should add default media root as necessary', async () => {
      const folder = createFolder({
        ha: { path: [{ matchers: [{ type: 'title', title: 'Frigate' }] }] },
      });
      const engine = new HAFoldersEngine();
      expect(engine.generateDefaultFolderQuery(folder)).toEqual({
        folder,
        path: [
          { ha: { id: 'media-source://' } },
          { ha: { matchers: [{ type: 'title', title: 'Frigate' }] } },
        ],
      });
    });
  });

  describe('should expand folder', () => {
    it('should reject folders of the wrong type', async () => {
      const query = {
        folder: { type: 'UNKNOWN' },
      } as unknown as FolderQuery;
      const engine = new HAFoldersEngine();

      expect(await engine.expandFolder(createHASS(), query)).toBeNull();
    });

    it('should expand folder with cache by default', async () => {
      const query: FolderQuery = {
        folder: { type: 'ha' },
        path: [{ ha: { id: 'media-source://id' } }],
      };

      vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(
        createBrowseMedia({
          media_content_id: 'media-source://id',
          can_expand: true,
          children: [
            createBrowseMedia({
              media_content_id: 'media-source://media-item',
              title: 'Media Item',
            }),
            createBrowseMedia({
              media_content_id: 'media-source://frigate',
              title: 'Frigate',
              can_expand: true,
            }),
          ],
        }),
      );

      const engine = new HAFoldersEngine();
      const results = await engine.expandFolder(createHASS(), query);
      expect(results?.length).toBe(2);
      expect(results?.[0]).toBeInstanceOf(ViewMedia);
      expect(results?.[1]).toBeInstanceOf(ViewFolder);

      expect(homeAssistantWSRequest).toBeCalledTimes(1);

      // Expanding the folder again should use the cache.
      await engine.expandFolder(createHASS(), query);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);
    });

    it('should expand folder without cache when requested', async () => {
      const query: FolderQuery = {
        folder: { type: 'ha' },
        path: [{ ha: { id: 'media-source://id' } }],
      };

      vi.mocked(homeAssistantWSRequest)
        .mockResolvedValueOnce(
          createBrowseMedia({
            media_content_id: 'media-source://id',
            can_expand: true,
            children: [
              createBrowseMedia({
                media_content_id: 'media-source://media-item',
                title: 'Media Item',
              }),
              createBrowseMedia({
                media_content_id: 'media-source://frigate',
                title: 'Frigate',
                can_expand: true,
              }),
            ],
          }),
        )
        .mockResolvedValueOnce([]);

      const engine = new HAFoldersEngine();
      const results = await engine.expandFolder(
        createHASS(),
        query,
        {},
        {
          useCache: false,
        },
      );
      expect(results?.length).toBe(2);
      expect(results?.[0]).toBeInstanceOf(ViewMedia);
      expect(results?.[1]).toBeInstanceOf(ViewFolder);

      expect(homeAssistantWSRequest).toBeCalledTimes(1);

      // Expanding the folder again should use the cache.
      await engine.expandFolder(createHASS(), query);
      expect(homeAssistantWSRequest).toBeCalledTimes(2);
    });

    it('should use id from browsemedia in folder in query', async () => {
      const browseMedia = createBrowseMedia({
        media_content_id: 'media-source://id',
        can_expand: true,
      });

      const query: FolderQuery = {
        folder: { type: 'ha' },
        path: [
          {
            folder: new BrowseMediaViewFolder(createFolder(), browseMedia),
          },
        ],
      };

      vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(
        createBrowseMedia({
          media_content_id: 'media-source://id',
          can_expand: true,
          children: [],
        }),
      );

      const hass = createHASS();
      const engine = new HAFoldersEngine();
      await engine.expandFolder(hass, query);

      expect(homeAssistantWSRequest).toBeCalledWith(hass, browseMediaSchema, {
        type: 'media_source/browse_media',
        media_content_id: 'media-source://id',
      });
    });

    it('should not expand without a folder with an id', async () => {
      const query: FolderQuery = {
        folder: { type: 'ha' },
        // There's no component in the query with an id to start from.
        path: [{ ha: {} }],
      };
      const engine = new HAFoldersEngine();
      expect(await engine.expandFolder(createHASS(), query)).toBeNull();
    });

    // See additional matcher testing in media-matcher.test.ts .
    describe('should apply matchers', async () => {
      it.each([
        ['title exact', { type: 'title' as const, title: 'Frigate' }, 1],
        ['title regexp', { type: 'title' as const, regexp: 'rig' }, 1],
        [
          'or positive',
          {
            type: 'or' as const,
            matchers: [
              { type: 'title' as const, title: 'UNKNOWN' },
              { type: 'title' as const, title: 'Frigate' },
            ],
          },
          1,
        ],
        [
          'or negative',
          {
            type: 'or' as const,
            matchers: [{ type: 'title' as const, title: 'UNKNOWN' }],
          },
          0,
        ],
      ])('%s', async (_name: string, matcher: Matcher, expectedMatches: number) => {
        const query: FolderQuery = {
          folder: { type: 'ha' },
          path: [{ ha: { id: 'media-source://' } }, { ha: { matchers: [matcher] } }, {}],
        };

        vi.mocked(homeAssistantWSRequest)
          .mockResolvedValueOnce(
            createBrowseMedia({
              media_content_id: 'media-source://',
              can_expand: true,
              children: [
                createBrowseMedia({
                  media_content_id: 'media-source://frigate',
                  title: 'Frigate',
                  can_expand: true,
                }),
              ],
            }),
          )
          .mockResolvedValueOnce(
            createBrowseMedia({
              media_content_id: 'media-source://frigate',
              can_expand: true,
              children: [
                createBrowseMedia({
                  media_content_id: 'media-source://frigate/result',
                  title: 'Result',
                }),
              ],
            }),
          );

        const engine = new HAFoldersEngine();
        const results = await engine.expandFolder(createHASS(), query);
        expect(results?.length).toBe(expectedMatches);
      });
    });
  });
});



================================================
FILE: tests/card-controller/folders/ha/media-matcher.test.ts
================================================
import { renderTemplate } from 'ha-nunjucks';
import { describe, expect, it, vi } from 'vitest';
import { MediaMatcher } from '../../../../src/card-controller/folders/ha/media-matcher';
import { Matcher } from '../../../../src/config/schema/folders';
import {
  BrowseMediaMetadata,
  RichBrowseMedia,
} from '../../../../src/ha/browse-media/types';
import { createHASS } from '../../../test-utils';
import { sub } from 'date-fns';

vi.mock('ha-nunjucks');

describe('MediaMatcher', () => {
  describe('match', () => {
    const createMediaItem = (
      title: string,
      can_expand = false,
      media_class = 'image',
    ): RichBrowseMedia<BrowseMediaMetadata> => ({
      title,
      media_class,
      media_content_type: media_class === 'directory' ? 'directory' : 'image/jpeg',
      media_content_id: `${media_class}_${title.replace(/\s+/g, '_')}`,
      can_play: media_class !== 'directory',
      can_expand,
      thumbnail: null,
    });

    it('should return false if foldersOnly is true and media.can_expand is false', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test File');
      expect(
        mediaMatcher.match(createHASS(), media, { matchers: [], foldersOnly: true }),
      ).toBe(false);
    });

    it('should return true if foldersOnly is true and media.can_expand is true', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test Folder', true, 'directory');
      expect(
        mediaMatcher.match(createHASS(), media, { matchers: [], foldersOnly: true }),
      ).toBe(true);
    });

    it('should return true if matchers array is empty', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test Media');
      expect(mediaMatcher.match(createHASS(), media, { matchers: [] })).toBe(true);
    });

    it('should return true if matchers array is undefined', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test Media');
      expect(mediaMatcher.match(createHASS(), media, { matchers: undefined })).toBe(
        true,
      );
    });

    describe('with title matcher', () => {
      it('should return true when title matches exactly', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Exact Title');
        const matchers: Matcher[] = [{ type: 'title', title: 'Exact Title' }];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(true);
      });

      it('should return false when title does not match exactly', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('DOES NOT MATCH');
        const matchers: Matcher[] = [{ type: 'title', title: 'Exact Title' }];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(false);
      });

      it('should return true when title matches regexp and extracted value matches matcher.title', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Prefix-ImportantPart-Suffix');
        const matchers: Matcher[] = [
          {
            type: 'title',
            regexp: '^Prefix-(?<value>ImportantPart)-Suffix$',
            title: 'ImportantPart',
          },
        ];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(true);
      });

      it('should return false when title matches regexp but extracted value does not match matcher.title', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Prefix-ImportantPart-Suffix');
        const matchers: Matcher[] = [
          {
            type: 'title',
            regexp: '^Prefix-(?<value>ImportantPart)-Suffix$',
            title: 'WrongPart',
          },
        ];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(false);
      });

      it('should return true when title matches regexp with an explicit title value', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Prefix-ImportantPart-Suffix');
        const matchers: Matcher[] = [
          {
            type: 'title',
            regexp: '^Prefix-(?<value>ImportantPart)-Suffix$',
            // title is undefined.
          },
        ];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(true);
      });

      it('should return false when title does not match regexp', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Unrelated Title');
        const matchers: Matcher[] = [
          {
            type: 'title',
            regexp: '^Prefix-(?<value>ImportantPart)-Suffix$',
            title: 'ImportantPart',
          },
        ];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(false);
      });

      it('should return false when regexp is provided but does not extract the required group', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Prefix-ImportantPart-Suffix');
        const matchers: Matcher[] = [
          {
            type: 'title',
            regexp: `^Prefix-ImportantPart-Suffix$`, // No named group
            title: 'ImportantPart',
          },
        ];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(false);
      });

      it('should return true when no regexp and no matcher.title (matches any title)', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Any Title Will Do');
        const matchers: Matcher[] = [{ type: 'title' }];
        expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(true);
      });
    });

    describe('with template matcher', () => {
      it('should return true when template value matches', () => {
        const mediaMatcher = new MediaMatcher();
        const title = 'Any Title Will Do';
        const media = createMediaItem(title);

        vi.mocked(renderTemplate).mockReturnValue(true);

        const matchers: Matcher[] = [
          {
            type: 'template',
            value_template: '{{ acc.media.title == "Any Title Will Do" }}',
          },
        ];
        const hass = createHASS();
        expect(mediaMatcher.match(hass, media, { matchers })).toBe(true);

        expect(renderTemplate).toHaveBeenCalledWith(
          hass,
          '{{ acc.media.title == "Any Title Will Do" }}',
          {
            acc: {
              media: {
                title,
                is_folder: false,
              },
            },
            advanced_camera_card: {
              media: {
                title,
                is_folder: false,
              },
            },
          },
        );
      });

      it('should return false when template value does not match', () => {
        const mediaMatcher = new MediaMatcher();
        const title = 'Any Title Will Do';
        const media = createMediaItem(title);

        vi.mocked(renderTemplate).mockReturnValue(false);

        const matchers: Matcher[] = [
          {
            type: 'template',
            value_template: '{{ acc.media.title == "Any Title Will Do" }}',
          },
        ];
        const hass = createHASS();
        expect(mediaMatcher.match(hass, media, { matchers })).toBe(false);

        expect(renderTemplate).toHaveBeenCalledWith(
          hass,
          '{{ acc.media.title == "Any Title Will Do" }}',
          {
            acc: {
              media: {
                title,
                is_folder: false,
              },
            },
            advanced_camera_card: {
              media: {
                title,
                is_folder: false,
              },
            },
          },
        );
      });
    });

    describe('with or matcher', () => {
      it('should return true if at least one sub-matcher matches', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Test Media');
        const matcher: Matcher = {
          type: 'or',
          matchers: [
            { type: 'title', title: 'Non-Matching Title' }, // Fails
            { type: 'title', title: 'Test Media' }, // Passes
          ],
        };
        expect(mediaMatcher.match(createHASS(), media, { matchers: [matcher] })).toBe(
          true,
        );
      });

      it('should return false if no sub-matcher matches', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Test Media');
        const matcher: Matcher = {
          type: 'or',
          matchers: [
            { type: 'title', title: 'Non-Matching Title One' }, // Fails
            { type: 'title', title: 'Non-Matching Title Two' }, // Fails
          ],
        };
        expect(mediaMatcher.match(createHASS(), media, { matchers: [matcher] })).toBe(
          false,
        );
      });
    });

    describe('with date matcher', () => {
      it('should not match without metadata', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Test Media');
        const matcher: Matcher = {
          type: 'date',
          since: { days: 1 },
        };
        expect(mediaMatcher.match(createHASS(), media, { matchers: [matcher] })).toBe(
          false,
        );
      });

      it.each([
        [
          {
            type: 'date' as const,
            since: { days: 2, minutes: 1 },
          },
        ],
        [
          {
            type: 'date' as const,
            since: { days: 2, hours: 1 },
          },
        ],
        [
          {
            type: 'date' as const,
            since: { months: 1 },
          },
        ],
        [
          {
            type: 'date' as const,
            since: { years: 1 },
          },
        ],
      ])('should match with date more recent than matcher %s', (matcher: Matcher) => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Test Media');
        media._metadata = {
          startDate: sub(new Date(), { days: 1 }),
        };
        expect(mediaMatcher.match(createHASS(), media, { matchers: [matcher] })).toBe(
          true,
        );
      });

      it('should not match with date less recent than matcher', () => {
        const mediaMatcher = new MediaMatcher();
        const media = createMediaItem('Test Media');
        media._metadata = {
          startDate: sub(new Date(), { days: 2 }),
        };
        const matcher: Matcher = {
          type: 'date',
          since: { days: 1 },
        };
        expect(mediaMatcher.match(createHASS(), media, { matchers: [matcher] })).toBe(
          false,
        );
      });
    });

    it('should return false if one of multiple matchers fails', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test Media One');
      const matchers: Matcher[] = [
        { type: 'title', title: 'Test Media One' }, // Pass
        { type: 'title', title: 'Test Media Two' }, // Fail
      ];
      expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(false);
    });

    it('should return true if all multiple matchers pass', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test Media One');
      const matchers: Matcher[] = [
        { type: 'title', title: 'Test Media One' },
        {
          type: 'title',
          regexp: `^(?<value>Test Media One)$`,
          title: 'Test Media One',
        },
      ];
      expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(true);
    });

    it('should ignore matchers of unknown types', () => {
      const mediaMatcher = new MediaMatcher();
      const media = createMediaItem('Test Media');

      const matchers: Matcher[] = [{ type: 'unknownMatcherType' as 'title' }];
      expect(mediaMatcher.match(createHASS(), media, { matchers })).toBe(true);
    });
  });
});



================================================
FILE: tests/card-controller/folders/ha/metadata-generator.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { MetadataGenerator } from '../../../../src/card-controller/folders/ha/metadata-generator';
import { Parser } from '../../../../src/config/schema/folders';
import { createBrowseMedia, createRichBrowseMedia } from '../../../test-utils';

describe('MetadataGenerator', () => {
  const browseMedia = createBrowseMedia({
    title: 'Test Media 2025-05-26 18:18',
  });
  const expectedDate = new Date('2025-05-26T18:18:00.000Z');
  const formatlessDateParser: Parser = {
    type: 'startdate',
  };

  describe('should dynamically import any-date-parser when needed', () => {
    it('should not import any-date-parser if no parsers require it', async () => {
      const generator = new MetadataGenerator();
      await generator.prepare([
        // Pretend no parsers require unknown date formats.
      ]);

      expect(
        generator.generate(browseMedia, undefined, [formatlessDateParser])?.startDate,
      ).toBeUndefined();
    });

    it('should import any-date-parser if a parser requires it', async () => {
      const generator = new MetadataGenerator();

      await generator.prepare([formatlessDateParser]);
      expect(
        generator.generate(browseMedia, undefined, [formatlessDateParser])?.startDate,
      ).toEqual(expectedDate);

      // Re-preparing should nothing.
      await generator.prepare([formatlessDateParser]);
      expect(
        generator.generate(browseMedia, undefined, [formatlessDateParser])?.startDate,
      ).toEqual(expectedDate);
    });
  });

  describe('should generate metadata', () => {
    it('should not generate metadata without an parsers', async () => {
      const generator = new MetadataGenerator();
      await generator.prepare([]);

      expect(generator.generate(browseMedia)).toBeNull();
    });

    it('should ignore unknown parsers', async () => {
      const goodParser: Parser = {
        type: 'date',
      };
      const badParser: Parser = {
        type: 'UNKNOWN' as 'date',
      };
      const generator = new MetadataGenerator();
      await generator.prepare([goodParser, badParser]);

      expect(
        generator.generate(browseMedia, undefined, [goodParser, badParser]),
      ).toEqual({
        startDate: expectedDate,
      });
    });

    describe('should generate date metadata', () => {
      describe('should generate date metadata without a date format', () => {
        it('should generate start date without a date format', async () => {
          const generator = new MetadataGenerator();
          await generator.prepare([formatlessDateParser]);

          expect(
            generator.generate(browseMedia, undefined, [formatlessDateParser])
              ?.startDate,
          ).toEqual(expectedDate);
        });

        it('should treat date as an alias for the startdate parser', async () => {
          const parser: Parser = {
            type: 'date',
          };
          const generator = new MetadataGenerator();
          await generator.prepare([parser]);

          expect(
            generator.generate(browseMedia, undefined, [parser])?.startDate,
          ).toEqual(expectedDate);
        });

        it('should not parse when regexp fails to match', async () => {
          const parser: Parser = {
            type: 'date',
            regexp: 'WILL_NOT_MATCH',
          };
          const generator = new MetadataGenerator();
          await generator.prepare([parser]);

          expect(
            generator.generate(browseMedia, undefined, [parser])?.startDate,
          ).toBeUndefined();
        });

        it('should fail to generate start date without a date format', async () => {
          const badBrowseMedia = createBrowseMedia({
            title: 'Test Media NO DATE',
          });
          const generator = new MetadataGenerator();
          await generator.prepare([formatlessDateParser]);

          expect(
            generator.generate(badBrowseMedia, undefined, [formatlessDateParser])
              ?.startDate,
          ).toBeUndefined();
        });

        it('should fail to generate start date with invalid date', async () => {
          const badBrowseMedia = createBrowseMedia({
            title: '20250507AM',
          });
          const generator = new MetadataGenerator();
          await generator.prepare([formatlessDateParser]);

          expect(
            generator.generate(badBrowseMedia, undefined, [formatlessDateParser])
              ?.startDate,
          ).toBeUndefined();
        });

        it('should incorporate parent metadata without a date format', async () => {
          const parentBrowseMedia = createRichBrowseMedia({
            title: '2025-05-26',
            _metadata: {
              startDate: new Date('2025-05-26T00:00:00.000Z'),
            },
          });
          const childBrowseMedia = createBrowseMedia({
            title: '22:42',
          });
          const generator = new MetadataGenerator();
          await generator.prepare([formatlessDateParser]);

          expect(
            generator.generate(childBrowseMedia, parentBrowseMedia, [
              formatlessDateParser,
            ])?.startDate,
          ).toEqual(new Date('2025-05-26T22:42:00.000Z'));
        });
      });

      describe('should generate date metadata with a date format', () => {
        it('should generate start date with a date formater and a regexp', async () => {
          const dateParser: Parser = {
            type: 'startdate',
            format: 'yyyy-MM-dd HH:mm',
            regexp: 'Test Media (?<value>.*)',
          };
          const generator = new MetadataGenerator();
          await generator.prepare([dateParser]);

          expect(
            generator.generate(browseMedia, undefined, [dateParser])?.startDate,
          ).toEqual(expectedDate);
        });

        it('should fail to generate start date with a date formater without a regexp', async () => {
          const dateParser: Parser = {
            type: 'startdate',
            format: 'yyyy-MM-dd HH:mm',
          };
          const generator = new MetadataGenerator();
          await generator.prepare([dateParser]);

          expect(
            generator.generate(browseMedia, undefined, [dateParser])?.startDate,
          ).toBeUndefined();
        });

        it('should use multiple parsed dates together', async () => {
          const browseMedia = createBrowseMedia({
            title: 'Foscam C1-20250507-171758-1746631078004-3.mp4',
          });
          const parsers: Parser[] = [
            {
              type: 'date',
              regexp: '\\d{8}',
            },
            {
              type: 'date',
              regexp: '-(?<value>\\d{6})-',
              format: 'HHmmss',
            },
          ];
          const generator = new MetadataGenerator();
          await generator.prepare(parsers);

          expect(generator.generate(browseMedia, undefined, parsers)?.startDate).toEqual(
            new Date('2025-05-07T17:17:58.000Z'),
          );
        });

        it('should incorporate parent metadata with a date format', async () => {
          const parentBrowseMedia = createRichBrowseMedia({
            title: '2025-05-26',
            _metadata: {
              startDate: new Date('2025-05-26T00:00:00.000Z'),
            },
          });
          const childBrowseMedia = createBrowseMedia({
            title: '22:42',
          });
          const parser: Parser = {
            type: 'startdate',
            format: 'HH:mm',
          };
          const generator = new MetadataGenerator();
          await generator.prepare([parser]);

          expect(
            generator.generate(childBrowseMedia, parentBrowseMedia, [parser])?.startDate,
          ).toEqual(new Date('2025-05-26T22:42:00.000Z'));
        });
      });
    });
  });
});



================================================
FILE: tests/card-controller/fullscreen/factory.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { FullscreenProviderFactory } from '../../../src/card-controller/fullscreen/factory';
import { ScreenfullFullScreenProvider } from '../../../src/card-controller/fullscreen/screenfull';
import { WebkitFullScreenProvider } from '../../../src/card-controller/fullscreen/webkit';
import { WebkitHTMLVideoElement } from '../../../src/types';
import { createCardAPI, setScreenfulEnabled } from '../../test-utils';

// @vitest-environment jsdom
describe('FullscreenProviderFactory', () => {
  afterEach(() => {
    vi.unstubAllGlobals();
  });

  it('should return screenful when enabled', () => {
    setScreenfulEnabled(true);

    expect(FullscreenProviderFactory.create(createCardAPI(), vi.fn())).toBeInstanceOf(
      ScreenfullFullScreenProvider,
    );
  });

  it('should return webkit when enabled', () => {
    setScreenfulEnabled(false);

    const element = document.createElement('video') as HTMLVideoElement &
      Partial<WebkitHTMLVideoElement>;
    element['webkitEnterFullscreen'] = vi.fn();

    const stubDocument = mock<Document>();
    stubDocument.createElement.mockReturnValue(element);

    vi.stubGlobal('document', stubDocument);

    expect(FullscreenProviderFactory.create(createCardAPI(), vi.fn())).toBeInstanceOf(
      WebkitFullScreenProvider,
    );
  });

  it('should return null without any provider', () => {
    setScreenfulEnabled(false);

    const element = document.createElement('video') as HTMLVideoElement &
      Partial<WebkitHTMLVideoElement>;
    element['webkitEnterFullscreen'] = undefined;

    const stubDocument = mock<Document>();
    stubDocument.createElement.mockReturnValue(element);

    vi.stubGlobal('document', stubDocument);

    expect(FullscreenProviderFactory.create(createCardAPI(), vi.fn())).toBeNull();
  });
});



================================================
FILE: tests/card-controller/fullscreen/fullscreen-manager.test.ts
================================================
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { FullscreenProviderFactory } from '../../../src/card-controller/fullscreen/factory';
import { FullscreenManager } from '../../../src/card-controller/fullscreen/fullscreen-manager';
import { FullscreenProvider } from '../../../src/card-controller/fullscreen/types';
import { createCardAPI } from '../../test-utils';

vi.mock('../../../src/card-controller/fullscreen/factory');

describe('FullscreenManager', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should initialize', () => {
    const api = createCardAPI();
    const manager = new FullscreenManager(api, mock<FullscreenProvider>());

    manager.initialize();
    expect(api.getConditionStateManager().setState).toBeCalledWith({
      fullscreen: false,
    });
  });

  it('should correctly determine whether in fullscreen', () => {
    const provider = mock<FullscreenProvider>();
    const manager = new FullscreenManager(createCardAPI(), provider);

    provider.isInFullscreen.mockReturnValue(true);

    expect(manager.isInFullscreen()).toBeTruthy();

    provider.isInFullscreen.mockReturnValue(false);

    expect(manager.isInFullscreen()).toBeFalsy();
  });

  describe('describe toggle fullscreen', () => {
    it.each([
      [true, false],
      [false, true],
    ])('%s -> %s', async (state: boolean, expected: boolean) => {
      const provider = mock<FullscreenProvider>();
      provider.isInFullscreen.mockReturnValue(state);

      const manager = new FullscreenManager(createCardAPI(), provider);

      manager.toggleFullscreen();

      expect(provider.setFullscreen).toBeCalledWith(expected);
    });
  });

  describe('describe set fullscreen', () => {
    it.each([[true], [false]])('%s', async (fullscreen: boolean) => {
      const provider = mock<FullscreenProvider>();
      const manager = new FullscreenManager(createCardAPI(), provider);

      manager.setFullscreen(fullscreen);

      expect(provider.setFullscreen).toBeCalledWith(fullscreen);
    });
  });

  it('should connect', () => {
    const provider = mock<FullscreenProvider>();
    const manager = new FullscreenManager(createCardAPI(), provider);

    manager.connect();

    expect(provider.connect).toBeCalled();
  });

  it('should disconnect', () => {
    const provider = mock<FullscreenProvider>();
    const manager = new FullscreenManager(createCardAPI(), provider);

    manager.disconnect();

    expect(provider.disconnect).toBeCalled();
  });

  describe('should confirm whether fullscreen is supported', () => {
    beforeEach(() => {
      vi.stubGlobal('navigator', { userAgent: 'foo' });
    });
    afterEach(() => {
      vi.restoreAllMocks();
    });

    it('when being casted', () => {
      vi.stubGlobal('navigator', { userAgent: 'CrKey/' });

      const api = createCardAPI();
      const provider = mock<FullscreenProvider>();
      provider.isSupported.mockReturnValue(true);

      const manager = new FullscreenManager(api, provider);

      expect(manager.isSupported()).toBeFalsy();
    });

    describe('should return provider support', () => {
      it.each([[true], [false]])('%s', async (support: boolean) => {
        const api = createCardAPI();
        const provider = mock<FullscreenProvider>();
        provider.isSupported.mockReturnValue(support);
        const manager = new FullscreenManager(api, provider);

        expect(manager.isSupported()).toBe(support);
      });
    });

    it('without a provider', () => {
      vi.mocked(FullscreenProviderFactory).create.mockReturnValue(null);

      const manager = new FullscreenManager(createCardAPI());

      expect(manager.isSupported()).toBeFalsy();
    });
  });

  describe('should handle state change', () => {
    it.each([[true], [false]])('%s', async (fullscreen: boolean) => {
      const api = createCardAPI();

      const provider = mock<FullscreenProvider>();
      vi.mocked(FullscreenProviderFactory.create).mockReturnValue(provider);

      new FullscreenManager(api);

      const handler = vi.mocked(FullscreenProviderFactory.create).mock.calls[0][1];

      provider.isInFullscreen.mockReturnValue(fullscreen);

      handler();

      expect(api.getConditionStateManager().setState).toBeCalledWith({
        fullscreen: fullscreen,
      });
    });
  });

  it('should create provider from factory', () => {
    const api = createCardAPI();

    new FullscreenManager(api);

    expect(FullscreenProviderFactory.create).toBeCalledWith(api, expect.anything());
  });
});



================================================
FILE: tests/card-controller/fullscreen/screenfull/index.test.ts
================================================
import screenfull from 'screenfull';
import { afterEach, describe, expect, it, vi } from 'vitest';
import { ScreenfullFullScreenProvider } from '../../../../src/card-controller/fullscreen/screenfull';
import { createCardAPI, setScreenfulEnabled } from '../../../test-utils';

vi.mock('screenfull', () => ({
  default: {
    exit: vi.fn(),
    request: vi.fn(),
    off: vi.fn(),
    on: vi.fn(),
  },
}));

const setScreenfulFullscreen = (fullscreen: boolean): void => {
  Object.defineProperty(screenfull, 'isFullscreen', {
    value: fullscreen,
    writable: true,
  });
};

// @vitest-environment jsdom
describe('ScreenfullFullScreenProvider', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('should connect', () => {
    it('should connect if enabled', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());
      const on = vi.mocked(screenfull.on);

      setScreenfulEnabled(true);

      provider.connect();

      expect(on).toBeCalledWith('change', expect.anything());
    });

    it('should not connect if not enabled', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());
      const on = vi.mocked(screenfull.on);

      setScreenfulEnabled(false);

      provider.connect();

      expect(on).not.toBeCalled();
    });
  });

  describe('should disconnect', () => {
    it('should disconnect if enabled', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());
      const off = vi.mocked(screenfull.off);

      setScreenfulEnabled(true);

      provider.disconnect();

      expect(off).toBeCalledWith('change', expect.anything());
    });

    it('should not disconnect if not enabled', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());
      const off = vi.mocked(screenfull.off);

      setScreenfulEnabled(false);

      provider.disconnect();

      expect(off).not.toBeCalled();
    });
  });

  describe('should return if in fullscreen', () => {
    it('should return true if in fullscreen', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());

      setScreenfulEnabled(true);
      setScreenfulFullscreen(true);

      expect(provider.isInFullscreen()).toBeTruthy();
    });

    it('should return false if not in fullscreen', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());

      setScreenfulEnabled(true);
      setScreenfulFullscreen(false);

      expect(provider.isInFullscreen()).toBeFalsy();
    });

    it('should return false if not supported', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());

      setScreenfulEnabled(false);
      setScreenfulFullscreen(true);

      expect(provider.isInFullscreen()).toBeFalsy();
    });
  });

  describe('should return if supported', () => {
    it('should return true if supported', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());

      setScreenfulEnabled(true);

      expect(provider.isSupported()).toBeTruthy();
    });

    it('should return false if not supported', () => {
      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());

      setScreenfulEnabled(false);

      expect(provider.isSupported()).toBeFalsy();
    });
  });

  describe('should set fullscreen', () => {
    it('should request fullscreen if fullscreen is true', () => {
      setScreenfulEnabled(true);

      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      const provider = new ScreenfullFullScreenProvider(api, vi.fn());

      provider.setFullscreen(true);

      expect(screenfull.request).toBeCalledWith(element);
    });

    it('should exit fullscreen if fullscreen is false', () => {
      setScreenfulEnabled(true);

      const provider = new ScreenfullFullScreenProvider(createCardAPI(), vi.fn());

      provider.setFullscreen(false);

      expect(screenfull.exit).toBeCalled();
    });

    it('should take no action if not supported', () => {
      setScreenfulEnabled(false);

      const api = createCardAPI();
      const element = document.createElement('div');
      vi.mocked(api.getCardElementManager().getElement).mockReturnValue(element);
      const provider = new ScreenfullFullScreenProvider(api, vi.fn());

      provider.setFullscreen(true);
      provider.setFullscreen(false);

      expect(screenfull.request).not.toBeCalled();
      expect(screenfull.exit).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/card-controller/fullscreen/webkit/index.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { WebkitFullScreenProvider } from '../../../../src/card-controller/fullscreen/webkit';
import { ConditionStateManager } from '../../../../src/conditions/state-manager';
import { MediaPlayerController, WebkitHTMLVideoElement } from '../../../../src/types';
import { createCardAPI, createMediaLoadedInfo } from '../../../test-utils';

const createWebkitVideoElement = (): HTMLVideoElement &
  Partial<WebkitHTMLVideoElement> => {
  return document.createElement('video');
};

const createMediaPlayerController = (element: HTMLElement): MediaPlayerController => {
  const mediaPlayerController = mock<MediaPlayerController>();
  mediaPlayerController.getFullscreenElement.mockReturnValue(element);
  return mediaPlayerController;
};

// @vitest-environment jsdom
describe('WebkitFullScreenProvider', () => {
  beforeAll(() => {
    vi.useFakeTimers();
  });

  afterAll(() => {
    vi.useRealTimers();
  });

  it('should connect', () => {
    const api = createCardAPI();
    const provider = new WebkitFullScreenProvider(api, vi.fn());

    provider.connect();

    expect(api.getConditionStateManager().addListener).toBeCalledWith(expect.anything());
  });

  it('should disconnect', () => {
    const api = createCardAPI();
    const provider = new WebkitFullScreenProvider(api, vi.fn());

    provider.disconnect();

    expect(api.getConditionStateManager().removeListener).toBeCalledWith(
      expect.anything(),
    );
  });

  describe('should return if in fullscreen', () => {
    it.each([[true], [false]])('%s', async (fullscreen: boolean) => {
      const api = createCardAPI();
      const provider = new WebkitFullScreenProvider(api, vi.fn());

      const element = createWebkitVideoElement();
      element.webkitDisplayingFullscreen = fullscreen;

      const mediaPlayerController = createMediaPlayerController(element);
      vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
        createMediaLoadedInfo({
          mediaPlayerController,
        }),
      );

      expect(provider.isInFullscreen()).toBe(fullscreen);
    });
  });

  describe('should return if supported', () => {
    it.each([[true], [false]])('%s', async (supported: boolean) => {
      const api = createCardAPI();
      const provider = new WebkitFullScreenProvider(api, vi.fn());

      const element = createWebkitVideoElement();
      element.webkitSupportsFullscreen = supported;

      const mediaPlayerController = createMediaPlayerController(element);
      vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
        createMediaLoadedInfo({
          mediaPlayerController,
        }),
      );

      expect(provider.isSupported()).toBe(supported);
    });
  });

  describe('should set fullscreen', () => {
    it('should request fullscreen if fullscreen is true', () => {
      const api = createCardAPI();
      const provider = new WebkitFullScreenProvider(api, vi.fn());

      const element = createWebkitVideoElement();
      element.webkitEnterFullscreen = vi.fn();
      element.webkitSupportsFullscreen = true;

      const mediaPlayerController = createMediaPlayerController(element);
      vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
        createMediaLoadedInfo({
          mediaPlayerController,
        }),
      );

      provider.setFullscreen(true);

      expect(element.webkitEnterFullscreen).toBeCalled();
    });

    it('should exit fullscreen if fullscreen is true', () => {
      const api = createCardAPI();
      const provider = new WebkitFullScreenProvider(api, vi.fn());

      const element = createWebkitVideoElement();
      element.webkitExitFullscreen = vi.fn();
      element.webkitSupportsFullscreen = true;

      const mediaPlayerController = createMediaPlayerController(element);
      vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
        createMediaLoadedInfo({
          mediaPlayerController,
        }),
      );

      provider.setFullscreen(false);

      expect(element.webkitExitFullscreen).toBeCalled();
    });

    it('should take no action if not supported', () => {
      const api = createCardAPI();
      const provider = new WebkitFullScreenProvider(api, vi.fn());

      const element = createWebkitVideoElement();
      element.webkitEnterFullscreen = vi.fn();
      element.webkitExitFullscreen = vi.fn();
      element.webkitSupportsFullscreen = false;

      const mediaPlayerController = createMediaPlayerController(element);
      vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
        createMediaLoadedInfo({
          mediaPlayerController,
        }),
      );

      provider.setFullscreen(true);
      provider.setFullscreen(false);

      expect(element.webkitEnterFullscreen).not.toBeCalled();
      expect(element.webkitExitFullscreen).not.toBeCalled();
    });

    it('should take no action if element is not a video', () => {
      const api = createCardAPI();
      const provider = new WebkitFullScreenProvider(api, vi.fn());

      const element = document.createElement('img') as HTMLImageElement &
        Partial<WebkitHTMLVideoElement>;
      element.webkitEnterFullscreen = vi.fn();
      element.webkitExitFullscreen = vi.fn();

      const mediaPlayerController = createMediaPlayerController(element);
      vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
        createMediaLoadedInfo({
          mediaPlayerController,
        }),
      );

      provider.setFullscreen(true);
      provider.setFullscreen(false);

      expect(element.webkitEnterFullscreen).not.toBeCalled();
      expect(element.webkitExitFullscreen).not.toBeCalled();
    });
  });

  describe('should handle state changes', () => {
    describe('should call handler when fullscreen state changes', () => {
      it.each([['webkitbeginfullscreen'], ['webkitendfullscreen']])(
        '%s',
        (event: string) => {
          const handler = vi.fn();
          const api = createCardAPI();
          const stateManager = new ConditionStateManager();
          vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

          const provider = new WebkitFullScreenProvider(api, handler);

          provider.connect();

          const element_1 = createWebkitVideoElement();
          const mediaPlayerController_1 = mock<MediaPlayerController>();
          mediaPlayerController_1.getFullscreenElement.mockReturnValue(element_1);
          const mediaLoadedInfo_1 = createMediaLoadedInfo({
            mediaPlayerController: mediaPlayerController_1,
          });

          stateManager.setState({ mediaLoadedInfo: mediaLoadedInfo_1 });

          element_1.dispatchEvent(new Event(event));

          expect(handler).toBeCalledTimes(1);

          const element_2 = createWebkitVideoElement();
          const mediaPlayerController_2 = mock<MediaPlayerController>();
          mediaPlayerController_2.getFullscreenElement.mockReturnValue(element_2);
          const mediaLoadedInfo_2 = createMediaLoadedInfo({
            mediaPlayerController: mediaPlayerController_2,
          });

          stateManager.setState({ mediaLoadedInfo: mediaLoadedInfo_2 });

          element_2.dispatchEvent(new Event(event));

          expect(handler).toBeCalledTimes(2);

          // Events on the old element should be ignored.
          element_1.dispatchEvent(new Event(event));

          expect(handler).toBeCalledTimes(2);

          // Test the media loaded info changing, but the player not changing.
          stateManager.setState({
            mediaLoadedInfo: { ...mediaLoadedInfo_2, width: 101 },
          });

          // Events on the new element should still be handled.
          element_2.dispatchEvent(new Event(event));

          expect(handler).toBeCalledTimes(3);
        },
      );
    });
  });

  it('should play the video after fullscreen ends', () => {
    const handler = vi.fn();
    const api = createCardAPI();
    const stateManager = new ConditionStateManager();
    vi.mocked(api.getConditionStateManager).mockReturnValue(stateManager);

    const provider = new WebkitFullScreenProvider(api, handler);

    provider.connect();

    const element = createWebkitVideoElement();
    element.play = vi.fn();

    const mediaPlayerController = createMediaPlayerController(element);
    vi.mocked(api.getMediaLoadedInfoManager().get).mockReturnValue(
      createMediaLoadedInfo({
        mediaPlayerController,
      }),
    );

    const mediaLoadedInfo = createMediaLoadedInfo({ mediaPlayerController });

    stateManager.setState({ mediaLoadedInfo });

    element.dispatchEvent(new Event('webkitendfullscreen'));

    expect(element.play).not.toBeCalled();

    vi.runOnlyPendingTimers();

    expect(element.play).toBeCalled();
  });
});



================================================
FILE: tests/card-controller/hass/hass-manager.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { HASSManager } from '../../../src/card-controller/hass/hass-manager';
import { StateWatcher } from '../../../src/card-controller/hass/state-watcher';
import {
  createCameraConfig,
  createCameraManager,
  createCardAPI,
  createConfig,
  createHASS,
  createStateEntity,
  createStore,
  createView,
} from '../../test-utils';

describe('HASSManager', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  it('should have null hass on construction', () => {
    const manager = new HASSManager(createCardAPI());
    expect(manager.getHASS()).toBeNull();
    expect(manager.hasHASS()).toBeFalsy();
  });

  it('should get state watcher', () => {
    const manager = new HASSManager(createCardAPI());
    expect(manager.getStateWatcher()).toEqual(expect.any(StateWatcher));
  });

  it('should get hass after set', () => {
    const manager = new HASSManager(createCardAPI());
    const hass = createHASS();
    manager.setHASS(hass);

    expect(manager.getHASS()).toBe(hass);
    expect(manager.hasHASS()).toBeTruthy();
  });

  it('should update theme upon setting hass', () => {
    const api = createCardAPI();
    const manager = new HASSManager(api);

    manager.setHASS(createHASS());

    expect(api.getStyleManager().applyTheme).toBeCalled();
  });

  it('should set condition manager state', () => {
    const api = createCardAPI();
    const manager = new HASSManager(api);
    const hass = createHASS();

    manager.setHASS(hass);

    expect(api.getConditionStateManager().setState).toBeCalledWith(
      expect.objectContaining({
        hass: hass,
      }),
    );
  });

  describe('should handle connection state change when', () => {
    it('initially disconnected', () => {
      const api = createCardAPI();
      const manager = new HASSManager(api);

      const disconnectedHASS = createHASS();
      disconnectedHASS.connected = false;

      manager.setHASS(disconnectedHASS);

      expect(api.getMessageManager().setMessageIfHigherPriority).toBeCalledWith(
        expect.objectContaining({
          message: 'Reconnecting',
          icon: 'mdi:lan-disconnect',
          type: 'connection',
          dotdotdot: true,
        }),
      );
    });

    it('disconnected', () => {
      const api = createCardAPI();
      const manager = new HASSManager(api);

      manager.setHASS(createHASS());

      const disconnectedHASS = createHASS();
      disconnectedHASS.connected = false;
      manager.setHASS(disconnectedHASS);

      expect(api.getMessageManager().setMessageIfHigherPriority).toBeCalledWith(
        expect.objectContaining({
          message: 'Reconnecting',
          icon: 'mdi:lan-disconnect',
          type: 'connection',
          dotdotdot: true,
        }),
      );
    });

    it('reconnected', () => {
      const api = createCardAPI();
      const manager = new HASSManager(api);

      const disconnectedHASS = createHASS();
      disconnectedHASS.connected = false;
      manager.setHASS(disconnectedHASS);

      const reconnectedHASS = createHASS();
      manager.setHASS(reconnectedHASS);

      expect(api.getMessageManager().resetType).toBeCalled();
    });

    it('hass is null', () => {
      const api = createCardAPI();
      const manager = new HASSManager(api);
      const connectedHASS = createHASS();
      connectedHASS.connected = true;

      manager.setHASS(connectedHASS);
      manager.setHASS(null);

      expect(api.getMessageManager().setMessageIfHigherPriority).toBeCalledWith(
        expect.objectContaining({
          message: 'Reconnecting',
          icon: 'mdi:lan-disconnect',
          type: 'connection',
          dotdotdot: true,
        }),
      );

      manager.setHASS(connectedHASS);
      expect(api.getMessageManager().resetType).toBeCalled();
    });
  });

  describe('should not set default view when', () => {
    it('selected camera is unknown', () => {
      const api = createCardAPI();
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera.foo',
            config: createCameraConfig({
              triggers: {
                entities: ['binary_sensor.motion'],
              },
            }),
          },
        ]),
      );
      vi.mocked(api.getViewManager().getView).mockReturnValue(
        createView({
          camera: 'camera.UNKNOWN',
        }),
      );

      const manager = new HASSManager(api);
      const hass = createHASS({
        'binary_sensor.motion': createStateEntity(),
      });

      manager.setHASS(hass);

      expect(api.getViewManager().setViewDefault).not.toBeCalled();
    });

    it('when there is card interaction', () => {
      const api = createCardAPI();
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
        createConfig({
          view: {
            default_reset: {
              entities: ['sensor.force_default_view'],
            },
          },
        }),
      );
      vi.mocked(api.getInteractionManager().hasInteraction).mockReturnValue(true);

      const manager = new HASSManager(api);
      const hass = createHASS({
        'sensor.force_default_view': createStateEntity(),
      });

      manager.setHASS(hass);

      expect(api.getViewManager().setViewDefault).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/card-controller/hass/state-watcher.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { StateWatcher } from '../../../src/card-controller/hass/state-watcher';
import { createHASS, createStateEntity } from '../../test-utils';

describe('StateWatcher', () => {
  it('should not subscribe with no entities', () => {
    const stateWatcher = new StateWatcher();
    const callback = vi.fn();
    expect(stateWatcher.subscribe(callback, [])).toBeFalsy();
  });

  it('should call back with state change', () => {
    const stateWatcher = new StateWatcher();
    const callback = vi.fn();
    expect(stateWatcher.subscribe(callback, ['binary_sensor.foo'])).toBeTruthy();
    expect(stateWatcher.subscribe(callback, ['binary_sensor.bar'])).toBeTruthy();

    stateWatcher.setHASS(
      null,
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
        'binary_sensor.bar': createStateEntity({ state: 'off' }),
      }),
    );

    expect(callback).not.toBeCalled();

    stateWatcher.setHASS(
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
        'binary_sensor.bar': createStateEntity({ state: 'off' }),
      }),
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
        'binary_sensor.bar': createStateEntity({ state: 'on' }),
      }),
    );

    expect(callback).toBeCalledTimes(1);
    expect(callback).toBeCalledWith(
      expect.objectContaining({
        entityID: 'binary_sensor.bar',
        oldState: createStateEntity({ state: 'off' }),
        newState: createStateEntity({ state: 'on' }),
      }),
    );
  });

  it('should not call back without state change', () => {
    const stateWatcher = new StateWatcher();
    const callback = vi.fn();
    expect(stateWatcher.subscribe(callback, ['binary_sensor.foo'])).toBeTruthy();

    stateWatcher.setHASS(
      null,
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
      }),
    );

    expect(callback).not.toBeCalled();

    stateWatcher.setHASS(
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
      }),
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
      }),
    );

    expect(callback).not.toBeCalled();
  });

  it('should not call back when unsubscribed', () => {
    const stateWatcher = new StateWatcher();
    const callback = vi.fn();
    expect(stateWatcher.subscribe(callback, ['binary_sensor.foo'])).toBeTruthy();
    expect(stateWatcher.unsubscribe(callback));

    stateWatcher.setHASS(
      null,
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
      }),
    );

    expect(callback).not.toBeCalled();

    stateWatcher.setHASS(
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'on' }),
      }),
      createHASS({
        'binary_sensor.foo': createStateEntity({ state: 'off' }),
      }),
    );

    expect(callback).not.toBeCalled();
  });
});



================================================
FILE: tests/card-controller/view/factory.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { ViewFactory } from '../../../src/card-controller/view/factory';
import { ViewModifier } from '../../../src/card-controller/view/types';
import { AdvancedCameraCardView } from '../../../src/config/schema/common/const';
import { ViewDisplayMode } from '../../../src/config/schema/common/display';
import { View } from '../../../src/view/view';
import {
  createCameraManager,
  createCapabilities,
  createCardAPI,
  createConfig,
  createStore,
  createView,
} from '../../test-utils';
import { createPopulatedAPI } from './test-utils';

describe('getViewDefault', () => {
  it('should return null without config', () => {
    const factory = new ViewFactory(createCardAPI());
    expect(factory.getViewDefault()).toBeNull();
  });

  it('should throw if no cameras support view', () => {
    const api = createCardAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());

    // No cameras support live.
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(
      createStore([
        {
          cameraID: 'camera.office',
          capabilities: createCapabilities({
            live: false,
          }),
        },
        {
          cameraID: 'camera.kitchen',
          capabilities: createCapabilities({
            live: false,
          }),
        },
      ]),
    );

    const factory = new ViewFactory(api);
    expect(() => factory.getViewDefault()).toThrowError(/No cameras support this view/);
  });

  it('should create view', () => {
    const factory = new ViewFactory(createPopulatedAPI());
    const view = factory.getViewDefault();

    expect(view?.is('live')).toBeTruthy();
    expect(view?.camera).toBe('camera.office');
  });

  it('should cycle camera when configured', () => {
    const api = createPopulatedAPI();
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(
      createConfig({
        view: {
          default_cycle_camera: true,
        },
      }),
    );

    const factory = new ViewFactory(api);

    let view = factory.getViewDefault();
    expect(view?.camera).toBe('camera.office');

    view = factory.getViewDefault({ baseView: view });
    expect(view?.camera).toBe('camera.kitchen');

    view = factory.getViewDefault({ baseView: view });
    expect(view?.camera).toBe('camera.office');

    // When a parameter is specified, it will not cycle.
    view = factory.getViewDefault({
      params: { camera: 'camera.office' },
      baseView: view,
    });
    expect(view?.camera).toBe('camera.office');
  });

  it('should use default camera when camera unspecified', () => {
    // Even though baseView has a camera, since default is called it should
    // use that camera.

    const factory = new ViewFactory(createPopulatedAPI());
    const baseView = createView({ camera: 'camera.kitchen' });
    const view = factory.getViewDefault({
      baseView: baseView,
    });

    expect(view?.is('live')).toBeTruthy();
    expect(view?.camera).toBe('camera.office');
  });

  it('should respect parameters', () => {
    const factory = new ViewFactory(createPopulatedAPI());
    const view = factory.getViewDefault({
      params: {
        camera: 'camera.kitchen',
      },
    });

    expect(view?.is('live')).toBeTruthy();
    expect(view?.camera).toBe('camera.kitchen');
  });
});

describe('getViewByParameters', () => {
  it('should get view by parameters specifying camera and view', () => {
    const api = createPopulatedAPI();
    vi.mocked(api.getCameraManager().getAggregateCameraCapabilities).mockReturnValue(
      createCapabilities({
        clips: true,
      }),
    );

    const factory = new ViewFactory(api);
    const view = factory.getViewByParameters({
      params: {
        camera: 'camera.kitchen',
        view: 'clips',
      },
    });

    expect(view?.is('clips')).toBeTruthy();
    expect(view?.camera).toBe('camera.kitchen');
  });

  it('should get view by parameters using base view if unspecified', () => {
    const api = createPopulatedAPI();
    vi.mocked(api.getCameraManager().getAggregateCameraCapabilities).mockReturnValue(
      createCapabilities({
        clips: true,
      }),
    );

    const factory = new ViewFactory(api);
    const baseView = new View({
      camera: 'camera.kitchen',
      view: 'clips',
    });

    const view = factory.getViewByParameters({
      baseView: baseView,
      params: {
        camera: 'camera.office',
      },
    });

    expect(view?.view).toBe('clips');
    expect(view?.camera).toBe('camera.office');
  });

  it('should set view by parameters using config as fallback', () => {
    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(
      createStore([
        {
          cameraID: 'camera.kitchen',
          capabilities: createCapabilities({ live: true }),
        },
      ]),
    );
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

    const factory = new ViewFactory(api);
    const view = factory.getViewByParameters({
      params: {
        camera: 'camera.kitchen',

        // No prior view, and no specified view. This could happen during query
        // string based initialization.
      },
    });

    expect(view?.is('live')).toBeTruthy();
    expect(view?.camera).toBe('camera.kitchen');
  });

  it('should not set view by parameters without config', () => {
    const factory = new ViewFactory(createCardAPI());

    const view = factory.getViewByParameters({
      params: {
        view: 'live',
      },
    });

    expect(view).toBeNull();
  });

  it('should throw without camera and without failsafe', () => {
    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(
      createStore([
        {
          cameraID: 'camera.kitchen',
          capabilities: createCapabilities({ snapshots: false }),
        },
        {
          cameraID: 'camera.office',
          // No capabilities.
          capabilities: null,
        },
      ]),
    );
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

    const factory = new ViewFactory(api);
    expect(() =>
      factory.getViewByParameters({
        // Since no camera is specified, and no camera supports the capabilities
        // necessary for this view, the view will be null.
        params: {
          view: 'snapshots',
        },
      }),
    ).toThrowError(/No cameras support this view/);
  });

  describe('should handle unsupported view', () => {
    it('should throw without failsafe', () => {
      const api = createCardAPI();
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera.kitchen',
            capabilities: createCapabilities({ snapshots: false }),
          },
        ]),
      );
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(api.getCameraManager().getAggregateCameraCapabilities).mockReturnValue(
        createCapabilities({
          snapshots: false,
        }),
      );

      const factory = new ViewFactory(api);
      expect(() =>
        factory.getViewByParameters({
          params: {
            camera: 'camera.kitchen',
            view: 'snapshots',
          },
        }),
      ).toThrowError(/The selected camera does not support this view/);
    });

    it('should choose live view with failsafe', () => {
      const api = createCardAPI();
      vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
      vi.mocked(api.getCameraManager().getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera.kitchen',
            capabilities: createCapabilities({ live: true, snapshots: false }),
          },
        ]),
      );
      vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());
      vi.mocked(api.getCameraManager().getAggregateCameraCapabilities).mockReturnValue(
        createCapabilities({
          live: true,
          snapshots: false,
        }),
      );

      const factory = new ViewFactory(api);
      const view = factory.getViewByParameters({
        params: {
          camera: 'camera.kitchen',
          view: 'snapshots',
        },
        failSafe: true,
      });
      expect(view?.is('live')).toBeTruthy();
    });
  });

  it('should call modifiers', () => {
    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(
      createStore([
        {
          cameraID: 'camera.office',
          capabilities: createCapabilities({ live: true }),
        },
      ]),
    );
    vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig());

    const modifyCallback = vi.fn();
    class TestViewModifier implements ViewModifier {
      modify = modifyCallback;
    }

    const view = new View({
      view: 'live',
      camera: 'camera.office',
    });
    const factory = new ViewFactory(api);
    const modifiedView = factory.getViewByParameters({
      baseView: view,
      modifiers: [new TestViewModifier()],
    });

    expect(modifiedView?.is('live')).toBeTruthy();
    expect(modifiedView?.camera).toBe('camera.office');
    expect(view).not.toBe(modifiedView);
    expect(modifyCallback).toHaveBeenCalledWith(modifiedView);
  });

  describe('should get correct display mode', () => {
    it('should use config display mode when changing views', () => {
      const api = createPopulatedAPI({
        media_viewer: {
          display: { mode: 'single' },
        },
      });

      const factory = new ViewFactory(api);
      expect(
        factory.getViewByParameters({
          params: {
            view: 'clip',
            displayMode: 'grid',
          },
        })?.displayMode,
      ).toBe('single');
    });

    it('should ignore config display mode with a view', () => {
      const api = createPopulatedAPI({
        media_viewer: {
          display: { mode: 'single' },
        },
      });

      const baseView = createView({
        view: 'live',
      });

      const factory = new ViewFactory(api);
      expect(
        factory.getViewByParameters({
          baseView: baseView,
          params: {
            view: 'live',
            displayMode: 'grid',
          },
        })?.displayMode,
      ).toBe('grid');
    });

    describe('should get correct default display mode', () => {
      describe.each([
        ['single' as const, { mode: 'single' as const }],
        ['grid' as const, { mode: 'grid' as const }],
        ['single' as const, undefined],
      ])('%s', (expectedDisplayMode: ViewDisplayMode, displayConfig?: unknown) => {
        it.each([
          ['media' as const],
          ['clip' as const],
          ['recording' as const],
          ['snapshot' as const],
          ['live' as const],
        ])('%s', (viewName: AdvancedCameraCardView) => {
          const api = createPopulatedAPI({
            media_viewer: {
              display: displayConfig,
            },
            live: {
              display: displayConfig,
            },
          });

          const factory = new ViewFactory(api);
          expect(
            factory.getViewByParameters({
              params: {
                view: viewName,
              },
            })?.displayMode,
          ).toBe(expectedDisplayMode);
        });
      });
    });
  });
});



================================================
FILE: tests/card-controller/view/item-manager.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { ViewItemManager } from '../../../src/card-controller/view/item-manager';
import { homeAssistantSignPath } from '../../../src/ha/sign-path.js';
import { downloadURL } from '../../../src/utils/download';
import { ViewFolder, ViewMediaType } from '../../../src/view/item';
import {
  createCardAPI,
  createFolder,
  createHASS,
  TestViewMedia,
} from '../../test-utils';

vi.mock('../../../src/utils/download');
vi.mock('../../../src/ha/sign-path.js');

describe('ViewItemManager', () => {
  describe('getCapabilities', () => {
    it('should return null for unsupported item types', () => {
      const api = createCardAPI();
      const manager = new ViewItemManager(api);

      expect(manager.getCapabilities(new TestViewMedia({ cameraID: null }))).toBeNull();
    });

    it('should return capabilities for camera media', () => {
      const api = createCardAPI();
      const capabilities = {
        canDownload: true,
        canFavorite: true,
      };
      vi.mocked(api.getCameraManager().getMediaCapabilities).mockReturnValue(
        capabilities,
      );

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: 'camera.office' });

      expect(manager.getCapabilities(item)).toEqual(capabilities);
    });

    it('should return capabilities for folder media', () => {
      const api = createCardAPI();
      const capabilities = {
        canDownload: true,
        canFavorite: true,
      };
      vi.mocked(api.getFoldersManager().getItemCapabilities).mockReturnValue(
        capabilities,
      );

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ folder: createFolder() });

      expect(manager.getCapabilities(item)).toEqual(capabilities);
    });
  });

  describe('download', () => {
    afterEach(() => {
      vi.restoreAllMocks();
    });

    it('should not download without hass', async () => {
      const api = createCardAPI();
      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: 'camera.office' });

      expect(await manager.download(item)).toBe(true);
      expect(downloadURL).not.toHaveBeenCalled();
    });

    it('should throw error when signing fails', async () => {
      const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: 'camera.office' });

      vi.mocked(api.getCameraManager().getMediaDownloadPath).mockResolvedValue({
        sign: true,
        endpoint: 'foo',
      });

      const signError = new Error('sign-error');
      vi.mocked(homeAssistantSignPath).mockRejectedValue(signError);

      expect(await manager.download(item)).toBe(false);
      expect(api.getMessageManager().setErrorIfHigherPriority).toHaveBeenCalledWith(
        expect.objectContaining({
          message: 'Could not sign media URL for download',
        }),
      );
      expect(consoleSpy).toHaveBeenCalledWith('sign-error');
    });

    it('should download camera media', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: 'camera.office' });

      vi.mocked(api.getCameraManager().getMediaDownloadPath).mockResolvedValue({
        sign: true,
        endpoint: 'foo',
      });

      vi.mocked(homeAssistantSignPath).mockResolvedValue('http://foo/signed-url');

      expect(await manager.download(item)).toBe(true);
      expect(downloadURL).toBeCalledWith(
        'http://foo/signed-url',
        'camera-office_id.mp4',
      );
    });

    it('should download folder media', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: null, folder: createFolder() });

      vi.mocked(api.getFoldersManager().getDownloadPath).mockResolvedValue({
        sign: true,
        endpoint: 'foo',
      });

      vi.mocked(homeAssistantSignPath).mockResolvedValue('http://foo/signed-url');

      expect(await manager.download(item)).toBe(true);
      expect(downloadURL).toBeCalledWith('http://foo/signed-url', 'media_id.mp4');
    });

    it('should download media without signing', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: 'camera.office' });

      vi.mocked(api.getCameraManager().getMediaDownloadPath).mockResolvedValue({
        sign: false,
        endpoint: 'foo',
      });

      expect(homeAssistantSignPath).not.toBeCalled();

      expect(await manager.download(item)).toBe(true);
      expect(downloadURL).toBeCalledWith('foo', 'camera-office_id.mp4');
    });

    it('should download media without camera or folder', async () => {
      const api = createCardAPI();
      vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({ cameraID: null, folder: null });

      expect(await manager.download(item)).toBe(false);
      expect(api.getMessageManager().setErrorIfHigherPriority).toHaveBeenCalledWith(
        expect.objectContaining({
          message: 'No media to download',
        }),
      );
    });

    describe('should generate useful download filenames', () => {
      it('should generate filename for media without ID', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = new ViewItemManager(api);
        const item = new TestViewMedia({ id: null });

        vi.mocked(api.getCameraManager().getMediaDownloadPath).mockResolvedValue({
          sign: false,
          endpoint: 'foo',
        });

        expect(await manager.download(item)).toBe(true);
        expect(downloadURL).toBeCalledWith('foo', 'camera.mp4');
      });

      it('should generate filename for media with start time', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = new ViewItemManager(api);
        const item = new TestViewMedia({ startTime: new Date('2025-05-03T17:41:00Z') });

        vi.mocked(api.getCameraManager().getMediaDownloadPath).mockResolvedValue({
          sign: false,
          endpoint: 'foo',
        });

        expect(await manager.download(item)).toBe(true);
        expect(downloadURL).toBeCalledWith('foo', 'camera_id_2025-05-03-17-41-00.mp4');
      });

      it('should generate filename for snapshot', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = new ViewItemManager(api);
        const item = new TestViewMedia({ mediaType: ViewMediaType.Snapshot });

        vi.mocked(api.getCameraManager().getMediaDownloadPath).mockResolvedValue({
          sign: false,
          endpoint: 'foo',
        });

        expect(await manager.download(item)).toBe(true);
        expect(downloadURL).toBeCalledWith('foo', 'camera_id.jpg');
      });

      it('should generate filename for folder without title', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = new ViewItemManager(api);
        const item = new ViewFolder(createFolder());

        vi.mocked(api.getFoldersManager().getDownloadPath).mockResolvedValue({
          sign: false,
          endpoint: 'foo',
        });

        expect(await manager.download(item)).toBe(true);
        expect(downloadURL).toBeCalledWith('foo', 'media');
      });

      it('should generate filename for folder with title', async () => {
        const api = createCardAPI();
        vi.mocked(api.getHASSManager().getHASS).mockReturnValue(createHASS());

        const manager = new ViewItemManager(api);
        const item = new ViewFolder(createFolder(), { title: 'title' });

        vi.mocked(api.getFoldersManager().getDownloadPath).mockResolvedValue({
          sign: false,
          endpoint: 'foo',
        });

        expect(await manager.download(item)).toBe(true);
        expect(downloadURL).toBeCalledWith('foo', 'title');
      });
    });
  });

  describe('favorite', () => {
    it('should favorite camera media', async () => {
      const api = createCardAPI();

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({
        cameraID: 'camera.office',
        mediaType: ViewMediaType.Snapshot,
      });

      await manager.favorite(item, true);

      expect(api.getCameraManager().favoriteMedia).toBeCalledWith(item, true);
    });

    it('should favorite folder media', async () => {
      const api = createCardAPI();

      const manager = new ViewItemManager(api);
      const item = new TestViewMedia({
        folder: createFolder(),
        mediaType: ViewMediaType.Snapshot,
      });

      await manager.favorite(item, true);

      expect(api.getFoldersManager().favorite).toBeCalledWith(item, true);
    });
  });
});



================================================
FILE: tests/card-controller/view/query-executor.test.ts
================================================
import { add } from 'date-fns';
import { describe, expect, it, vi } from 'vitest';
import { QueryType } from '../../../src/camera-manager/types';
import { FolderQuery } from '../../../src/card-controller/folders/types';
import { QueryExecutor } from '../../../src/card-controller/view/query-executor';
import { ClipsOrSnapshotsOrAll } from '../../../src/types';
import { EventMediaQuery, FolderViewQuery } from '../../../src/view/query';
import {
  TestViewMedia,
  createCameraManager,
  createCardAPI,
  createFolder,
  createStore,
  generateViewMediaArray,
} from '../../test-utils';
import { createPopulatedAPI } from './test-utils';

describe('executeDefaultEventQuery', () => {
  it('should return null without cameras', async () => {
    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(createStore());

    const executor = new QueryExecutor(api);
    expect(
      await executor.executeDefaultEventQuery({
        cameraID: 'camera.office',
      }),
    ).toBeNull();
  });

  it('should return null without queries', async () => {
    const api = createPopulatedAPI();
    vi.mocked(api.getCameraManager().generateDefaultEventQueries).mockReturnValue(null);

    const executor = new QueryExecutor(api);
    expect(
      await executor.executeDefaultEventQuery({
        cameraID: 'camera.office',
      }),
    ).toBeNull();
  });

  describe('should return query results for specified camera', async () => {
    it.each([['all' as const], ['clips' as const], ['snapshots' as const], [undefined]])(
      '%s',
      async (mediaType?: ClipsOrSnapshotsOrAll) => {
        const api = createPopulatedAPI();
        const media = generateViewMediaArray();
        const rawQueries = [
          { type: QueryType.Event as const, cameraIDs: new Set(['camera.office']) },
        ];
        vi.mocked(api.getCameraManager().generateDefaultEventQueries).mockReturnValue(
          rawQueries,
        );
        vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

        const executor = new QueryExecutor(api);
        const results = await executor.executeDefaultEventQuery({
          cameraID: 'camera.office',
          eventsMediaType: mediaType,
        });

        expect(results?.query.getQuery()).toEqual(rawQueries);
        expect(results?.queryResults.getResults()).toEqual(media);
        expect(api.getCameraManager().generateDefaultEventQueries).toBeCalledWith(
          new Set(['camera.office']),
          {
            limit: 50,
            ...(mediaType === 'clips' && { hasClip: true }),
            ...(mediaType === 'snapshots' && { hasSnapshot: true }),
          },
        );
      },
    );
  });

  it('should return query results for all cameras', async () => {
    const api = createPopulatedAPI();
    const media = generateViewMediaArray();
    const rawQueries = [
      {
        type: QueryType.Event as const,
        cameraIDs: new Set(['camera.office', 'camera.kitchen']),
      },
    ];
    vi.mocked(api.getCameraManager().generateDefaultEventQueries).mockReturnValue(
      rawQueries,
    );
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

    const executor = new QueryExecutor(api);
    const results = await executor.executeDefaultEventQuery();

    expect(results?.query.getQuery()).toEqual(rawQueries);
    expect(results?.queryResults.getResults()).toEqual(media);
    expect(api.getCameraManager().generateDefaultEventQueries).toBeCalledWith(
      new Set(['camera.office', 'camera.kitchen']),
      {
        limit: 50,
      },
    );
  });

  it('should return null when query returns null', async () => {
    const api = createPopulatedAPI();
    const rawQueries = [
      {
        type: QueryType.Event as const,
        cameraIDs: new Set(['camera.office']),
      },
    ];
    vi.mocked(api.getCameraManager().generateDefaultEventQueries).mockReturnValue(
      rawQueries,
    );
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(null);

    const executor = new QueryExecutor(api);
    expect(
      await executor.executeDefaultEventQuery({ cameraID: 'camera.office' }),
    ).toBeNull();
    expect(api.getCameraManager().generateDefaultEventQueries).toBeCalledWith(
      new Set(['camera.office']),
      {
        limit: 50,
      },
    );
  });
});

describe('executeDefaultRecordingQuery', () => {
  it('should return null without cameras', async () => {
    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(createStore());

    const executor = new QueryExecutor(api);
    expect(
      await executor.executeDefaultRecordingQuery({
        cameraID: 'camera.office',
      }),
    ).toBeNull();
  });

  it('should return null without queries', async () => {
    const api = createPopulatedAPI();
    vi.mocked(api.getCameraManager().generateDefaultRecordingQueries).mockReturnValue(
      null,
    );

    const executor = new QueryExecutor(api);
    expect(
      await executor.executeDefaultRecordingQuery({
        cameraID: 'camera.office',
      }),
    ).toBeNull();
  });

  it('should return query results for specified camera', async () => {
    const api = createPopulatedAPI();
    const media = generateViewMediaArray();
    const rawQueries = [
      { type: QueryType.Recording as const, cameraIDs: new Set(['camera.office']) },
    ];
    vi.mocked(api.getCameraManager().generateDefaultRecordingQueries).mockReturnValue(
      rawQueries,
    );
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

    const executor = new QueryExecutor(api);
    const results = await executor.executeDefaultRecordingQuery({
      cameraID: 'camera.office',
    });

    expect(results?.query.getQuery()).toEqual(rawQueries);
    expect(results?.queryResults.getResults()).toEqual(media);
    expect(api.getCameraManager().generateDefaultRecordingQueries).toBeCalledWith(
      new Set(['camera.office']),
      {
        limit: 50,
      },
    );
  });

  it('should return query results for all cameras', async () => {
    const api = createPopulatedAPI();
    const media = generateViewMediaArray();
    const rawQueries = [
      {
        type: QueryType.Recording as const,
        cameraIDs: new Set(['camera.office', 'camera.kitchen']),
      },
    ];
    vi.mocked(api.getCameraManager().generateDefaultRecordingQueries).mockReturnValue(
      rawQueries,
    );
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

    const executor = new QueryExecutor(api);
    const results = await executor.executeDefaultRecordingQuery();

    expect(results?.query.getQuery()).toEqual(rawQueries);
    expect(results?.queryResults.getResults()).toEqual(media);
    expect(api.getCameraManager().generateDefaultRecordingQueries).toBeCalledWith(
      new Set(['camera.office', 'camera.kitchen']),
      {
        limit: 50,
      },
    );
  });

  it('should return null when query returns null', async () => {
    const api = createPopulatedAPI();
    const rawQueries = [
      {
        type: QueryType.Recording as const,
        cameraIDs: new Set(['camera.office']),
      },
    ];
    vi.mocked(api.getCameraManager().generateDefaultRecordingQueries).mockReturnValue(
      rawQueries,
    );
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(null);

    const executor = new QueryExecutor(api);
    expect(
      await executor.executeDefaultRecordingQuery({ cameraID: 'camera.office' }),
    ).toBeNull();
    expect(api.getCameraManager().generateDefaultRecordingQueries).toBeCalledWith(
      new Set(['camera.office']),
      {
        limit: 50,
      },
    );
  });
});

describe('executeQuery', () => {
  it('should return null when query is empty', async () => {
    const executor = new QueryExecutor(createCardAPI());
    expect(await executor.executeQuery(new EventMediaQuery())).toBeNull();
  });

  describe('should handle result rejections', () => {
    it('rejected', async () => {
      const api = createPopulatedAPI();
      const media = generateViewMediaArray();
      vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

      const query = new EventMediaQuery([
        {
          type: QueryType.Event as const,
          cameraIDs: new Set(['camera.office']),
        },
      ]);
      const executor = new QueryExecutor(api);

      expect(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        await executor.executeQuery(query, { rejectResults: (_) => true }),
      ).toBeNull();
    });

    it('not rejected', async () => {
      const api = createPopulatedAPI();
      const media = generateViewMediaArray();
      vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

      const query = new EventMediaQuery([
        {
          type: QueryType.Event as const,
          cameraIDs: new Set(['camera.office']),
        },
      ]);
      const executor = new QueryExecutor(api);

      expect(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        await executor.executeQuery(query, { rejectResults: (_) => false }),
      ).not.toBeNull();
    });
  });

  describe('should select', () => {
    it('by id', async () => {
      const api = createPopulatedAPI();
      const media = generateViewMediaArray({
        cameraIDs: ['camera.office'],
        count: 100,
      });
      vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

      const query = new EventMediaQuery([
        {
          type: QueryType.Event as const,
          cameraIDs: new Set(['camera.office']),
        },
      ]);
      const executor = new QueryExecutor(api);

      const results = await executor.executeMediaQuery(query, {
        selectResult: { id: 'id-camera.office-42' },
      });
      expect(results?.queryResults.getSelectedResult()?.getID()).toBe(
        'id-camera.office-42',
      );
    });
  });

  it('by func', async () => {
    const api = createPopulatedAPI();
    const media = generateViewMediaArray({
      cameraIDs: ['camera.office'],
      count: 100,
    });
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

    const query = new EventMediaQuery([
      {
        type: QueryType.Event as const,
        cameraIDs: new Set(['camera.office']),
      },
    ]);
    const executor = new QueryExecutor(api);

    const results = await executor.executeMediaQuery(query, {
      selectResult: { func: (media) => media.getID() === 'id-camera.office-43' },
    });
    expect(results?.queryResults.getSelectedResult()?.getID()).toBe(
      'id-camera.office-43',
    );
  });

  it('by time', async () => {
    const now = new Date('2024-07-21T19:09:37Z');

    const api = createPopulatedAPI();
    const media = [
      new TestViewMedia({
        cameraID: 'camera.office',
        id: 'id-camera.office-0',
        startTime: now,
      }),
      new TestViewMedia({
        cameraID: 'camera.office',
        id: 'id-camera.office-1',
        startTime: add(now, { seconds: 1 }),
      }),
      new TestViewMedia({
        cameraID: 'camera.office',
        id: 'id-camera.office-2',
        startTime: add(now, { seconds: 2 }),
      }),
    ];
    vi.mocked(api.getCameraManager().executeMediaQueries).mockResolvedValue(media);

    const query = new EventMediaQuery([
      {
        type: QueryType.Event as const,
        cameraIDs: new Set(['camera.office']),
      },
    ]);
    const executor = new QueryExecutor(api);

    const results = await executor.executeMediaQuery(query, {
      selectResult: { time: { time: add(now, { seconds: 1 }) } },
    });
    expect(results?.queryResults.getSelectedResult()?.getID()).toBe(
      'id-camera.office-1',
    );
  });

  describe('should handle folder query', () => {
    it('should return null without raw query', async () => {
      const executor = new QueryExecutor(createCardAPI());
      expect(await executor.executeQuery(new FolderViewQuery())).toBeNull();
    });

    it('should return null when query expansion fails', async () => {
      const api = createCardAPI();
      vi.mocked(api.getFoldersManager().getFolder).mockReturnValue(createFolder());
      vi.mocked(api.getFoldersManager().expandFolder).mockResolvedValue(null);

      const executor = new QueryExecutor(api);
      expect(await executor.executeDefaultFolderQuery()).toBeNull();
    });
  });
});

describe('executeDefaultFolderQuery', () => {
  it('should return null without folders', async () => {
    const executor = new QueryExecutor(createCardAPI());
    expect(await executor.executeDefaultFolderQuery()).toBeNull();
  });

  it('should execute query against first folder', async () => {
    const api = createCardAPI();
    const items = [new TestViewMedia()];
    const folder = createFolder();
    const query: FolderQuery = {
      folder,
      path: ['path'],
    };
    vi.mocked(api.getFoldersManager().generateDefaultFolderQuery).mockReturnValue(query);
    vi.mocked(api.getFoldersManager().expandFolder).mockResolvedValue(items);

    const executor = new QueryExecutor(api);
    const result = await executor.executeDefaultFolderQuery();

    expect(result?.query.getQuery()).toEqual(query);
    expect(result?.queryResults.getResults()).toEqual(items);
  });

  it('should return null without folder results', async () => {
    const api = createCardAPI();
    const folder = createFolder();
    const query: FolderQuery = {
      folder,
      path: ['path'],
    };
    vi.mocked(api.getFoldersManager().generateDefaultFolderQuery).mockReturnValue(query);
    vi.mocked(api.getFoldersManager().expandFolder).mockResolvedValue(null);

    const executor = new QueryExecutor(api);
    expect(await executor.executeDefaultFolderQuery()).toBeNull();
  });
});



================================================
FILE: tests/card-controller/view/sort.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { sortItems } from '../../../src/card-controller/view/sort.js';
import { createFolder, TestViewMedia } from '../../test-utils.js';
import { ViewFolder } from '../../../src/view/item.js';

describe('sortMedia', () => {
  const media_1 = new TestViewMedia({
    id: 'id-1',
    startTime: new Date('2023-04-29T14:25'),
    cameraID: 'camera-1',
  });
  const media_2 = new TestViewMedia({
    id: 'id-2',
    startTime: new Date('2023-04-29T14:26'),
    cameraID: 'camera-1',
  });
  const media_3_dup_id = new TestViewMedia({
    id: 'id-2',
    startTime: new Date('2023-04-29T14:26'),
    cameraID: 'camera-1',
  });
  const media_4_no_id = new TestViewMedia({
    id: null,
    startTime: new Date('2023-04-29T14:27'),
    cameraID: 'camera-1',
  });
  const folder_1 = new ViewFolder(createFolder(), { id: 'folder_1' });
  const folder_2 = new ViewFolder(createFolder(), { id: 'folder_2' });

  it('should sort sorted media', () => {
    const media = [media_1, media_2];
    expect(sortItems(media)).toEqual(media);
  });
  it('should sort unsorted media', () => {
    expect(sortItems([media_2, media_1])).toEqual([media_1, media_2]);
  });
  it('should remove duplicate id', () => {
    expect(sortItems([media_1, media_2, media_3_dup_id])).toEqual([media_1, media_2]);
  });
  it('should sort by id when time not available', () => {
    const folder = createFolder();
    expect(
      sortItems([
        new TestViewMedia({ id: 'snake' }),
        new TestViewMedia({ id: 'zebra' }),
        new TestViewMedia({ id: 'aardvark' }),
        new ViewFolder(folder, { id: 'folder' }),
      ]),
    ).toEqual([
      new ViewFolder(folder, { id: 'folder' }),
      new TestViewMedia({ id: 'aardvark' }),
      new TestViewMedia({ id: 'snake' }),
      new TestViewMedia({ id: 'zebra' }),
    ]);
  });
  it('should remove de-duplicate by object if no id', () => {
    expect(sortItems([media_1, media_2, media_4_no_id, media_4_no_id])).toEqual([
      media_1,
      media_2,
      media_4_no_id,
    ]);
  });
  it('should sort folders at the start', () => {
    expect(sortItems([media_1, media_2, folder_1, folder_2])).toEqual([
      folder_1,
      folder_2,
      media_1,
      media_2,
    ]);
  });
});



================================================
FILE: tests/card-controller/view/test-utils.ts
================================================
import { vi } from 'vitest';
import { CardController } from '../../../src/card-controller/controller';
import { RawAdvancedCameraCardConfig } from '../../../src/config/types';
import {
  createCameraManager,
  createCapabilities,
  createCardAPI,
  createConfig,
  createStore,
} from '../../test-utils';

export const createPopulatedAPI = (
  config?: RawAdvancedCameraCardConfig,
): CardController => {
  const api = createCardAPI();
  vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
  vi.mocked(api.getCameraManager().getStore).mockReturnValue(
    createStore([
      {
        cameraID: 'camera.office',
        capabilities: createCapabilities({
          live: true,
          snapshots: true,
          clips: true,
          recordings: true,
          substream: true,
        }),
      },
      {
        cameraID: 'camera.kitchen',
        capabilities: createCapabilities({
          live: true,
          snapshots: true,
          clips: true,
          recordings: true,
          substream: true,
        }),
      },
    ]),
  );
  vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig(config));
  return api;
};



================================================
FILE: tests/card-controller/view/view-manager.test.ts
================================================
import { ViewContext } from 'view';
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { QueryType } from '../../../src/camera-manager/types';
import { CardController } from '../../../src/card-controller/controller';
import { ViewFactory } from '../../../src/card-controller/view/factory';
import { SetQueryViewModifier } from '../../../src/card-controller/view/modifiers/set-query';
import {
  QueryExecutorOptions,
  ViewModifier,
} from '../../../src/card-controller/view/types';
import { ViewManager } from '../../../src/card-controller/view/view-manager';
import { ViewQueryExecutor } from '../../../src/card-controller/view/view-query-executor';
import { AdvancedCameraCardView } from '../../../src/config/schema/common/const';
import { ViewMedia, ViewMediaType } from '../../../src/view/item';
import { EventMediaQuery } from '../../../src/view/query';
import { QueryResults } from '../../../src/view/query-results';
import { View } from '../../../src/view/view';
import {
  createCameraManager,
  createCapabilities,
  createCardAPI,
  createStore,
  createView,
} from '../../test-utils';

const createInitializedCardAPI = (initialized?: boolean): CardController => {
  const api = createCardAPI();
  vi.mocked(api.getInitializationManager().isInitialized).mockReturnValue(
    initialized ?? true,
  );
  return api;
};

describe('should act correctly when view is set', () => {
  it('basic view', () => {
    const view = createView({
      view: 'live',
      camera: 'camera',
      displayMode: 'grid',
    });

    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(view);

    const api = createInitializedCardAPI();
    const manager = new ViewManager(api, { viewFactory: factory });

    manager.setViewDefault();

    expect(manager.getView()).toBe(view);
    expect(manager.hasView()).toBeTruthy();
    expect(api.getMediaLoadedInfoManager().clear).toBeCalled();
    expect(api.getCardElementManager().scrollReset).toBeCalled();
    expect(api.getMessageManager().reset).toBeCalled();
    expect(api.getStyleManager().setExpandedMode).toBeCalled();
    expect(api.getConditionStateManager()?.setState).toBeCalledWith({
      view: 'live',
      camera: 'camera',
      displayMode: 'grid',
    });
    expect(api.getCardElementManager().update).toBeCalled();
  });

  it('view with minor changes without media clearing or scroll', () => {
    const view_1 = createView({
      view: 'live',
      camera: 'camera',
    });
    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(view_1);

    const api = createInitializedCardAPI();
    const manager = new ViewManager(api, { viewFactory: factory });

    manager.setViewDefault();

    vi.mocked(api.getMediaLoadedInfoManager().clear).mockClear();
    vi.mocked(api.getCardElementManager().scrollReset).mockClear();

    const view_2 = createView({
      view: 'live',
      camera: 'camera',
      displayMode: 'single',
    });
    factory.getViewDefault.mockReturnValue(view_2);

    manager.setViewDefault();

    expect(manager.getView()).toBe(view_2);

    // The new view is neither a major media change, nor a different view name,
    // so media clearing and scrolling should not happen.
    expect(api.getMediaLoadedInfoManager().clear).not.toBeCalled();
    expect(api.getCardElementManager().scrollReset).not.toBeCalled();
  });
});

it('setViewWithMergedContext', () => {
  const api = createInitializedCardAPI();
  const factory = mock<ViewFactory>();

  const manager = new ViewManager(api, { viewFactory: factory });
  const context: ViewContext = { timeline: {} };

  // Setting context with no existing view does nothing.
  manager.setViewWithMergedContext(context);
  expect(manager.getView()).toBeNull();

  const view = createView({
    view: 'live',
    camera: 'camera',
  });
  factory.getViewDefault.mockReturnValue(view);
  manager.setViewDefault();
  manager.setViewWithMergedContext(context);

  expect(manager.getView()?.camera).toBe('camera');
  expect(manager.getView()?.view).toBe('live');
  expect(manager.getView()?.context).toEqual(context);
});

it('getEpoch', () => {
  const factory = mock<ViewFactory>();
  const manager = new ViewManager(createCardAPI(), { viewFactory: factory });
  expect(manager.getEpoch()).toBeTruthy();
  expect(manager.getEpoch().manager).toBe(manager);
});

it('reset', () => {
  const factory = mock<ViewFactory>();
  const manager = new ViewManager(createInitializedCardAPI(), { viewFactory: factory });

  manager.reset();
  expect(manager.getView()).toBeNull();
  expect(manager.hasView()).toBeFalsy();

  factory.getViewDefault.mockReturnValue(createView());
  manager.setViewDefault();

  expect(manager.getView()).not.toBeNull();
  expect(manager.hasView()).toBeTruthy();

  manager.reset();

  expect(manager.getView()).toBeNull();
  expect(manager.hasView()).toBeFalsy();
});

describe('should not set view without cameras being initialized', () => {
  it('should ignore requests to set generic view without cameras being initialized', () => {
    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(createView());

    const manager = new ViewManager(createInitializedCardAPI(false), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(manager.getView()).toBeNull();
  });

  it('should ignore requests to set view then modify without cameras being initialized', () => {
    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(createView());

    const manager = new ViewManager(createInitializedCardAPI(false), {
      viewFactory: factory,
    });
    manager.setViewDefaultWithNewQuery();

    expect(manager.getView()).toBeNull();
  });
});

it('setViewDefault', () => {
  const factory = mock<ViewFactory>();
  factory.getViewDefault.mockReturnValue(createView());

  const manager = new ViewManager(createInitializedCardAPI(), { viewFactory: factory });
  manager.setViewDefault();

  expect(manager.getView()?.view).toBe('live');
  expect(manager.getView()?.camera).toBe('camera');
});

it('setViewByParameters', () => {
  const factory = mock<ViewFactory>();
  factory.getViewByParameters.mockReturnValue(createView());

  const manager = new ViewManager(createInitializedCardAPI(), { viewFactory: factory });
  manager.setViewByParameters();

  expect(manager.getView()?.view).toBe('live');
  expect(manager.getView()?.camera).toBe('camera');
});

it('setViewDefaultWithNewQuery', async () => {
  const viewFactory = mock<ViewFactory>();
  viewFactory.getViewDefault.mockReturnValue(createView());

  const viewQueryExecutor = mock<ViewQueryExecutor>();
  viewQueryExecutor.getNewQueryModifiers.mockResolvedValue([]);

  const manager = new ViewManager(createInitializedCardAPI(), {
    viewFactory: viewFactory,
    viewQueryExecutor: viewQueryExecutor,
  });
  await manager.setViewDefaultWithNewQuery();

  expect(manager.getView()?.view).toBe('live');
  expect(manager.getView()?.camera).toBe('camera');
});

it('setViewByParametersWithNewQuery', async () => {
  const viewFactory = mock<ViewFactory>();
  viewFactory.getViewByParameters.mockReturnValue(createView());

  const viewQueryExecutor = mock<ViewQueryExecutor>();
  viewQueryExecutor.getNewQueryModifiers.mockResolvedValue([]);

  const manager = new ViewManager(createInitializedCardAPI(), {
    viewFactory: viewFactory,
    viewQueryExecutor: viewQueryExecutor,
  });
  await manager.setViewByParametersWithNewQuery();

  expect(manager.getView()?.view).toBe('live');
  expect(manager.getView()?.camera).toBe('camera');
});

it('setViewByParametersWithExistingQuery', async () => {
  const viewFactory = mock<ViewFactory>();
  viewFactory.getViewByParameters.mockReturnValue(createView());

  const viewQueryExecutor = mock<ViewQueryExecutor>();
  viewQueryExecutor.getNewQueryModifiers.mockResolvedValue([]);

  const manager = new ViewManager(createInitializedCardAPI(), {
    viewFactory: viewFactory,
    viewQueryExecutor: viewQueryExecutor,
  });

  await manager.setViewByParametersWithExistingQuery();

  expect(manager.getView()?.view).toBe('live');
  expect(manager.getView()?.camera).toBe('camera');
});

describe('should handle exceptions', () => {
  it('should handle exceptions in sync calls', () => {
    const error = new Error();
    const viewFactory = mock<ViewFactory>();
    viewFactory.getViewDefault.mockImplementation(() => {
      throw error;
    });

    const api = createInitializedCardAPI();
    const manager = new ViewManager(api, { viewFactory: viewFactory });
    manager.setViewDefault();

    expect(manager.hasView()).toBeFalsy();
    expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(error);
  });

  it('should handle viewFactory exceptions in async calls', async () => {
    const error = new Error();
    const viewFactory = mock<ViewFactory>();
    viewFactory.getViewDefault.mockImplementation(() => {
      throw error;
    });

    const api = createInitializedCardAPI();
    const manager = new ViewManager(api, { viewFactory: viewFactory });
    await manager.setViewDefaultWithNewQuery();

    expect(manager.hasView()).toBeFalsy();
    expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(error);
  });

  it('should handle viewQueryExecutor exceptions in async calls', async () => {
    const error = new Error();
    const viewFactory = mock<ViewFactory>();
    viewFactory.getViewDefault.mockReturnValue(createView());
    const viewQueryExecutor = mock<ViewQueryExecutor>();
    viewQueryExecutor.getNewQueryModifiers.mockRejectedValue(error);

    const api = createInitializedCardAPI();
    const manager = new ViewManager(api, {
      viewFactory: viewFactory,
      viewQueryExecutor: viewQueryExecutor,
    });

    await manager.setViewDefaultWithNewQuery();

    // The initial view will have been set.
    expect(manager.hasView()).toBeTruthy();

    // But an error will also be generated.
    expect(api.getMessageManager().setErrorIfHigherPriority).toBeCalledWith(error);
  });
});

describe('isViewSupportedByCamera', () => {
  it.each([
    ['live' as const, false],
    ['image' as const, true],
    ['diagnostics' as const, true],
    ['clip' as const, false],
    ['clips' as const, false],
    ['snapshot' as const, false],
    ['snapshots' as const, false],
    ['recording' as const, false],
    ['recordings' as const, false],
    ['timeline' as const, false],
    ['media' as const, true],
  ])('%s', (viewName: AdvancedCameraCardView, expected: boolean) => {
    const api = createInitializedCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
    vi.mocked(api.getCameraManager().getStore).mockReturnValue(
      createStore([
        {
          cameraID: 'camera.kitchen',
          capabilities: createCapabilities({
            live: false,
            'favorite-events': false,
            'favorite-recordings': false,
            seek: false,
            clips: false,
            recordings: false,
            snapshots: false,
          }),
        },
      ]),
    );
    const manager = new ViewManager(api);

    expect(manager.isViewSupportedByCamera('camera', viewName)).toBe(expected);
  });
});

describe('hasMajorMediaChange', () => {
  it('should consider undefined views as major', () => {
    const manager = new ViewManager(createCardAPI());

    expect(manager.hasMajorMediaChange(undefined)).toBeFalsy();
    expect(manager.hasMajorMediaChange(createView())).toBeTruthy();
    expect(manager.hasMajorMediaChange()).toBeFalsy();
  });

  it('should consider view change as major', () => {
    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(createView({ view: 'live' }));

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(manager.hasMajorMediaChange(createView({ view: 'clips' }))).toBeTruthy();
  });

  it('should consider camera change as major', () => {
    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(createView({ camera: 'camera-1' }));

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(manager.hasMajorMediaChange(createView({ camera: 'camera-2' }))).toBeTruthy();
  });

  it('should consider live substream change as major in live view', () => {
    const overrides_1: Map<string, string> = new Map();
    overrides_1.set('camera', 'camera-2');

    const overrides_2: Map<string, string> = new Map();
    overrides_2.set('camera', 'camera-3');

    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(
      createView({ context: { live: { overrides: overrides_1 } } }),
    );

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(
      manager.hasMajorMediaChange(
        createView({ context: { live: { overrides: overrides_2 } } }),
      ),
    ).toBeTruthy();
  });

  it('should not consider live substream change as major in other view', () => {
    const overrides_1: Map<string, string> = new Map();
    overrides_1.set('camera', 'camera-2');

    const overrides_2: Map<string, string> = new Map();
    overrides_2.set('camera', 'camera-3');

    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(
      createView({ view: 'clips', context: { live: { overrides: overrides_1 } } }),
    );

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(
      manager.hasMajorMediaChange(
        createView({ view: 'clips', context: { live: { overrides: overrides_2 } } }),
      ),
    ).toBeFalsy();
  });

  it('should consider result change as major in other view', () => {
    const media = [
      new ViewMedia(ViewMediaType.Clip, {
        cameraID: 'camera-1',
      }),
      new ViewMedia(ViewMediaType.Clip, {
        cameraID: 'camera-2',
      }),
    ];
    const queryResults_1 = new QueryResults({ results: media, selectedIndex: 0 });
    const queryResults_2 = new QueryResults({ results: media, selectedIndex: 1 });

    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(
      createView({ view: 'media', queryResults: queryResults_1 }),
    );

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(
      manager.hasMajorMediaChange(
        createView({ view: 'media', queryResults: queryResults_2 }),
      ),
    ).toBeTruthy();
  });

  it('should not consider selected result change as major in live view', () => {
    const media = [
      new ViewMedia(ViewMediaType.Clip, {
        cameraID: 'camera-1',
      }),
      new ViewMedia(ViewMediaType.Clip, {
        cameraID: 'camera-2',
      }),
    ];
    const queryResults_1 = new QueryResults({ results: media, selectedIndex: 0 });
    const queryResults_2 = new QueryResults({ results: media, selectedIndex: 1 });

    const factory = mock<ViewFactory>();
    factory.getViewDefault.mockReturnValue(createView({ queryResults: queryResults_1 }));

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: factory,
    });
    manager.setViewDefault();

    expect(
      manager.hasMajorMediaChange(createView({ queryResults: queryResults_2 })),
    ).toBeFalsy();
  });
});

describe('should initialize', () => {
  it('without querystring', async () => {
    const view = createView({
      view: 'live',
      camera: 'camera',
    });

    const viewFactory = mock<ViewFactory>();
    viewFactory.getViewDefault.mockReturnValue(view);

    const api = createInitializedCardAPI();
    const manager = new ViewManager(api, {
      viewFactory: viewFactory,
    });

    expect(await manager.initialize()).toBeTruthy();

    expect(manager.getView()).toBe(view);
  });

  it('with querystring', async () => {
    const api = createCardAPI();
    const factory = mock<ViewFactory>();
    const manager = new ViewManager(api, { viewFactory: factory });
    vi.mocked(api.getQueryStringManager().hasViewRelatedActionsToRun).mockReturnValue(
      true,
    );

    expect(await manager.initialize()).toBeTruthy();

    expect(manager.hasView()).toBeFalsy();
  });
});

it('should adopt query and results when changing to gallery from viewer', async () => {
  const baseView = createView({
    view: 'media',
    camera: 'camera.office',
    query: new EventMediaQuery([
      {
        type: QueryType.Event,
        cameraIDs: new Set(['camera.office']),
        hasClip: true,
      },
    ]),
    queryResults: new QueryResults(),
  });

  const viewFactory = mock<ViewFactory>();
  viewFactory.getViewDefault
    .mockReturnValueOnce(baseView)
    .mockReturnValueOnce(createView({ view: 'clips' }));

  const viewQueryExecutor = mock<ViewQueryExecutor>();
  viewQueryExecutor.getNewQueryModifiers.mockResolvedValue([]);

  const manager = new ViewManager(createInitializedCardAPI(), {
    viewFactory: viewFactory,
    viewQueryExecutor: viewQueryExecutor,
  });

  manager.setViewDefault();
  expect(manager.getView()?.is('media')).toBeTruthy();

  await manager.setViewDefaultWithNewQuery({
    params: {
      view: 'clips',
    },
  });

  expect(manager.getView()?.is('clips')).toBeTruthy();
  expect(manager.getView()?.query).toBe(baseView.query);
  expect(manager.getView()?.queryResults).toBe(baseView.queryResults);
  expect(viewQueryExecutor.getNewQueryModifiers).not.toHaveBeenCalled();
  expect(viewQueryExecutor.getExistingQueryModifiers).not.toHaveBeenCalled();
});

describe('should apply async view modifications', () => {
  it('should apply modifications successfully', async () => {
    const viewFactory = mock<ViewFactory>();
    viewFactory.getViewDefault.mockReturnValue(createView({ view: 'live' }));

    const query = new EventMediaQuery();
    const queryResults = new QueryResults();

    const viewQueryExecutor = mock<ViewQueryExecutor>();
    viewQueryExecutor.getNewQueryModifiers.mockResolvedValue([
      new SetQueryViewModifier({
        query: query,
        queryResults: queryResults,
      }),
    ]);

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: viewFactory,
      viewQueryExecutor: viewQueryExecutor,
    });

    await manager.setViewDefaultWithNewQuery();

    expect(manager.getView()?.query).toBe(query);
    expect(manager.getView()?.queryResults).toBe(queryResults);
    expect(manager.getView()?.context?.loading?.query).toBeUndefined();
  });

  it('should not apply modifications if there is a major media change', async () => {
    const viewFactory = mock<ViewFactory>();
    viewFactory.getViewDefault.mockReturnValueOnce(createView({ view: 'live' }));

    const query = new EventMediaQuery();
    const queryResults = new QueryResults();

    const viewQueryExecutor = mock<ViewQueryExecutor>();

    const manager = new ViewManager(createInitializedCardAPI(), {
      viewFactory: viewFactory,
      viewQueryExecutor: viewQueryExecutor,
    });

    viewQueryExecutor.getNewQueryModifiers.mockImplementation(
      async (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _view: View,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _executorqueryExecutorOptions?: QueryExecutorOptions,
      ): Promise<ViewModifier[] | null> => {
        // Simulate a major media change while the async operation is running.
        viewFactory.getViewDefault.mockReturnValueOnce(
          createView({ view: 'clips', context: { loading: { query: 1 } } }),
        );
        manager.setViewDefault();

        // Now return the modifiers (which should be ignored since there has
        // been a major change in the meantime).
        return [
          new SetQueryViewModifier({
            query: query,
            queryResults: queryResults,
          }),
        ];
      },
    );

    await manager.setViewDefaultWithNewQuery();

    // View set during the async operation should not be touched.
    expect(manager.getView()?.is('clips')).toBeTruthy();
    expect(manager.getView()?.query).toBeNull();
    expect(manager.getView()?.queryResults).toBeNull();
    expect(manager.getView()?.context?.loading?.query).toBeUndefined();
  });

  describe('should manage loading state correctly', () => {
    it('should mark as not loading when with major media change', async () => {
      const viewFactory = mock<ViewFactory>();
      viewFactory.getViewDefault.mockReturnValueOnce(createView({ view: 'live' }));
      const viewQueryExecutor = mock<ViewQueryExecutor>();

      const manager = new ViewManager(createInitializedCardAPI(), {
        viewFactory: viewFactory,
        viewQueryExecutor: viewQueryExecutor,
      });

      viewQueryExecutor.getNewQueryModifiers.mockImplementation(
        async (
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _view: View,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _executorqueryExecutorOptions?: QueryExecutorOptions,
        ): Promise<ViewModifier[] | null> => {
          expect(manager.getView()?.context?.loading?.query).not.toBeUndefined();

          // Simulate a major media change while the async operation is running.
          viewFactory.getViewDefault.mockReturnValueOnce(
            createView({ view: 'clips', context: { loading: { query: 1 } } }),
          );
          manager.setViewDefault();

          // Now return the modifiers (which should be ignored since there has
          // been a major change in the meantime).
          return [];
        },
      );

      await manager.setViewDefaultWithNewQuery();

      expect(manager.getView()?.context?.loading?.query).toBeUndefined();
    });

    it('should not change loading status if something else is being loaded', async () => {
      const viewFactory = mock<ViewFactory>();
      viewFactory.getViewDefault.mockReturnValueOnce(createView({ view: 'live' }));
      const viewQueryExecutor = mock<ViewQueryExecutor>();

      const manager = new ViewManager(createInitializedCardAPI(), {
        viewFactory: viewFactory,
        viewQueryExecutor: viewQueryExecutor,
      });

      viewQueryExecutor.getNewQueryModifiers.mockImplementation(
        async (
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _view: View,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _executorqueryExecutorOptions?: QueryExecutorOptions,
        ): Promise<ViewModifier[] | null> => {
          expect(manager.getView()?.context?.loading?.query).not.toBeUndefined();

          // Simulate a major media change while the async operation is running.
          viewFactory.getViewDefault.mockReturnValueOnce(
            createView({ view: 'clips', context: { loading: { query: 2 } } }),
          );
          manager.setViewDefault();

          // Now return the modifiers (which should be ignored since there has
          // been a major change in the meantime).
          return [];
        },
      );

      await manager.setViewDefaultWithNewQuery();

      expect(manager.getView()?.context?.loading?.query).toBe(2);
    });

    it('should not change loading status if it is unexpected', async () => {
      const viewFactory = mock<ViewFactory>();
      viewFactory.getViewDefault.mockReturnValueOnce(createView({ view: 'live' }));
      const viewQueryExecutor = mock<ViewQueryExecutor>();

      const manager = new ViewManager(createInitializedCardAPI(), {
        viewFactory: viewFactory,
        viewQueryExecutor: viewQueryExecutor,
      });

      viewQueryExecutor.getNewQueryModifiers.mockImplementation(
        async (
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _view: View,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          _executorqueryExecutorOptions?: QueryExecutorOptions,
        ): Promise<ViewModifier[] | null> => {
          expect(manager.getView()?.context?.loading?.query).not.toBeUndefined();

          // Simulate another view update (without a major media change)
          viewFactory.getViewDefault.mockReturnValueOnce(
            createView({ context: { loading: { query: 100 } } }),
          );
          manager.setViewDefault();

          // Now return the modifiers (which should be ignored since there has
          // been a major change in the meantime).
          return [];
        },
      );

      await manager.setViewDefaultWithNewQuery();

      expect(manager.getView()?.context?.loading?.query).toBe(100);
    });
  });
});

it('should adopt query and results when changing to gallery from viewer', async () => {
  const baseView = createView({
    view: 'media',
    camera: 'camera.office',
    query: new EventMediaQuery([
      {
        type: QueryType.Event,
        cameraIDs: new Set(['camera.office']),
        hasClip: true,
      },
    ]),
    queryResults: new QueryResults(),
  });

  const viewFactory = mock<ViewFactory>();
  viewFactory.getViewDefault
    .mockReturnValueOnce(baseView)
    .mockReturnValueOnce(createView({ view: 'clips' }));

  const viewQueryExecutor = mock<ViewQueryExecutor>();
  viewQueryExecutor.getNewQueryModifiers.mockResolvedValue([]);

  const manager = new ViewManager(createInitializedCardAPI(), {
    viewFactory: viewFactory,
    viewQueryExecutor: viewQueryExecutor,
  });

  manager.setViewDefault();
  expect(manager.getView()?.is('media')).toBeTruthy();

  await manager.setViewDefaultWithNewQuery({
    params: {
      view: 'clips',
    },
  });

  expect(manager.getView()?.is('clips')).toBeTruthy();
  expect(manager.getView()?.query).toBe(baseView.query);
  expect(manager.getView()?.queryResults).toBe(baseView.queryResults);
  expect(viewQueryExecutor.getNewQueryModifiers).not.toHaveBeenCalled();
  expect(viewQueryExecutor.getExistingQueryModifiers).not.toHaveBeenCalled();
});



================================================
FILE: tests/card-controller/view/view-query-executor.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { applyViewModifiers } from '../../../src/card-controller/view/modifiers';
import { QueryExecutor } from '../../../src/card-controller/view/query-executor';
import { ViewQueryExecutor } from '../../../src/card-controller/view/view-query-executor';
import { AdvancedCameraCardView } from '../../../src/config/schema/common/const';
import {
  EventMediaQuery,
  FolderViewQuery,
  RecordingMediaQuery,
} from '../../../src/view/query';
import { QueryResults } from '../../../src/view/query-results';
import { View } from '../../../src/view/view';
import { createCardAPI, createView } from '../../test-utils';
import { createPopulatedAPI } from './test-utils';

describe('ViewQueryExecutor', () => {
  describe('getExistingQueryModifiers', () => {
    it('should return modifier with result when query present', async () => {
      const executor = mock<QueryExecutor>();
      const viewQueryExecutor = new ViewQueryExecutor(createCardAPI(), executor);

      const query = new EventMediaQuery();
      const queryResults = new QueryResults();
      const view = createView({
        query: query,
      });

      executor.executeQuery.mockResolvedValue({ query, queryResults });

      const queryExecutorOptions = { useCache: true };
      const modifiers = await viewQueryExecutor.getExistingQueryModifiers(
        view,
        queryExecutorOptions,
      );

      applyViewModifiers(view, modifiers);

      expect(view.query).toBe(query);
      expect(view.queryResults).toBe(queryResults);
      expect(executor.executeQuery).toBeCalledWith(query, queryExecutorOptions);
    });

    it('should not return modifier when query absent', async () => {
      const executor = mock<QueryExecutor>();
      const viewQueryExecutor = new ViewQueryExecutor(createCardAPI(), executor);

      const view = createView();

      const queryExecutorOptions = {};
      const modifiers = await viewQueryExecutor.getExistingQueryModifiers(
        view,
        queryExecutorOptions,
      );

      expect(modifiers?.length).toBe(0);

      applyViewModifiers(view, modifiers);

      expect(view.query).toBeNull();
      expect(view.queryResults).toBeNull();
      expect(executor.executeMediaQuery).not.toBeCalled();
    });
  });

  describe('getNewQueryModifiers', () => {
    it('should return null without config', async () => {
      const factory = new ViewQueryExecutor(createCardAPI());
      expect(await factory.getNewQueryModifiers(createView())).toBeNull();
    });

    describe('with a live view', () => {
      beforeAll(() => {
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2024-07-21T13:22:06Z'));
      });

      afterAll(() => {
        vi.useRealTimers();
      });

      it('should set query and queryResults for events', async () => {
        const query = new EventMediaQuery();
        const queryResults = new QueryResults();

        const executor = mock<QueryExecutor>();
        executor.executeDefaultEventQuery.mockResolvedValue({
          query: query,
          queryResults: queryResults,
        });

        const viewQueryExecutor = new ViewQueryExecutor(createPopulatedAPI(), executor);
        const view = createView({ view: 'live', camera: 'camera.office' });
        const queryExecutorOptions = {};

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(
          view,
          queryExecutorOptions,
        );
        applyViewModifiers(view, modifiers);

        expect(view?.query).toBe(query);
        expect(view?.queryResults).toBe(queryResults);
        expect(executor.executeDefaultEventQuery).toBeCalledWith({
          cameraID: 'camera.office',
          eventsMediaType: 'all',
          executorOptions: {
            useCache: false,
          },
        });
        expect(executor.executeDefaultRecordingQuery).not.toHaveBeenCalled();
        expect(executor.executeDefaultFolderQuery).not.toHaveBeenCalled();
      });

      it('should set query and queryResults for recordings', async () => {
        const query = new RecordingMediaQuery();
        const queryResults = new QueryResults();

        const executor = mock<QueryExecutor>();
        executor.executeDefaultRecordingQuery.mockResolvedValue({
          query: query,
          queryResults: queryResults,
        });

        const viewQueryExecutor = new ViewQueryExecutor(
          createPopulatedAPI({
            live: {
              controls: {
                thumbnails: {
                  media_type: 'recordings',
                },
              },
            },
          }),
          executor,
        );
        const view = createView({ view: 'live', camera: 'camera.office' });
        const queryExecutorOptions = {};

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(
          view,
          queryExecutorOptions,
        );
        applyViewModifiers(view, modifiers);

        expect(view?.query).toBe(query);
        expect(view?.queryResults).toBe(queryResults);
        expect(executor.executeDefaultRecordingQuery).toBeCalledWith({
          cameraID: 'camera.office',
          executorOptions: {
            useCache: false,
          },
        });
        expect(executor.executeDefaultEventQuery).not.toBeCalled();
        expect(executor.executeDefaultFolderQuery).not.toHaveBeenCalled();
      });

      describe('should set timeline window', async () => {
        it('should set timeline to now for live views', async () => {
          const executor = mock<QueryExecutor>();
          const viewQueryExecutor = new ViewQueryExecutor(
            createPopulatedAPI(),
            executor,
          );
          const view = createView({ view: 'live', camera: 'camera.office' });

          const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
          applyViewModifiers(view, modifiers);

          expect(view?.context).toEqual({
            timeline: {
              window: {
                start: new Date('2024-07-21T12:22:06.000Z'),
                end: new Date('2024-07-21T13:22:06.000Z'),
              },
            },
          });
        });

        it('should unset timeline for non-live views', async () => {
          const executor = mock<QueryExecutor>();
          const viewQueryExecutor = new ViewQueryExecutor(
            createPopulatedAPI(),
            executor,
          );
          const view = createView({
            view: 'clips',
            camera: 'camera.office',
            context: {
              timeline: {
                window: {
                  start: new Date('2024-07-21T12:22:06.000Z'),
                  end: new Date('2024-07-21T13:22:06.000Z'),
                },
              },
            },
          });

          const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
          applyViewModifiers(view, modifiers);

          expect(view?.context).toEqual({ timeline: {} });
        });
      });

      it('should not fetch anything if configured for no thumbnails', async () => {
        const executor = mock<QueryExecutor>();
        const viewQueryExecutor = new ViewQueryExecutor(
          createPopulatedAPI({
            live: {
              controls: {
                thumbnails: {
                  mode: 'none' as const,
                },
              },
            },
          }),
          executor,
        );

        const view = createView({
          view: 'live',
          camera: 'camera.office',
        });

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
        applyViewModifiers(view, modifiers);

        expect(view?.query).toBeNull();
        expect(view?.queryResults).toBeNull();
        expect(executor.executeDefaultEventQuery).not.toHaveBeenCalled();
        expect(executor.executeDefaultRecordingQuery).not.toHaveBeenCalled();
        expect(executor.executeDefaultFolderQuery).not.toHaveBeenCalled();
      });
    });

    describe('with a media view', () => {
      it('should set query and queryResults for events', async () => {
        const executor = mock<QueryExecutor>();
        const query = new EventMediaQuery();
        const queryResults = new QueryResults();

        executor.executeDefaultEventQuery.mockResolvedValue({
          query: query,
          queryResults: queryResults,
        });

        const viewQueryExecutor = new ViewQueryExecutor(createPopulatedAPI(), executor);
        const view = new View({
          view: 'media',
          camera: 'camera.office',
        });

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
        applyViewModifiers(view, modifiers);

        expect(view?.query).toBe(query);
        expect(view?.queryResults).toBe(queryResults);
        expect(executor.executeDefaultEventQuery).toBeCalledWith({
          cameraID: 'camera.office',
          eventsMediaType: 'clips',
          executorOptions: {
            useCache: false,
          },
        });
        expect(executor.executeDefaultRecordingQuery).not.toHaveBeenCalled();
        expect(executor.executeDefaultFolderQuery).not.toHaveBeenCalled();
      });
    });

    describe('with an events-based view', () => {
      it.each([
        ['clip' as const, 'clips' as const],
        ['clips' as const, 'clips' as const],
        ['snapshot' as const, 'snapshots' as const],
        ['snapshots' as const, 'snapshots' as const],
      ])(
        '%s',
        async (
          viewName: AdvancedCameraCardView,
          eventsMediaType: 'clips' | 'snapshots',
        ) => {
          const executor = mock<QueryExecutor>();
          const query = new EventMediaQuery();
          const queryResults = new QueryResults();

          executor.executeDefaultEventQuery.mockResolvedValue({
            query: query,
            queryResults: queryResults,
          });

          const viewQueryExecutor = new ViewQueryExecutor(
            createPopulatedAPI(),
            executor,
          );
          const view = new View({
            view: viewName,
            camera: 'camera.office',
          });

          const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
          applyViewModifiers(view, modifiers);

          expect(view?.query).toBe(query);
          expect(view?.queryResults).toBe(queryResults);
          expect(executor.executeDefaultEventQuery).toBeCalledWith({
            cameraID: 'camera.office',
            eventsMediaType: eventsMediaType,
            executorOptions: {
              useCache: false,
            },
          });
          expect(executor.executeDefaultRecordingQuery).not.toHaveBeenCalled();
          expect(executor.executeDefaultFolderQuery).not.toHaveBeenCalled();
        },
      );
    });

    describe('with a recordings-based view', () => {
      it.each([['recording' as const], ['recordings' as const]])(
        '%s',
        async (viewName: AdvancedCameraCardView) => {
          const executor = mock<QueryExecutor>();
          const query = new RecordingMediaQuery();
          const queryResults = new QueryResults();

          executor.executeDefaultRecordingQuery.mockResolvedValue({
            query: query,
            queryResults: queryResults,
          });

          const viewQueryExecutor = new ViewQueryExecutor(
            createPopulatedAPI(),
            executor,
          );
          const view = new View({
            view: viewName,
            camera: 'camera.office',
          });

          const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
          applyViewModifiers(view, modifiers);

          expect(view?.query).toBe(query);
          expect(view?.queryResults).toBe(queryResults);
          expect(executor.executeDefaultEventQuery).not.toHaveBeenCalled();
          expect(executor.executeDefaultRecordingQuery).toBeCalledWith({
            cameraID: 'camera.office',
            executorOptions: {
              useCache: false,
            },
          });
          expect(executor.executeDefaultFolderQuery).not.toHaveBeenCalled();
        },
      );
    });

    describe('with a folder view', () => {
      it('should execute default folder query with folder view', async () => {
        const executor = mock<QueryExecutor>();
        const query = new FolderViewQuery();
        const queryResults = new QueryResults();

        executor.executeDefaultFolderQuery.mockResolvedValue({
          query: query,
          queryResults: queryResults,
        });

        const viewQueryExecutor = new ViewQueryExecutor(createPopulatedAPI(), executor);
        const view = createView({ view: 'folder', camera: 'camera.office' });

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
        applyViewModifiers(view, modifiers);

        expect(view?.query).toBe(query);
        expect(view?.queryResults).toBe(queryResults);
        expect(executor.executeDefaultEventQuery).not.toBeCalled();
        expect(executor.executeDefaultRecordingQuery).not.toBeCalled();
        expect(executor.executeDefaultFolderQuery).toBeCalledWith({
          useCache: false,
        });
      });

      it('should execute default folder query with folder view and handle null results', async () => {
        const executor = mock<QueryExecutor>();
        executor.executeDefaultFolderQuery.mockResolvedValue(null);

        const viewQueryExecutor = new ViewQueryExecutor(createPopulatedAPI(), executor);
        const view = createView({ view: 'folder', camera: 'camera.office' });

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
        applyViewModifiers(view, modifiers);

        expect(view?.query).toBeNull();
        expect(view?.queryResults).toBeNull();
      });
    });

    describe('when setting or removing seek time', () => {
      it('should set seek time when results are selected based on time', async () => {
        const now = new Date();
        const executor = mock<QueryExecutor>();
        const viewQueryExecutor = new ViewQueryExecutor(createPopulatedAPI(), executor);

        const view = new View({
          view: 'clip',
          camera: 'camera.office',
        });

        const queryExecutorOptions = {
          selectResult: {
            time: {
              time: now,
            },
          },
        };

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(
          view,
          queryExecutorOptions,
        );
        applyViewModifiers(view, modifiers);

        expect(view?.context).toEqual({
          mediaViewer: {
            seek: now,
          },
        });
      });

      it('should remove seek time when results are not selected based on time', async () => {
        const executor = mock<QueryExecutor>();
        const viewQueryExecutor = new ViewQueryExecutor(createPopulatedAPI(), executor);

        const view = new View({
          view: 'clip',
          camera: 'camera.office',
          context: {
            mediaViewer: {
              seek: new Date(),
            },
          },
        });

        const modifiers = await viewQueryExecutor.getNewQueryModifiers(view);
        applyViewModifiers(view, modifiers);

        expect(view?.context?.mediaViewer?.seek).toBeUndefined();
      });
    });
  });
});



================================================
FILE: tests/card-controller/view/modifiers/index.test.ts
================================================
import { expect, it } from 'vitest';
import { applyViewModifiers } from '../../../../src/card-controller/view/modifiers';
import { MergeContextViewModifier } from '../../../../src/card-controller/view/modifiers/merge-context';
import { SetQueryViewModifier } from '../../../../src/card-controller/view/modifiers/set-query';
import { EventMediaQuery } from '../../../../src/view/query';
import { QueryResults } from '../../../../src/view/query-results';
import { createView } from '../../../test-utils';

it('should apply view modifiers', () => {
  const view = createView();

  const query = new EventMediaQuery();
  const queryResults = new QueryResults();

  const context = {
    timeline: { window: { start: new Date(), end: new Date() } },
  };

  const modifiers = [
    new SetQueryViewModifier({
      query: query,
      queryResults: queryResults,
    }),
    new MergeContextViewModifier(context),
  ];

  applyViewModifiers(view, modifiers);

  expect(view.query).toBe(query);
  expect(view.queryResults).toBe(queryResults);
  expect(view.context).toEqual(context);
});



================================================
FILE: tests/card-controller/view/modifiers/merge-context.test.ts
================================================
import { ViewContext } from 'view';
import { expect, it } from 'vitest';
import { MergeContextViewModifier } from '../../../../src/card-controller/view/modifiers/merge-context';
import { createView } from '../../../test-utils';

it('should merge context', () => {
  const context: ViewContext = {
    timeline: {
      window: {
        start: new Date(),
        end: new Date(),
      },
    },
  };
  const modifier = new MergeContextViewModifier(context);

  const view = createView({
    view: 'live',
    camera: 'camera',
    displayMode: 'grid',
  });

  expect(view.context).toBeNull();

  modifier.modify(view);

  expect(view.context).toEqual(context);
});



================================================
FILE: tests/card-controller/view/modifiers/remove-context-property.test.ts
================================================
import { expect, it } from 'vitest';
import { createView } from '../../../test-utils';
import { RemoveContextPropertyViewModifier } from '../../../../src/card-controller/view/modifiers/remove-context-property';

it('should remove context property', () => {
  const modifier = new RemoveContextPropertyViewModifier('timeline', 'window');

  const view = createView({
    view: 'live',
    camera: 'camera',
    displayMode: 'grid',
    context: {
      timeline: {
        window: {
          start: new Date(),
          end: new Date(),
        },
      },
    },
  });

  modifier.modify(view);

  expect(view.context).toEqual({ timeline: {} });
});



================================================
FILE: tests/card-controller/view/modifiers/remove-context.test.ts
================================================
import { expect, it } from 'vitest';
import { createView } from '../../../test-utils';
import { RemoveContextViewModifier } from '../../../../src/card-controller/view/modifiers/remove-context';

it('should remove context property', () => {
  const modifier = new RemoveContextViewModifier(['timeline']);

  const view = createView({
    view: 'live',
    camera: 'camera',
    displayMode: 'grid',
    context: {
      timeline: {
        window: {
          start: new Date(),
          end: new Date(),
        },
      },
    },
  });

  modifier.modify(view);

  expect(view.context).toEqual({});
});



================================================
FILE: tests/card-controller/view/modifiers/set-query.test.ts
================================================
import { expect, it } from 'vitest';
import { SetQueryViewModifier } from '../../../../src/card-controller/view/modifiers/set-query';
import { EventMediaQuery } from '../../../../src/view/query';
import { QueryResults } from '../../../../src/view/query-results';
import { createView } from '../../../test-utils';

it('should do nothing without arguments', () => {
  const view = createView();

  const modifier = new SetQueryViewModifier();
  modifier.modify(view);

  expect(view.query).toBeNull();
  expect(view.queryResults).toBeNull();
});

it('should set query and results', () => {
  const view = createView();
  const query = new EventMediaQuery();
  const queryResults = new QueryResults();

  const modifier = new SetQueryViewModifier({
    query: query,
    queryResults: queryResults,
  });
  modifier.modify(view);

  expect(view.query).toBe(query);
  expect(view.queryResults).toBe(queryResults);
});



================================================
FILE: tests/card-controller/view/modifiers/substream-off.test.ts
================================================
import { expect, it } from 'vitest';
import { createView } from '../../../test-utils';
import { SubstreamOffViewModifier } from '../../../../src/card-controller/view/modifiers/substream-off';
import { hasSubstream, setSubstream } from '../../../../src/utils/substream';

it('should turn off substream', () => {
  const view = createView({
    view: 'live',
    camera: 'camera',
    displayMode: 'grid',
  });

  setSubstream(view, 'substream');
  expect(hasSubstream(view)).toBe(true);

  const modifier = new SubstreamOffViewModifier();
  modifier.modify(view);

  expect(hasSubstream(view)).toBe(false);
});



================================================
FILE: tests/card-controller/view/modifiers/substream-on.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { CardController } from '../../../../src/card-controller/controller';
import { SubstreamOnViewModifier } from '../../../../src/card-controller/view/modifiers/substream-on';
import { RawAdvancedCameraCardConfig } from '../../../../src/config/types';
import {
  getStreamCameraID,
  hasSubstream,
  setSubstream,
} from '../../../../src/utils/substream';
import {
  createCameraConfig,
  createCameraManager,
  createCapabilities,
  createCardAPI,
  createConfig,
  createStore,
  createView,
} from '../../../test-utils';

const createAPIWithSubstreams = (
  config?: RawAdvancedCameraCardConfig,
): CardController => {
  const api = createCardAPI();
  vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());
  vi.mocked(api.getCameraManager().getStore).mockReturnValue(
    createStore([
      {
        cameraID: 'camera.office',
        capabilities: createCapabilities({
          live: true,
          substream: true,
        }),
        config: createCameraConfig({
          dependencies: {
            all_cameras: true,
          },
        }),
      },
      {
        cameraID: 'camera.kitchen',
        capabilities: createCapabilities({
          substream: true,
        }),
      },
    ]),
  );
  vi.mocked(api.getConfigManager().getConfig).mockReturnValue(createConfig(config));
  return api;
};

describe('should turn on substream', () => {
  it('substream available', () => {
    const view = createView({
      view: 'live',
      camera: 'camera.office',
    });

    expect(hasSubstream(view)).toBe(false);

    const api = createAPIWithSubstreams();

    const modifier = new SubstreamOnViewModifier(api);
    modifier.modify(view);

    expect(hasSubstream(view)).toBe(true);
    expect(getStreamCameraID(view)).toBe('camera.kitchen');

    modifier.modify(view);

    expect(hasSubstream(view)).toBe(false);
    expect(getStreamCameraID(view)).toBe('camera.office');
  });

  it('malformed substream', () => {
    const view = createView({
      view: 'live',
      camera: 'camera.office',
    });

    const api = createAPIWithSubstreams();

    setSubstream(view, 'NOT_A_REAL_CAMERA');

    const modifier = new SubstreamOnViewModifier(api);
    modifier.modify(view);

    expect(hasSubstream(view)).toBe(false);
    expect(getStreamCameraID(view)).toBe('camera.office');
  });

  it('substream unavailable', () => {
    const view = createView({
      view: 'live',
      camera: 'camera.office',
    });

    expect(hasSubstream(view)).toBe(false);

    const api = createCardAPI();
    vi.mocked(api.getCameraManager).mockReturnValue(createCameraManager());

    const modifier = new SubstreamOnViewModifier(api);
    modifier.modify(view);

    expect(hasSubstream(view)).toBe(false);
  });
});



================================================
FILE: tests/card-controller/view/modifiers/substream-select.test.ts
================================================
import { expect, it } from 'vitest';
import { SubstreamSelectViewModifier } from '../../../../src/card-controller/view/modifiers/substream-select';
import { getStreamCameraID, hasSubstream } from '../../../../src/utils/substream';
import { createView } from '../../../test-utils';

it('should select substream', () => {
  const view = createView({
    view: 'live',
    camera: 'camera.office',
  });

  expect(hasSubstream(view)).toBe(false);

  const modifier = new SubstreamSelectViewModifier('substream');
  modifier.modify(view);

  expect(hasSubstream(view)).toBe(true);
  expect(getStreamCameraID(view)).toBe('substream');
});



================================================
FILE: tests/components-lib/icon-controller.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { IconController } from '../../src/components-lib/icon-controller';
import { createHASS, createStateEntity } from '../test-utils';

describe('IconController', () => {
  describe('should get custom icon', () => {
    it('should return frigate SVG for frigate icon', () => {
      expect(new IconController().getCustomIcon({ icon: 'frigate' })).toMatch(
        /frigate.svg$/,
      );
    });

    it('should return motioneye SVG for motioneye icon', () => {
      expect(new IconController().getCustomIcon({ icon: 'motioneye' })).toMatch(
        /motioneye.svg$/,
      );
    });

    it('should return reolink SVG for reolink icon', () => {
      expect(new IconController().getCustomIcon({ icon: 'reolink' })).toMatch(
        /reolink.svg$/,
      );
    });

    it('should return iris SVG for iris icon', () => {
      expect(new IconController().getCustomIcon({ icon: 'iris' })).toMatch(/iris.svg$/);
    });

    it('should return null for mdi icon', () => {
      expect(new IconController().getCustomIcon({ icon: 'mdi:car' })).toBeNull();
    });

    it('should return null for undefined icon', () => {
      expect(new IconController().getCustomIcon()).toBeNull();
    });
  });

  describe('should create state object for state badge', () => {
    it('should return null for non-existent entity', () => {
      expect(
        new IconController().createStateObjectForStateBadge(
          createHASS(),
          'sensor.DOES_NOT_EXIST',
        ),
      ).toBeNull();
    });

    it('should return modified state object for existing entity', () => {
      expect(
        new IconController().createStateObjectForStateBadge(
          createHASS({
            'sensor.existing': createStateEntity({
              entity_id: 'sensor.existing',
              attributes: {
                friendly_name: 'Existing',
                icon: 'mdi:car',
                entity_picture: 'http://example.com/image.jpg',
                entity_picture_local: 'local.jpg',
              },
            }),
          }),
          'sensor.existing',
        ),
      ).toEqual(
        expect.objectContaining({
          entity_id: 'sensor.existing',
          attributes: expect.objectContaining({
            friendly_name: 'Existing',
            icon: 'mdi:car',
            entity_picture: undefined,
            entity_picture_local: undefined,
          }),
        }),
      );
    });
  });
});



================================================
FILE: tests/components-lib/key-assigner-controller.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { KeyAssignerController } from '../../src/components-lib/key-assigner-controller';
import { createLitElement } from '../test-utils';

// @vitest-environment jsdom
describe('KeyAssignerController', () => {
  it('should be creatable', () => {
    const controller = new KeyAssignerController(createLitElement());
    expect(controller).toBeTruthy();
  });

  describe('should manage value', () => {
    it('should have no value to start', () => {
      const controller = new KeyAssignerController(createLitElement());
      expect(controller.hasValue()).toBeFalsy();
    });

    it('should set value', () => {
      const element = createLitElement();
      const valueChangeHandler = vi.fn();
      element.addEventListener('value-changed', valueChangeHandler);
      const controller = new KeyAssignerController(element);

      controller.setValue({ key: 'ArrowLeft' });

      expect(controller.hasValue()).toBeTruthy();
      expect(controller.getValue()).toEqual({ key: 'ArrowLeft' });
      expect(element.requestUpdate).toBeCalled();
      expect(valueChangeHandler).toBeCalledWith(
        expect.objectContaining({
          detail: { value: { key: 'ArrowLeft' } },
        }),
      );

      // Set again with the same value.
      controller.setValue({ key: 'ArrowLeft' });
      expect(element.requestUpdate).toBeCalledTimes(1);
      expect(valueChangeHandler).toBeCalledTimes(1);
    });
  });

  describe('should manage assignment state', () => {
    it('should not be assigned to start', () => {
      const element = createLitElement();
      const controller = new KeyAssignerController(element);
      expect(controller.isAssigning()).toBeFalsy();
      expect(element.getAttribute('assigning')).toBeNull();
    });

    it('should toggle assigning', () => {
      const element = createLitElement();
      const controller = new KeyAssignerController(element);
      controller.toggleAssigning();
      expect(element.requestUpdate).toBeCalled();
      expect(controller.isAssigning()).toBeTruthy();
      expect(element.getAttribute('assigning')).toBe('');

      expect(controller.hasValue()).toBeFalsy();
      element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));

      expect(controller.hasValue()).toBeTruthy();
      expect(controller.isAssigning()).toBeFalsy();

      controller.setValue(null);

      // A key sent when not assigning will do nothing.
      element.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }));
      expect(controller.hasValue()).toBeFalsy();
    });

    it('should not assign when focus lost', () => {
      const element = createLitElement();
      const controller = new KeyAssignerController(element);

      controller.hostConnected();

      controller.toggleAssigning();
      expect(controller.isAssigning()).toBeTruthy();

      element.dispatchEvent(new FocusEvent('blur'));
      expect(controller.isAssigning()).toBeFalsy();

      controller.hostDisconnected();
    });
  });

  describe('should manage key down', () => {
    it('should reject modifiers only', () => {
      const element = createLitElement();
      const controller = new KeyAssignerController(element);
      controller.toggleAssigning();

      element.dispatchEvent(new KeyboardEvent('keydown', { key: 'Control' }));
      expect(controller.hasValue()).toBeFalsy();
    });

    it('should reject empty key', () => {
      const element = createLitElement();
      const controller = new KeyAssignerController(element);
      controller.toggleAssigning();

      element.dispatchEvent(new KeyboardEvent('keydown', { key: '' }));
      expect(controller.hasValue()).toBeFalsy();
    });

    it('should accept valid key', () => {
      const element = createLitElement();
      const controller = new KeyAssignerController(element);
      controller.toggleAssigning();

      element.dispatchEvent(
        new KeyboardEvent('keydown', {
          key: 'ArrowLeft',
          ctrlKey: true,
          shiftKey: true,
          altKey: true,
          metaKey: true,
        }),
      );
      expect(controller.hasValue()).toBeTruthy();
      expect(controller.getValue()).toEqual({
        key: 'ArrowLeft',
        ctrl: true,
        shift: true,
        alt: true,
        meta: true,
      });
      expect(controller.isAssigning()).toBeFalsy();
    });
  });
});



================================================
FILE: tests/components-lib/lazy-load-controller.test.ts
================================================
import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
  vi,
} from 'vitest';
import { LazyLoadController } from '../../src/components-lib/lazy-load-controller';
import { LazyUnloadCondition } from '../../src/config/schema/common/media-actions';
import {
  callIntersectionHandler,
  callVisibilityHandler,
  createLitElement,
  getMockIntersectionObserver,
  IntersectionObserverMock,
} from '../test-utils';

// @vitest-environment jsdom
describe('LazyLoadController', () => {
  beforeAll(() => {
    vi.stubGlobal('IntersectionObserver', IntersectionObserverMock);
  });

  afterAll(() => {
    vi.unstubAllGlobals();
  });

  beforeEach(() => {
    vi.spyOn(global.document, 'addEventListener');
    vi.spyOn(global.document, 'removeEventListener');
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should be unloaded by default', () => {
    const controller = new LazyLoadController(createLitElement());
    expect(controller.isLoaded()).toBe(false);
  });

  it('should not be loaded by default when lazy load is set to true', () => {
    const controller = new LazyLoadController(createLitElement());
    controller.setConfiguration(true);
    expect(controller.isLoaded()).toBe(false);
  });

  it('should add controller to host', () => {
    const host = createLitElement();
    const controller = new LazyLoadController(host);
    expect(host.addController).toBeCalledWith(controller);
  });

  it('should remove controller from host', () => {
    const host = createLitElement();
    const controller = new LazyLoadController(host);
    controller.removeController();
    expect(host.removeController).toBeCalledWith(controller);
  });

  it('should remove handlers and listeners on destroy', () => {
    const controller = new LazyLoadController(createLitElement());
    controller.setConfiguration(true, ['unselected', 'hidden']);
    controller.hostConnected();

    const listener = vi.fn();
    controller.addListener(listener);

    controller.destroy();

    expect(getMockIntersectionObserver()?.disconnect).toBeCalled();
    expect(global.document.removeEventListener).toBeCalledWith(
      'visibilitychange',
      expect.anything(),
    );
    expect(controller.isLoaded()).toBe(false);

    callVisibilityHandler(true);
    callIntersectionHandler(true);
    expect(listener).not.toBeCalled();
  });

  describe('should set configuration', () => {
    it('should set loaded if lazy loading set to false', () => {
      const listener = vi.fn();
      const controller = new LazyLoadController(createLitElement());
      controller.addListener(listener);

      expect(controller.isLoaded()).toBe(false);
      expect(listener).not.toBeCalled();

      controller.setConfiguration(false);

      expect(controller.isLoaded()).toBe(true);
      expect(listener).toBeCalled();
    });
  });

  describe('should lazy load', () => {
    it('should load when both visible and intersecting', () => {
      const controller = new LazyLoadController(createLitElement());
      controller.setConfiguration(true);
      controller.hostConnected();

      expect(controller.isLoaded()).toBe(false);

      callVisibilityHandler(true);
      expect(controller.isLoaded()).toBe(false);

      callIntersectionHandler(true);
      expect(controller.isLoaded()).toBe(true);
    });
  });

  describe('should lazy unload', () => {
    it('should unload on DOM disconnection', () => {
      const controller = new LazyLoadController(createLitElement());

      // No lazy loading.
      controller.setConfiguration(false);
      controller.hostConnected();

      expect(controller.isLoaded()).toBe(true);

      controller.hostDisconnected();

      expect(controller.isLoaded()).toBe(false);

      // Should also stop observing.
      expect(getMockIntersectionObserver()?.disconnect).toBeCalled();
      expect(global.document.removeEventListener).toBeCalledWith(
        'visibilitychange',
        expect.anything(),
      );
    });

    describe('should lazy unload when not visible', () => {
      it.each([
        [[], true],
        [['unselected' as const], true],
        [['hidden' as const], false],
        [['unselected' as const, 'hidden' as const], false],
      ])(
        'when unload conditions are: %s',
        (unloadConditions: LazyUnloadCondition[], shouldBeLoaded: boolean) => {
          const controller = new LazyLoadController(createLitElement());
          controller.setConfiguration(true, unloadConditions);
          controller.hostConnected();

          callIntersectionHandler(true);
          callVisibilityHandler(true);
          expect(controller.isLoaded()).toBe(true);

          callVisibilityHandler(false);
          expect(controller.isLoaded()).toBe(shouldBeLoaded);
        },
      );
    });

    describe('should lazy unload when not intersecting', () => {
      it.each([
        [[], true],
        [['unselected' as const], false],
        [['hidden' as const], true],
        [['unselected' as const, 'hidden' as const], false],
      ])(
        'when unload conditions are: %s',
        (unloadConditions: LazyUnloadCondition[], shouldBeLoaded: boolean) => {
          const controller = new LazyLoadController(createLitElement());
          controller.setConfiguration(true, unloadConditions);
          controller.hostConnected();

          callIntersectionHandler(true);
          callVisibilityHandler(true);
          expect(controller.isLoaded()).toBe(true);

          callIntersectionHandler(false);
          expect(controller.isLoaded()).toBe(shouldBeLoaded);
        },
      );
    });
  });

  it('should call listeners', () => {
    const listener = vi.fn();
    const controller = new LazyLoadController(createLitElement());
    controller.setConfiguration(true, ['unselected', 'hidden']);
    controller.hostConnected();
    controller.addListener(listener);

    expect(controller.isLoaded()).toBe(false);

    callIntersectionHandler(true);
    callVisibilityHandler(true);
    expect(listener).toHaveBeenLastCalledWith(true);
    expect(listener).toBeCalledTimes(1);

    callIntersectionHandler(false);
    expect(listener).toHaveBeenLastCalledWith(false);
    expect(listener).toBeCalledTimes(2);

    callIntersectionHandler(true);
    expect(listener).toHaveBeenLastCalledWith(true);
    expect(listener).toBeCalledTimes(3);

    controller.removeListener(listener);

    callIntersectionHandler(false);
    expect(listener).toBeCalledTimes(3);
  });
});



================================================
FILE: tests/components-lib/media-actions-controller.test.ts
================================================
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { MicrophoneState } from '../../src/card-controller/types';
import {
  MediaActionsController,
  MediaActionsControllerOptions,
} from '../../src/components-lib/media-actions-controller';
import { MediaPlayerController, MediaPlayerElement } from '../../src/types';
import {
  IntersectionObserverMock,
  MutationObserverMock,
  callIntersectionHandler,
  callMutationHandler,
  callVisibilityHandler,
  createParent,
  flushPromises,
} from '../test-utils';
import { createTestSlideNodes } from '../utils/embla/test-utils';

const getPlayer = (
  element: HTMLElement,
  selector: string,
): MediaPlayerElement | null => {
  return element.querySelector(selector);
};

const createPlayerElement = (controller?: MediaPlayerController): MediaPlayerElement => {
  const player = document.createElement('video');
  player['getMediaPlayerController'] = vi
    .fn()
    .mockResolvedValue(controller ?? mock<MediaPlayerController>());
  return player as unknown as MediaPlayerElement;
};

const createPlayerSlideNodes = (n = 10): HTMLElement[] => {
  const divs = createTestSlideNodes({ n: n });
  for (const div of divs) {
    div.appendChild(createPlayerElement());
  }
  return divs;
};

// @vitest-environment jsdom
describe('MediaActionsController', () => {
  beforeAll(() => {
    vi.stubGlobal('IntersectionObserver', IntersectionObserverMock);
    vi.stubGlobal('MutationObserver', MutationObserverMock);
  });

  afterAll(() => {
    vi.unstubAllGlobals();
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('should set root', () => {
    it('should have root', async () => {
      const controller = new MediaActionsController();

      controller.setRoot(createParent());

      expect(controller.hasRoot()).toBeTruthy();
    });

    it('should do nothing without options', async () => {
      const controller = new MediaActionsController();

      const children = createPlayerSlideNodes();
      const parent = createParent({ children: children });

      controller.setRoot(parent);
      await controller.setTarget(0, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).not.toBeCalled();
    });

    it('should do nothing on resetting same root', () => {
      const controller = new MediaActionsController();
      const parent = createParent({ children: createPlayerSlideNodes() });

      expect(controller.setRoot(parent)).toBeTruthy();
      expect(controller.setRoot(parent)).toBeFalsy();
    });

    it('should re-setRoot after mutation', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        playerSelector: 'video',
        autoPlayConditions: ['selected' as const],
      });

      const parent = createParent({ children: createPlayerSlideNodes(1) });
      controller.setRoot(parent);

      const mediaPlayerController = mock<MediaPlayerController>();

      const newPlayer = createPlayerElement(mediaPlayerController);
      const newChild = document.createElement('div');
      newChild.appendChild(newPlayer);
      parent.append(newChild);

      await callMutationHandler();

      await controller.setTarget(1, true);

      expect(mediaPlayerController.play).toBeCalled();
    });
  });

  describe('should destroy', () => {
    it('should do nothing after destroy', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        playerSelector: 'video',
        autoPlayConditions: ['selected' as const],
      });

      const children = createPlayerSlideNodes();
      const parent = createParent({ children: children });
      controller.setRoot(parent);

      controller.destroy();

      await controller.setTarget(0, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).not.toBeCalled();
    });
  });

  describe('should respond to setting target', () => {
    it.each([
      ['should play', { autoPlayConditions: ['selected' as const] }, 'play', true],
      ['should not play', { autoPlayConditions: [] }, 'play', false],
      ['should unmute', { autoUnmuteConditions: ['selected' as const] }, 'unmute', true],
      ['should not unmute', { autoUnmuteConditions: [] }, 'unmute', false],
    ])(
      '%s',
      async (
        _: string,
        options: Partial<MediaActionsControllerOptions>,
        func: string,
        called: boolean,
      ) => {
        const controller = new MediaActionsController();
        controller.setOptions({
          playerSelector: 'video',
          ...options,
        });

        const children = createPlayerSlideNodes();
        controller.setRoot(createParent({ children: children }));

        await controller.setTarget(0, true);

        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).toBeCalledTimes(called ? 1 : 0);
      },
    );

    it('should not reselect previously selected target', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoPlayConditions: ['selected' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalledTimes(1);

      await controller.setTarget(0, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalledTimes(1);
    });

    it('should unselect before selecting a new target', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoPauseConditions: ['unselected' as const],
        autoMuteConditions: ['unselected' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);
      await controller.setTarget(1, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.pause,
      ).toBeCalled();
      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.mute,
      ).toBeCalled();
    });

    it('should select after target was previously visible', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoPlayConditions: ['selected' as const],
        autoUnmuteConditions: ['selected' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, false);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).not.toBeCalled();
      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).not.toBeCalled();

      await controller.setTarget(0, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalled();
      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).toBeCalled();
    });
  });

  it('should take no action after target unset', async () => {
    const controller = new MediaActionsController();
    controller.setOptions({
      autoPlayConditions: ['selected' as const, 'visible' as const],
      autoUnmuteConditions: ['selected' as const, 'visible' as const],
      playerSelector: 'video',
    });

    const children = createPlayerSlideNodes();
    controller.setRoot(createParent({ children: children }));

    await controller.setTarget(0, true);

    expect(
      (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
    ).toBeCalledTimes(1);
    expect(
      (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
    ).toBeCalledTimes(1);

    controller.unsetTarget();

    getPlayer(children[0], 'video')?.dispatchEvent(
      new Event('advanced-camera-card:media:loaded'),
    );
    await flushPromises();

    // Play/Mute will not have been called again.
    expect(
      (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
    ).toBeCalledTimes(1);
    expect(
      (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
    ).toBeCalledTimes(1);
  });

  describe('should respond to media loaded', () => {
    it('should play after media load', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoPlayConditions: ['selected' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalledTimes(1);

      getPlayer(children[0], 'video')?.dispatchEvent(
        new Event('advanced-camera-card:media:loaded'),
      );

      await flushPromises();

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalledTimes(2);
    });

    it('should unmute after media load', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoUnmuteConditions: ['selected' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);
      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).toBeCalledTimes(1);

      getPlayer(children[0], 'video')?.dispatchEvent(
        new Event('advanced-camera-card:media:loaded'),
      );

      await flushPromises();

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).toBeCalledTimes(2);
    });

    it('should take no action on unrelated media load', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoPlayConditions: ['selected' as const, 'visible' as const],
        autoUnmuteConditions: ['selected' as const, 'visible' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);

      getPlayer(children[9], 'video')?.dispatchEvent(
        new Event('advanced-camera-card:media:loaded'),
      );

      await flushPromises();

      expect(
        (await getPlayer(children[9], 'video')?.getMediaPlayerController())?.play,
      ).not.toBeCalled();
      expect(
        (await getPlayer(children[9], 'video')?.getMediaPlayerController())?.unmute,
      ).not.toBeCalled();
    });

    it('should play and unmute on unselected but targeted media load', async () => {
      const controller = new MediaActionsController();
      controller.setOptions({
        autoPlayConditions: ['visible' as const],
        autoUnmuteConditions: ['visible' as const],
        playerSelector: 'video',
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, false);

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalledTimes(1);
      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).toBeCalledTimes(1);

      getPlayer(children[0], 'video')?.dispatchEvent(
        new Event('advanced-camera-card:media:loaded'),
      );

      await flushPromises();

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.play,
      ).toBeCalledTimes(2);
      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).toBeCalledTimes(2);
    });
  });

  describe('should take action on unselect', () => {
    it.each([
      ['should pause', { autoPauseConditions: ['unselected' as const] }, 'pause', true],
      ['should not pause', { autoPauseConditions: [] }, 'pause', false],
      ['should mute', { autoMuteConditions: ['unselected' as const] }, 'mute', true],
      ['should not mute', { autoMuteConditions: [] }, 'mute', false],
    ])(
      '%s',
      async (
        _: string,
        options: Partial<MediaActionsControllerOptions>,
        func: string,
        called: boolean,
      ) => {
        const controller = new MediaActionsController();
        controller.setOptions({
          playerSelector: 'video',
          ...options,
        });

        const children = createPlayerSlideNodes();
        controller.setRoot(createParent({ children: children }));

        await controller.setTarget(0, true);
        await controller.setTarget(0, false);

        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).toBeCalledTimes(called ? 1 : 0);
      },
    );
  });

  describe('should take action on page being visible', () => {
    it.each([
      ['should play', { autoPlayConditions: ['visible' as const] }, 'play', true],
      ['should not play', { autoPlayConditions: [] }, 'play', false],
      ['should unmute', { autoUnmuteConditions: ['visible' as const] }, 'unmute', true],
      ['should not unmute', { autoUnmuteConditions: [] }, 'unmute', false],
    ])(
      '%s',
      async (
        _: string,
        options: Partial<MediaActionsControllerOptions>,
        func: string,
        called: boolean,
      ) => {
        vi.spyOn(global.document, 'addEventListener');

        const controller = new MediaActionsController();
        controller.setOptions({
          playerSelector: 'video',
          ...options,
        });

        const children = createPlayerSlideNodes();
        controller.setRoot(createParent({ children: children }));
        await controller.setTarget(0, true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).not.toBeCalled();

        await callVisibilityHandler(true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).toBeCalledTimes(called ? 1 : 0);
      },
    );
  });

  describe('should take action on page being hiddne', () => {
    beforeAll(() => {
      vi.spyOn(global.document, 'addEventListener');
    });

    it.each([
      ['should pause', { autoPauseConditions: ['hidden' as const] }, 'pause', true],
      ['should not pause', { autoPauseConditions: [] }, 'pause', false],
      ['should mute', { autoMuteConditions: ['hidden' as const] }, 'mute', true],
      ['should not mute', { autoMuteConditions: [] }, 'mute', false],
    ])(
      '%s',
      async (
        _: string,
        options: Partial<MediaActionsControllerOptions>,
        func: string,
        called: boolean,
      ) => {
        const controller = new MediaActionsController();
        controller.setOptions({
          playerSelector: 'video',
          ...options,
        });

        const children = createPlayerSlideNodes();
        controller.setRoot(createParent({ children: children }));
        await controller.setTarget(0, true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).not.toBeCalled();

        await callVisibilityHandler(false);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).toBeCalledTimes(called ? 1 : 0);
      },
    );
  });

  describe('should take action on page intersecting with viewport', () => {
    it.each([
      ['should play', { autoPlayConditions: ['visible' as const] }, 'play', true],
      ['should not play', { autoPlayConditions: [] }, 'play', false],
      ['should unmute', { autoUnmuteConditions: ['visible' as const] }, 'unmute', true],
      ['should not unmute', { autoUnmuteConditions: [] }, 'unmute', false],
    ])(
      '%s',
      async (
        _: string,
        options: Partial<MediaActionsControllerOptions>,
        func: string,
        called: boolean,
      ) => {
        const controller = new MediaActionsController();
        controller.setOptions({
          playerSelector: 'video',
          ...options,
        });

        const children = createPlayerSlideNodes();
        controller.setRoot(createParent({ children: children }));
        await controller.setTarget(0, true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).not.toBeCalled();

        // There's always a first call to an intersection observer handler. In
        // this case the MediaActionsController ignores it.
        await callIntersectionHandler(false);

        await callIntersectionHandler(true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).toBeCalledTimes(called ? 1 : 0);
      },
    );
  });

  describe('should take action on page not intersecting with viewport', () => {
    it.each([
      ['should play', { autoPlayConditions: ['visible' as const] }, 'play', true],
      ['should not play', { autoPlayConditions: [] }, 'play', false],
      ['should unmute', { autoUnmuteConditions: ['visible' as const] }, 'unmute', true],
      ['should not unmute', { autoUnmuteConditions: [] }, 'unmute', false],
    ])(
      '%s',
      async (
        _: string,
        options: Partial<MediaActionsControllerOptions>,
        func: string,
        called: boolean,
      ) => {
        const controller = new MediaActionsController();
        controller.setOptions({
          playerSelector: 'video',
          ...options,
        });

        const children = createPlayerSlideNodes();
        controller.setRoot(createParent({ children: children }));
        await controller.setTarget(0, true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).not.toBeCalled();

        // There's always a first call to an intersection observer handler. In
        // this case the MediaActionsController ignores it.
        await callIntersectionHandler(false);

        await callIntersectionHandler(true);

        // Not configured to take action on selection.
        expect(
          (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.[func],
        ).toBeCalledTimes(called ? 1 : 0);
      },
    );
  });

  describe('should take action on microphone state changes', () => {
    beforeAll(() => {
      vi.useFakeTimers();
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    const createMicrophoneState = (
      state?: Partial<MicrophoneState>,
    ): MicrophoneState => {
      return {
        muted: true,
        forbidden: false,
        connected: false,
        ...state,
      };
    };

    it('should unmute when microphone unmuted', async () => {
      const controller = new MediaActionsController();

      controller.setOptions({
        autoUnmuteConditions: ['microphone' as const],
        playerSelector: 'video',
        microphoneState: createMicrophoneState({ muted: true }),
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);

      controller.setOptions({
        autoUnmuteConditions: ['microphone' as const],
        playerSelector: 'video',
        microphoneState: createMicrophoneState({ muted: false }),
      });

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.unmute,
      ).toBeCalled();
    });

    it('should mute after delay after microphone muted', async () => {
      const controller = new MediaActionsController();

      controller.setOptions({
        autoMuteConditions: ['microphone' as const],
        playerSelector: 'video',
        microphoneState: createMicrophoneState({ muted: false }),
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);

      controller.setOptions({
        autoMuteConditions: ['microphone' as const],
        playerSelector: 'video',
        microphoneState: createMicrophoneState({ muted: true }),
      });

      vi.runOnlyPendingTimers();

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.mute,
      ).toBeCalled();
    });

    it('should not mute after delay after microphone muted', async () => {
      const controller = new MediaActionsController();

      controller.setOptions({
        autoMuteConditions: [],
        playerSelector: 'video',
        microphoneState: createMicrophoneState({ muted: false }),
      });

      const children = createPlayerSlideNodes();
      controller.setRoot(createParent({ children: children }));

      await controller.setTarget(0, true);

      controller.setOptions({
        autoMuteConditions: ['microphone' as const],
        playerSelector: 'video',
        microphoneState: createMicrophoneState({ muted: true }),
      });

      vi.runOnlyPendingTimers();

      expect(
        (await getPlayer(children[0], 'video')?.getMediaPlayerController())?.mute,
      ).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/components-lib/media-filter-controller.test.ts
================================================
import { endOfDay, startOfDay, sub } from 'date-fns';
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { Capabilities } from '../../src/camera-manager/capabilities';
import { CameraManagerStore } from '../../src/camera-manager/store';
import { QueryType } from '../../src/camera-manager/types';
import { ViewManager } from '../../src/card-controller/view/view-manager';
import {
  MediaFilterController,
  MediaFilterCoreDefaults,
  MediaFilterCoreFavoriteSelection,
  MediaFilterCoreWhen,
  MediaFilterMediaType,
} from '../../src/components-lib/media-filter-controller';
import { EventMediaQuery, Query, RecordingMediaQuery } from '../../src/view/query';
import {
  createCameraConfig,
  createCameraManager,
  createCapabilities,
  createLitElement,
  createPerformanceConfig,
  createStore,
  createView,
} from '../test-utils';

const createCameraStore = (options?: {
  capabilities: Capabilities;
}): CameraManagerStore => {
  return createStore([
    {
      cameraID: 'camera.kitchen',
      config: createCameraConfig({
        camera_entity: 'camera.kitchen',
      }),
      capabilities:
        options?.capabilities ??
        new Capabilities({
          clips: true,
          snapshots: true,
          recordings: true,
        }),
    },
  ]);
};

// @vitest-environment jsdom
describe('MediaFilterController', () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  describe('should have correct default options', () => {
    it('media type', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getMediaTypeOptions()).toEqual([
        {
          value: MediaFilterMediaType.Clips,
          label: 'Clips',
        },
        {
          value: MediaFilterMediaType.Snapshots,
          label: 'Snapshots',
        },
        {
          value: MediaFilterMediaType.Recordings,
          label: 'Recordings',
        },
      ]);
    });

    it('favorite', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getFavoriteOptions()).toEqual([
        {
          value: MediaFilterCoreFavoriteSelection.Favorite,
          label: 'Favorite',
        },
        {
          value: MediaFilterCoreFavoriteSelection.NotFavorite,
          label: 'Not Favorite',
        },
      ]);
    });

    it('when', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getWhenOptions()).toEqual([
        {
          value: MediaFilterCoreWhen.Today,
          label: 'Today',
        },
        {
          value: MediaFilterCoreWhen.Yesterday,
          label: 'Yesterday',
        },
        {
          value: MediaFilterCoreWhen.PastWeek,
          label: 'Past Week',
        },
        {
          value: MediaFilterCoreWhen.PastMonth,
          label: 'Past Month',
        },
        {
          value: MediaFilterCoreWhen.Custom,
          label: 'Custom',
        },
      ]);
    });

    it('cameras', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getCameraOptions()).toEqual([]);
    });

    it('what', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getWhatOptions()).toEqual([]);
    });

    it('where', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getWhereOptions()).toEqual([]);
    });

    it('tags', () => {
      const controller = new MediaFilterController(createLitElement());
      expect(controller.getTagsOptions()).toEqual([]);
    });
  });

  describe('should calculate correct dynamic options', () => {
    describe('cameras', () => {
      it('with valid camera', () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getCameraMetadata).mockReturnValue({
          title: 'Kitchen Camera',
          icon: { icon: 'mdi:camera' },
        });
        vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

        const controller = new MediaFilterController(createLitElement());
        controller.computeCameraOptions(cameraManager);
        expect(controller.getCameraOptions()).toEqual([
          {
            label: 'Kitchen Camera',
            value: 'camera.kitchen',
          },
        ]);
      });

      it('with camera that does not support media', () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getCameraMetadata).mockReturnValue({
          title: 'Kitchen Camera',
          icon: { icon: 'mdi:camera' },
        });
        vi.mocked(cameraManager.getStore).mockReturnValue(
          createCameraStore({
            capabilities: new Capabilities({
              clips: false,
              snapshots: false,
              recordings: false,
            }),
          }),
        );

        const controller = new MediaFilterController(createLitElement());
        controller.computeCameraOptions(cameraManager);
        expect(controller.getCameraOptions()).toEqual([]);
      });

      it('without camera metadata', () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getCameraMetadata).mockReturnValue(null);
        vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

        const controller = new MediaFilterController(createLitElement());
        controller.computeCameraOptions(cameraManager);
        expect(controller.getCameraOptions()).toEqual([
          {
            label: 'camera.kitchen',
            value: 'camera.kitchen',
          },
        ]);
      });
    });

    describe('metadata', () => {
      it('with failed getMediaMetadata call', async () => {
        vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getMediaMetadata).mockRejectedValue(new Error('error'));

        const host = createLitElement();
        const controller = new MediaFilterController(host);
        await controller.computeMetadataOptions(cameraManager);
        expect(host.requestUpdate).not.toBeCalled();
      });

      it('with metadata for what', async () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getMediaMetadata).mockResolvedValue({
          what: new Set(['person', 'car']),
        });

        const host = createLitElement();
        const controller = new MediaFilterController(host);
        await controller.computeMetadataOptions(cameraManager);
        expect(controller.getWhatOptions()).toEqual([
          {
            value: 'car',
            label: 'Car',
          },
          {
            value: 'person',
            label: 'Person',
          },
        ]);
        expect(host.requestUpdate).toBeCalled();
      });

      it('with metadata for where', async () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getMediaMetadata).mockResolvedValue({
          where: new Set(['front_door', 'back_yard']),
        });

        const host = createLitElement();
        const controller = new MediaFilterController(host);
        await controller.computeMetadataOptions(cameraManager);
        expect(controller.getWhereOptions()).toEqual([
          {
            value: 'back_yard',
            label: 'Back Yard',
          },
          {
            value: 'front_door',
            label: 'Front Door',
          },
        ]);
        expect(host.requestUpdate).toBeCalled();
      });

      it('with metadata for tags', async () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getMediaMetadata).mockResolvedValue({
          tags: new Set(['tag-1', 'tag-2']),
        });

        const host = createLitElement();
        const controller = new MediaFilterController(host);
        await controller.computeMetadataOptions(cameraManager);
        expect(controller.getTagsOptions()).toEqual([
          {
            value: 'tag-1',
            label: 'Tag-1',
          },
          {
            value: 'tag-2',
            label: 'Tag-2',
          },
        ]);
        expect(host.requestUpdate).toBeCalled();
      });

      it('with metadata for days', async () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getMediaMetadata).mockResolvedValue({
          days: new Set(['2024-02-04', '2024-02-05']),
        });

        const host = createLitElement();
        const controller = new MediaFilterController(host);
        await controller.computeMetadataOptions(cameraManager);

        expect(controller.getWhenOptions()).toEqual(
          expect.arrayContaining([
            expect.objectContaining({
              value: '2024-02-01,2024-02-29',
              label: 'February 2024',
            }),
          ]),
        );
        expect(host.requestUpdate).toBeCalled();
      });
    });
  });

  describe('should get correct controls to show', () => {
    it('view with events', () => {
      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView({ query: new EventMediaQuery() }));
      const cameraManager = createCameraManager();

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);
      expect(controller.getControlsToShow(cameraManager)).toMatchObject({
        events: true,
        recordings: false,
      });
    });

    it('view with recordings', () => {
      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(
        createView({ query: new RecordingMediaQuery() }),
      );
      const cameraManager = createCameraManager();

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);
      expect(controller.getControlsToShow(cameraManager)).toMatchObject({
        events: false,
        recordings: true,
      });
    });

    it('can favorite events', () => {
      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView({ query: new EventMediaQuery() }));
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getAggregateCameraCapabilities).mockReturnValue(
        createCapabilities({ 'favorite-events': true }),
      );

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      expect(controller.getControlsToShow(cameraManager)).toMatchObject({
        favorites: true,
      });
    });

    it('can favorite recordings', () => {
      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(
        createView({ query: new RecordingMediaQuery() }),
      );

      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getAggregateCameraCapabilities).mockReturnValue(
        createCapabilities({ 'favorite-recordings': true }),
      );

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      expect(controller.getControlsToShow(cameraManager)).toMatchObject({
        favorites: true,
      });
    });

    it('can not favorite without a query', () => {
      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView());

      const cameraManager = createCameraManager();

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      expect(controller.getControlsToShow(cameraManager)).toMatchObject({
        favorites: false,
      });
    });
  });

  describe('should handle value change', () => {
    it('must have visible cameras', async () => {
      const viewManager = mock<ViewManager>();

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      await controller.valueChangeHandler(createCameraManager(), {}, { when: {} });

      expect(viewManager.setViewByParametersWithExistingQuery).not.toBeCalled();
    });

    describe('with events media type', () => {
      it.each([['clips' as const], ['snapshots' as const]])(
        '%s',
        async (viewName: 'clips' | 'snapshots') => {
          const host = createLitElement();
          const viewManager = mock<ViewManager>();
          viewManager.getView.mockReturnValue(createView());

          const controller = new MediaFilterController(host);
          controller.setViewManager(viewManager);

          const cameraManager = createCameraManager(createCameraStore());

          const from = new Date('2024-02-06T21:59');
          const to = new Date('2024-02-06T22:00');

          await controller.valueChangeHandler(
            cameraManager,
            {
              performance: createPerformanceConfig({
                features: {
                  media_chunk_size: 11,
                },
              }),
            },
            {
              camera: 'camera.kitchen',
              mediaType:
                viewName === 'clips'
                  ? MediaFilterMediaType.Clips
                  : MediaFilterMediaType.Snapshots,
              when: {
                to: to,
                from: from,
              },
              tags: ['tag-1', 'tag-2'],
              what: ['what-1', 'what-2'],
              where: ['where-1', 'where-2'],
              favorite: MediaFilterCoreFavoriteSelection.Favorite,
            },
          );

          expect(viewManager.setViewByParametersWithExistingQuery).toBeCalledWith({
            params: expect.objectContaining({
              camera: 'camera.kitchen',
              view: viewName,
            }),
          });
          expect(
            viewManager.setViewByParametersWithExistingQuery.mock.calls[0][0]?.params?.query?.getQuery(),
          ).toEqual([
            {
              cameraIDs: new Set(['camera.kitchen']),
              ...(viewName === 'clips' && { hasClip: true }),
              ...(viewName === 'snapshots' && { hasSnapshot: true }),
              type: 'event-query',
              tags: new Set(['tag-1', 'tag-2']),
              what: new Set(['what-1', 'what-2']),
              where: new Set(['where-1', 'where-2']),
              favorite: true,
              start: from,
              end: to,
              limit: 11,
            },
          ]);

          expect(host.requestUpdate).toBeCalled();
        },
      );
    });

    it('with recordings media type', async () => {
      const host = createLitElement();

      const cameraManager = createCameraManager(createCameraStore());

      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView());

      vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

      const controller = new MediaFilterController(host);
      controller.setViewManager(viewManager);

      const from = new Date('2024-02-06T21:59');
      const to = new Date('2024-02-06T22:00');

      await controller.valueChangeHandler(
        cameraManager,
        {
          performance: createPerformanceConfig({
            features: {
              media_chunk_size: 11,
            },
          }),
        },
        {
          mediaType: MediaFilterMediaType.Recordings,
          when: {
            to: to,
            from: from,
          },
          favorite: MediaFilterCoreFavoriteSelection.Favorite,
        },
      );

      expect(viewManager.setViewByParametersWithExistingQuery).toBeCalledWith({
        params: expect.objectContaining({
          camera: 'camera.kitchen',
          view: 'recordings',
        }),
      });

      expect(
        viewManager.setViewByParametersWithExistingQuery.mock.calls[0][0]?.params?.query?.getQuery(),
      ).toEqual([
        {
          cameraIDs: new Set(['camera.kitchen']),
          type: 'recording-query',
          favorite: true,
          start: from,
          end: to,
          limit: 11,
        },
      ]);

      expect(host.requestUpdate).toBeCalled();
    });

    it('without favorites', async () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView());

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      await controller.valueChangeHandler(
        cameraManager,
        {},
        {
          mediaType: MediaFilterMediaType.Recordings,
          when: {},
        },
      );

      expect(viewManager.setViewByParametersWithExistingQuery).toBeCalledWith({
        params: expect.objectContaining({
          camera: 'camera.kitchen',
          view: 'recordings',
        }),
      });

      expect(
        viewManager.setViewByParametersWithExistingQuery.mock.calls[0][0]?.params?.query?.getQuery(),
      ).toEqual([
        {
          cameraIDs: new Set(['camera.kitchen']),
          type: 'recording-query',
        },
      ]);
    });

    describe('with fixed when selection', () => {
      const date = new Date('2024-10-01T17:14');

      beforeAll(() => {
        vi.useFakeTimers();
        vi.setSystemTime(date);
      });

      afterAll(() => {
        vi.useFakeTimers();
      });

      it.each([
        [MediaFilterCoreWhen.Today, startOfDay(date), endOfDay(date)],
        [
          MediaFilterCoreWhen.Yesterday,
          startOfDay(sub(date, { days: 1 })),
          endOfDay(sub(date, { days: 1 })),
        ],
        [
          MediaFilterCoreWhen.PastWeek,
          startOfDay(sub(date, { days: 7 })),
          endOfDay(date),
        ],
        [
          MediaFilterCoreWhen.PastMonth,
          startOfDay(sub(date, { months: 1 })),
          endOfDay(date),
        ],
        [
          '2024-02-01,2024-02-29',
          new Date('2024-02-01T00:00:00'),
          new Date('2024-02-29T23:59:59.999'),
        ],
      ])('%s', async (value: MediaFilterCoreWhen | string, from: Date, to: Date) => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

        const viewManager = mock<ViewManager>();
        viewManager.getView.mockReturnValue(createView());

        const controller = new MediaFilterController(createLitElement());
        controller.setViewManager(viewManager);

        await controller.valueChangeHandler(
          cameraManager,
          {},
          {
            mediaType: MediaFilterMediaType.Recordings,
            when: {
              selected: value,
            },
          },
        );
        expect(
          viewManager.setViewByParametersWithExistingQuery.mock.calls[0][0]?.params?.query?.getQuery(),
        ).toEqual([
          {
            cameraIDs: new Set(['camera.kitchen']),
            type: 'recording-query',
            start: from,
            end: to,
          },
        ]);
      });

      it('custom without values', async () => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

        const viewManager = mock<ViewManager>();
        viewManager.getView.mockReturnValue(createView());

        const controller = new MediaFilterController(createLitElement());
        controller.setViewManager(viewManager);

        await controller.valueChangeHandler(
          cameraManager,
          {},
          {
            mediaType: MediaFilterMediaType.Recordings,
            when: {
              selected: MediaFilterCoreWhen.Custom,
            },
          },
        );

        expect(
          viewManager.setViewByParametersWithExistingQuery.mock.calls[0][0]?.params?.query?.getQuery(),
        ).toEqual([
          {
            cameraIDs: new Set(['camera.kitchen']),
            type: 'recording-query',
          },
        ]);
      });
    });
  });

  describe('should calculate correct defaults', () => {
    it('with no query', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView());

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      controller.computeInitialDefaultsFromView(cameraManager);

      expect(controller.getDefaults()).toBeNull();
    });

    it('with no raw queries', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(
        createView({
          query: new EventMediaQuery(),
        }),
      );

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      controller.computeInitialDefaultsFromView(cameraManager);

      expect(controller.getDefaults()).toBeNull();
    });

    it('with no cameras', () => {
      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(createView());

      const controller = new MediaFilterController(createLitElement());
      controller.setViewManager(viewManager);

      controller.computeInitialDefaultsFromView(createCameraManager());

      expect(controller.getDefaults()).toBeNull();
    });

    describe('for queries', () => {
      it.each([
        [
          'same cameras' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen', 'camera.living_room']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen', 'camera.living_room']),
            },
          ]),
          {
            cameraIDs: ['camera.kitchen', 'camera.living_room'],
          },
        ],
        [
          'different cameras' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.living_room']),
            },
          ]),
          {},
        ],
        [
          'all cameras' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
            },
          ]),
          {},
        ],
        [
          'different favorites ' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: true,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: undefined,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: false,
            },
          ]),
          {},
        ],
        [
          'all favorites' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: true,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: true,
            },
          ]),
          {
            favorite: MediaFilterCoreFavoriteSelection.Favorite,
          },
        ],
        [
          'all not favorites' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: false,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              favorite: false,
            },
          ]),
          {
            favorite: MediaFilterCoreFavoriteSelection.NotFavorite,
          },
        ],
        [
          'same hasClip' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasClip: true,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasClip: true,
            },
          ]),
          {
            mediaType: MediaFilterMediaType.Clips,
          },
        ],
        [
          'different hasClip' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasClip: true,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasClip: false,
            },
          ]),
          {},
        ],
        [
          'same hasSnapshot' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasSnapshot: true,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasSnapshot: true,
            },
          ]),
          {
            mediaType: MediaFilterMediaType.Snapshots,
          },
        ],
        [
          'different hasSnapshot' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasSnapshot: true,
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              hasSnapshot: false,
            },
          ]),
          {},
        ],
        [
          'same what' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              what: new Set(['person']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              what: new Set(['person']),
            },
          ]),
          {
            what: ['person' as const],
          },
        ],
        [
          'different what' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              what: new Set(['person']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              what: new Set(['car']),
            },
          ]),
          {},
        ],
        [
          'same where' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              where: new Set(['front_door']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              where: new Set(['front_door']),
            },
          ]),
          {
            where: ['front_door' as const],
          },
        ],
        [
          'different where' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              where: new Set(['front_door']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              where: new Set(['back_steps']),
            },
          ]),
          {},
        ],
        [
          'same tags' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              tags: new Set(['tag-1']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              tags: new Set(['tag-1']),
            },
          ]),
          {
            tags: ['tag-1' as const],
          },
        ],
        [
          'different tags' as const,
          new EventMediaQuery([
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              tags: new Set(['tag-1']),
            },
            {
              type: QueryType.Event,
              cameraIDs: new Set(['camera.kitchen']),
              tags: new Set(['tag-2']),
            },
          ]),
          {},
        ],
        [
          'recordings' as const,
          new RecordingMediaQuery([
            {
              type: QueryType.Recording,
              cameraIDs: new Set(['camera.kitchen']),
            },
          ]),
          {
            mediaType: MediaFilterMediaType.Recordings,
          },
        ],
      ])(
        '%s',
        (
          _name: string,
          mediaQueries: Query,
          defaults: MediaFilterCoreDefaults | null,
        ) => {
          const viewManager = mock<ViewManager>();
          viewManager.getView.mockReturnValue(
            createView({
              query: mediaQueries,
            }),
          );

          const controller = new MediaFilterController(createLitElement());
          controller.setViewManager(viewManager);

          const cameraManager = createCameraManager();
          vi.mocked(cameraManager.getStore).mockReturnValue(createCameraStore());

          controller.computeInitialDefaultsFromView(cameraManager);

          expect(controller.getDefaults()).toEqual(defaults);
        },
      );
    });
  });
});



================================================
FILE: tests/components-lib/media-grid-controller.test.ts
================================================
import Masonry from 'masonry-layout';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import {
  ExtendedMasonry,
  MediaGridConstructorOptions,
  MediaGridController,
} from '../../src/components-lib/media-grid-controller';
import { MediaLoadedInfo } from '../../src/types';
import { dispatchExistingMediaLoadedInfoAsEvent } from '../../src/utils/media-info';
import {
  MutationObserverMock,
  ResizeObserverMock,
  createSlot,
  createSlotHost,
} from '../test-utils';

vi.mock('lodash-es', async () => ({
  ...(await vi.importActual('lodash-es')),
  throttle: vi.fn((fn) => fn),
}));

const masonry = mock<ExtendedMasonry>();
vi.mock('masonry-layout', () => ({
  default: vi.fn().mockImplementation(() => {
    return masonry;
  }),
}));

const createChildren = (childIDs?: string[], idAttribute?: string): HTMLElement[] => {
  const children: HTMLElement[] = [];
  for (let i = 0; i < (childIDs?.length ?? 3); ++i) {
    const child = document.createElement('div');
    if (childIDs) {
      child.setAttribute(idAttribute ?? 'grid-id', childIDs[i]);
    }
    children.push(child);
  }
  return children;
};

const setElementWidth = (element: HTMLElement, width: number): void => {
  element.getBoundingClientRect = vi.fn().mockReturnValue({
    width: width,
  });
};

const createParent = (options?: {
  children?: HTMLElement[];
  width?: number;
}): HTMLElement => {
  const host = document.createElement('div');
  if (options?.children) {
    host.append(...options.children);
  }
  // Default Lovelace card width is 492.
  setElementWidth(host, options?.width ?? 492);
  return host;
};

const createController = (host: HTMLElement, options?: MediaGridConstructorOptions) => {
  return new MediaGridController(host, options);
};

const triggerMutationObserver = (hostOrCell: 'cell' | 'host'): void => {
  const mutationObserverTrigger = vi.mocked(global.MutationObserver).mock.calls[
    hostOrCell === 'host' ? 0 : 1
  ][0];
  mutationObserverTrigger([], mock<MutationObserver>());
};

const triggerResizeObserver = (hostOrCell: 'cell' | 'host'): void => {
  const resizeObserverTrigger = vi.mocked(global.ResizeObserver).mock.calls[
    hostOrCell === 'host' ? 0 : 1
  ][0];
  resizeObserverTrigger([], mock<ResizeObserver>());
};

// @vitest-environment jsdom
describe('MediaGridController', () => {
  const mediaLoadedInfo: MediaLoadedInfo = {
    width: 10,
    height: 20,
  };

  beforeEach(() => {
    vi.clearAllMocks();
    vi.stubGlobal('MutationObserver', MutationObserverMock);
    vi.stubGlobal('ResizeObserver', ResizeObserverMock);

    masonry.items = [];
  });

  it('should be constructable', () => {
    const controller = createController(createParent());
    expect(controller).toBeTruthy();
    expect(masonry.layout).toBeCalled();
  });

  it('should set grid contents correctly from regular elements', () => {
    const children = createChildren();
    const parent = createParent({ children: children });
    const controller = createController(parent);
    expect(controller.getGridContents()).toEqual(
      new Map([
        ['0', children[0]],
        ['1', children[1]],
        ['2', children[2]],
      ]),
    );
    expect(controller.getGridSize()).toBe(3);
    expect(masonry.layout).toBeCalled();
  });

  it('should set grid contents correctly from slotted elements', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(host);
    expect(controller.getGridContents()).toEqual(
      new Map([
        ['0', children[0]],
        ['1', children[1]],
        ['2', children[2]],
      ]),
    );
    expect(controller.getGridSize()).toBe(3);
  });

  it('should select element', () => {
    const children = createChildren();
    const slot = createSlot();
    createSlotHost({ slot: slot, children: children });

    const controller = createController(slot);

    // All children should be unselected.
    expect(controller.getSelected()).toBeNull();
    for (const child of children) {
      expect(child.getAttribute('selected')).toBeNull();
      expect(child.getAttribute('unselected')).toEqual('');
    }

    controller.selectCell('0');
    expect(controller.getSelected()).toBe('0');

    // 1st child should now be selected.
    expect(children[0].getAttribute('selected')).toEqual('');
    expect(children[0].getAttribute('unselected')).toBeNull();

    // 2nd and 3rd should be unselected.
    for (const child of children.slice(1)) {
      expect(child.getAttribute('selected')).toBeNull();
      expect(child.getAttribute('unselected')).toEqual('');
    }
  });

  it('should re-select element', () => {
    const children = createChildren();
    const slot = createSlot();
    createSlotHost({ slot: slot, children: children });
    const controller = createController(slot);

    // All children should be unselected.
    expect(controller.getSelected()).toBeNull();

    controller.selectCell('0');
    expect(controller.getSelected()).toBe('0');

    controller.selectCell('0');
    expect(controller.getSelected()).toBe('0');
  });

  it('should dispatch media loaded info on selection', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(slot);

    const mediaLoadedInfoHandler = vi.fn();
    host.addEventListener('advanced-camera-card:media:loaded', mediaLoadedInfoHandler);
    dispatchExistingMediaLoadedInfoAsEvent(children[0], mediaLoadedInfo);

    controller.selectCell('0');
    expect(mediaLoadedInfoHandler).toBeCalledWith(
      expect.objectContaining({
        detail: mediaLoadedInfo,
      }),
    );
  });

  it('should dispatch media loaded info when cell is selected', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(slot);

    controller.selectCell('0');

    const mediaLoadedInfoHandler = vi.fn();
    host.addEventListener('advanced-camera-card:media:loaded', mediaLoadedInfoHandler);
    dispatchExistingMediaLoadedInfoAsEvent(children[0], mediaLoadedInfo);

    expect(mediaLoadedInfoHandler).toBeCalledWith(
      expect.objectContaining({
        detail: mediaLoadedInfo,
      }),
    );
  });

  it('should not dispatch media loaded info when cell is not selected', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(host);

    controller.selectCell('1');

    const mediaLoadedInfoHandler = vi.fn();
    host.addEventListener('advanced-camera-card:media:loaded', mediaLoadedInfoHandler);
    dispatchExistingMediaLoadedInfoAsEvent(children[0], mediaLoadedInfo);

    // Another element is selected, so the event should not have propagated.
    expect(mediaLoadedInfoHandler).not.toBeCalled();
  });

  it('should unselect', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(host);

    const unselectedHandler = vi.fn();
    const unloadMediaHandler = vi.fn();
    host.addEventListener(
      'advanced-camera-card:media-grid:unselected',
      unselectedHandler,
    );
    host.addEventListener('advanced-camera-card:media:unloaded', unloadMediaHandler);

    controller.selectCell('0');
    expect(controller.getSelected()).toBe('0');

    // Unselect all elements.
    controller.unselectAll();

    // Expect selected to now be null.
    expect(controller.getSelected()).toBeNull();

    // Expect styles to have been updated.
    for (const child of children) {
      expect(child.getAttribute('selected')).toBeNull();
      expect(child.getAttribute('unselected')).toEqual('');
    }

    // Expect handlers to have been called.
    expect(unselectedHandler).toBeCalledTimes(1);
    expect(unloadMediaHandler).toBeCalledTimes(1);

    // Unselecting a second time should do nothing.
    controller.unselectAll();

    expect(unselectedHandler).toBeCalledTimes(1);
    expect(unloadMediaHandler).toBeCalledTimes(1);
  });

  it('should select in constructor', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(host, { selected: '2' });

    expect(controller.getSelected()).toBe('2');
  });

  it('should respect grid attribute option', () => {
    const children = createChildren(['one', 'two', 'three'], 'test-id');
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });
    const controller = createController(host, { idAttribute: 'test-id' });
    expect(controller.getGridContents()).toEqual(
      new Map([
        ['one', children[0]],
        ['two', children[1]],
        ['three', children[2]],
      ]),
    );
  });

  it('should destroy with regular elements', () => {
    const children = createChildren();
    const parent = createParent({ children: children });
    const controller = createController(parent);
    expect(controller.getGridSize()).toBe(3);
    controller.destroy();
    expect(controller.getGridSize()).toBe(0);
  });

  it('should destroy with slotted elements', () => {
    const children = createChildren();
    const slot = createSlot();
    createSlotHost({ slot: slot, children: children });
    const controller = createController(slot);

    expect(controller.getGridSize()).toBe(3);
    controller.destroy();
    expect(controller.getGridSize()).toBe(0);
  });

  it('should replace children when they change', () => {
    const children = createChildren();
    const parent = createParent({ children: children });
    const controller = createController(parent, { selected: '1' });
    dispatchExistingMediaLoadedInfoAsEvent(children[0], mediaLoadedInfo);

    expect(controller.getSelected()).toBe('1');
    expect(controller.getGridSize()).toBe(3);

    children.forEach((child) => parent.removeChild(child));
    const newChildren = createChildren(['one', 'two', 'three']);
    newChildren.forEach((child) => parent.appendChild(child));

    triggerMutationObserver('host');

    expect(controller.getGridContents()).toEqual(
      new Map([
        ['one', newChildren[0]],
        ['two', newChildren[1]],
        ['three', newChildren[2]],
      ]),
    );
    expect(controller.getSelected()).toBeNull();
  });

  it('should re-calculate children when id attribute changes', () => {
    const children = createChildren(['one', 'two', 'three'], 'test-id');
    const parent = createParent({ children: children });
    const controller = createController(parent, {
      selected: 'one',
      idAttribute: 'test-id',
    });

    expect(controller.getSelected()).toBe('one');
    expect(controller.getGridSize()).toBe(3);

    children[0].setAttribute('test-id', 'alpha');
    children[1].setAttribute('test-id', 'beta');
    children[2].setAttribute('test-id', 'gamma');

    triggerMutationObserver('cell');

    expect(controller.getGridContents()).toEqual(
      new Map([
        ['alpha', children[0]],
        ['beta', children[1]],
        ['gamma', children[2]],
      ]),
    );
    expect(controller.getSelected()).toBeNull();
  });

  it('should replace children of a slot when they change', () => {
    const children = createChildren();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });

    const controller = createController(slot, { selected: '1' });

    expect(controller.getSelected()).toBe('1');
    expect(controller.getGridSize()).toBe(3);

    children.forEach((child) => host.removeChild(child));
    const newChildren = createChildren(['one', 'two', 'three']);
    newChildren.forEach((child) => host.append(child));

    slot.dispatchEvent(new Event('slotchange'));

    expect(controller.getGridContents()).toEqual(
      new Map([
        ['one', newChildren[0]],
        ['two', newChildren[1]],
        ['three', newChildren[2]],
      ]),
    );
    expect(controller.getSelected()).toBeNull();
  });

  it('should construct masonry correctly', () => {
    const children = createChildren();
    const parent = createParent({ children: children });
    createController(parent);
    expect(Masonry).toBeCalledWith(
      parent,
      expect.objectContaining({
        initLayout: false,
        percentPosition: true,
        transitionDuration: '0.2s',
      }),
    );
  });

  it('should set default column size correctly', () => {
    const parent = createParent({ children: createChildren() });
    createController(parent);
    expect(Masonry).toBeCalledWith(
      parent,
      expect.objectContaining({
        columnWidth: 245,
      }),
    );
    expect(
      parent.style.getPropertyValue('--advanced-camera-card-grid-column-size'),
    ).toBe('245px');
  });

  it('should respect exact columns', () => {
    const parent = createParent({ children: createChildren(), width: 3000 });
    const controller = createController(parent);
    controller.setDisplayConfig({ mode: 'grid', grid_columns: 2 });

    // Will have been called once on construction, and then again when the
    // number of columns changes.
    expect(Masonry).toBeCalledTimes(2);
    expect(Masonry).toBeCalledWith(
      parent,
      expect.objectContaining({
        columnWidth: 1499,
      }),
    );
    expect(
      parent.style.getPropertyValue('--advanced-camera-card-grid-column-size'),
    ).toBe('1499px');
  });

  it('should respect selected width factor', () => {
    const parent = createParent({ children: createChildren(), width: 2000 });
    const controller = createController(parent);
    controller.setDisplayConfig({ mode: 'grid', grid_selected_width_factor: 3 });
    expect(
      parent.style.getPropertyValue('--advanced-camera-card-grid-selected-width-factor'),
    ).toBe('3');

    // Setting the same config again should do nothing.
    controller.setDisplayConfig({ mode: 'grid', grid_selected_width_factor: 3 });
    expect(
      parent.style.getPropertyValue('--advanced-camera-card-grid-selected-width-factor'),
    ).toBe('3');
  });

  it('should select cell when interacted with', () => {
    const children = createChildren();
    const parent = createParent({ children: children, width: 2000 });
    const controller = createController(parent);

    expect(controller.getSelected()).toBeNull();

    const clickHandler = vi.fn();
    parent.addEventListener('click', clickHandler);

    children[1].click();

    // Click will not be allowed through.
    expect(clickHandler).not.toBeCalled();
    expect(controller.getSelected()).toBe('1');
  });

  it('should ignore interaction events on already selected cell', () => {
    const children = createChildren();
    const parent = createParent({ children: children, width: 2000 });
    const controller = createController(parent);
    controller.selectCell('1');

    const clickHandler = vi.fn();
    parent.addEventListener('click', clickHandler);
    children[1].click();

    // Click will be allowed through.
    expect(clickHandler).toBeCalled();
    expect(controller.getSelected()).toBe('1');
  });

  it('should re-layout when child size changes', () => {
    createController(createParent({ children: createChildren() }));

    vi.mocked(masonry.layout)?.mockClear();
    triggerResizeObserver('cell');
    expect(masonry.layout).toBeCalled();
  });

  it('should re-create masonry when host size changes', () => {
    const children = createChildren();
    const parent = createParent({ children: children });
    createController(parent);
    expect(Masonry).toBeCalledWith(
      parent,
      expect.objectContaining({
        columnWidth: 245,
      }),
    );
    expect(
      parent.style.getPropertyValue('--advanced-camera-card-grid-column-size'),
    ).toBe('245px');

    // Clear mock state.
    vi.mocked(Masonry).mockClear();
    vi.mocked(masonry.layout)?.mockClear();

    // Resize the host.
    setElementWidth(parent, 3000);
    triggerResizeObserver('host');

    // Masonry should be reconstructed, styles set and layout called.
    expect(Masonry).toBeCalledWith(
      parent,
      expect.objectContaining({
        columnWidth: 599,
      }),
    );
    expect(
      parent.style.getPropertyValue('--advanced-camera-card-grid-column-size'),
    ).toBe('599px');
    expect(masonry.layout).toBeCalled();

    // Clear mock state.
    vi.mocked(Masonry).mockClear();
    vi.mocked(masonry.layout)?.mockClear();

    // Triger with the same sizes.
    triggerResizeObserver('host');
    expect(Masonry).not.toBeCalled();
    expect(masonry.layout).not.toBeCalled();
  });

  describe('describe should sort grid elements correctly', () => {
    it('should respect placement when grid_selected_position is default', () => {
      const children = createChildren();
      const parent = createParent({ children: children });

      // Simulate wrapped children in masonry object.
      masonry.items = children.map((child) => ({ element: child }));

      const controller = createController(parent);
      controller.setDisplayConfig({ mode: 'grid', grid_selected_position: 'default' });

      controller.selectCell('1');

      expect(masonry.items).toEqual([
        { element: children[0] },
        { element: children[1] },
        { element: children[2] },
      ]);
    });

    it('should respect placement when grid_selected_position is first', () => {
      const children = createChildren(['0', '1', '2']);
      const parent = createParent({ children: children });

      // Simulate wrapped children in masonry object.
      masonry.items = children.map((child) => ({ element: child }));

      const controller = createController(parent);
      controller.setDisplayConfig({ mode: 'grid', grid_selected_position: 'first' });

      controller.selectCell('1');

      expect(masonry.items).toEqual([
        { element: children[1] },
        { element: children[0] },
        { element: children[2] },
      ]);
    });

    it('should respect placement when grid_selected_position is last', () => {
      const children = createChildren(['0', '1', '2']);
      const parent = createParent({ children: children });

      // Simulate wrapped children in masonry object.
      masonry.items = children.map((child) => ({ element: child }));

      const controller = createController(parent);
      controller.setDisplayConfig({ mode: 'grid', grid_selected_position: 'last' });

      controller.selectCell('1');

      expect(masonry.items).toEqual([
        { element: children[0] },
        { element: children[2] },
        { element: children[1] },
      ]);
    });
  });
});



================================================
FILE: tests/components-lib/media-height-controller.test.ts
================================================
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { MediaHeightController } from '../../src/components-lib/media-height-controller';
import {
  callMutationHandler,
  MutationObserverMock,
  ResizeObserverMock,
} from '../test-utils';
import { callResizeHandler } from '../utils/embla/test-utils';

vi.mock('lodash-es', async () => ({
  ...(await vi.importActual('lodash-es')),
  debounce: vi.fn((fn) => fn),
}));

// @vitest-environment jsdom
describe('MediaHeightController', () => {
  beforeAll(() => {
    vi.stubGlobal('MutationObserver', MutationObserverMock);
    vi.stubGlobal('ResizeObserver', ResizeObserverMock);
  });

  afterAll(() => {
    vi.unstubAllGlobals();
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('should set height', () => {
    it('should set height on selection', () => {
      const host = document.createElement('div');
      const controller = new MediaHeightController(host, 'div');

      const root = document.createElement('div');
      const child = document.createElement('div');
      child.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 600,
      });
      root.appendChild(child);

      controller.setRoot(root);

      // Calling a second time has no effect.
      controller.setRoot(root);

      controller.setSelected(0);

      expect(host.style.maxHeight).toBe(`600px`);
    });

    it('should not set height without children', () => {
      const host = document.createElement('div');
      const controller = new MediaHeightController(host, 'div');

      const root = document.createElement('div');

      controller.setRoot(root);

      controller.setSelected(10);

      expect(host.style.maxHeight).toBe('');
    });

    it('should respond to resize observer of selected child', () => {
      const host = document.createElement('div');
      const controller = new MediaHeightController(host, 'div');

      const root = document.createElement('div');
      const child = document.createElement('div');
      root.appendChild(child);

      controller.setRoot(root);
      controller.setSelected(0);

      child.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 800,
      });

      callResizeHandler([
        {
          target: child,
          height: 800,
          width: 400,
        },
      ]);

      expect(host.style.maxHeight).toBe('800px');
    });

    it('should not respond to resize observer without a selected child', () => {
      const host = document.createElement('div');
      const controller = new MediaHeightController(host, 'div');

      const root = document.createElement('div');
      const child = document.createElement('div');
      root.appendChild(child);

      controller.setRoot(root);

      child.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 800,
      });

      callResizeHandler([
        {
          target: child,
          height: 800,
          width: 400,
        },
      ]);

      expect(host.style.maxHeight).toBe('');
    });

    it('should respond to new children being added', () => {
      const host = document.createElement('div');
      const controller = new MediaHeightController(host, 'div');

      const root = document.createElement('div');
      const child_0 = document.createElement('div');
      child_0.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 100,
      });
      root.appendChild(child_0);

      controller.setRoot(root);

      const child_1 = document.createElement('div');
      child_1.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 200,
      });
      root.appendChild(child_1);

      callMutationHandler();

      controller.setSelected(1);

      expect(host.style.maxHeight).toBe('200px');
    });

    it('should ignore new chil to new children being added', () => {
      const host = document.createElement('div');
      const controller = new MediaHeightController(host, 'div');

      const root = document.createElement('div');
      const child_0 = document.createElement('div');
      child_0.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 100,
      });
      root.appendChild(child_0);

      controller.setRoot(root);

      const child_1 = document.createElement('div');
      child_1.getBoundingClientRect = vi.fn().mockReturnValue({
        height: 200,
      });
      root.appendChild(child_1);

      callMutationHandler();

      controller.setSelected(1);

      expect(host.style.maxHeight).toBe('200px');
    });
  });

  it('should destroy', () => {
    const host = document.createElement('div');
    const controller = new MediaHeightController(host, 'div');

    controller.destroy();

    // No observable effect.
  });
});



================================================
FILE: tests/components-lib/menu-button-controller.test.ts
================================================
import { isEqual } from 'lodash-es';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { Capabilities } from '../../src/camera-manager/capabilities.js';
import { CameraManager } from '../../src/camera-manager/manager.js';
import { CameraManagerCameraMetadata } from '../../src/camera-manager/types.js';
import { FoldersManager } from '../../src/card-controller/folders/manager.js';
import { FullscreenManager } from '../../src/card-controller/fullscreen/fullscreen-manager.js';
import { MediaPlayerManager } from '../../src/card-controller/media-player-manager.js';
import { MicrophoneManager } from '../../src/card-controller/microphone-manager.js';
import { ViewManager } from '../../src/card-controller/view/view-manager.js';
import {
  MenuButtonController,
  MenuButtonControllerOptions,
} from '../../src/components-lib/menu-button-controller.js';
import { AdvancedCameraCardView } from '../../src/config/schema/common/const.js';
import { ViewDisplayMode } from '../../src/config/schema/common/display.js';
import { MenuItem } from '../../src/config/schema/elements/custom/menu/types.js';
import { AdvancedCameraCardConfig } from '../../src/config/schema/types.js';
import { HomeAssistant } from '../../src/ha/types.js';
import { MediaPlayerController, PTZMovementType } from '../../src/types.js';
import { createGeneralAction, createViewAction } from '../../src/utils/action.js';
import { ViewMedia, ViewMediaType } from '../../src/view/item.js';
import { QueryResults } from '../../src/view/query-results.js';
import { FolderViewQuery } from '../../src/view/query.js';
import { View } from '../../src/view/view.js';
import {
  createCameraConfig,
  createCameraManager,
  createCapabilities,
  createConfig,
  createFolder,
  createHASS,
  createMediaCapabilities,
  createMediaLoadedInfo,
  createStateEntity,
  createStore,
  createView,
  TestViewMedia,
} from '../test-utils.js';

vi.mock('../../src/utils/media-player-controller.js');
vi.mock('../../src/card-controller/microphone-manager.js');

const calculateButtons = (
  controller: MenuButtonController,
  options?: MenuButtonControllerOptions & {
    hass?: HomeAssistant;
    config?: AdvancedCameraCardConfig;
    cameraManager?: CameraManager;
    view?: View | null;
    viewManager?: ViewManager;
  },
): MenuItem[] => {
  let cameraManager: CameraManager | null = options?.cameraManager ?? null;
  if (!cameraManager) {
    cameraManager = createCameraManager();
  }

  return controller.calculateButtons(
    options?.hass ?? createHASS(),
    options?.config ?? createConfig(),
    cameraManager,
    {
      ...options,
      view:
        options?.view === undefined ? createView({ camera: 'camera-1' }) : options.view,
    },
  );
};

// @vitest-environment jsdom
describe('MenuButtonController', () => {
  let controller: MenuButtonController;
  const dynamicButton: MenuItem = {
    type: 'custom:advanced-camera-card-menu-icon',
    icon: 'mdi:alpha-a-circle',
    title: 'Dynamic button',
  };

  beforeEach(() => {
    vi.resetAllMocks();
    controller = new MenuButtonController();
  });

  describe('should have iris menu button', () => {
    it('with hidden menu style', () => {
      const buttons = calculateButtons(controller);

      expect(buttons).toContainEqual({
        icon: 'iris',
        enabled: true,
        permanent: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Iris / Default View / Unhide menu',
        tap_action: createGeneralAction('menu_toggle'),
        hold_action: createViewAction('diagnostics'),
      });
    });

    it('without hidden menu style', () => {
      const buttons = calculateButtons(controller, {
        config: createConfig({ menu: { style: 'overlay' } }),
      });

      expect(buttons).toContainEqual({
        icon: 'iris',
        enabled: true,
        permanent: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Iris / Default View / Unhide menu',
        tap_action: createGeneralAction('default'),
        hold_action: createViewAction('diagnostics'),
      });
    });
  });

  describe('should have cameras menu', () => {
    it('should have cameras menu with multiple cameras', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          { cameraID: 'camera-1', capabilities: createCapabilities({ menu: true }) },
          { cameraID: 'camera-2', capabilities: createCapabilities({ menu: true }) },
          { cameraID: 'camera-3', capabilities: createCapabilities({ menu: false }) },
        ]),
      );
      vi.mocked(cameraManager).getCameraMetadata.mockReturnValue({
        title: 'title',
        icon: {
          icon: 'icon',
        },
      });
      const buttons = calculateButtons(controller, { cameraManager: cameraManager });

      expect(buttons).toContainEqual({
        icon: 'mdi:video-switch',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: 'Cameras',
        items: [
          {
            enabled: true,
            icon: 'icon',
            entity: undefined,
            state_color: true,
            title: 'title',
            selected: true,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'camera_select',
              camera: 'camera-1',
            },
          },
          {
            enabled: true,
            icon: 'icon',
            entity: undefined,
            state_color: true,
            title: 'title',
            selected: false,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'camera_select',
              camera: 'camera-2',
            },
          },
        ],
      });
    });

    it('should not have cameras menu with <= 1 camera', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          { cameraID: 'camera-1', capabilities: createCapabilities({ menu: true }) },
          { cameraID: 'camera-3', capabilities: createCapabilities({ menu: false }) },
        ]),
      );
      vi.mocked(cameraManager).getCameraMetadata.mockReturnValue({
        title: 'title',
        icon: {
          icon: 'icon',
        },
      });
      const buttons = calculateButtons(controller, { cameraManager: cameraManager });

      expect(buttons).not.toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            title: 'Cameras',
          }),
        ]),
      );
    });
  });

  describe('should have substream button', () => {
    it('with no view', () => {
      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(),
        view: null,
      });

      expect(buttons).not.toContainEqual(
        expect.objectContaining({
          title: 'Substream(s)',
        }),
      );
    });

    it('with no dependency', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            capabilities: createCapabilities({ substream: true }),
          },
        ]),
      );
      const buttons = calculateButtons(controller, { cameraManager: cameraManager });

      expect(buttons).not.toContainEqual(
        expect.objectContaining({
          title: 'Substream(s)',
        }),
      );
    });

    it('with single dependency', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({ dependencies: { cameras: ['camera-2'] } }),
          },
          {
            cameraID: 'camera-2',
            capabilities: createCapabilities({ substream: true }),
          },
        ]),
      );
      const buttons = calculateButtons(controller, { cameraManager: cameraManager });

      expect(buttons).toContainEqual({
        icon: 'mdi:video-input-component',
        style: {},
        title: 'Substream(s)',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'live_substream_on',
        },
      });
    });

    it('with substream selected and single dependency', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({ dependencies: { cameras: ['camera-2'] } }),
          },
          {
            cameraID: 'camera-2',
            capabilities: createCapabilities({ substream: true }),
          },
        ]),
      );
      const view = createView({
        camera: 'camera-1',
        context: {
          live: {
            overrides: new Map([['camera-1', 'camera-2']]),
          },
        },
      });
      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        view: view,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:video-input-component',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        title: 'Substream(s)',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'live_substream_off',
        },
      });
    });

    it('with substream unselected and multiple dependencies', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({
              camera_entity: 'camera.1',
              dependencies: { cameras: ['camera-2', 'camera-3'] },
            }),
            capabilities: createCapabilities({ substream: true }),
          },
          {
            cameraID: 'camera-2',
            config: createCameraConfig({
              camera_entity: 'camera.2',
            }),
            capabilities: createCapabilities({ substream: true }),
          },
          {
            cameraID: 'camera-3',
            config: createCameraConfig({
              camera_entity: 'camera.3',
            }),
            capabilities: createCapabilities({ substream: true }),
          },
        ]),
      );

      // Return different metadata depending on the camera to test multiple code
      // paths.
      mock<CameraManager>(cameraManager).getCameraMetadata.mockImplementation(
        (cameraID: string): CameraManagerCameraMetadata | null => {
          return cameraID === 'camera-1'
            ? {
                title: 'title',
                icon: {
                  icon: 'icon',
                  entity: 'entity',
                },
              }
            : null;
        },
      );

      const buttons = calculateButtons(controller, { cameraManager: cameraManager });

      expect(buttons).toContainEqual({
        icon: 'mdi:video-input-component',
        title: 'Substream(s)',
        style: {},
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        items: [
          {
            enabled: true,
            icon: 'icon',
            entity: 'entity',
            state_color: true,
            title: 'title',
            selected: true,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'live_substream_select',
              camera: 'camera-1',
            },
          },
          {
            enabled: true,
            icon: undefined,
            entity: undefined,
            state_color: true,
            title: undefined,
            selected: false,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'live_substream_select',
              camera: 'camera-2',
            },
          },
          {
            enabled: true,
            icon: undefined,
            entity: undefined,
            state_color: true,
            title: undefined,
            selected: false,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'live_substream_select',
              camera: 'camera-3',
            },
          },
        ],
      });
    });

    it('with substream selected and with multiple dependencies', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({
              camera_entity: 'camera.1',
              dependencies: { cameras: ['camera-2', 'camera-3'] },
            }),
            capabilities: createCapabilities({ substream: true }),
          },
          {
            cameraID: 'camera-2',
            config: createCameraConfig({
              camera_entity: 'camera.2',
            }),
            capabilities: createCapabilities({ substream: true }),
          },
          {
            cameraID: 'camera-3',
            config: createCameraConfig({
              camera_entity: 'camera.3',
            }),
            capabilities: createCapabilities({ substream: true }),
          },
        ]),
      );
      const view = createView({
        camera: 'camera-1',
        context: {
          live: {
            overrides: new Map([['camera-1', 'camera-2']]),
          },
        },
      });
      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        view: view,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:video-input-component',
        title: 'Substream(s)',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        items: [
          {
            enabled: true,
            icon: undefined,
            entity: undefined,
            state_color: true,
            title: undefined,
            selected: false,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'live_substream_select',
              camera: 'camera-1',
            },
          },
          {
            enabled: true,
            icon: undefined,
            entity: undefined,
            state_color: true,
            title: undefined,
            // camera-2 is selected in this test scenario because of the view
            // override.
            selected: true,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'live_substream_select',
              camera: 'camera-2',
            },
          },
          {
            enabled: true,
            icon: undefined,
            entity: undefined,
            state_color: true,
            title: undefined,
            selected: false,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'live_substream_select',
              camera: 'camera-3',
            },
          },
        ],
      });
    });
  });

  describe('should have live menu button', () => {
    it('when in live view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'live' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:cctv',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Live view',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'live' },
      });
    });

    it('when not in live view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'clips' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:cctv',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Live view',
        style: {},
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'live' },
      });
    });

    it('when not supported', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(false);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).not.toContainEqual(
        expect.objectContaining({
          title: 'Live view',
        }),
      );
    });
  });

  describe('should have clips menu button', () => {
    it('when in clips view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'clips' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:filmstrip',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Clips gallery',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'clips' },
        hold_action: { action: 'fire-dom-event', advanced_camera_card_action: 'clip' },
      });
    });

    it('when not in clips view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:filmstrip',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Clips gallery',
        style: {},
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'clips' },
        hold_action: { action: 'fire-dom-event', advanced_camera_card_action: 'clip' },
      });
    });

    it('when not supported', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(false);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([expect.objectContaining({ title: 'Clips gallery' })]),
      );
    });
  });

  describe('should have snapshots menu button', () => {
    it('when in snapshots view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'snapshots' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:camera',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Snapshots gallery',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'snapshots',
        },
        hold_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'snapshot',
        },
      });
    });

    it('when not in snapshots view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:camera',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Snapshots gallery',
        style: {},
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'snapshots',
        },
        hold_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'snapshot',
        },
      });
    });

    it('when not supported', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(false);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([
          expect.objectContaining({ title: 'Snapshots gallery' }),
        ]),
      );
    });
  });

  describe('should have recordings menu button', () => {
    it('when in recordings view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'recordings' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:album',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Recordings gallery',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'recordings',
        },
        hold_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'recording',
        },
      });
    });

    it('when not in recordings view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:album',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Recordings gallery',
        style: {},
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'recordings',
        },
        hold_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'recording',
        },
      });
    });

    it('when not supported', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(false);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([
          expect.objectContaining({ title: 'Recordings gallery' }),
        ]),
      );
    });
  });

  describe('should have image menu button', () => {
    it('when in image view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        view: createView({ view: 'image' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:image',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Static image',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'image' },
      });
    });

    it('when not in image view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        view: createView({ view: 'live' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:image',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Static image',
        style: {},
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'image' },
      });
    });

    it('when not supported', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(false);
      const buttons = calculateButtons(controller, {
        viewManager: viewManager,
      });

      expect(buttons).not.toContainEqual(
        expect.objectContaining({
          title: 'Static image',
        }),
      );
    });
  });

  describe('should have timeline button', () => {
    it('when in timeline view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'timeline' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:chart-gantt',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Timeline view',
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'timeline',
        },
      });
    });

    it('when not in timeline view', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(true);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'live' }),
        viewManager: viewManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:chart-gantt',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Timeline view',
        style: {},
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'timeline',
        },
      });
    });

    it('when not supported', () => {
      const viewManager = mock<ViewManager>();
      vi.mocked(viewManager.isViewSupportedByCamera).mockReturnValue(false);
      const buttons = calculateButtons(controller, {
        view: createView({ view: 'live' }),
        viewManager: viewManager,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([expect.objectContaining({ title: 'Timeline view' })]),
      );
    });
  });

  describe('should have download button', () => {
    it('when media available', () => {
      vi.stubGlobal('navigator', { userAgent: 'foo' });

      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getMediaCapabilities).mockReturnValue(
        createMediaCapabilities({ canDownload: true }),
      );
      const view = createView({
        view: 'media',
        queryResults: new QueryResults({
          results: [
            new ViewMedia(ViewMediaType.Clip, {
              cameraID: 'camera-1',
            }),
          ],
          selectedIndex: 0,
        }),
      });
      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        view: view,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:download',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Download',
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'download',
        },
      });
    });

    it('not when being casted', () => {
      vi.stubGlobal('navigator', {
        userAgent:
          'Mozilla/5.0 (Fuchsia) AppleWebKit/537.36 (KHTML, like Gecko) ' +
          'Chrome/114.0.0.0 Safari/537.36 CrKey/1.56.500000',
      });

      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getMediaCapabilities).mockReturnValue(
        createMediaCapabilities({ canDownload: true }),
      );
      const view = createView({
        queryResults: new QueryResults({
          results: [new ViewMedia(ViewMediaType.Clip, { cameraID: 'camera-1' })],
          selectedIndex: 0,
        }),
      });
      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        view: view,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([expect.objectContaining({ title: 'Download' })]),
      );
    });

    it('not in a non-media view', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getMediaCapabilities).mockReturnValue(
        createMediaCapabilities({ canDownload: true }),
      );
      const view = createView({
        view: 'live',
        queryResults: new QueryResults({
          results: [new ViewMedia(ViewMediaType.Clip, { cameraID: 'camera-1' })],
          selectedIndex: 0,
        }),
      });
      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        view: view,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([expect.objectContaining({ title: 'Download' })]),
      );
    });
  });

  it('should have camera UI button', () => {
    const buttons = calculateButtons(controller, {
      showCameraUIButton: true,
    });

    expect(buttons).toContainEqual({
      icon: 'mdi:web',
      enabled: true,
      priority: 50,
      type: 'custom:advanced-camera-card-menu-icon',
      title: 'Camera user interface',
      tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'camera_ui' },
    });
  });

  describe('should have microphone button', () => {
    it('with suitable loaded media', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(false);
      vi.mocked(microphoneManager.isMuted).mockReturnValue(false);
      vi.mocked(microphoneManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: true,
          },
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:microphone',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Microphone',
        style: {
          animation: 'pulse 3s infinite',
          color: 'var(--advanced-camera-card-menu-button-critical-color)',
        },
        start_tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'microphone_unmute',
        },
        end_tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'microphone_mute',
        },
      });
    });

    it('without suitable loaded media', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(false);
      vi.mocked(microphoneManager.isMuted).mockReturnValue(false);
      vi.mocked(microphoneManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: false,
          },
        }),
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([expect.objectContaining({ title: 'Microphone' })]),
      );
    });

    it('with forbidden microphone', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: true,
          },
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:microphone-message-off',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Microphone',
        style: {},
      });
    });

    it('with muted microphone', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(false);
      vi.mocked(microphoneManager.isMuted).mockReturnValue(true);
      vi.mocked(microphoneManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: true,
          },
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:microphone-off',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Microphone',
        style: {},
        start_tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'microphone_unmute',
        },
        end_tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'microphone_mute',
        },
      });
    });

    it('with unsupported microphone', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(false);
      vi.mocked(microphoneManager.isMuted).mockReturnValue(true);
      vi.mocked(microphoneManager.isSupported).mockReturnValue(false);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: true,
          },
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:microphone-message-off',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Microphone',
        style: {},
      });
    });

    it('with muted toggle type microphone', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(false);
      vi.mocked(microphoneManager.isMuted).mockReturnValue(true);
      vi.mocked(microphoneManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: true,
          },
        }),
        config: createConfig({
          menu: { buttons: { microphone: { type: 'toggle' } } },
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:microphone-off',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Microphone',
        style: {},
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'microphone_unmute',
        },
      });
    });

    it('with unmuted toggle type microphone', () => {
      const microphoneManager = mock<MicrophoneManager>();
      vi.mocked(microphoneManager.isForbidden).mockReturnValue(false);
      vi.mocked(microphoneManager.isMuted).mockReturnValue(false);
      vi.mocked(microphoneManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, {
        microphoneManager: microphoneManager,
        currentMediaLoadedInfo: createMediaLoadedInfo({
          capabilities: {
            supports2WayAudio: true,
          },
        }),
        config: createConfig({
          menu: { buttons: { microphone: { type: 'toggle' } } },
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:microphone',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Microphone',
        style: {
          animation: 'pulse 3s infinite',
          color: 'var(--advanced-camera-card-menu-button-critical-color)',
        },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'microphone_mute',
        },
      });
    });
  });

  describe('should have fullscreen button', () => {
    afterEach(() => {
      vi.unstubAllGlobals();
    });

    it('when not in fullscreen mode', () => {
      // Need to write a readonly property.
      vi.stubGlobal('navigator', { userAgent: 'foo' });

      const fullscreenManager = mock<FullscreenManager>();
      vi.mocked(fullscreenManager.isInFullscreen).mockReturnValue(false);
      vi.mocked(fullscreenManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, { fullscreenManager });

      expect(buttons).toContainEqual({
        icon: 'mdi:fullscreen',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Fullscreen',
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'fullscreen',
        },
        style: {},
      });
    });

    it('when in fullscreen mode', () => {
      vi.stubGlobal('navigator', { userAgent: 'foo' });
      const fullscreenManager = mock<FullscreenManager>();
      vi.mocked(fullscreenManager.isInFullscreen).mockReturnValue(true);
      vi.mocked(fullscreenManager.isSupported).mockReturnValue(true);

      const buttons = calculateButtons(controller, { fullscreenManager });

      expect(buttons).toContainEqual({
        icon: 'mdi:fullscreen-exit',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Fullscreen',
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'fullscreen',
        },
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
      });
    });

    it('when not supported', () => {
      // Need to write a readonly property.
      vi.stubGlobal('navigator', { userAgent: 'foo' });
      const fullscreenManager = mock<FullscreenManager>();
      vi.mocked(fullscreenManager.isSupported).mockReturnValue(false);

      const buttons = calculateButtons(controller, { fullscreenManager });

      expect(buttons).not.toContainEqual(
        expect.objectContaining({ title: 'Fullscreen' }),
      );
    });
  });

  describe('should have expand button', () => {
    it('when not expanded', () => {
      const buttons = calculateButtons(controller, { inExpandedMode: false });

      expect(buttons).toContainEqual({
        icon: 'mdi:arrow-expand-all',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Expand',
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'expand' },
        style: {},
      });
    });

    it('when expanded', () => {
      const buttons = calculateButtons(controller, { inExpandedMode: true });

      expect(buttons).toContainEqual({
        icon: 'mdi:arrow-collapse-all',
        enabled: false,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Expand',
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'expand' },
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
      });
    });
  });

  describe('should have media players button', () => {
    it('with media players', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({
              camera_entity: 'camera.1',
            }),
          },
        ]),
      );

      const mediaPlayerController = mock<MediaPlayerManager>();
      mediaPlayerController.hasMediaPlayers.mockReturnValue(true);
      mediaPlayerController.getMediaPlayers.mockReturnValue(['media_player.tv']);

      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        mediaPlayerController: mediaPlayerController,
        hass: createHASS({
          'media_player.tv': createStateEntity({ entity_id: 'media_player.tv' }),
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:cast',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: 'Send to media player',
        items: [
          {
            enabled: true,
            selected: false,
            entity: 'media_player.tv',
            state_color: false,
            title: 'media_player.tv',
            disabled: false,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'media_player',
              media_player: 'media_player.tv',
              media_player_action: 'play',
            },
            hold_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'media_player',
              media_player: 'media_player.tv',
              media_player_action: 'stop',
            },
          },
        ],
      });
    });

    it('when entity not found', () => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({
              camera_entity: 'camera.1',
            }),
          },
        ]),
      );
      const mediaPlayerController = mock<MediaPlayerManager>();
      mediaPlayerController.hasMediaPlayers.mockReturnValue(true);
      mediaPlayerController.getMediaPlayers.mockReturnValue(['not_a_real_player']);

      const buttons = calculateButtons(controller, {
        cameraManager: cameraManager,
        mediaPlayerController: mediaPlayerController,
        hass: createHASS(),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:cast',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: 'Send to media player',
        items: [
          {
            enabled: true,
            selected: false,
            entity: 'not_a_real_player',
            state_color: false,
            title: 'not_a_real_player',
            disabled: true,
          },
        ],
      });
    });
  });

  it('should have pause button', () => {
    const mediaPlayerController = mock<MediaPlayerController>();
    const buttons = calculateButtons(controller, {
      currentMediaLoadedInfo: createMediaLoadedInfo({
        capabilities: {
          supportsPause: true,
        },
        mediaPlayerController,
      }),
    });

    expect(buttons).toContainEqual({
      icon: 'mdi:pause',
      enabled: false,
      priority: 50,
      type: 'custom:advanced-camera-card-menu-icon',
      title: 'Play / Pause',
      tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'pause' },
    });
  });

  it('should have play button', () => {
    const mediaPlayerController = mock<MediaPlayerController>();
    mediaPlayerController.isPaused.mockReturnValue(true);
    const buttons = calculateButtons(controller, {
      currentMediaLoadedInfo: createMediaLoadedInfo({
        capabilities: {
          supportsPause: true,
        },
        mediaPlayerController,
      }),
    });

    expect(buttons).toContainEqual({
      icon: 'mdi:play',
      enabled: false,
      priority: 50,
      type: 'custom:advanced-camera-card-menu-icon',
      title: 'Play / Pause',
      tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'play' },
    });
  });

  it('should have mute button', () => {
    const mediaPlayerController = mock<MediaPlayerController>();
    const buttons = calculateButtons(controller, {
      currentMediaLoadedInfo: createMediaLoadedInfo({
        capabilities: {
          hasAudio: true,
        },
        mediaPlayerController,
      }),
    });

    expect(buttons).toContainEqual({
      icon: 'mdi:volume-high',
      enabled: false,
      priority: 50,
      type: 'custom:advanced-camera-card-menu-icon',
      title: 'Mute / Unmute',
      tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'mute' },
    });
  });

  it('should have unmute button', () => {
    const mediaPlayerController = mock<MediaPlayerController>();
    mediaPlayerController.isMuted.mockReturnValue(true);
    const buttons = calculateButtons(controller, {
      currentMediaLoadedInfo: createMediaLoadedInfo({
        capabilities: {
          hasAudio: true,
        },
        mediaPlayerController,
      }),
    });

    expect(buttons).toContainEqual({
      icon: 'mdi:volume-off',
      enabled: false,
      priority: 50,
      type: 'custom:advanced-camera-card-menu-icon',
      title: 'Mute / Unmute',
      tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'unmute' },
    });
  });

  it('should have screenshot button', () => {
    const buttons = calculateButtons(controller, {
      currentMediaLoadedInfo: createMediaLoadedInfo({
        mediaPlayerController: mock<MediaPlayerController>(),
      }),
    });

    expect(buttons).toContainEqual({
      icon: 'mdi:monitor-screenshot',
      enabled: false,
      priority: 50,
      type: 'custom:advanced-camera-card-menu-icon',
      title: 'Screenshot',
      tap_action: {
        action: 'fire-dom-event',
        advanced_camera_card_action: 'screenshot',
      },
    });
  });

  describe('should have grid button when display mode is', () => {
    it.each([['single' as const], ['grid' as const]])(
      '%s',
      (displayMode: ViewDisplayMode) => {
        const view = createView({
          camera: 'camera-1',
          view: 'live',
          displayMode: displayMode,
        });
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getStore).mockReturnValue(
          createStore([
            { cameraID: 'camera-1', capabilities: createCapabilities({ live: true }) },
            { cameraID: 'camera-2', capabilities: createCapabilities({ live: true }) },
          ]),
        );

        expect(
          calculateButtons(controller, { cameraManager: cameraManager, view: view }),
        ).toContainEqual({
          icon: displayMode === 'single' ? 'mdi:grid' : 'mdi:grid-off',
          enabled: true,
          priority: 50,
          type: 'custom:advanced-camera-card-menu-icon',
          title:
            displayMode === 'grid'
              ? 'Show single media viewer'
              : 'Show media viewer for each camera in a grid',
          style:
            displayMode === 'grid'
              ? { color: 'var(--advanced-camera-card-menu-button-active-color)' }
              : {},
          tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'display_mode_select',
            display_mode: displayMode === 'single' ? 'grid' : 'single',
          },
        });
      },
    );
  });

  describe('should have show ptz button', () => {
    it('should not show when not in live view', () => {
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);

      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(store),
        view: createView({ view: 'clips' }),
      });

      expect(buttons).not.toContainEqual(
        expect.objectContaining({
          title: 'Show PTZ controls',
        }),
      );
    });

    it('should show when in live view', () => {
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);

      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(store),
        view: createView({ view: 'live' }),
      });

      expect(buttons).toContainEqual(
        expect.objectContaining({
          title: 'Show PTZ controls',
        }),
      );
    });

    it('should show when the context has PTZ enabled', () => {
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);

      const view = createView({
        camera: 'camera-1',
        context: { ptzControls: { enabled: true } },
      });
      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(store),
        view: view,
      });

      expect(buttons).toContainEqual({
        enabled: false,
        icon: 'mdi:pan',
        priority: 50,
        style: {
          color: 'var(--advanced-camera-card-menu-button-active-color)',
        },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_controls',
          enabled: false,
        },
        title: 'Show PTZ controls',
        type: 'custom:advanced-camera-card-menu-icon',
      });
    });

    it('should show when the context has PTZ disabled', () => {
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);

      const view = createView({
        camera: 'camera-1',
        context: { ptzControls: { enabled: false } },
      });
      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(store),
        view: view,
      });

      expect(buttons).toContainEqual({
        enabled: false,
        icon: 'mdi:pan',
        priority: 50,
        style: {},
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_controls',
          enabled: true,
        },
        title: 'Show PTZ controls',
        type: 'custom:advanced-camera-card-menu-icon',
      });
    });

    it('should detect current status without context in auto mode', () => {
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);

      const view = createView({
        camera: 'camera-1',
      });
      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(store),
        config: createConfig({ live: { controls: { ptz: { mode: 'auto' } } } }),
        view: view,
      });

      expect(buttons).toContainEqual({
        enabled: false,
        icon: 'mdi:pan',
        priority: 50,
        style: {
          color: 'var(--advanced-camera-card-menu-button-active-color)',
        },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_controls',
          enabled: false,
        },
        title: 'Show PTZ controls',
        type: 'custom:advanced-camera-card-menu-icon',
      });
    });

    it('should show when a substream is PTZ enabled', () => {
      const store = createStore([
        {
          cameraID: 'camera-1',
          config: createCameraConfig({ dependencies: { cameras: ['camera-2'] } }),
        },
        {
          cameraID: 'camera-2',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);
      const view = createView({
        camera: 'camera-1',
        context: {
          live: {
            overrides: new Map([['camera-1', 'camera-2']]),
          },
        },
      });
      const buttons = calculateButtons(controller, {
        cameraManager: createCameraManager(store),
        view: view,
      });

      expect(buttons).toContainEqual({
        enabled: false,
        icon: 'mdi:pan',
        priority: 50,
        style: {
          color: 'var(--advanced-camera-card-menu-button-active-color)',
        },
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_controls',
          enabled: false,
        },
        title: 'Show PTZ controls',
        type: 'custom:advanced-camera-card-menu-icon',
      });
    });
  });

  describe('should have ptz home button', () => {
    it.each([
      ['live' as const, true, false],
      ['live' as const, undefined, false],
      ['live' as const, false, true],
      ['media' as const, true, false],
      ['media' as const, undefined, false],
      ['media' as const, false, true],
    ])(
      '%s view with isDefault %s',
      (
        viewName: AdvancedCameraCardView,
        isDefault: boolean | undefined,
        expectedResult: boolean,
      ) => {
        const cameraManager = createCameraManager();
        vi.mocked(cameraManager.getStore).mockReturnValue(
          createStore([{ cameraID: 'camera-1' }]),
        );

        const targetID = viewName === 'live' ? 'camera-1' : 'media-1';
        const view = createView({
          view: viewName,
          camera: 'camera-1',
          queryResults: new QueryResults({
            results: [new TestViewMedia({ id: 'media-1' })],
            selectedIndex: 0,
          }),
          ...(isDefault !== undefined && {
            context: {
              zoom: {
                [targetID]: {
                  observed: {
                    isDefault: isDefault,
                    unzoomed: false,
                    zoom: 1,
                    pan: {
                      x: 50,
                      y: 50,
                    },
                  },
                },
              },
            },
          }),
        });
        const buttons = calculateButtons(controller, {
          cameraManager: cameraManager,
          view: view,
        });

        if (expectedResult) {
          expect(buttons).toContainEqual({
            enabled: false,
            icon: 'mdi:home',
            priority: 50,
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'ptz_multi',
              target_id: targetID,
            },
            title: 'PTZ Home',
            type: 'custom:advanced-camera-card-menu-icon',
          });
        } else {
          expect(buttons).not.toContainEqual(
            expect.objectContaining({ title: 'PTZ Home' }),
          );
        }
      },
    );
  });

  describe('should have folders button', () => {
    it('should have no folders button without folders', () => {
      const foldersManager = mock<FoldersManager>();
      foldersManager.getFolders.mockReturnValue(new Map().entries());

      const buttons = calculateButtons(controller, {
        foldersManager,
      });

      expect(buttons).not.toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            icon: 'mdi:folder',
          }),
        ]),
      );
    });

    it('should have a folders button for a single folder outside the folder view', () => {
      const foldersManager = mock<FoldersManager>();
      foldersManager.getFolders.mockReturnValue(
        new Map([['folder-0', createFolder({ id: 'folder-0' })]]).entries(),
      );

      const buttons = calculateButtons(controller, {
        foldersManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:folder',
        enabled: true,
        priority: 50,
        style: {},
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Folders',
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'folders' },
        hold_action: { action: 'fire-dom-event', advanced_camera_card_action: 'folder' },
      });
    });

    it('should have a folders button for a single folder inside the folder view', () => {
      const folder = createFolder({ id: 'folder-0' });
      const foldersManager = mock<FoldersManager>();
      foldersManager.getFolders.mockReturnValue(
        new Map([['folder-0', folder]]).entries(),
      );

      const buttons = calculateButtons(controller, {
        foldersManager,
        view: createView({
          view: 'folder',
          query: new FolderViewQuery({ folder, path: [{ ha: { id: 'one' } }] }),
        }),
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:folder',
        enabled: true,
        priority: 50,
        style: {
          color: 'var(--advanced-camera-card-menu-button-active-color)',
        },
        type: 'custom:advanced-camera-card-menu-icon',
        title: 'Folders',
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'folders' },
        hold_action: { action: 'fire-dom-event', advanced_camera_card_action: 'folder' },
      });
    });

    it('should have a folders submenu for multiple folder with a selected folder', () => {
      const foldersManager = mock<FoldersManager>();
      const selectedFolder = createFolder({ id: 'folder-selected' });
      const folders = new Map([
        ['folder-0', createFolder({ id: 'folder-0' })],
        ['folder-selected', selectedFolder],
      ]);
      foldersManager.getFolders.mockReturnValue(folders.entries());

      const view = createView({
        view: 'folder',
        query: new FolderViewQuery({
          folder: selectedFolder,
          path: [{ ha: { id: 'id' } }],
        }),
      });

      const buttons = calculateButtons(controller, {
        foldersManager,
        view,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:folder-multiple',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: 'Folders',
        style: {
          color: 'var(--advanced-camera-card-menu-button-active-color)',
        },
        items: [
          {
            enabled: true,
            hold_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folder',
              folder: 'folder-0',
            },
            icon: 'mdi:folder',
            selected: false,
            style: {},
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folders',
              folder: 'folder-0',
            },
            title: 'folder-0',
          },
          {
            enabled: true,
            hold_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folder',
              folder: 'folder-selected',
            },
            icon: 'mdi:folder',
            selected: true,
            style: {
              color: 'var(--advanced-camera-card-menu-button-active-color)',
            },
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folders',
              folder: 'folder-selected',
            },
            title: 'folder-selected',
          },
        ],
      });
    });

    it('should have a folders submenu for multiple folder without a selected folder', () => {
      const foldersManager = mock<FoldersManager>();
      const folders = new Map([
        ['folder-0', createFolder({ id: 'folder-0' })],
        ['folder-1', createFolder({ id: 'folder-1' })],
      ]);
      foldersManager.getFolders.mockReturnValue(folders.entries());

      const buttons = calculateButtons(controller, {
        foldersManager,
      });

      expect(buttons).toContainEqual({
        icon: 'mdi:folder-multiple',
        enabled: true,
        priority: 50,
        type: 'custom:advanced-camera-card-menu-submenu',
        title: 'Folders',
        style: {},
        items: [
          {
            enabled: true,
            icon: 'mdi:folder',
            hold_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folder',
              folder: 'folder-0',
            },
            selected: false,
            style: {},
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folders',
              folder: 'folder-0',
            },
            title: 'folder-0',
          },
          {
            enabled: true,
            hold_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folder',
              folder: 'folder-1',
            },
            icon: 'mdi:folder',
            selected: false,
            style: {},
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'folders',
              folder: 'folder-1',
            },
            title: 'folder-1',
          },
        ],
      });
    });
  });

  describe('should handle dynamic buttons', () => {
    it('successfully', () => {
      const button: MenuItem = {
        ...dynamicButton,
        style: {},
      };
      controller.addDynamicMenuButton(button);

      expect(
        calculateButtons(controller).filter((menuButton) => isEqual(button, menuButton))
          .length,
      ).toBe(1);

      // Adding it again will have no effect.
      controller.addDynamicMenuButton(button);
      expect(
        calculateButtons(controller).filter((menuButton) => isEqual(button, menuButton))
          .length,
      ).toBe(1);

      controller.removeDynamicMenuButton(button);
      expect(calculateButtons(controller)).not.toContainEqual(button);
    });

    it('with stock HA action', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: { action: 'navigate', navigation_path: 'foo' },
      };
      controller.addDynamicMenuButton(button);

      expect(calculateButtons(controller)).toContainEqual({
        ...button,
        style: {},
      });
    });

    it('with non-advanced-camera-card fire-dom-event action', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: { action: 'fire-dom-event' },
      };
      controller.addDynamicMenuButton(button);
      controller.addDynamicMenuButton(dynamicButton);

      expect(calculateButtons(controller)).toContainEqual({
        ...button,
        style: {},
      });
    });

    it('with advanced camera card view action', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'clips' },
      };
      const view = createView({ view: 'clips' });
      controller.addDynamicMenuButton(button);

      expect(calculateButtons(controller, { view: view })).toContainEqual({
        ...button,
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
      });
    });

    it('with advanced camera card default action', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: { action: 'fire-dom-event', advanced_camera_card_action: 'default' },
      };
      controller.addDynamicMenuButton(button);

      expect(calculateButtons(controller)).toContainEqual({
        ...button,
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
      });
    });

    it('with fullscreen action', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'fullscreen',
        },
      };
      controller.addDynamicMenuButton(button);
      const fullscreenManager = mock<FullscreenManager>();
      vi.mocked(fullscreenManager.isInFullscreen).mockReturnValue(true);
      vi.mocked(fullscreenManager.isSupported).mockReturnValue(true);

      expect(calculateButtons(controller, { fullscreenManager })).toContainEqual({
        ...button,
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
      });
    });

    it('with camera_select action', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'camera_select',
          camera: 'foo',
        },
      };
      const view = createView({ camera: 'foo' });
      controller.addDynamicMenuButton(button);

      expect(calculateButtons(controller, { view: view })).toContainEqual({
        ...button,
        style: { color: 'var(--advanced-camera-card-menu-button-active-color)' },
      });
    });

    it('with array of actions', () => {
      const button: MenuItem = {
        ...dynamicButton,
        tap_action: [
          { action: 'fire-dom-event' },
          { action: 'fire-dom-event', advanced_camera_card_action: 'clips' },
        ],
      };
      const view = createView({ camera: 'clips' });
      controller.addDynamicMenuButton(button);

      expect(calculateButtons(controller, { view: view })).toContainEqual({
        ...button,
        style: {},
      });
    });
  });
});



================================================
FILE: tests/components-lib/menu-controller.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { MenuController } from '../../src/components-lib/menu-controller.js';
import { SubmenuItem } from '../../src/components/submenu/types.js';
import { MenuConfig, menuConfigSchema } from '../../src/config/schema/menu.js';
import {
  createInteractionActionEvent,
  createLitElement,
  createSubmenuInteractionActionEvent,
} from '../test-utils';

const createMenuConfig = (config: unknown): MenuConfig => {
  return menuConfigSchema.parse(config);
};

// @vitest-environment jsdom
describe('MenuController', () => {
  const action = {
    action: 'fire-dom-event' as const,
  };
  const menuToggleAction = {
    action: 'fire-dom-event' as const,
    advanced_camera_card_action: 'menu_toggle' as const,
  };
  const tapActionConfig = {
    camera_entity: 'foo',
    tap_action: action,
  };
  const tapActionConfigMulti = {
    camera_entity: 'foo',
    tap_action: [action, action, action],
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should set and get menu config', () => {
    const host = createLitElement();
    const controller = new MenuController(host);

    const config = createMenuConfig({
      button_size: 21,
      style: 'hover',
      position: 'left',
      alignment: 'top',
    });
    controller.setMenuConfig(config);
    expect(controller.getMenuConfig()).toBe(config);

    expect(host.style.getPropertyValue('--advanced-camera-card-menu-button-size')).toBe(
      '21px',
    );
    expect(host.getAttribute('data-style')).toBe('hover');
    expect(host.getAttribute('data-position')).toBe('left');
    expect(host.getAttribute('data-alignment')).toBe('top');
  });

  it('should expand', () => {
    const host = createLitElement();
    const controller = new MenuController(host);

    expect(controller.isExpanded()).toBeFalsy();
    expect(host.getAttribute('expanded')).toBeNull();

    controller.setExpanded(true);
    expect(controller.isExpanded()).toBeTruthy();
    expect(host.getAttribute('expanded')).toBe('');

    controller.setExpanded(false);
    expect(controller.isExpanded()).toBeFalsy();
    expect(host.getAttribute('expanded')).toBeNull();
  });

  describe('should set and sort buttons', () => {
    it('without a hidden menu', () => {
      const controller = new MenuController(createLitElement());
      controller.setMenuConfig(
        createMenuConfig({
          style: 'overlay',
        }),
      );

      controller.setButtons([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          priority: 20,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:goat',
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:chicken',
          priority: 40,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:horse',
          priority: 40,
          alignment: 'matching',

          // Will have no effect without a hidden menu.
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          priority: 30,
          alignment: 'matching',
        },
      ]);

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:chicken',
          priority: 40,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:horse',
          priority: 40,
          alignment: 'matching',
          permanent: true,
        },
        {
          alignment: 'matching',
          icon: 'mdi:sheep',
          priority: 30,
          type: 'custom:advanced-camera-card-menu-icon',
        },
        {
          alignment: 'matching',
          icon: 'mdi:cow',
          priority: 20,
          type: 'custom:advanced-camera-card-menu-icon',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:goat',
          alignment: 'matching',
        },
      ]);
    });

    it('with an expanded hidden menu', () => {
      const controller = new MenuController(createLitElement());
      controller.setMenuConfig(
        createMenuConfig({
          style: 'hidden',
        }),
      );
      controller.setExpanded(true);
      controller.setButtons([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          priority: 99,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          alignment: 'matching',
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          priority: 100,
          alignment: 'matching',
        },
      ]);

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          alignment: 'matching',
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          priority: 100,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          priority: 99,
          alignment: 'matching',
        },
      ]);
    });

    it('with a non-expanded hidden menu', () => {
      const controller = new MenuController(createLitElement());
      controller.setMenuConfig(
        createMenuConfig({
          style: 'hidden',
        }),
      );
      controller.setExpanded(false);
      controller.setButtons([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          priority: 100,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          alignment: 'matching',
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          priority: 100,
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          alignment: 'matching',
          priority: 100,
          permanent: true,
        },
      ]);

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          alignment: 'matching',
          priority: 100,
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          alignment: 'matching',
          permanent: true,
        },
      ]);
    });
  });

  describe('should get buttons', () => {
    it('with matching alignment', () => {
      const controller = new MenuController(createLitElement());
      controller.setButtons([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
          alignment: 'opposing',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
        },
      ]);

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          alignment: 'matching',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
        },
      ]);
    });

    it('with disabled buttons', () => {
      const controller = new MenuController(createLitElement());
      controller.setButtons([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
          enabled: false,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:goat',
          enabled: true,
        },
      ]);

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:cow',
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:goat',
          enabled: true,
        },
      ]);
    });

    it('with hidden non-expanded menu', () => {
      const controller = new MenuController(createLitElement());
      controller.setMenuConfig(
        createMenuConfig({
          style: 'hidden',
        }),
      );

      controller.setButtons([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
        },
      ]);

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          permanent: true,
        },
      ]);

      controller.toggleExpanded();

      expect(controller.getButtons('matching')).toEqual([
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'iris',
          permanent: true,
        },
        {
          type: 'custom:advanced-camera-card-menu-icon',
          icon: 'mdi:sheep',
        },
      ]);
    });
  });

  describe('should handle actions', () => {
    it('should bail without config', () => {
      const host = createLitElement();
      const handler = vi.fn();
      host.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new MenuController(host);
      controller.handleAction(createInteractionActionEvent('tap'));
      expect(handler).not.toBeCalled();
    });

    it('should execute simple action in non-hidden menu', () => {
      const host = createLitElement();
      const handler = vi.fn();
      host.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new MenuController(host);

      controller.handleAction(createInteractionActionEvent('tap'), tapActionConfig);
      expect(handler).toBeCalledWith(
        expect.objectContaining({
          detail: { actions: [action], config: tapActionConfig },
        }),
      );
      expect(controller.isExpanded()).toBeFalsy();
    });

    it('should execute simple action in with config in event', () => {
      const host = createLitElement();
      const handler = vi.fn();
      host.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new MenuController(host);

      controller.handleAction(
        createSubmenuInteractionActionEvent('tap', tapActionConfig as SubmenuItem),
      );
      expect(handler).toBeCalledWith(
        expect.objectContaining({
          detail: { actions: [action], config: tapActionConfig },
        }),
      );
    });

    it('should execute simple array of actions in non-hidden menu', () => {
      const host = createLitElement();
      const handler = vi.fn();
      host.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new MenuController(host);

      controller.handleAction(createInteractionActionEvent('tap'), tapActionConfigMulti);

      expect(handler).toBeCalledWith(
        expect.objectContaining({
          detail: { actions: [action, action, action], config: tapActionConfigMulti },
        }),
      );
    });

    describe('should close menu', () => {
      it('tap', () => {
        const host = createLitElement();
        const controller = new MenuController(host);
        controller.setMenuConfig(
          createMenuConfig({
            style: 'hidden',
          }),
        );

        controller.setExpanded(true);
        expect(controller.isExpanded()).toBeTruthy();

        controller.handleAction(createInteractionActionEvent('tap'), tapActionConfig);
        expect(controller.isExpanded()).toBeFalsy();
      });

      it('end_tap', () => {
        const host = createLitElement();
        const controller = new MenuController(host);
        controller.setMenuConfig(
          createMenuConfig({
            style: 'hidden',
          }),
        );

        controller.setExpanded(true);
        expect(controller.isExpanded()).toBeTruthy();

        controller.handleAction(createInteractionActionEvent('end_tap'), {
          end_tap_action: action,
        });
        expect(controller.isExpanded()).toBeFalsy();
      });
    });

    describe('should not close menu', () => {
      it('start_tap with later action', () => {
        const host = createLitElement();
        const controller = new MenuController(host);
        controller.setMenuConfig(
          createMenuConfig({
            style: 'hidden',
          }),
        );

        controller.setExpanded(true);
        expect(controller.isExpanded()).toBeTruthy();

        controller.handleAction(createInteractionActionEvent('start_tap'), {
          start_tap_action: action,
          end_tap_action: action,
        });
        expect(controller.isExpanded()).toBeTruthy();
      });

      it('with a menu toggle action', () => {
        const host = createLitElement();
        const controller = new MenuController(host);
        controller.setMenuConfig(
          createMenuConfig({
            style: 'hidden',
          }),
        );

        controller.setExpanded(false);
        expect(controller.isExpanded()).toBeFalsy();

        controller.handleAction(createInteractionActionEvent('tap'), {
          camera_entity: 'foo',
          tap_action: menuToggleAction,
        });
        expect(controller.isExpanded()).toBeTruthy();
      });

      it('when no action is actually taken', () => {
        const host = createLitElement();
        const controller = new MenuController(host);
        controller.setMenuConfig(
          createMenuConfig({
            style: 'hidden',
          }),
        );

        controller.setExpanded(true);
        expect(controller.isExpanded()).toBeTruthy();

        controller.handleAction(
          createInteractionActionEvent('end_tap'),
          tapActionConfig,
        );
        expect(controller.isExpanded()).toBeTruthy();
      });
    });
  });
});



================================================
FILE: tests/components-lib/status-bar-controller.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { StatusBarController } from '../../src/components-lib/status-bar-controller';
import {
  StatusBarConfig,
  statusBarConfigSchema,
} from '../../src/config/schema/status-bar';
import { setOrRemoveAttribute } from '../../src/utils/basic';
import { createInteractionActionEvent, createLitElement } from '../test-utils';

const createConfig = (config?: unknown): StatusBarConfig => {
  return statusBarConfigSchema.parse(config);
};

// @vitest-environment jsdom
describe('StatusBarController', () => {
  describe('should set config', () => {
    it('should set config', () => {
      const host = createLitElement();
      const controller = new StatusBarController(host);
      const config = createConfig({
        position: 'top',
        style: 'hover',
        height: 50,
      });
      controller.setConfig(config);

      expect(controller.getConfig()).toEqual(config);
      expect(
        host.style.getPropertyValue('--advanced-camera-card-status-bar-height'),
      ).toBe('50px');
      expect(host.getAttribute('data-style')).toBe('hover');
      expect(host.getAttribute('data-position')).toBe('top');
      expect(host.requestUpdate).toHaveBeenCalled();
    });

    it('should not hide when not in popup style', () => {
      const host = createLitElement();
      setOrRemoveAttribute(host, true, 'hide');

      const controller = new StatusBarController(host);

      controller.setConfig(
        createConfig({
          position: 'top',
          style: 'hover',
          height: 50,
        }),
      );

      expect(host.getAttribute('hide')).toBe(null);
    });

    it('should not show when in popup style', () => {
      const host = createLitElement();
      setOrRemoveAttribute(host, true, 'hide');

      const controller = new StatusBarController(host);

      controller.setConfig(
        createConfig({
          position: 'top',
          style: 'popup',
          height: 50,
        }),
      );

      expect(host.getAttribute('hide')).not.toBe(null);
    });
  });

  describe('should set items', () => {
    beforeAll(() => {
      vi.useFakeTimers();
    });

    afterAll(() => {
      vi.useRealTimers();
    });

    it('set/get basic items', () => {
      const host = createLitElement();
      const controller = new StatusBarController(host);
      const items = [
        {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Test',
        },
      ];

      controller.setItems(items);
      expect(controller.getRenderItems()).toEqual(items);
    });

    it('should order items', () => {
      const host = createLitElement();
      const controller = new StatusBarController(host);
      const item1 = {
        type: 'custom:advanced-camera-card-status-bar-string' as const,
        string: 'Item 1',
        priority: 40,
      };
      const item2 = {
        type: 'custom:advanced-camera-card-status-bar-string' as const,
        string: 'Item 2',
        priority: 10,
      };
      const item3 = {
        type: 'custom:advanced-camera-card-status-bar-string' as const,
        string: 'Item 3',
        priority: 60,
      };
      const item4 = {
        type: 'custom:advanced-camera-card-status-bar-string' as const,
        string: 'Item 4',
        priority: undefined,
      };

      controller.setItems([item1, item2, item3, item4]);
      expect(controller.getRenderItems()).toEqual([item3, item4, item1, item2]);
    });

    it('should treat exclusive items exclusively', () => {
      const host = createLitElement();
      const controller = new StatusBarController(host);
      const item1 = {
        type: 'custom:advanced-camera-card-status-bar-string' as const,
        string: 'Item 1',
        priority: 100,
      };
      const exclusiveItem = {
        type: 'custom:advanced-camera-card-status-bar-string' as const,
        string: 'Item 2',
        priority: 1,
        exclusive: true,
      };

      controller.setItems([item1, exclusiveItem]);
      expect(controller.getRenderItems()).toEqual([exclusiveItem]);
    });

    describe('should recognize sufficient items', () => {
      it('with sufficient item', () => {
        const host = createLitElement();
        const controller = new StatusBarController(host);
        const insufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 1',
          sufficient: false,
        };
        const sufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 2',
          sufficient: true,
        };

        controller.setItems([insufficientItem, sufficientItem]);
        expect(controller.getRenderItems()).toEqual([insufficientItem, sufficientItem]);
        expect(controller.shouldRender()).toBeTruthy();
      });

      it('without sufficient item', () => {
        const host = createLitElement();
        const controller = new StatusBarController(host);
        const insufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 1',
          sufficient: false,
        };
        const sufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 2',
          sufficient: false,
        };

        controller.setItems([insufficientItem, sufficientItem]);
        expect(controller.getRenderItems()).toEqual([insufficientItem, sufficientItem]);
        expect(controller.shouldRender()).toBeFalsy();
      });
    });

    describe('should deal with popup styles correctly', () => {
      it('should show from empty to sufficient', () => {
        const host = createLitElement();
        setOrRemoveAttribute(host, true, 'hide');

        const controller = new StatusBarController(host);
        controller.setConfig(
          createConfig({
            style: 'popup',
          }),
        );

        const sufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 1',
          priority: 100,
          sufficient: true,
        };

        controller.setItems([sufficientItem]);
        expect(host.getAttribute('hide')).toBe(null);
      });

      it('should not show from empty to insufficient', () => {
        const host = createLitElement();
        setOrRemoveAttribute(host, true, 'hide');

        const controller = new StatusBarController(host);
        controller.setConfig(
          createConfig({
            style: 'popup',
          }),
        );

        const insufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 1',
          priority: 100,
          sufficient: false,
        };

        controller.setItems([insufficientItem]);
        expect(host.getAttribute('hide')).not.toBeNull();
      });

      it('should show from sufficient to different sufficient', () => {
        const host = createLitElement();

        const controller = new StatusBarController(host);
        controller.setConfig(
          createConfig({
            style: 'popup',
          }),
        );

        const sufficientString = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'String',
          priority: 100,
          sufficient: true,
        };
        const sufficientIcon = {
          type: 'custom:advanced-camera-card-status-bar-icon' as const,
          icon: 'Icon',
          priority: 100,
          sufficient: true,
        };
        const sufficientImage = {
          type: 'custom:advanced-camera-card-status-bar-image' as const,
          image: 'Image',
          priority: 100,
          sufficient: true,
        };

        controller.setItems([sufficientString]);

        // Emulate the popup being hidden.
        setOrRemoveAttribute(host, true, 'hide');
        controller.setItems([sufficientIcon]);

        expect(host.getAttribute('hide')).toBe(null);

        // Emulate the popup being hidden.
        setOrRemoveAttribute(host, true, 'hide');
        controller.setItems([sufficientImage]);

        expect(host.getAttribute('hide')).toBe(null);
      });

      it('should hide popup after expiry', () => {
        const host = createLitElement();

        const controller = new StatusBarController(host);
        controller.setConfig(
          createConfig({
            style: 'popup',
          }),
        );

        const sufficientItem = {
          type: 'custom:advanced-camera-card-status-bar-string' as const,
          string: 'Item 1',
          priority: 100,
          sufficient: true,
        };

        controller.setItems([sufficientItem]);
        expect(host.getAttribute('hide')).toBe(null);

        vi.advanceTimersByTime(1000);
        expect(host.getAttribute('hide')).toBe(null);

        vi.advanceTimersByTime(2000);
        expect(host.getAttribute('hide')).not.toBe(null);
      });
    });
  });

  describe('should handle actions', () => {
    it('should bail without action', () => {
      const host = createLitElement();
      const handler = vi.fn();
      host.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new StatusBarController(host);
      controller.actionHandler(createInteractionActionEvent('tap'));
      expect(handler).not.toBeCalled();
    });

    it('should request action execution', () => {
      const host = createLitElement();
      const handler = vi.fn();
      host.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new StatusBarController(host);

      const action = {
        action: 'fire-dom-event' as const,
      };
      const tapActionConfig = {
        tap_action: action,
      };

      controller.actionHandler(createInteractionActionEvent('tap'), tapActionConfig);

      expect(handler).toBeCalledWith(
        expect.objectContaining({
          detail: { actions: [action], config: tapActionConfig },
        }),
      );
    });
  });
});



================================================
FILE: tests/components-lib/folder/up-folder.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { ViewManagerEpoch } from '../../../src/card-controller/view/types';
import {
  getUpFolderMediaItem,
  upFolderClickHandler,
} from '../../../src/components-lib/folder/up-folder';
import { ViewFolder } from '../../../src/view/item';
import { EventMediaQuery, FolderViewQuery } from '../../../src/view/query';
import {
  createCardAPI,
  createFolder,
  createView,
  TestViewMedia,
} from '../../test-utils';

describe('upFolderClickHandler', () => {
  const item = new TestViewMedia();

  it('should ignore non-folder query', () => {
    const api = createCardAPI();
    const view = createView({
      query: new EventMediaQuery(),
    });
    vi.mocked(api.getViewManager().getView).mockReturnValue(view);

    const epoch: ViewManagerEpoch = {
      manager: api.getViewManager(),
    };

    upFolderClickHandler(item, new Event('click'), epoch);

    expect(api.getViewManager().setViewByParametersWithExistingQuery).not.toBeCalled();
  });

  it('should ignore folder query without raw query', () => {
    const api = createCardAPI();
    const view = createView({
      query: new FolderViewQuery(),
    });
    vi.mocked(api.getViewManager().getView).mockReturnValue(view);

    const epoch: ViewManagerEpoch = {
      manager: api.getViewManager(),
    };

    upFolderClickHandler(item, new Event('click'), epoch);

    expect(api.getViewManager().setViewByParametersWithExistingQuery).not.toBeCalled();
  });

  it('should ignore folder query wihout parent to go up to', () => {
    const api = createCardAPI();
    const view = createView({
      query: new FolderViewQuery({ folder: createFolder(), path: ['path'] }),
    });
    vi.mocked(api.getViewManager().getView).mockReturnValue(view);

    const epoch: ViewManagerEpoch = {
      manager: api.getViewManager(),
    };

    upFolderClickHandler(item, new Event('click'), epoch);

    expect(api.getViewManager().setViewByParametersWithExistingQuery).not.toBeCalled();
  });

  it('should go up in the folder hierarchy', () => {
    const api = createCardAPI();
    const folder = createFolder();
    const view = createView({
      query: new FolderViewQuery({
        folder,
        path: ['one', 'two', 'three'],
      }),
    });
    vi.mocked(api.getViewManager().getView).mockReturnValue(view);

    const epoch: ViewManagerEpoch = {
      manager: api.getViewManager(),
    };

    upFolderClickHandler(item, new Event('click'), epoch);

    expect(api.getViewManager().setViewByParametersWithExistingQuery).toBeCalledWith({
      params: {
        query: expect.any(FolderViewQuery),
      },
    });

    const query = vi.mocked(api.getViewManager().setViewByParametersWithExistingQuery)
      .mock.calls[0][0]?.params?.query;
    expect(query?.getQuery()).toEqual({
      folder,
      path: ['one', 'two'],
    });
  });
});

describe('getUpFolderMediaItem', () => {
  it('should ignore non-folder query', () => {
    const view = createView({
      query: new EventMediaQuery(),
    });
    expect(getUpFolderMediaItem(view)).toBeNull();
  });

  it('should ignore folder query without raw query', () => {
    const view = createView({
      query: new FolderViewQuery(),
    });
    expect(getUpFolderMediaItem(view)).toBeNull();
  });

  it('should ignore folder query without parents', () => {
    const view = createView({
      query: new FolderViewQuery({ folder: createFolder(), path: ['one'] }),
    });
    expect(getUpFolderMediaItem(view)).toBeNull();
  });

  it('should get up folder media', () => {
    const view = createView({
      query: new FolderViewQuery({
        folder: createFolder(),
        path: ['one', 'two', 'three'],
      }),
    });

    const folderMedia = getUpFolderMediaItem(view);

    expect(folderMedia).toBeInstanceOf(ViewFolder);
    expect(folderMedia?.getIcon()).toBe('mdi:arrow-up-left');
  });
});



================================================
FILE: tests/components-lib/gallery/folder-gallery-controller.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { ViewManagerInterface } from '../../../src/card-controller/view/types';
import {
  FOLDER_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN,
  FolderGalleryController,
} from '../../../src/components-lib/gallery/folder-gallery-controller';
import { THUMBNAIL_WIDTH_DEFAULT } from '../../../src/config/schema/common/controls/thumbnails';
import { ViewFolder } from '../../../src/view/item';
import { FolderViewQuery } from '../../../src/view/query';
import { QueryResults } from '../../../src/view/query-results';
import { createFolder, createView, TestViewMedia } from '../../test-utils';

// @vitest-environment jsdom
describe('FolderGalleryController', () => {
  describe('should set thumbnail size', () => {
    it('should set thumbnail size explicitly', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      controller.setThumbnailSize(100);

      expect(host.style.getPropertyValue('--advanced-camera-card-thumbnail-size')).toBe(
        '100px',
      );
    });

    it('should set thumbnail size implicitly', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      controller.setThumbnailSize();

      expect(host.style.getPropertyValue('--advanced-camera-card-thumbnail-size')).toBe(
        `${THUMBNAIL_WIDTH_DEFAULT}px`,
      );
    });
  });

  describe('should get column width', () => {
    it('should get default column width', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      expect(controller.getColumnWidth()).toBe(THUMBNAIL_WIDTH_DEFAULT);
    });

    it('should get column width with defailts', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      expect(
        controller.getColumnWidth({
          size: 100,
          show_details: true,
          show_favorite_control: true,
          show_timeline_control: true,
          show_download_control: true,
        }),
      ).toBe(FOLDER_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN);
    });

    it('should get column width with explicit size', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      expect(
        controller.getColumnWidth({
          size: 142,
          show_details: false,
          show_favorite_control: true,
          show_timeline_control: true,
          show_download_control: true,
        }),
      ).toBe(142);
    });
  });

  describe('should get column count round method', () => {
    it('should get default column count round method', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      expect(controller.getColumnCountRoundMethod()).toBe('ceil');
    });

    it('should get column count round method when details being shown', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      expect(
        controller.getColumnCountRoundMethod({
          size: 100,
          show_details: true,
          show_favorite_control: true,
          show_timeline_control: true,
          show_download_control: true,
        }),
      ).toBe('floor');
    });
  });

  describe('should handle item clicks', () => {
    it('should ignore calls without view', () => {
      const host = document.createElement('div');
      const controller = new FolderGalleryController(host);

      const viewManager = mock<ViewManagerInterface>();

      const item = new TestViewMedia();
      controller.itemClickHandler(viewManager, item, new Event('click'));

      expect(viewManager.setViewByParameters).not.toHaveBeenCalled();
      expect(viewManager.setViewByParametersWithExistingQuery).not.toHaveBeenCalled();
    });

    it('should handle media item click', () => {
      const host = document.createElement('div');
      const item_1 = new TestViewMedia();
      const item_2 = new TestViewMedia();

      const controller = new FolderGalleryController(host);
      const event = new Event('click');

      const view = createView({
        queryResults: new QueryResults({ results: [item_1, item_2], selectedIndex: 0 }),
      });

      const viewManager = mock<ViewManagerInterface>();
      viewManager.getView.mockReturnValue(view);

      controller.itemClickHandler(viewManager, item_2, event);

      expect(viewManager.setViewByParameters).toHaveBeenCalledWith({
        params: {
          view: 'media',
          queryResults: expect.any(QueryResults),
        },
      });

      const newQueryResults =
        viewManager.setViewByParameters.mock.calls[0][0]?.params?.queryResults;
      expect(newQueryResults).toBeInstanceOf(QueryResults);
      expect(newQueryResults?.getSelectedResult()).toBe(item_2);
    });

    describe('should handle folder click', () => {
      it('should handle normal folder click', () => {
        const folder = createFolder();
        const folderItem = new ViewFolder(folder, {
          id: 'parent',
        });

        const controller = new FolderGalleryController(document.createElement('div'));
        const event = new Event('click');

        const view = createView({
          queryResults: new QueryResults({
            results: [new TestViewMedia(), folderItem],
            selectedIndex: 0,
          }),
          query: new FolderViewQuery({
            folder,
            path: [{ ha: { id: 'grandparent' } }],
          }),
        });

        const viewManager = mock<ViewManagerInterface>();
        viewManager.getView.mockReturnValue(view);

        controller.itemClickHandler(viewManager, folderItem, event);

        expect(viewManager.setViewByParametersWithExistingQuery).toHaveBeenCalledWith({
          params: {
            query: expect.any(FolderViewQuery),
          },
        });

        const newQuery =
          viewManager.setViewByParametersWithExistingQuery.mock.calls[0][0]?.params
            ?.query;
        expect(newQuery).toBeInstanceOf(FolderViewQuery);
        expect(newQuery?.getQuery()).toEqual({
          folder,
          path: [{ ha: { id: 'grandparent' } }, { folder: folderItem }],
        });
      });

      it('should handle folder click without query', () => {
        const controller = new FolderGalleryController(document.createElement('div'));

        const view = createView({
          query: null,
        });
        const viewManager = mock<ViewManagerInterface>();
        viewManager.getView.mockReturnValue(view);

        controller.itemClickHandler(
          viewManager,
          new ViewFolder(createFolder(), {
            id: 'parent',
          }),
          new Event('click'),
        );

        expect(viewManager.setViewByParametersWithExistingQuery).not.toBeCalled();
        expect(viewManager.setViewByParameters).not.toBeCalled();
      });

      it('should handle folder click without path', () => {
        const controller = new FolderGalleryController(document.createElement('div'));
        const folder = createFolder();

        const view = createView({
          query: new FolderViewQuery({
            folder,
            path: [{ ha: { id: 'id' } }],
          }),
        });
        const viewManager = mock<ViewManagerInterface>();
        viewManager.getView.mockReturnValue(view);

        controller.itemClickHandler(
          viewManager,
          new ViewFolder(folder),
          new Event('click'),
        );

        expect(viewManager.setViewByParametersWithExistingQuery).not.toBeCalled();
        expect(viewManager.setViewByParameters).not.toBeCalled();
      });
    });
  });
});



================================================
FILE: tests/components-lib/gallery/gallery-core-controller.test.ts
================================================
import { LitElement } from 'lit';
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  GalleryColumnCountRoundMethod,
  GalleryCoreController,
} from '../../../src/components-lib/gallery/gallery-core-controller';
import { GalleryExtendEvent } from '../../../src/components/gallery/types';
import { scrollIntoView } from '../../../src/utils/scroll';
import { sleep } from '../../../src/utils/sleep';
import {
  callIntersectionHandler,
  createLitElement,
  createSlot,
  createSlotHost,
  createTouch,
  createTouchEvent,
  flushPromises,
  IntersectionObserverMock,
  ResizeObserverMock,
} from '../../test-utils';
import { callResizeHandler } from '../../utils/embla/test-utils';

vi.mock('lodash-es', async () => {
  return {
    ...(await vi.importActual('lodash-es')),
    throttle: vi.fn((fn) => fn),
  };
});

vi.mock('../../../src/utils/sleep');
vi.mock('../../../src/utils/scroll');

// @vitest-environment jsdom
describe('GalleryCoreController', () => {
  const createController = (options?: {
    host?: LitElement;
    getSlot?: () => HTMLSlotElement | null;
    getSentinelBottom?: () => HTMLElement | null;
    showLoaderTopCallback?: (show: boolean) => void;
    showSentinelBottomCallback?: (show: boolean) => void;
  }) => {
    return new GalleryCoreController(
      options?.host ?? createLitElement(),
      options?.getSlot ?? (() => null),
      options?.getSentinelBottom ?? (() => null),
      options?.showLoaderTopCallback ?? (() => null),
      options?.showSentinelBottomCallback ?? (() => null),
    );
  };

  beforeAll(() => {
    vi.stubGlobal('ResizeObserver', ResizeObserverMock);
    vi.stubGlobal('IntersectionObserver', IntersectionObserverMock);
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterAll(() => {
    vi.unstubAllGlobals();
  });

  it('should add controller', () => {
    const host = createLitElement();
    const controller = createController({ host });
    expect(controller).toBeInstanceOf(GalleryCoreController);
    expect(host.addController).toBeCalledWith(controller);
  });

  it('should remove controller', () => {
    const host = createLitElement();
    const controller = createController({ host });
    expect(controller).toBeInstanceOf(GalleryCoreController);
    controller.removeController();
    expect(host.removeController).toBeCalledWith(controller);
  });

  it('should remove controller', () => {
    const host = createLitElement();
    const controller = createController({ host });
    expect(controller).toBeInstanceOf(GalleryCoreController);
    controller.removeController();
    expect(host.removeController).toBeCalledWith(controller);
  });

  describe('should observe sentintel when host updated', () => {
    it('should disconnect and observe sentinel when valid sentinel exists', () => {
      const sentinel = document.createElement('div');
      const getSentinelBottom = vi.fn(() => sentinel);
      const host = createLitElement();

      const controller = createController({
        host,
        getSentinelBottom,
      });

      controller.hostUpdated();

      expect(
        vi.mocked(IntersectionObserver).mock.results[0].value.disconnect,
      ).toBeCalled();
      expect(
        vi.mocked(IntersectionObserver).mock.results[0].value.observe,
      ).toBeCalledWith(sentinel);
    });

    it('should not observe when sentinel is null', () => {
      const getSentinelBottom = vi.fn(() => null);
      const host = createLitElement();

      const controller = createController({
        host,
        getSentinelBottom,
      });

      controller.hostUpdated();

      expect(
        vi.mocked(IntersectionObserver).mock.results[0].value.disconnect,
      ).toBeCalled();
      expect(
        vi.mocked(IntersectionObserver).mock.results[0].value.observe,
      ).not.toBeCalled();
    });
  });

  it('should attach listeners on connect', () => {
    const host = createLitElement();
    host.addEventListener = vi.fn();
    const controller = createController({ host });

    controller.hostConnected();

    expect(vi.mocked(ResizeObserver).mock.results[0].value.observe).toBeCalledWith(host);
    expect(host.addEventListener).toBeCalledWith('wheel', expect.anything(), {
      passive: true,
    });
    expect(host.addEventListener).toBeCalledWith('touchstart', expect.anything(), {
      passive: true,
    });
    expect(host.addEventListener).toBeCalledWith('touchend', expect.anything());
    expect(host.requestUpdate).toBeCalled();
  });

  it('should detach listeners on disconnect', () => {
    const host = createLitElement();
    host.removeEventListener = vi.fn();
    const controller = createController({ host });

    controller.hostDisconnected();

    expect(vi.mocked(ResizeObserver).mock.results[0].value.disconnect).toBeCalled();
    expect(
      vi.mocked(IntersectionObserver).mock.results[0].value.disconnect,
    ).toBeCalled();
    expect(host.removeEventListener).toBeCalledWith('wheel', expect.anything());
    expect(host.removeEventListener).toBeCalledWith('touchstart', expect.anything());
    expect(host.removeEventListener).toBeCalledWith('touchend', expect.anything());
  });

  describe('should set the number of columns', () => {
    it('should update columns based on columnWidth and host width', () => {
      const host = createLitElement();
      Object.defineProperty(host, 'clientWidth', { value: 492 });

      const controller = createController({ host });

      controller.setOptions({ columnWidth: 250 });

      expect(host.style.getPropertyValue('--advanced-camera-card-gallery-columns')).toBe(
        '1',
      );
    });

    it('should calculate at least 1 column', () => {
      const host = createLitElement();
      Object.defineProperty(host, 'clientWidth', { value: 100 });

      const controller = createController({ host });

      controller.setOptions({ columnWidth: 200 });

      expect(host.style.getPropertyValue('--advanced-camera-card-gallery-columns')).toBe(
        '1',
      );
    });

    describe('should respect column count round method', () => {
      it.each([
        ['ceil' as const, 2],
        ['floor' as const, 1],
      ])(
        '%s',
        async (
          columnCountRoundMethod: GalleryColumnCountRoundMethod,
          expectedColumns: number,
        ) => {
          const host = createLitElement();
          Object.defineProperty(host, 'clientWidth', { value: 100 });

          const controller = createController({ host });

          controller.setOptions({ columnWidth: 51, columnCountRoundMethod });

          expect(
            host.style.getPropertyValue('--advanced-camera-card-gallery-columns'),
          ).toBe(String(expectedColumns));
        },
      );
    });

    it('should not update columns when columnWidth is not set', () => {
      const host = createLitElement();
      Object.defineProperty(host, 'clientWidth', { value: 500 });

      const controller = createController({ host });

      controller.setOptions({});

      expect(host.style.getPropertyValue('--advanced-camera-card-gallery-columns')).toBe(
        '',
      );
    });

    it('should update columns on resize', () => {
      const host = createLitElement();
      const controller = createController({ host });
      controller.setOptions({ columnWidth: 250 });

      const width = 1000;
      Object.defineProperty(host, 'clientWidth', { value: width });
      callResizeHandler([{ target: host, width, height: 200 }]);

      expect(host.style.getPropertyValue('--advanced-camera-card-gallery-columns')).toBe(
        '4',
      );
    });
  });

  describe('should extend gallery', () => {
    describe('should extend gallery up', () => {
      describe('should extend gallery up with wheel events', () => {
        it('should extend up with wheel event upwards', async () => {
          const host = createLitElement();
          host.scrollTop = 0;
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          const extendUpCallback = vi
            .fn()
            .mockImplementation((ev: CustomEvent<GalleryExtendEvent>) => {
              expect(showLoaderTop).toHaveBeenLastCalledWith(true);

              ev.detail.resolve();
            });
          host.addEventListener(
            'advanced-camera-card:gallery:extend:up',
            extendUpCallback,
          );

          host.dispatchEvent(new WheelEvent('wheel', { deltaY: -100 }));

          await flushPromises();
          expect(showLoaderTop).toHaveBeenLastCalledWith(false);
        });

        it('should not extend up with wheel event when not at top of component', async () => {
          const host = createLitElement();
          host.scrollTop = 100;
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          host.dispatchEvent(new WheelEvent('wheel', { deltaY: -100 }));

          expect(showLoaderTop).not.toHaveBeenCalled();
        });

        it('should not extend up with wheel event downwards', async () => {
          const host = createLitElement();
          host.scrollTop = 0;
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          host.dispatchEvent(new WheelEvent('wheel', { deltaY: 100 }));

          expect(showLoaderTop).not.toHaveBeenCalled();
        });
      });

      describe('should extend gallery up with touch events', () => {
        it('should extend up with touch event upwards', async () => {
          const host = createLitElement();
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          const extendUpCallback = vi
            .fn()
            .mockImplementation((ev: CustomEvent<GalleryExtendEvent>) => {
              expect(showLoaderTop).toHaveBeenLastCalledWith(true);

              ev.detail.resolve();
            });

          host.addEventListener(
            'advanced-camera-card:gallery:extend:up',
            extendUpCallback,
          );

          host.dispatchEvent(
            createTouchEvent('touchstart', { touches: [createTouch({ screenY: 0 })] }),
          );
          host.dispatchEvent(
            createTouchEvent('touchend', {
              changedTouches: [createTouch({ screenY: 100 })],
            }),
          );

          await flushPromises();
          expect(showLoaderTop).toHaveBeenLastCalledWith(false);
        });

        it('should not extend up with multiple touches', async () => {
          const host = createLitElement();
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          host.dispatchEvent(
            createTouchEvent('touchstart', {
              touches: [createTouch({ screenY: 0 }), createTouch({ screenY: 0 })],
            }),
          );
          host.dispatchEvent(
            createTouchEvent('touchend', {
              changedTouches: [createTouch({ screenY: 100 })],
            }),
          );

          await flushPromises();
          expect(showLoaderTop).not.toBeCalled();
        });

        it('should not extend up with touch when when not at top of component', async () => {
          const host = createLitElement();
          host.scrollTop = 100;
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          host.dispatchEvent(
            createTouchEvent('touchstart', {
              touches: [createTouch({ screenY: 0 }), createTouch({ screenY: 0 })],
            }),
          );
          host.dispatchEvent(
            createTouchEvent('touchend', {
              changedTouches: [createTouch({ screenY: 100 })],
            }),
          );

          await flushPromises();
          expect(showLoaderTop).not.toBeCalled();
        });

        it('should not extend up with touch when touches moved downwards', async () => {
          const host = createLitElement();
          const showLoaderTop = vi.fn();
          const controller = createController({
            host,
            showLoaderTopCallback: showLoaderTop,
          });

          controller.setOptions({ extendUp: true });
          controller.hostConnected();

          host.dispatchEvent(
            createTouchEvent('touchstart', {
              touches: [createTouch({ screenY: 100 })],
            }),
          );
          host.dispatchEvent(
            createTouchEvent('touchend', {
              changedTouches: [createTouch({ screenY: 0 })],
            }),
          );

          await flushPromises();
          expect(showLoaderTop).not.toBeCalled();
        });
      });

      it('should not extend when extending up is disabled', async () => {
        const host = createLitElement();
        const showLoaderTop = vi.fn();
        const controller = createController({
          host,
          showLoaderTopCallback: showLoaderTop,
        });

        controller.setOptions({ extendUp: false });
        controller.hostConnected();

        host.dispatchEvent(new WheelEvent('wheel', { deltaY: -100 }));

        expect(showLoaderTop).not.toHaveBeenCalled();
      });

      it('should not artifically sleep if extend up call takes too long', async () => {
        vi.useFakeTimers();

        const host = createLitElement();
        host.scrollTop = 0;
        const showLoaderTop = vi.fn();
        const controller = createController({
          host,
          showLoaderTopCallback: showLoaderTop,
        });

        controller.setOptions({ extendUp: true });
        controller.hostConnected();

        const extendUpCallback = vi
          .fn()
          .mockImplementation((ev: CustomEvent<GalleryExtendEvent>) => {
            vi.advanceTimersByTime(10000);
            ev.detail.resolve();
          });

        host.addEventListener(
          'advanced-camera-card:gallery:extend:up',
          extendUpCallback,
        );

        host.dispatchEvent(new WheelEvent('wheel', { deltaY: -100 }));

        await flushPromises();
        expect(sleep).not.toHaveBeenCalled();
      });
    });

    describe('should extend gallery down', () => {
      it('should extend down when sentinel intersects', async () => {
        const host = createLitElement();
        const showSentinelBottom = vi.fn();
        const controller = createController({
          host,
          showSentinelBottomCallback: showSentinelBottom,
        });

        controller.setOptions({ extendDown: true });
        controller.hostConnected();

        const extendDownCallback = vi
          .fn()
          .mockImplementation((ev: CustomEvent<GalleryExtendEvent>) => {
            expect(showSentinelBottom).toHaveBeenLastCalledWith(false);

            ev.detail.resolve();
          });
        host.addEventListener(
          'advanced-camera-card:gallery:extend:down',
          extendDownCallback,
        );

        callIntersectionHandler(true);

        await flushPromises();
        expect(showSentinelBottom).toHaveBeenLastCalledWith(false);
      });

      it('should not extend down when sentinel does not intersect', async () => {
        const host = createLitElement();
        const showSentinelBottom = vi.fn();
        const controller = createController({
          host,
          showSentinelBottomCallback: showSentinelBottom,
        });

        controller.setOptions({ extendUp: true });
        controller.hostConnected();

        callIntersectionHandler(false);

        expect(showSentinelBottom).not.toHaveBeenCalled();
      });

      it('should not extend when extending down is disabled', async () => {
        const host = createLitElement();
        const showSentinelBottom = vi.fn();
        const controller = createController({
          host,
          showSentinelBottomCallback: showSentinelBottom,
        });

        controller.setOptions({ extendUp: false });
        controller.hostConnected();

        callIntersectionHandler(true);

        expect(showSentinelBottom).not.toHaveBeenCalled();
      });
    });
  });

  describe('should handle content change', () => {
    describe('should scroll selected into view', () => {
      it('should scroll selected into view on first load', async () => {
        const selectedChild = document.createElement('div');
        selectedChild.setAttribute('selected', '');

        const slot = createSlot();
        const host = createSlotHost({
          slot,
          children: [
            document.createElement('div'),
            document.createElement('div'),
            selectedChild,
          ],
        });

        const controller = createController({
          host,
          getSlot: () => slot,
        });
        controller.updateContents();

        expect(scrollIntoView).toBeCalledWith(selectedChild, {
          boundary: host,
          block: 'center',
        });
      });

      it('should do nothing on subsequent contents changes', async () => {
        const selectedChild = document.createElement('div');
        selectedChild.setAttribute('selected', '');

        const slot = createSlot();
        const host = createSlotHost({
          slot,
          children: [
            document.createElement('div'),
            document.createElement('div'),
            selectedChild,
          ],
        });

        const controller = createController({
          host,
          getSlot: () => slot,
        });
        controller.updateContents();
        controller.updateContents();
        controller.updateContents();

        expect(scrollIntoView).toBeCalledTimes(1);
      });

      it('should do nothing without a selected element', async () => {
        const slot = createSlot();
        const host = createSlotHost({
          slot,
          children: [
            document.createElement('div'),
            document.createElement('div'),
            document.createElement('div'),
          ],
        });

        const controller = createController({
          host,
          getSlot: () => slot,
        });
        controller.updateContents();

        expect(scrollIntoView).not.toBeCalled();
      });
    });

    it('should show bottom sentintel if contents change', async () => {
      const slot = createSlot();
      const host = createSlotHost({
        slot,
      });

      const showSentinelBottom = vi.fn();
      const controller = createController({
        host,
        getSlot: () => slot,
        showSentinelBottomCallback: showSentinelBottom,
      });

      controller.updateContents();

      expect(showSentinelBottom).toBeCalledWith(true);
    });

    it('should do nothing without slot', async () => {
      const slot = createSlot();
      const host = createSlotHost({
        slot,
      });

      const showSentinelBottom = vi.fn();
      const controller = createController({
        host,
        showSentinelBottomCallback: showSentinelBottom,
      });

      controller.updateContents();

      expect(showSentinelBottom).not.toBeCalled();
      expect(scrollIntoView).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/components-lib/gallery/media-gallery-controller.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { ExtendedMediaQueryResult } from '../../../src/camera-manager/manager';
import {
  EventQuery,
  QueryType,
  RecordingQuery,
} from '../../../src/camera-manager/types';
import { ViewManagerEpoch } from '../../../src/card-controller/view/types';
import { ViewManager } from '../../../src/card-controller/view/view-manager';
import {
  MEDIA_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN,
  MediaGalleryController,
} from '../../../src/components-lib/gallery/media-gallery-controller';
import { THUMBNAIL_WIDTH_DEFAULT } from '../../../src/config/schema/common/controls/thumbnails';
import {
  EventMediaQuery,
  FolderViewQuery,
  RecordingMediaQuery,
} from '../../../src/view/query';
import { QueryResults } from '../../../src/view/query-results';
import {
  createCameraManager,
  createLitElement,
  createView,
  TestViewMedia,
} from '../../test-utils';

// @vitest-environment jsdom
describe('MediaGalleryController', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('getMedia', () => {
    it('should return null initially', () => {
      expect(new MediaGalleryController(createLitElement()).getMedia()).toBeNull();
    });
  });

  describe('setMediaFromView', () => {
    it('should set media from view if media is null', () => {
      const controller = new MediaGalleryController(createLitElement());
      controller.setMediaFromView(null);
      expect(controller.getMedia()).toBeNull();
    });

    it('should set media from view if results are null', () => {
      const controller = new MediaGalleryController(createLitElement());
      controller.setMediaFromView(createView({ queryResults: new QueryResults() }));
      expect(controller.getMedia()).toEqual([]);
    });

    it('should update media when query results first set', () => {
      const media_1 = new TestViewMedia({ id: 'one' });
      const media_2 = new TestViewMedia({ id: 'two' });
      const newView = createView({
        queryResults: new QueryResults({ results: [media_1, media_2] }),
      });
      const controller = new MediaGalleryController(createLitElement());
      controller.setMediaFromView(newView);
      expect(controller.getMedia()).toEqual([media_2, media_1]);
    });

    it('should update media when query results change', () => {
      const media_1 = new TestViewMedia({ id: 'one' });
      const media_2 = new TestViewMedia({ id: 'two' });
      const media_3 = new TestViewMedia({ id: 'three' });

      const oldView = createView({
        queryResults: new QueryResults({ results: [media_1, media_2] }),
      });
      const newView = createView({
        queryResults: new QueryResults({ results: [media_2, media_3] }),
      });

      const controller = new MediaGalleryController(createLitElement());
      controller.setMediaFromView(newView, oldView);
      expect(controller.getMedia()).toEqual([media_3, media_2]);
    });

    it('should not update media if query results are the same', () => {
      const media_1 = new TestViewMedia({ id: 'one' });
      const media_2 = new TestViewMedia({ id: 'two' });
      const results = [media_1, media_2];
      const oldView = createView({
        queryResults: new QueryResults({ results }),
      });
      const newView = createView({
        queryResults: new QueryResults({ results }),
      });

      const controller = new MediaGalleryController(createLitElement());
      controller.setMediaFromView(oldView);
      const media = controller.getMedia();

      controller.setMediaFromView(newView, oldView);

      expect(controller.getMedia()).toBe(media);
    });
  });

  describe('should set thumbnail size', () => {
    it('should set thumbnail size explicitly', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      controller.setThumbnailSize(100);

      expect(host.style.getPropertyValue('--advanced-camera-card-thumbnail-size')).toBe(
        '100px',
      );
    });

    it('should set thumbnail size implicitly', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      controller.setThumbnailSize();

      expect(host.style.getPropertyValue('--advanced-camera-card-thumbnail-size')).toBe(
        `${THUMBNAIL_WIDTH_DEFAULT}px`,
      );
    });
  });

  describe('should get column width', () => {
    it('should get default column width', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      expect(controller.getColumnWidth()).toBe(THUMBNAIL_WIDTH_DEFAULT);
    });

    it('should get column width with defailts', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      expect(
        controller.getColumnWidth({
          size: 100,
          show_details: true,
          show_favorite_control: true,
          show_timeline_control: true,
          show_download_control: true,
        }),
      ).toBe(MEDIA_GALLERY_THUMBNAIL_DETAILS_WIDTH_MIN);
    });

    it('should get column width with explicit size', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      expect(
        controller.getColumnWidth({
          size: 142,
          show_details: false,
          show_favorite_control: true,
          show_timeline_control: true,
          show_download_control: true,
        }),
      ).toBe(142);
    });
  });

  describe('should get column count round method', () => {
    it('should get default column count round method', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      expect(controller.getColumnCountRoundMethod()).toBe('ceil');
    });

    it('should get column count round method when details being shown', () => {
      const host = document.createElement('div');
      const controller = new MediaGalleryController(host);

      expect(
        controller.getColumnCountRoundMethod({
          size: 100,
          show_details: true,
          show_favorite_control: true,
          show_timeline_control: true,
          show_download_control: true,
        }),
      ).toBe('floor');
    });
  });

  describe('extendMediaGallery', () => {
    it('should do nothing if no view is available', async () => {
      const controller = new MediaGalleryController(createLitElement());
      const cameraManager = createCameraManager();
      const viewManagerEpoch = mock<ViewManagerEpoch>();
      viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(null);

      await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
      expect(cameraManager.extendMediaQueries).not.toHaveBeenCalled();
    });

    it('should do nothing if no queries are available', async () => {
      const controller = new MediaGalleryController(createLitElement());
      const cameraManager = createCameraManager();
      const viewManagerEpoch = mock<ViewManagerEpoch>();
      viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(
        createView({
          query: new EventMediaQuery(),
          queryResults: new QueryResults({ results: [new TestViewMedia()] }),
        }),
      );

      await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
      expect(cameraManager.extendMediaQueries).not.toHaveBeenCalled();
    });

    it('should do nothing if no query results are available', async () => {
      const controller = new MediaGalleryController(createLitElement());
      const cameraManager = createCameraManager();
      const viewManagerEpoch = mock<ViewManagerEpoch>();
      viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(createView());

      await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
      expect(cameraManager.extendMediaQueries).not.toHaveBeenCalled();
    });

    it('should do nothing if non-media query is present', async () => {
      const controller = new MediaGalleryController(createLitElement());
      const cameraManager = createCameraManager();
      const viewManagerEpoch = mock<ViewManagerEpoch>();
      viewManagerEpoch.manager.getView = vi
        .fn()
        .mockReturnValue(createView({ query: new FolderViewQuery() }));

      await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
      expect(cameraManager.extendMediaQueries).not.toHaveBeenCalled();
    });

    it('should successfully extend event media queries', async () => {
      const controller = new MediaGalleryController(createLitElement());
      const cameraManager = createCameraManager();
      const viewManagerEpoch = mock<ViewManagerEpoch>({ manager: mock<ViewManager>() });

      const existingRawQueries: EventQuery[] = [
        { type: QueryType.Event, cameraIDs: new Set(['camera.office']) },
      ];
      const existingMedia = [new TestViewMedia()];
      const baseView = createView({
        query: new EventMediaQuery(existingRawQueries),
        queryResults: new QueryResults({ results: existingMedia }),
      });
      viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(baseView);

      const newQueries: EventQuery[] = [
        { type: QueryType.Event, cameraIDs: new Set(['camera.office']) },
      ];
      const newResults = [new TestViewMedia()];

      const extension: ExtendedMediaQueryResult<EventQuery> = {
        queries: newQueries,
        results: newResults,
      };
      vi.mocked(cameraManager.extendMediaQueries).mockResolvedValue(extension);

      await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
      expect(cameraManager.extendMediaQueries).toBeCalledWith(
        existingRawQueries,
        existingMedia,
        'earlier',
        { useCache: true },
      );
      expect(viewManagerEpoch.manager.setViewByParameters).toBeCalledWith({
        baseView,
        params: {
          query: expect.any(EventMediaQuery),
          queryResults: expect.any(QueryResults),
        },
      });

      const callArguments = vi.mocked(viewManagerEpoch.manager.setViewByParameters).mock
        .lastCall?.[0];

      expect(callArguments?.params?.query?.getQuery()).toEqual(newQueries);
      expect(callArguments?.params?.queryResults?.getResults()).toEqual(newResults);
    });
  });

  it('should successfully extend recording media queries', async () => {
    const controller = new MediaGalleryController(createLitElement());
    const cameraManager = createCameraManager();
    const viewManagerEpoch = mock<ViewManagerEpoch>({ manager: mock<ViewManager>() });

    const existingRawQueries: RecordingQuery[] = [
      { type: QueryType.Recording, cameraIDs: new Set(['camera.office']) },
    ];
    const existingMedia = [new TestViewMedia()];
    const baseView = createView({
      query: new RecordingMediaQuery(existingRawQueries),
      queryResults: new QueryResults({ results: existingMedia }),
    });
    viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(baseView);

    const newQueries: RecordingQuery[] = [
      { type: QueryType.Recording, cameraIDs: new Set(['camera.office']) },
    ];
    const newResults = [new TestViewMedia()];

    const extension: ExtendedMediaQueryResult<RecordingQuery> = {
      queries: newQueries,
      results: newResults,
    };
    vi.mocked(cameraManager.extendMediaQueries).mockResolvedValue(extension);

    await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
    expect(cameraManager.extendMediaQueries).toBeCalledWith(
      existingRawQueries,
      existingMedia,
      'earlier',
      { useCache: true },
    );
    expect(viewManagerEpoch.manager.setViewByParameters).toBeCalledWith({
      baseView,
      params: {
        query: expect.any(RecordingMediaQuery),
        queryResults: expect.any(QueryResults),
      },
    });

    const callArguments = vi.mocked(viewManagerEpoch.manager.setViewByParameters).mock
      .lastCall?.[0];

    expect(callArguments?.params?.query?.getQuery()).toEqual(newQueries);
    expect(callArguments?.params?.queryResults?.getResults()).toEqual(newResults);
  });

  it('should handle errors gracefully', async () => {
    const controller = new MediaGalleryController(createLitElement());
    const cameraManager = createCameraManager();
    const viewManagerEpoch = mock<ViewManagerEpoch>({ manager: mock<ViewManager>() });

    viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(
      createView({
        query: new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera.office']) },
        ]),
        queryResults: new QueryResults({ results: [new TestViewMedia()] }),
      }),
    );

    vi.mocked(cameraManager.extendMediaQueries).mockRejectedValue(
      new Error('Test error'),
    );

    const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);
    await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');

    expect(viewManagerEpoch.manager.setViewByParameters).not.toHaveBeenCalled();

    expect(consoleSpy).toBeCalledWith('Test error');
  });

  it('should handle null extension gracefully', async () => {
    const controller = new MediaGalleryController(createLitElement());
    const cameraManager = createCameraManager();
    const viewManagerEpoch = mock<ViewManagerEpoch>({ manager: mock<ViewManager>() });

    viewManagerEpoch.manager.getView = vi.fn().mockReturnValue(
      createView({
        query: new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera.office']) },
        ]),
        queryResults: new QueryResults({ results: [new TestViewMedia()] }),
      }),
    );

    vi.mocked(cameraManager.extendMediaQueries).mockResolvedValue(null);

    await controller.extendMediaGallery(cameraManager, viewManagerEpoch, 'earlier');
    expect(viewManagerEpoch.manager.setViewByParameters).not.toHaveBeenCalled();
  });

  describe('should handle item click', () => {
    it('should do nothing without a view', () => {
      const controller = new MediaGalleryController(createLitElement());
      const viewManager = mock<ViewManager>();

      controller.itemClickHandler(viewManager, 0, new Event('click'));

      expect(viewManager.setViewByParameters).not.toHaveBeenCalled();
    });

    it('should change view to selected item', () => {
      const media = [
        new TestViewMedia({ id: 'zero' }),
        new TestViewMedia({ id: 'one' }),
      ];
      const view = createView({
        queryResults: new QueryResults({ results: media, selectedIndex: 0 }),
      });

      const controller = new MediaGalleryController(createLitElement());
      controller.setMediaFromView(view);

      const viewManager = mock<ViewManager>();
      viewManager.getView.mockReturnValue(view);

      controller.itemClickHandler(
        viewManager,
        // As the media in the gallery is reversed, passing in 0 as a
        // reversedIndex argument is requesting the selection of the media item
        // with index 1 (from an array of 2 media items).
        0,
        new Event('click'),
      );

      expect(viewManager.setViewByParameters).toBeCalledWith({
        params: {
          view: 'media',
          queryResults: expect.any(QueryResults),
        },
      });

      const newQueryResults = vi.mocked(viewManager.setViewByParameters).mock
        .lastCall?.[0]?.params?.queryResults;
      expect(newQueryResults?.getSelectedResult()).toEqual(media[1]);
    });
  });
});



================================================
FILE: tests/components-lib/live/live-controller.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { LiveController } from '../../../src/components-lib/live/live-controller';
import { dispatchExistingMediaLoadedInfoAsEvent } from '../../../src/utils/media-info';
import {
  IntersectionObserverMock,
  callIntersectionHandler,
  createLitElement,
  createMediaLoadedInfo,
  createMediaLoadedInfoEvent,
  createParent,
} from '../../test-utils';

// @vitest-environment jsdom
describe('LiveController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.stubGlobal('IntersectionObserver', IntersectionObserverMock);
  });

  it('should be constructable', () => {
    const controller = new LiveController(createLitElement());
    expect(controller).toBeTruthy();
  });

  it('should connect and disconnect', () => {
    const host = createLitElement();
    const parent = createParent({ children: [host] });
    const eventListener = vi.fn();
    parent.addEventListener('advanced-camera-card:media:loaded', eventListener);

    const controller = new LiveController(host);
    expect(host.addController).toBeCalled();

    controller.hostConnected();

    callIntersectionHandler(false);

    dispatchExistingMediaLoadedInfoAsEvent(host, createMediaLoadedInfo());

    expect(eventListener).toBeCalledTimes(0);

    controller.hostDisconnected();
    dispatchExistingMediaLoadedInfoAsEvent(host, createMediaLoadedInfo());

    expect(eventListener).toBeCalledTimes(1);
  });

  describe('should handle background / foreground', () => {
    it('should start in the foreground', () => {
      const controller = new LiveController(createLitElement());
      expect(controller.isInBackground()).toBeFalsy();
    });

    it('should handle changing to background', () => {
      const element = createLitElement();
      const controller = new LiveController(element);
      expect(controller.isInBackground()).toBeFalsy();
      expect(element.requestUpdate).toBeCalledTimes(0);

      callIntersectionHandler(true);
      expect(controller.isInBackground()).toBeFalsy();
      expect(element.requestUpdate).toBeCalledTimes(0);

      callIntersectionHandler(false);
      expect(controller.isInBackground()).toBeTruthy();
      expect(element.requestUpdate).toBeCalledTimes(1);
    });

    it('should dispatch media loaded on background change', () => {
      const host = createLitElement();
      const parent = createParent({ children: [host] });
      const eventListener = vi.fn();
      parent.addEventListener('advanced-camera-card:media:loaded', eventListener);

      const controller = new LiveController(host);
      const mediaLoadedInfo = createMediaLoadedInfo();

      controller.hostConnected();

      callIntersectionHandler(false);
      expect(controller.isInBackground()).toBeTruthy();

      host.dispatchEvent(createMediaLoadedInfoEvent(mediaLoadedInfo));
      expect(eventListener).toBeCalledTimes(0);

      callIntersectionHandler(true);
      expect(eventListener).toBeCalledTimes(1);
      expect(eventListener).toHaveBeenLastCalledWith(
        expect.objectContaining({
          detail: mediaLoadedInfo,
        }),
      );

      host.dispatchEvent(createMediaLoadedInfoEvent(mediaLoadedInfo));
      expect(eventListener).toBeCalledTimes(2);
    });
  });
});



================================================
FILE: tests/components-lib/live/utils/dispatch-live-error.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { dispatchLiveErrorEvent } from '../../../../src/components-lib/live/utils/dispatch-live-error';

// @vitest-environment jsdom
it('should dispatch live error event', () => {
  const element = document.createElement('div');
  const handler = vi.fn();
  element.addEventListener('advanced-camera-card:live:error', handler);

  dispatchLiveErrorEvent(element);
  expect(handler).toBeCalled();
});



================================================
FILE: tests/components-lib/live/utils/get-technology-for-video-rts.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getTechnologyForVideoRTC } from '../../../../src/components-lib/live/utils/get-technology-for-video-rtc';
import { VideoRTC } from '../../../../src/components/live/providers/go2rtc/video-rtc';
import { createLitElement } from '../../../test-utils';

// @vitest-environment jsdom
describe('getTechnologyForVideoRTC', () => {
  it('webrtc', () => {
    const element = createLitElement() as unknown as VideoRTC;
    element.pc = {} as unknown as RTCPeerConnection;
    expect(getTechnologyForVideoRTC(element)).toEqual(['webrtc']);
  });

  it('mse', () => {
    const element = createLitElement() as unknown as VideoRTC;
    element.mseCodecs = 'mp4a';
    expect(getTechnologyForVideoRTC(element)).toEqual(['mse', 'hls']);
  });

  it('other', () => {
    const element = createLitElement() as unknown as VideoRTC;
    expect(getTechnologyForVideoRTC(element)).toBeUndefined();
  });
});



================================================
FILE: tests/components-lib/media-player/image.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { ImageMediaPlayerController } from '../../../src/components-lib/media-player/image';
import { createLitElement } from '../../test-utils';
import { screenshotImage } from '../../../src/utils/screenshot';

vi.mock('../../../src/utils/screenshot.js');

// @vitest-environment jsdom
describe('ImageMediaPlayerController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should ignore play', async () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    await controller.play();

    // Currently no observable side effects.
  });

  it('should ignore pause', async () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    await controller.pause();

    // Currently no observable side effects.
  });

  it('should ignore mute', async () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    await controller.mute();

    // Currently no observable side effects.
  });

  it('should ignore unmute', async () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    await controller.unmute();

    // Currently no observable side effects.
  });

  it('should always report muted', () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    expect(controller.isMuted()).toBeTruthy();
  });

  it('should ignore seek', async () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    await controller.seek(10);

    // Currently no observable side effects.
  });

  it('should ignore set controls', async () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    await controller.setControls(true);

    // Currently no observable side effects.
  });

  it('should always report unpaused', () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    expect(controller.isPaused()).toBeFalsy();
  });

  describe('should get screenshot URL', async () => {
    it('should return screenshot URL with image', async () => {
      const url = 'data:image/png;base64,';
      vi.mocked(screenshotImage).mockReturnValue(url);

      const image = mock<HTMLImageElement>();

      const controller = new ImageMediaPlayerController(createLitElement(), () => image);

      expect(await controller.getScreenshotURL()).toBe(url);
    });

    it('should return null without image', async () => {
      const controller = new ImageMediaPlayerController(createLitElement(), () => null);

      expect(await controller.getScreenshotURL()).toBeNull();
    });
  });

  describe('should get fullscreen element', async () => {
    it('should return fullscreen element with image', async () => {
      const image = mock<HTMLImageElement>();

      const controller = new ImageMediaPlayerController(createLitElement(), () => image);

      expect(await controller.getFullscreenElement()).toBe(image);
    });

    it('should return null without image', async () => {
      const controller = new ImageMediaPlayerController(createLitElement(), () => null);

      expect(controller.getFullscreenElement()).toBeNull();
    });
  });
});



================================================
FILE: tests/components-lib/media-player/jsmpeg.test.ts
================================================
import JSMpeg from '@cycjimmy/jsmpeg-player';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { JSMPEGMediaPlayerController } from '../../../src/components-lib/media-player/jsmpeg';
import { createLitElement } from '../../test-utils';

// @vitest-environment jsdom
describe('JSMPEGMediaPlayerController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should play', async () => {
    const videoElement = mock<JSMpeg.VideoElement>();

    const controller = new JSMPEGMediaPlayerController(
      createLitElement(),
      () => videoElement,
      () => mock<HTMLCanvasElement>(),
    );

    await controller.play();

    expect(videoElement.play).toBeCalled();
  });

  it('should pause', async () => {
    const videoElement = mock<JSMpeg.VideoElement>();

    const controller = new JSMPEGMediaPlayerController(
      createLitElement(),
      () => videoElement,
      () => mock<HTMLCanvasElement>(),
    );

    await controller.pause();

    expect(videoElement.stop).toBeCalled();
  });

  describe('should mute', async () => {
    it('should mute with player', async () => {
      const videoElement = mock<JSMpeg.VideoElement>();
      videoElement.player = mock<JSMpeg.Player>();
      videoElement.player.volume = 1;

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => videoElement,
        () => mock<HTMLCanvasElement>(),
      );

      await controller.mute();

      expect(videoElement.player.volume).toBe(0);
    });

    it('should ignore calls without player', async () => {
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => null,
        () => mock<HTMLCanvasElement>(),
      );

      await controller.mute();

      // Currently no observable side effects.
    });
  });

  describe('should unmute', async () => {
    it('should mute with player', async () => {
      const videoElement = mock<JSMpeg.VideoElement>();
      videoElement.player = mock<JSMpeg.Player>();
      videoElement.player.volume = 0;

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => videoElement,
        () => mock<HTMLCanvasElement>(),
      );

      await controller.unmute();

      expect(videoElement.player.volume).toBe(1);
    });

    it('should ignore calls without player', async () => {
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => null,
        () => mock<HTMLCanvasElement>(),
      );

      await controller.unmute();

      // Currently no observable side effects.
    });
  });

  describe('should return muted state', () => {
    it('should return true when muted', () => {
      const videoElement = mock<JSMpeg.VideoElement>();
      videoElement.player = mock<JSMpeg.Player>();
      videoElement.player.volume = 0;

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => videoElement,
        () => mock<HTMLCanvasElement>(),
      );

      expect(controller.isMuted()).toBeTruthy();
    });

    it('should return false when not muted', () => {
      const videoElement = mock<JSMpeg.VideoElement>();
      videoElement.player = mock<JSMpeg.Player>();
      videoElement.player.volume = 1;

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => videoElement,
        () => mock<HTMLCanvasElement>(),
      );

      expect(controller.isMuted()).toBeFalsy();
    });

    it('should return true when no player', () => {
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => null,
        () => mock<HTMLCanvasElement>(),
      );

      expect(controller.isMuted()).toBeTruthy();
    });
  });

  it('should ignore seek', async () => {
    const controller = new JSMPEGMediaPlayerController(
      createLitElement(),
      () => mock<JSMpeg.VideoElement>(),
      () => mock<HTMLCanvasElement>(),
    );

    await controller.seek(10);

    // Currently no observable side effects.
  });

  it('should ignore set controls', async () => {
    const controller = new JSMPEGMediaPlayerController(
      createLitElement(),
      () => mock<JSMpeg.VideoElement>(),
      () => mock<HTMLCanvasElement>(),
    );
    await controller.setControls(true);

    // Currently no observable side effects.
  });

  describe('should return paused state', () => {
    it('should return true when paused', async () => {
      const videoElement = mock<JSMpeg.VideoElement>();
      videoElement.player = mock<JSMpeg.Player>();
      videoElement.player.paused = true;

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => videoElement,
        () => mock<HTMLCanvasElement>(),
      );

      expect(controller.isPaused()).toBeTruthy();
    });

    it('should return false when not paused', async () => {
      const videoElement = mock<JSMpeg.VideoElement>();
      videoElement.player = mock<JSMpeg.Player>();
      videoElement.player.paused = false;

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => videoElement,
        () => mock<HTMLCanvasElement>(),
      );

      expect(controller.isPaused()).toBeFalsy();
    });

    it('should return true when no video', () => {
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => null,
        () => mock<HTMLCanvasElement>(),
      );

      expect(controller.isPaused()).toBeTruthy();
    });
  });

  describe('should get screenshot URL', async () => {
    it('should return screenshot URL with canvas', async () => {
      const url = 'data:image/png;base64,';
      const canvas = mock<HTMLCanvasElement>();
      canvas.toDataURL.mockReturnValue(url);

      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => mock<JSMpeg.VideoElement>(),
        () => canvas,
      );

      expect(await controller.getScreenshotURL()).toBe(url);
    });

    it('should return null without canvas', async () => {
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => mock<JSMpeg.VideoElement>(),
        () => null,
      );

      expect(await controller.getScreenshotURL()).toBeNull();
    });
  });

  describe('should get fullscreen element', async () => {
    it('should return fullscreen element with canvas', async () => {
      const canvas = mock<HTMLCanvasElement>();
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => mock<JSMpeg.VideoElement>(),
        () => canvas,
      );

      expect(await controller.getFullscreenElement()).toBe(canvas);
    });

    it('should return null without cancas', async () => {
      const controller = new JSMPEGMediaPlayerController(
        createLitElement(),
        () => mock<JSMpeg.VideoElement>(),
        () => null,
      );

      expect(controller.getFullscreenElement()).toBeNull();
    });
  });
});



================================================
FILE: tests/components-lib/media-player/updating-image.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CachedValueController } from '../../../src/components-lib/cached-value-controller';
import { ImageMediaPlayerController } from '../../../src/components-lib/media-player/image';
import { UpdatingImageMediaPlayerController } from '../../../src/components-lib/media-player/updating-image';
import { createLitElement } from '../../test-utils';

// @vitest-environment jsdom
describe('UpdatingImageMediaPlayerController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should play', async () => {
    const cachedValueController = mock<CachedValueController<string>>();
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => cachedValueController,
    );

    await controller.play();

    expect(cachedValueController.startTimer).toHaveBeenCalled();
  });

  it('should pause', async () => {
    const cachedValueController = mock<CachedValueController<string>>();
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => cachedValueController,
    );

    await controller.pause();

    expect(cachedValueController.stopTimer).toHaveBeenCalled();
  });

  it('should ignore mute', async () => {
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => mock<CachedValueController<string>>(),
    );

    await controller.mute();

    // Currently no observable side effects.
  });

  it('should ignore unmute', async () => {
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => mock<CachedValueController<string>>(),
    );

    await controller.unmute();

    // Currently no observable side effects.
  });

  it('should always report muted', () => {
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => mock<CachedValueController<string>>(),
    );

    expect(controller.isMuted()).toBeTruthy();
  });

  it('should ignore seek', async () => {
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => mock<CachedValueController<string>>(),
    );

    await controller.seek(10);

    // Currently no observable side effects.
  });

  it('should ignore set controls', async () => {
    const controller = new UpdatingImageMediaPlayerController(
      createLitElement(),
      () => mock<HTMLImageElement>(),
      () => mock<CachedValueController<string>>(),
    );

    await controller.setControls(true);

    // Currently no observable side effects.
  });

  it('should always report unpaused', () => {
    const image = mock<HTMLImageElement>();
    const controller = new ImageMediaPlayerController(createLitElement(), () => image);

    expect(controller.isPaused()).toBeFalsy();
  });

  describe('should get paused state', () => {
    it('should return true when the cached value controller does not have a timer', () => {
      const cachedValueController = mock<CachedValueController<string>>();
      cachedValueController.hasTimer.mockReturnValue(false);

      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => mock<HTMLImageElement>(),
        () => cachedValueController,
      );

      expect(controller.isPaused()).toBeTruthy();
    });

    it('should return false when the cached value controller has a timer', () => {
      const cachedValueController = mock<CachedValueController<string>>();
      cachedValueController.hasTimer.mockReturnValue(true);

      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => mock<HTMLImageElement>(),
        () => cachedValueController,
      );

      expect(controller.isPaused()).toBeFalsy();
    });

    it('should return true without cached value controller', () => {
      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => mock<HTMLImageElement>(),
        () => null,
      );

      expect(controller.isPaused()).toBeTruthy();
    });
  });

  describe('should get screenshot URL', () => {
    it('should return screenshot URL with cached value controller', async () => {
      const url = 'data:image/png;base64,';
      const cachedValueController = mock<CachedValueController<string>>();
      Object.defineProperty(cachedValueController, 'value', { value: url });

      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => mock<HTMLImageElement>(),
        () => cachedValueController,
      );

      expect(await controller.getScreenshotURL()).toBe(url);
    });

    it('should return null without cached value controller', async () => {
      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => mock<HTMLImageElement>(),
        () => null,
      );

      expect(await controller.getScreenshotURL()).toBeNull();
    });
  });

  describe('should get fullscreen element', async () => {
    it('should return fullscreen element with image', async () => {
      const image = mock<HTMLImageElement>();

      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => image,
        () => mock<CachedValueController<string>>(),
      );

      expect(await controller.getFullscreenElement()).toBe(image);
    });

    it('should return null without image', async () => {
      const controller = new UpdatingImageMediaPlayerController(
        createLitElement(),
        () => null,
        () => mock<CachedValueController<string>>(),
      );

      expect(controller.getFullscreenElement()).toBeNull();
    });
  });
});



================================================
FILE: tests/components-lib/media-player/video.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { VideoMediaPlayerController } from '../../../src/components-lib/media-player/video';
import {
  hideMediaControlsTemporarily,
  setControlsOnVideo,
} from '../../../src/utils/controls';
import { screenshotVideo } from '../../../src/utils/screenshot';
import { createLitElement } from '../../test-utils';

vi.mock('../../../src/utils/controls.js');
vi.mock('../../../src/utils/screenshot.js');

class NotAllowedError extends Error {
  name = 'NotAllowedError';
}

// @vitest-environment jsdom
describe('VideoMediaPlayerController', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('should play', () => {
    it('should play when no error', async () => {
      const video = mock<HTMLVideoElement>();
      video.play.mockResolvedValue();

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.play();

      expect(video.play).toBeCalled();
    });

    it('should mute if not allowed to play and unmuted', async () => {
      const video = mock<HTMLVideoElement>();
      video.play.mockRejectedValueOnce(new NotAllowedError()).mockResolvedValueOnce();
      video.muted = false;

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.play();

      expect(video.play).toBeCalledTimes(2);
      expect(video.muted).toBeTruthy();
    });

    it('should not mute if not allowed to play and already unmuted', async () => {
      const video = mock<HTMLVideoElement>();
      video.play.mockRejectedValueOnce(new NotAllowedError());
      video.muted = true;

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.play();

      expect(video.play).toBeCalledTimes(1);
      expect(video.muted).toBeTruthy();
    });

    it('should ignore exception if subsequent play call throws', async () => {
      const video = mock<HTMLVideoElement>();
      video.play.mockRejectedValue(new NotAllowedError());
      video.muted = false;

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.play();

      expect(video.play).toBeCalledTimes(2);
      expect(video.muted).toBeTruthy();
    });

    it('should ignore calls without a video', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      await controller.play();

      // Currently no observable side effects.
    });
  });

  it('should pause', async () => {
    const video = mock<HTMLVideoElement>();
    const controller = new VideoMediaPlayerController(createLitElement(), () => video);

    await controller.pause();

    expect(video.pause).toBeCalled();
  });

  describe('should mute', async () => {
    it('should mute with video', async () => {
      const video = mock<HTMLVideoElement>();
      video.muted = false;
      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.mute();

      expect(video.muted).toBeTruthy();
    });

    it('should ignore calls without a video', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      await controller.mute();

      // Currently no observable side effects.
    });
  });

  describe('should unmute', async () => {
    it('should unmute with video', async () => {
      const video = mock<HTMLVideoElement>();
      video.muted = true;
      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.unmute();

      expect(video.muted).toBeFalsy();
    });

    it('should ignore calls without a video', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      await controller.unmute();

      // Currently no observable side effects.
    });
  });

  describe('should return muted state', () => {
    it('should return true when muted', () => {
      const video = mock<HTMLVideoElement>();
      video.muted = true;
      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      expect(controller.isMuted()).toBeTruthy();
    });

    it('should return false when not muted', () => {
      const video = mock<HTMLVideoElement>();
      video.muted = false;
      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      expect(controller.isMuted()).toBeFalsy();
    });

    it('should return true when no video', () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      expect(controller.isMuted()).toBeTruthy();
    });
  });

  describe('should seek', () => {
    it('should seek', async () => {
      const video = mock<HTMLVideoElement>();
      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.seek(10);

      expect(hideMediaControlsTemporarily).toBeCalled();
      expect(video.currentTime).toBe(10);
    });

    it('should ignore calls without a video', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      await controller.seek(10);

      // Currently no observable side effects.
    });
  });

  describe('should set controls', () => {
    it('should set controls', async () => {
      const video = mock<HTMLVideoElement>();
      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.setControls(true);

      expect(setControlsOnVideo).toBeCalledWith(video, true);
    });

    it('should set controls to default', async () => {
      const video = mock<HTMLVideoElement>();
      const controller = new VideoMediaPlayerController(
        createLitElement(),
        () => video,
        () => true,
      );

      await controller.setControls();

      expect(setControlsOnVideo).toBeCalledWith(video, true);
    });

    it('should ignore calls without a default or value', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      await controller.setControls(true);

      expect(setControlsOnVideo).not.toBeCalled();
    });
  });

  describe('should return paused state', () => {
    it('should return true when paused', async () => {
      const video = mock<HTMLVideoElement>();
      Object.defineProperty(video, 'paused', { value: true });

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.pause();

      expect(controller.isPaused()).toBeTruthy();
    });

    it('should return false when not paused', async () => {
      const video = mock<HTMLVideoElement>();
      Object.defineProperty(video, 'paused', { value: false });

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      await controller.pause();

      expect(controller.isPaused()).toBeFalsy();
    });

    it('should return true when no video', () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      expect(controller.isPaused()).toBeTruthy();
    });
  });

  describe('should get screenshot URL', async () => {
    it('should return screenshot URL with video', async () => {
      const url = 'data:image/png;base64,';
      vi.mocked(screenshotVideo).mockReturnValue(url);

      const video = mock<HTMLVideoElement>();

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      expect(await controller.getScreenshotURL()).toBe(url);
    });

    it('should return null without video', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      expect(await controller.getScreenshotURL()).toBeNull();
    });
  });

  describe('should get fullscreen element', async () => {
    it('should return fullscreen element with video', async () => {
      const video = mock<HTMLVideoElement>();

      const controller = new VideoMediaPlayerController(createLitElement(), () => video);

      expect(await controller.getFullscreenElement()).toBe(video);
    });

    it('should return null without video', async () => {
      const controller = new VideoMediaPlayerController(createLitElement(), () => null);

      expect(controller.getFullscreenElement()).toBeNull();
    });
  });
});



================================================
FILE: tests/components-lib/message/controller.test.ts
================================================
import yaml from 'js-yaml';
import { describe, expect, it } from 'vitest';
import { MessageController } from '../../../src/components-lib/message/controller';
import { TROUBLESHOOTING_URL } from '../../../src/const';
import { localize } from '../../../src/localize/localize';
import { Message, MessageType, MessageURL } from '../../../src/types';

describe('MessageController', () => {
  describe('should return the correct message string', () => {
    it('should return simple message string', () => {
      const controller = new MessageController();
      const message: Message = {
        message: 'Message',
        type: 'info',
      };
      expect(controller.getMessageString(message)).toBe('Message');
    });

    it('should embed simple string context', () => {
      const controller = new MessageController();
      const message: Message = {
        message: 'Message',
        context: 'Context',
        type: 'info',
      };
      expect(controller.getMessageString(message)).toBe('Message: Context');
    });
  });

  describe('should return the correct icon', () => {
    describe('when icon is specified', () => {
      it.each([['info' as const], ['error' as const], ['connection' as const]])(
        '%s',
        (type: MessageType) => {
          const controller = new MessageController();
          const message: Message = {
            message: 'Message',
            icon: 'mdi:car',
            type,
          };
          expect(controller.getIcon(message)).toBe('mdi:car');
        },
      );
    });

    it('when type is an error', () => {
      const controller = new MessageController();
      const message: Message = {
        message: 'Message',
        type: 'error',
      };
      expect(controller.getIcon(message)).toBe('mdi:alert-circle');
    });

    it('by default', () => {
      const controller = new MessageController();
      const message: Message = {
        message: 'Message',
      };
      expect(controller.getIcon(message)).toBe('mdi:information-outline');
    });
  });

  describe('should show troubleshooting link', () => {
    it('should show for errors', () => {
      const controller = new MessageController();
      const message: Message = { message: 'Error message', type: 'error' };
      expect(controller.getURL(message)).toEqual({
        link: TROUBLESHOOTING_URL,
        title: localize('error.troubleshooting'),
      });
    });

    describe('should not show for other types', () => {
      it.each([['info' as const], ['connection' as const]])(
        '%s',
        (type: MessageType) => {
          const controller = new MessageController();
          const message: Message = {
            message: 'Message',
            icon: 'mdi:car',
            type,
          };
          expect(controller.getURL(message)).toBeNull();
        },
      );
    });

    describe('should show correct URL', () => {
      it('by default', () => {
        const controller = new MessageController();
        const message: Message = { message: 'Error message', type: 'error' };
        expect(controller.getURL(message)?.link).toBe(TROUBLESHOOTING_URL);
      });

      it('when specified', () => {
        const controller = new MessageController();
        const url: MessageURL = {
          link: 'link',
          title: 'title',
        };
        const message: Message = {
          message: 'Error message',
          type: 'error',
          url,
        };
        expect(controller.getURL(message)).toBe(url);
      });
    });
  });

  describe('should get context strings', () => {
    it('for no context', () => {
      const controller = new MessageController();
      const message: Message = {
        message: 'Message',
        type: 'info',
      };
      expect(controller.getContextStrings(message)).toEqual([]);
    });

    it('for simple string', () => {
      const controller = new MessageController();
      const message: Message = {
        message: 'Message',
        context: 'Context',
        type: 'info',
      };
      expect(controller.getContextStrings(message)).toEqual(['Context']);
    });

    it('for object', () => {
      const controller = new MessageController();
      const obj = { one: 1, two: 2 };
      const message: Message = {
        message: 'Message',
        context: obj,
        type: 'info',
      };
      expect(controller.getContextStrings(message)).toEqual([yaml.dump(obj)]);
    });

    it('for array', () => {
      const controller = new MessageController();
      const array = ['one', 'two'];
      const message: Message = {
        message: 'Message',
        context: array,
        type: 'info',
      };
      expect(controller.getContextStrings(message)).toEqual(
        array.map((item) => yaml.dump(item)),
      );
    });
  });
});



================================================
FILE: tests/components-lib/message/dispatch.test.ts
================================================
import { expect, it, vi } from 'vitest';
import { dispatchAdvancedCameraCardErrorEvent } from '../../../src/components-lib/message/dispatch';
import { AdvancedCameraCardError } from '../../../src/types';

// @vitest-environment jsdom
it('should ignore non-error', () => {
  const element = document.createElement('div');
  const handler = vi.fn();
  element.addEventListener('advanced-camera-card:message', handler);

  dispatchAdvancedCameraCardErrorEvent(element, 'NOT_ADVANCED_CAMERA_CARD_EVENT');

  expect(handler).not.toBeCalled();
});

it('should dispatch error', () => {
  const element = document.createElement('div');
  const handler = vi.fn();
  element.addEventListener('advanced-camera-card:message', handler);

  dispatchAdvancedCameraCardErrorEvent(element, new Error('ERROR'));

  expect(handler).toBeCalledWith(
    expect.objectContaining({
      detail: expect.objectContaining({
        message: 'ERROR',
      }),
    }),
  );
});

it('should dispatch error with context', () => {
  const element = document.createElement('div');
  const handler = vi.fn();
  element.addEventListener('advanced-camera-card:message', handler);

  dispatchAdvancedCameraCardErrorEvent(
    element,
    new AdvancedCameraCardError('ERROR', 'CONTEXT'),
  );

  expect(handler).toBeCalledWith(
    expect.objectContaining({
      detail: expect.objectContaining({
        message: 'ERROR',
        context: 'CONTEXT',
      }),
    }),
  );
});



================================================
FILE: tests/components-lib/ptz/ptz-controller.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { Capabilities } from '../../../src/camera-manager/capabilities';
import { PTZController } from '../../../src/components-lib/ptz/ptz-controller';
import { PTZControlAction } from '../../../src/config/schema/actions/custom/ptz';
import {
  PTZControlsConfig,
  ptzControlsConfigSchema,
} from '../../../src/config/schema/common/controls/ptz';
import { PTZMovementType } from '../../../src/types';
import { createCameraManager, createCapabilities, createStore } from '../../test-utils';

const createConfig = (config?: Partial<PTZControlsConfig>): PTZControlsConfig => {
  return ptzControlsConfigSchema.parse({
    ...config,
  });
};

// @vitest-environment jsdom
describe('PTZController', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  it('should be creatable', () => {
    const controller = new PTZController(document.createElement('div'));
    expect(controller).toBeTruthy();
  });

  it('should get config', () => {
    const controller = new PTZController(document.createElement('div'));
    const config = createConfig();
    controller.setConfig(config);
    expect(controller.getConfig()).toBe(config);
  });

  describe('should set element attributes', () => {
    describe('orientation', () => {
      describe('with config', () => {
        it.each([['horizontal' as const], ['vertical' as const]])(
          '%s',
          (orientation: 'horizontal' | 'vertical') => {
            const element = document.createElement('div');
            const controller = new PTZController(element);
            controller.setConfig(createConfig({ orientation: orientation }));
            expect(element.getAttribute('data-orientation')).toBe(orientation);
          },
        );
      });
      it('without config', () => {
        const element = document.createElement('div');
        const controller = new PTZController(element);
        controller.setConfig();
        expect(element.getAttribute('data-orientation')).toBe('horizontal');
      });
    });
    describe('position', () => {
      describe('with config', () => {
        it.each([
          ['top-left' as const],
          ['top-right' as const],
          ['bottom-left' as const],
          ['bottom-right' as const],
        ])(
          '%s',
          (position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right') => {
            const element = document.createElement('div');
            const controller = new PTZController(element);
            controller.setConfig(createConfig({ position: position }));
            expect(element.getAttribute('data-position')).toBe(position);
          },
        );
      });
      it('without config', () => {
        const element = document.createElement('div');
        const controller = new PTZController(element);
        controller.setConfig();
        expect(element.getAttribute('data-position')).toBe('bottom-right');
      });
    });
    it('with style in config', () => {
      const element = document.createElement('div');
      const controller = new PTZController(element);
      controller.setConfig(createConfig({ style: { transform: 'none', left: '50%' } }));
      expect(element.getAttribute('style')).toBe('transform:none;left:50%');
    });
  });

  describe('should respect mode', () => {
    it('off', () => {
      const controller = new PTZController(document.createElement('div'));
      expect(controller.shouldDisplay()).toBeFalsy();
    });
    it('forced on', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setForceVisibility(true);

      expect(controller.shouldDisplay()).toBeTruthy();
    });
    it('forced off', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setForceVisibility(false);
      expect(controller.shouldDisplay()).toBeFalsy();
    });

    it('configured on', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig({ mode: 'on' }));
      expect(controller.shouldDisplay()).toBeTruthy();
    });
    it('configured off', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig({ mode: 'off' }));
      expect(controller.shouldDisplay()).toBeFalsy();
    });

    it('auto without capability', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig({ mode: 'auto' }));
      controller.setCamera(createCameraManager(), 'camera.office');
      expect(controller.shouldDisplay()).toBeFalsy();
    });
    it('auto with capability', () => {
      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({ ptz: { left: [PTZMovementType.Relative] } }),
        },
      ]);
      const cameraManager = createCameraManager(store);
      vi.mocked(cameraManager).getCameraCapabilities.mockReturnValue(
        createCapabilities({
          ptz: {
            left: [PTZMovementType.Relative],
          },
        }),
      );

      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig({ mode: 'auto' }));
      controller.setCamera(cameraManager, 'camera.office');
      expect(controller.shouldDisplay()).toBeTruthy();
    });
  });

  describe('should get PTZ actions', () => {
    it.each([
      ['left' as const],
      ['right' as const],
      ['up' as const],
      ['down' as const],
      ['zoom_in' as const],
      ['zoom_out' as const],
    ])('%s', (actionName: PTZControlAction) => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig());

      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Relative],
              right: [PTZMovementType.Relative],
              up: [PTZMovementType.Relative],
              down: [PTZMovementType.Relative],
              zoomIn: [PTZMovementType.Relative],
              zoomOut: [PTZMovementType.Relative],
            },
          }),
        },
      ]);

      const cameraManager = createCameraManager(store);
      controller.setCamera(cameraManager, 'camera.office');

      expect(controller.getPTZActions()?.[actionName]).toEqual({
        start_tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_multi',
          ptz_action: actionName,
          ptz_phase: 'start',
        },
        end_tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_multi',
          ptz_action: actionName,
          ptz_phase: 'stop',
        },
      });
    });

    it('home', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig());

      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              left: [PTZMovementType.Relative],
              right: [PTZMovementType.Relative],
              up: [PTZMovementType.Relative],
              down: [PTZMovementType.Relative],
              zoomIn: [PTZMovementType.Relative],
              zoomOut: [PTZMovementType.Relative],
              presets: ['door', 'window'],
            },
          }),
        },
      ]);

      const cameraManager = createCameraManager(store);
      controller.setCamera(cameraManager, 'camera.office');

      expect(controller.getPTZActions()['home']).toEqual({
        tap_action: {
          action: 'fire-dom-event',
          advanced_camera_card_action: 'ptz_multi',
        },
      });
    });

    it('only presets', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig());

      const store = createStore([
        {
          cameraID: 'camera.office',
          capabilities: new Capabilities({
            ptz: {
              presets: ['door', 'window'],
            },
          }),
        },
      ]);

      const cameraManager = createCameraManager(store);
      controller.setCamera(cameraManager, 'camera.office');

      expect(controller.getPTZActions()['presets']).toEqual([
        {
          actions: {
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'ptz_multi',
              ptz_action: 'preset',
              ptz_preset: 'door',
            },
          },
          preset: 'door',
        },
        {
          actions: {
            tap_action: {
              action: 'fire-dom-event',
              advanced_camera_card_action: 'ptz_multi',
              ptz_action: 'preset',
              ptz_preset: 'window',
            },
          },
          preset: 'window',
        },
      ]);
    });

    it('should return digital PTZ actions without camera capabilities', () => {
      const controller = new PTZController(document.createElement('div'));
      controller.setConfig(createConfig());

      expect(controller.getPTZActions()).toEqual({
        down: {
          end_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'down',
            ptz_phase: 'stop',
          },
          start_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'down',
            ptz_phase: 'start',
          },
        },
        home: {
          tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
          },
        },
        left: {
          end_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'left',
            ptz_phase: 'stop',
          },
          start_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'left',
            ptz_phase: 'start',
          },
        },
        right: {
          end_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'right',
            ptz_phase: 'stop',
          },
          start_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'right',
            ptz_phase: 'start',
          },
        },
        up: {
          end_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'up',
            ptz_phase: 'stop',
          },
          start_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'up',
            ptz_phase: 'start',
          },
        },
        zoom_in: {
          end_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'zoom_in',
            ptz_phase: 'stop',
          },
          start_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'zoom_in',
            ptz_phase: 'start',
          },
        },
        zoom_out: {
          end_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'zoom_out',
            ptz_phase: 'stop',
          },
          start_tap_action: {
            action: 'fire-dom-event',
            advanced_camera_card_action: 'ptz_multi',
            ptz_action: 'zoom_out',
            ptz_phase: 'start',
          },
        },
      });
    });
  });

  describe('should handle action', () => {
    it('successfully', () => {
      const action = {
        action: 'more-info' as const,
      };
      const config = {
        tap_action: action,
        camera_entity: 'camera.office',
      };

      const element = document.createElement('div');
      const handler = vi.fn();
      element.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new PTZController(element);
      controller.setCamera();
      controller.handleAction(
        new CustomEvent<{ action: string }>('@action', { detail: { action: 'tap' } }),
        config,
      );

      expect(handler).toBeCalledWith(
        expect.objectContaining({
          detail: {
            actions: action,
            config: config,
          },
        }),
      );
    });

    it('should not call action without actions config', () => {
      const element = document.createElement('div');
      const handler = vi.fn();
      element.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new PTZController(element);
      controller.setCamera();
      controller.handleAction(
        new CustomEvent<{ action: string }>('@action', { detail: { action: 'tap' } }),
      );

      expect(handler).not.toBeCalled();
    });

    it('should not call action without hass', () => {
      const element = document.createElement('div');
      const handler = vi.fn();
      element.addEventListener('advanced-camera-card:action:execution-request', handler);

      const controller = new PTZController(element);
      controller.setCamera();
      controller.handleAction(
        new CustomEvent<{ action: string }>('@action', { detail: { action: 'tap' } }),
      );

      expect(handler).not.toBeCalled();
    });
  });
});



================================================
FILE: tests/components-lib/thumbnail/details-controller.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CameraManager } from '../../../src/camera-manager/manager';
import { ThumbnailDetailsController } from '../../../src/components-lib/thumbnail/details-controller';
import { ViewFolder, ViewMediaType } from '../../../src/view/item';
import { createFolder, TestViewMedia } from '../../test-utils';

describe('ThumbnailDetailsController', () => {
  describe('should set heading', () => {
    it('should set heading on event with what, tags and score', () => {
      const item = new TestViewMedia({
        what: ['person', 'car'],
        tags: ['tag1', 'tag2'],
        score: 0.5,
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getHeading()).toBe('Person, Car: Tag1, Tag2 50.00%');
    });

    it('should set heading on event with tags', () => {
      const item = new TestViewMedia({
        tags: ['tag1', 'tag2'],
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getHeading()).toBe('Tag1, Tag2');
    });

    it('should set heading on event with what', () => {
      const item = new TestViewMedia({
        what: ['person', 'car'],
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getHeading()).toBe('Person, Car');
    });

    it('should set null heading on event with no other information', () => {
      const item = new TestViewMedia({
        mediaType: ViewMediaType.Snapshot,
        what: null,
        tags: null,
        score: null,
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getHeading()).toBeNull();
    });

    it('should set heading on recording with camera metadata', () => {
      const cameraManager = mock<CameraManager>();
      cameraManager.getCameraMetadata.mockReturnValue({
        title: 'Camera Title',
        icon: { icon: 'mdi:cow' },
      });

      const item = new TestViewMedia({
        mediaType: ViewMediaType.Recording,
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(cameraManager, item);
      expect(controller.getHeading()).toBe('Camera Title');
    });

    it('should set heading on recording without camera metadata', () => {
      const item = new TestViewMedia({
        mediaType: ViewMediaType.Recording,
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getHeading()).toBeNull();
    });

    it('should set no heading on folder', () => {
      const item = new ViewFolder(createFolder());

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getHeading()).toBeNull();
    });
  });

  describe('should set details', () => {
    describe('should have title in details', () => {
      it('should have icon with title when there are other details', () => {
        const item = new TestViewMedia({
          title: 'Test Event',
          where: ['where1', 'where2'],
        });

        const controller = new ThumbnailDetailsController();
        controller.calculate(null, item);
        expect(controller.getDetails()).toContainEqual({
          title: 'Test Event',
          icon: { icon: 'mdi:rename' },
          hint: 'Title',
        });
      });

      it('should not have icon with title when there are no other details', () => {
        const item = new TestViewMedia({
          title: 'Test Event',
        });

        const controller = new ThumbnailDetailsController();
        controller.calculate(null, item);
        expect(controller.getDetails()).toEqual([
          {
            title: 'Test Event',
          },
        ]);
      });

      it('should not have title with a start time', () => {
        const item = new TestViewMedia({
          title: 'Test Event',
          startTime: new Date('2025-05-22T21:12:00Z'),
        });

        const controller = new ThumbnailDetailsController();
        controller.calculate(null, item);
        expect(controller.getDetails()).not.toContainEqual(
          expect.objectContaining({
            title: 'Test Event',
          }),
        );
      });
    });

    it('should have start time in details', () => {
      const item = new TestViewMedia({
        startTime: new Date('2025-05-18T17:03:00Z'),
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getDetails()).toContainEqual({
        title: '2025-05-18 17:03:00',
        hint: 'Start',
        icon: { icon: 'mdi:calendar-clock-outline' },
      });
    });

    describe('should have duration in details', () => {
      it('should have duration in details', () => {
        const item = new TestViewMedia({
          startTime: new Date('2025-05-18T17:03:00Z'),
          endTime: new Date('2025-05-18T17:04:00Z'),
        });

        const controller = new ThumbnailDetailsController();
        controller.calculate(null, item);
        expect(controller.getDetails()).toContainEqual({
          title: '1m 0s',
          hint: 'Duration',
          icon: { icon: 'mdi:clock-outline' },
        });
      });

      it('should have in-progress in details', () => {
        const item = new TestViewMedia({
          startTime: new Date('2025-05-18T17:03:00Z'),
          endTime: null,
          inProgress: true,
        });

        const controller = new ThumbnailDetailsController();
        controller.calculate(null, item);
        expect(controller.getDetails()).toContainEqual({
          title: 'In Progress',
          hint: 'Duration',
          icon: { icon: 'mdi:clock-outline' },
        });
      });

      it('should have duration and in-progress in details', () => {
        const item = new TestViewMedia({
          startTime: new Date('2025-05-18T17:03:00Z'),
          endTime: new Date('2025-05-18T17:04:00Z'),
          inProgress: true,
        });

        const controller = new ThumbnailDetailsController();
        controller.calculate(null, item);
        expect(controller.getDetails()).toContainEqual({
          title: '1m 0s In Progress',
          hint: 'Duration',
          icon: { icon: 'mdi:clock-outline' },
        });
      });
    });

    it('should have camera title in details', () => {
      const cameraManager = mock<CameraManager>();
      cameraManager.getCameraMetadata.mockReturnValue({
        title: 'Camera Title',
        icon: { icon: 'mdi:cow' },
      });

      const item = new TestViewMedia({
        cameraID: 'camera_1',
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(cameraManager, item);
      expect(controller.getDetails()).toContainEqual({
        title: 'Camera Title',
        hint: 'Camera',
        icon: { icon: 'mdi:cctv' },
      });
    });

    it('should have where in details', () => {
      const item = new TestViewMedia({
        cameraID: 'camera_1',
        where: ['where1', 'where2'],
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getDetails()).toContainEqual({
        title: 'Where1, Where2',
        hint: 'Where',
        icon: { icon: 'mdi:map-marker-outline' },
      });
    });

    it('should have tags in details', () => {
      const item = new TestViewMedia({
        cameraID: 'camera_1',
        tags: ['tag1', 'tag2'],
      });

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item);
      expect(controller.getDetails()).toContainEqual({
        title: 'Tag1, Tag2',
        hint: 'Tag',
        icon: { icon: 'mdi:tag' },
      });
    });

    it('should have seek in details', () => {
      const item = new TestViewMedia();

      const controller = new ThumbnailDetailsController();
      controller.calculate(null, item, new Date('2025-05-20T07:14:57Z'));
      expect(controller.getDetails()).toContainEqual({
        title: '07:14:57',
        hint: 'Seek',
        icon: { icon: 'mdi:clock-fast' },
      });
    });
  });
});



================================================
FILE: tests/components-lib/thumbnail/feature/controller.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { CameraManager } from '../../../../src/camera-manager/manager';
import { ThumbnailFeatureController } from '../../../../src/components-lib/thumbnail/feature/controller';
import { ViewFolder } from '../../../../src/view/item';
import { createFolder, TestViewMedia } from '../../../test-utils';

describe('ThumbnailFeatureController', () => {
  const itemWithTime = new TestViewMedia({
    startTime: new Date('2025-05-18T17:03:00Z'),
    title: 'Test Event',
    cameraID: 'camera_1',
  });

  describe('should set title', () => {
    it('should set title with start time ', () => {
      const controller = new ThumbnailFeatureController();

      controller.calculate(null, itemWithTime, false);

      expect(controller.getTitle()).toBe('17:03');
    });

    it('should not set title when details are shown ', () => {
      const controller = new ThumbnailFeatureController();

      controller.calculate(null, itemWithTime, true);

      expect(controller.getTitle()).toBeNull();
    });

    it('should not set title on media with a thumbnail', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new TestViewMedia({
        startTime: new Date('2025-05-18T17:03:00Z'),
        title: 'Test Event',
        cameraID: 'camera_1',
        thumbnail: 'thumbnail',
      });

      controller.calculate(null, itemWithThumbnail, true);

      expect(controller.getTitle()).toBeNull();
    });
  });

  describe('should set subtitles', () => {
    it('should set subtitle with start date ', () => {
      const controller = new ThumbnailFeatureController();

      controller.calculate(null, itemWithTime, false);

      expect(controller.getSubtitles()).toContain('May 18th');
    });

    it('should set subtitle with source from item title ', () => {
      const controller = new ThumbnailFeatureController();

      controller.calculate(null, itemWithTime, false);

      expect(controller.getSubtitles()).toContain('Test Event');
    });

    it('should set subtitle with source from camera title ', () => {
      const controller = new ThumbnailFeatureController();

      const cameraManager = mock<CameraManager>();
      cameraManager.getCameraMetadata.mockReturnValue({
        title: 'Camera 1',
        icon: { icon: 'mdi:camera' },
      });

      const itemWithoutTitle = new TestViewMedia({
        startTime: new Date('2025-05-18T17:03:00Z'),
        title: null,
        cameraID: 'camera_1',
      });

      controller.calculate(cameraManager, itemWithoutTitle, false);

      expect(controller.getSubtitles()).toContain('Camera 1');
    });

    it('should set subtitle falling back to item title when cameraID not found', () => {
      const controller = new ThumbnailFeatureController();

      const item = new TestViewMedia({
        title: 'Title',
        cameraID: null,
      });

      controller.calculate(null, item, false);

      expect(controller.getSubtitles()).toContain('Title');
    });

    it('should not set subtitle on media with a thumbnail', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new TestViewMedia({
        startTime: new Date('2025-05-18T17:03:00Z'),
        title: 'Test Event',
        cameraID: 'camera_1',
        thumbnail: 'thumbnail',
      });

      controller.calculate(null, itemWithThumbnail, false);

      expect(controller.getSubtitles()).toEqual([]);
    });

    it('should not set subtitle on folder media', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new ViewFolder(createFolder(), {
        title: 'Test Folder',
      });

      controller.calculate(null, itemWithThumbnail, false);

      expect(controller.getSubtitles()).toContain('Test Folder');
    });
  });

  describe('should set icon', () => {
    it('should set icon without a thumbnail', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new TestViewMedia({
        thumbnail: null,
        icon: 'mdi:cow',
      });

      controller.calculate(null, itemWithThumbnail, false);

      expect(controller.getIcon()).toBe('mdi:cow');
    });

    it('should not set icon when there is a thumbnail', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new TestViewMedia({
        thumbnail: 'thumbnail',
        icon: 'mdi:cow',
      });

      controller.calculate(null, itemWithThumbnail, false);

      expect(controller.getIcon()).toBeNull();
    });
  });

  describe('should set thumbnail', () => {
    it('should set brand thumbnail', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new TestViewMedia({
        thumbnail: 'https://brands.home-assistant.io//amcrest/icon.png',
      });

      controller.calculate(null, itemWithThumbnail, false);

      expect(controller.getThumbnail()).toBe(
        'https://brands.home-assistant.io/brands/_/amcrest/icon.png',
      );
      expect(controller.getThumbnailClass()).toBe('brand');
    });

    it('should set other thumbnail', () => {
      const controller = new ThumbnailFeatureController();
      const itemWithThumbnail = new TestViewMedia({
        thumbnail: 'https://card.camera/thumbnail.jpg',
      });

      controller.calculate(null, itemWithThumbnail, false);

      expect(controller.getThumbnail()).toBe('https://card.camera/thumbnail.jpg');
      expect(controller.getThumbnailClass()).toBeNull();
    });
  });
});



================================================
FILE: tests/components-lib/zoom/zoom-controller.test.ts
================================================
import Panzoom, { PanzoomEventDetail, PanzoomObject } from '@dermotduffy/panzoom';
import { beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock, mockClear } from 'vitest-mock-extended';
import { ZoomController } from '../../../src/components-lib/zoom/zoom-controller';
import {
  ResizeObserverMock,
  createTouch,
  createTouchEvent,
  requestAnimationFrameMock,
} from '../../test-utils';

vi.mock('@dermotduffy/panzoom');
vi.mock('lodash-es', () => ({
  round: vi.fn((fn) => fn),
  throttle: vi.fn((fn) => fn),
}));

// https://github.com/jsdom/jsdom/issues/2527
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(window as any).PointerEvent = MouseEvent;

const triggerResizeObserver = (): void => {
  const resizeObserverTrigger = vi.mocked(global.ResizeObserver).mock.calls[0][0];
  resizeObserverTrigger([], mock<ResizeObserver>());
};

const setElementToDefaultCardSize = (element: HTMLElement, multiple?: number): void => {
  element.getBoundingClientRect = vi.fn().mockReturnValue({
    width: 492 * (multiple ?? 1),
    height: 276.75 * (multiple ?? 1),
  });
};

// @vitest-environment jsdom
describe('ZoomController', () => {
  const mediaSpy = vi.spyOn(window, 'matchMedia');

  const createMockPanZoom = (): PanzoomObject => {
    const panzoom = mock<PanzoomObject>();
    panzoom.getScale.mockReturnValue(1.0);
    panzoom.getPan.mockReturnValue({ x: 0, y: 0 });
    return panzoom;
  };

  const createAndRegisterZoom = (element: HTMLElement): ZoomController => {
    const zoom = new ZoomController(element);
    zoom.activate();
    return zoom;
  };

  beforeAll(() => {
    vi.stubGlobal('ResizeObserver', ResizeObserverMock);
    window.requestAnimationFrame = requestAnimationFrameMock;
  });

  beforeEach(() => {
    vi.mocked(Panzoom).mockReset();
    vi.mocked(global.ResizeObserver).mockClear();
    mediaSpy.mockReturnValue(<MediaQueryList>{ matches: true });
  });

  it('should be creatable', () => {
    const element = document.createElement('div');
    const zoom = new ZoomController(element);
    expect(zoom).toBeTruthy();
  });

  describe('should pan and zoom', () => {
    it('should respond with pointer', () => {
      const element = document.createElement('div');

      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      createAndRegisterZoom(element);

      // Won't zoom without control key.
      const ev_1 = new WheelEvent('wheel', { bubbles: false, deltaY: -120 });
      element.dispatchEvent(ev_1);
      expect(panzoom.zoomWithWheel).not.toBeCalled();

      const ev_2 = new WheelEvent('wheel', {
        bubbles: false,
        deltaY: -120,
        ctrlKey: true,
      });
      element.dispatchEvent(ev_2);
      expect(panzoom.zoomWithWheel).toBeCalledWith(ev_2);

      panzoom.getScale = vi.fn().mockReturnValue(1.2);

      const ev_3 = new PointerEvent('pointerdown');
      element.dispatchEvent(ev_3);
      expect(panzoom.handleDown).toBeCalledWith(ev_3);

      const ev_4 = new PointerEvent('pointermove');
      element.dispatchEvent(ev_4);
      expect(panzoom.handleMove).toBeCalledWith(ev_4);

      const ev_5 = new PointerEvent('pointerup');
      element.dispatchEvent(ev_5);
      expect(panzoom.handleUp).toBeCalledWith(ev_5);
    });

    it('should not respond to pointer when not zoomed', () => {
      const element = document.createElement('div');

      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      createAndRegisterZoom(element);

      const ev_1 = new PointerEvent('pointerdown');
      element.dispatchEvent(ev_1);
      expect(panzoom.handleDown).not.toBeCalledWith(ev_1);

      const ev_2 = new PointerEvent('pointermove');
      element.dispatchEvent(ev_2);
      expect(panzoom.handleDown).not.toBeCalledWith(ev_2);

      const ev_3 = new PointerEvent('pointerup');
      element.dispatchEvent(ev_3);
      expect(panzoom.handleDown).not.toBeCalledWith(ev_3);
    });

    it('should respond with touch', () => {
      mediaSpy.mockReturnValue(<MediaQueryList>{ matches: false });

      const element = document.createElement('div');

      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      createAndRegisterZoom(element);

      const ev_1 = createTouchEvent('touchstart', {
        touches: [createTouch({ target: element }), createTouch({ target: element })],
      });
      element.dispatchEvent(ev_1);
      expect(panzoom.handleDown).toBeCalledWith(ev_1);

      panzoom.getScale = vi.fn().mockReturnValue(1.2);

      const ev_3 = createTouchEvent('touchstart');
      element.dispatchEvent(ev_3);
      expect(panzoom.handleDown).toBeCalledWith(ev_3);

      const ev_4 = createTouchEvent('touchmove');
      element.dispatchEvent(ev_4);
      expect(panzoom.handleMove).toBeCalledWith(ev_4);

      const ev_5 = createTouchEvent('touchend');
      element.dispatchEvent(ev_5);
      expect(panzoom.handleUp).toBeCalledWith(ev_5);
    });
  });

  it('should ignore click after pointerdown', () => {
    const outer = document.createElement('div');
    const inner = document.createElement('div');
    outer.appendChild(inner);
    const clickHandler = vi.fn();
    outer.addEventListener('click', clickHandler);

    const panzoom = createMockPanZoom();
    vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

    createAndRegisterZoom(inner);

    // Simulate being zoomed in.
    panzoom.getScale = vi.fn().mockReturnValue(1.2);

    // A click on its own will be fine.
    const click_1 = new MouseEvent('click', { bubbles: true });
    inner.dispatchEvent(click_1);
    expect(clickHandler).toBeCalledTimes(1);

    // A click after a pointerdown will be ignored.
    const pointerdown_1 = new PointerEvent('pointerdown');
    inner.dispatchEvent(pointerdown_1);

    const click_2 = new MouseEvent('click', { bubbles: true });
    inner.dispatchEvent(click_2);

    // Click will have been ignored.
    //expect(clickHandler).toBeCalledTimes(1);

    // Simulate being zoomed out.
    panzoom.getScale = vi.fn().mockReturnValue(1.0);
    const pointerdown_2 = new PointerEvent('pointerdown');
    inner.dispatchEvent(pointerdown_2);

    const click_3 = new MouseEvent('click', { bubbles: true });
    inner.dispatchEvent(click_3);

    // Click will have been processed.
    expect(clickHandler).toBeCalledTimes(2);
  });

  it('deactivate should remove event handlers', () => {
    const element = document.createElement('div');

    const panzoom = createMockPanZoom();
    vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

    createAndRegisterZoom(element).deactivate();

    const ev_1 = new WheelEvent('wheel', {
      bubbles: false,
      deltaY: -120,
      ctrlKey: true,
    });
    element.dispatchEvent(ev_1);
    expect(panzoom.zoomWithWheel).not.toBeCalled();
  });

  describe('should fire events', () => {
    it('on zoom/unzoom', () => {
      const element = document.createElement('div');
      const zoomedFunc = vi.fn();
      const unzoomedFunc = vi.fn();
      element.addEventListener('advanced-camera-card:zoom:zoomed', zoomedFunc);
      element.addEventListener('advanced-camera-card:zoom:unzoomed', unzoomedFunc);

      vi.mocked(Panzoom).mockReturnValueOnce(createMockPanZoom());
      createAndRegisterZoom(element);

      const ev_1 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
        detail: {
          x: 0,
          y: 0,
          scale: 1.2,
          isSVG: false,
          originalEvent: new PointerEvent('pointermove'),
        },
      });
      element.dispatchEvent(ev_1);
      expect(zoomedFunc).toBeCalled();
      expect(unzoomedFunc).not.toBeCalled();

      const ev_2 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
        detail: {
          x: 0,
          y: 0,
          scale: 1,
          isSVG: false,
          originalEvent: new PointerEvent('pointermove'),
        },
      });
      element.dispatchEvent(ev_2);
      expect(unzoomedFunc).toBeCalled();
    });

    it('when state has not changed or spurious events received', () => {
      const element = document.createElement('div');
      const zoomedFunc = vi.fn();
      const unzoomedFunc = vi.fn();
      element.addEventListener('advanced-camera-card:zoom:zoomed', zoomedFunc);
      element.addEventListener('advanced-camera-card:zoom:unzoomed', unzoomedFunc);

      vi.mocked(Panzoom).mockReturnValueOnce(createMockPanZoom());
      createAndRegisterZoom(element);

      const ev_1 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
        detail: {
          x: 0,
          y: 0,
          scale: 1,
          isSVG: false,
          originalEvent: new PointerEvent('pointermove'),
        },
      });
      element.dispatchEvent(ev_1);

      // Unzoomed event with scale === 1, this._zoomed will already be false.
      expect(unzoomedFunc).not.toBeCalled();
      expect(zoomedFunc).not.toBeCalled();

      const ev_2 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
        detail: {
          x: 0,
          y: 0,
          scale: 1.2,
          isSVG: false,
          originalEvent: new PointerEvent('pointermove'),
        },
      });
      element.dispatchEvent(ev_2);
      expect(zoomedFunc).toBeCalledTimes(1);
      expect(unzoomedFunc).not.toBeCalled();

      // Another call when already zoomed will be ignored.
      element.dispatchEvent(ev_2);
      expect(zoomedFunc).toBeCalledTimes(1);
    });

    describe('on default/non-default', () => {
      it('without explicit default', () => {
        const element = document.createElement('div');
        setElementToDefaultCardSize(element);

        const changeFunc = vi.fn();
        element.addEventListener('advanced-camera-card:zoom:change', changeFunc);

        vi.mocked(Panzoom).mockReturnValueOnce(createMockPanZoom());
        createAndRegisterZoom(element);

        const ev_1 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
          detail: {
            x: 0,
            y: 0,
            scale: 1.2,
            isSVG: false,
            originalEvent: new PointerEvent('pointermove'),
          },
        });
        element.dispatchEvent(ev_1);

        expect(changeFunc).toHaveBeenLastCalledWith(
          expect.objectContaining({
            detail: expect.objectContaining({ isDefault: false }),
          }),
        );

        const ev_2 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
          detail: {
            x: 50,
            y: 50,
            scale: 1,
            isSVG: false,
            originalEvent: new PointerEvent('pointermove'),
          },
        });
        element.dispatchEvent(ev_2);

        expect(changeFunc).toHaveBeenLastCalledWith(
          expect.objectContaining({
            detail: expect.objectContaining({ isDefault: true }),
          }),
        );
      });

      it('with complete explicit default', () => {
        const element = document.createElement('div');
        setElementToDefaultCardSize(element);

        const changeFunc = vi.fn();
        element.addEventListener('advanced-camera-card:zoom:change', changeFunc);

        vi.mocked(Panzoom).mockReturnValueOnce(createMockPanZoom());
        const controller = createAndRegisterZoom(element);
        controller.setDefaultSettings({ zoom: 2, pan: { x: 3, y: 4 } });

        const ev_1 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
          detail: {
            x: 50,
            y: 50,
            scale: 1,
            isSVG: false,
            originalEvent: new PointerEvent('pointermove'),
          },
        });
        element.dispatchEvent(ev_1);

        expect(changeFunc).toHaveBeenLastCalledWith(
          expect.objectContaining({
            detail: expect.objectContaining({ isDefault: false }),
          }),
        );

        const ev_2 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
          detail: {
            x: 115.62,
            y: 63.6525,
            scale: 2,
            isSVG: false,
            originalEvent: new PointerEvent('pointermove'),
          },
        });
        element.dispatchEvent(ev_2);

        expect(changeFunc).toHaveBeenLastCalledWith(
          expect.objectContaining({
            detail: expect.objectContaining({ isDefault: true }),
          }),
        );
      });

      it('with partial explicit default', () => {
        const element = document.createElement('div');
        setElementToDefaultCardSize(element);

        const changeFunc = vi.fn();
        element.addEventListener('advanced-camera-card:zoom:change', changeFunc);

        vi.mocked(Panzoom).mockReturnValueOnce(createMockPanZoom());
        const controller = createAndRegisterZoom(element);

        const ev_1 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
          detail: {
            x: 51,
            y: 51,
            scale: 2,
            isSVG: false,
            originalEvent: new PointerEvent('pointermove'),
          },
        });
        element.dispatchEvent(ev_1);

        expect(changeFunc).toHaveBeenLastCalledWith(
          expect.objectContaining({
            detail: expect.objectContaining({ isDefault: false }),
          }),
        );

        controller.setDefaultSettings({});

        const ev_2 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
          detail: {
            x: 50,
            y: 50,
            scale: 1,
            isSVG: false,
            originalEvent: new PointerEvent('pointermove'),
          },
        });
        element.dispatchEvent(ev_2);

        expect(changeFunc).toHaveBeenLastCalledWith(
          expect.objectContaining({
            detail: expect.objectContaining({ isDefault: true }),
          }),
        );
      });
    });
  });

  describe('should automatically set correct zoom', () => {
    it('with start', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      const controller = new ZoomController(element);
      controller.setDefaultSettings({ zoom: 2, pan: { x: 3, y: 4 } });

      // Controller was not activated, config setting will not update pan/zoom.
      expect(panzoom.zoom).not.toBeCalled();
      expect(panzoom.pan).not.toBeCalled();

      controller.activate();
      expect(Panzoom).toBeCalledWith(
        expect.anything(),
        expect.objectContaining({
          contain: 'outside',
          cursor: undefined,
          maxScale: 10,
          minScale: 1,
          noBind: true,
          touchAction: '',
          startScale: 2,
          startX: 115.62,
          startY: 63.6525,
        }),
      );
    });

    it('with set of default config', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      const controller = createAndRegisterZoom(element);
      controller.setDefaultSettings({ zoom: 2, pan: { x: 3, y: 4 } });

      triggerResizeObserver();

      expect(panzoom.zoom).toBeCalledWith(2, { animate: false });
      expect(panzoom.pan).toBeCalledWith(115.62, 63.6525, {
        animate: true,
        duration: 100,
      });
    });

    it('with set of config when a default is already set', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      const controller = createAndRegisterZoom(element);

      // This call will do nothing since this is what zoom/pan already are.
      controller.setDefaultSettings({ zoom: 1, pan: { x: 0, y: 0 } });

      expect(panzoom.zoom).not.toBeCalled();
      expect(panzoom.pan).not.toBeCalled();

      controller.setDefaultSettings({ zoom: 2, pan: { x: 3, y: 4 } });

      expect(panzoom.zoom).toHaveBeenNthCalledWith(1, 2, { animate: false });
      expect(panzoom.pan).toHaveBeenNthCalledWith(1, 115.62, 63.6525, {
        animate: true,
        duration: 100,
      });

      controller.setSettings({ zoom: 3, pan: { x: 5, y: 6 } });

      expect(panzoom.zoom).toHaveBeenNthCalledWith(2, 3, { animate: false });
      expect(panzoom.pan).toHaveBeenNthCalledWith(2, 147.6, 81.18, {
        animate: true,
        duration: 100,
      });
    });

    it('with repeated calls with same values', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      const controller = createAndRegisterZoom(element);

      controller.setSettings({ zoom: 1 });
      expect(panzoom.zoom).not.toHaveBeenCalled();

      controller.setSettings({ pan: { x: 50, y: 50 } });
      expect(panzoom.zoom).not.toHaveBeenCalled();

      controller.setSettings({ zoom: 1, pan: { x: 50, y: 50 } });
      expect(panzoom.zoom).not.toHaveBeenCalled();

      controller.setSettings({});
      expect(panzoom.zoom).not.toHaveBeenCalled();

      controller.setSettings({ zoom: 2 });

      expect(panzoom.zoom).toBeCalledTimes(1);
      expect(panzoom.pan).toBeCalledTimes(1);
      expect(panzoom.zoom).toHaveBeenNthCalledWith(1, 2, { animate: false });
      expect(panzoom.pan).toHaveBeenNthCalledWith(1, 0, 0, {
        animate: true,
        duration: 100,
      });

      vi.mocked(panzoom.getScale).mockReturnValue(2);
      vi.mocked(panzoom.getPan).mockReturnValue({ x: 0, y: 0 });
      controller.setSettings({ zoom: 2 });

      expect(panzoom.zoom).toBeCalledTimes(1);
      expect(panzoom.pan).toBeCalledTimes(1);
    });

    it('when config is set to empty', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      const controller = createAndRegisterZoom(element);
      controller.setDefaultSettings({ zoom: 2, pan: { x: 3, y: 4 } });
      mockClear(panzoom);

      controller.setSettings({});

      // Should fall back to default.
      expect(panzoom.zoom).toBeCalledWith(2, { animate: false });
      expect(panzoom.pan).toBeCalledWith(115.62, 63.6525, {
        animate: true,
        duration: 100,
      });
    });

    it('when resized', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      const controller = createAndRegisterZoom(element);
      controller.setSettings({ zoom: 2, pan: { x: 3, y: 4 } });

      expect(panzoom.zoom).toHaveBeenNthCalledWith(1, 2, { animate: false });
      expect(panzoom.pan).toHaveBeenNthCalledWith(1, 115.62, 63.6525, {
        animate: true,
        duration: 100,
      });

      vi.mocked(panzoom.getScale).mockReturnValue(2);
      vi.mocked(panzoom.getPan).mockReturnValue({ x: 3, y: 4 });

      setElementToDefaultCardSize(element);
      triggerResizeObserver();

      expect(panzoom.zoom).toHaveBeenNthCalledWith(2, 2, { animate: false });
      expect(panzoom.pan).toHaveBeenNthCalledWith(2, 57.81, 31.82625, {
        animate: true,
        duration: 100,
      });
    });

    it('when not yet activated', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      setElementToDefaultCardSize(element);

      new ZoomController(element);

      triggerResizeObserver();

      expect(panzoom.zoom).not.toBeCalled();
      expect(panzoom.pan).not.toBeCalled();
    });

    it('when element has no size', () => {
      const panzoom = createMockPanZoom();
      vi.mocked(Panzoom).mockReturnValueOnce(panzoom);

      const element = document.createElement('div');
      element.getBoundingClientRect = vi.fn().mockReturnValue({
        width: 0,
        height: 0,
      });
      createAndRegisterZoom(element);

      triggerResizeObserver();

      expect(panzoom.zoom).not.toBeCalled();
      expect(panzoom.pan).not.toBeCalled();
    });
  });

  it('should set touch action on zoom/unzoom', () => {
    const element = document.createElement('div');
    vi.mocked(Panzoom).mockReturnValueOnce(createMockPanZoom());

    createAndRegisterZoom(element);

    const ev_1 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
      detail: {
        x: 0,
        y: 0,
        scale: 1.2,
        isSVG: false,
        originalEvent: new PointerEvent('pointermove'),
      },
    });
    element.dispatchEvent(ev_1);
    expect(element.style.touchAction).toBe('none');

    const ev_2 = new CustomEvent<PanzoomEventDetail>('panzoomchange', {
      detail: {
        x: 0,
        y: 0,
        scale: 1,
        isSVG: false,
        originalEvent: new PointerEvent('pointermove'),
      },
    });
    element.dispatchEvent(ev_2);
    expect(element.style.touchAction).toBeFalsy();
  });
});



================================================
FILE: tests/components-lib/zoom/zoom-view-context.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { MergeContextViewModifier } from '../../../src/card-controller/view/modifiers/merge-context';
import { ViewManager } from '../../../src/card-controller/view/view-manager';
import {
  generateViewContextForZoom,
  handleZoomSettingsObservedEvent,
} from '../../../src/components-lib/zoom/zoom-view-context';

vi.mock('../../../src/card-controller/view/modifiers/merge-context');

describe('generateViewContextForZoom', () => {
  it('with observed', () => {
    expect(
      generateViewContextForZoom('target', {
        observed: {
          pan: { x: 1, y: 2 },
          zoom: 3,
          isDefault: true,
          unzoomed: true,
        },
      }),
    ).toEqual({
      zoom: {
        target: {
          observed: {
            pan: { x: 1, y: 2 },
            zoom: 3,
            isDefault: true,
            unzoomed: true,
          },
          requested: null,
        },
      },
    });
  });

  it('with requested', () => {
    expect(
      generateViewContextForZoom('target', {
        requested: {
          pan: { x: 1, y: 2 },
          zoom: 3,
        },
      }),
    ).toEqual({
      zoom: {
        target: {
          requested: {
            pan: { x: 1, y: 2 },
            zoom: 3,
          },
        },
      },
    });
  });
});

// @vitest-environment jsdom
describe('handleZoomSettingsObservedEvent', () => {
  it('should reject observed zoom settings without viewManager ', () => {
    handleZoomSettingsObservedEvent(
      new CustomEvent('advanced-camera-card:zoom:change', {
        detail: {
          pan: { x: 1, y: 2 },
          zoom: 3,
          isDefault: true,
          unzoomed: true,
        },
      }),
    );

    // No observable effect.
  });

  it('should reject observed zoom settings without target ', () => {
    const viewManager = mock<ViewManager>();

    handleZoomSettingsObservedEvent(
      new CustomEvent('advanced-camera-card:zoom:change', {
        detail: {
          pan: { x: 1, y: 2 },
          zoom: 3,
          isDefault: true,
          unzoomed: true,
        },
      }),
      viewManager,
    );

    expect(viewManager.setViewByParameters).not.toBeCalled();
  });

  it('should handle observed zoom settings ', () => {
    const viewManager = mock<ViewManager>();

    handleZoomSettingsObservedEvent(
      new CustomEvent('advanced-camera-card:zoom:change', {
        detail: {
          pan: { x: 1, y: 2 },
          zoom: 3,
          isDefault: true,
          unzoomed: true,
        },
      }),
      viewManager,
      'target',
    );
    expect(viewManager.setViewByParameters).toBeCalledWith(
      expect.objectContaining({
        modifiers: [expect.any(MergeContextViewModifier)],
      }),
    );

    expect(MergeContextViewModifier).toBeCalledWith({
      zoom: {
        target: {
          observed: { pan: { x: 1, y: 2 }, zoom: 3, isDefault: true, unzoomed: true },
          requested: null,
        },
      },
    });
  });
});



================================================
FILE: tests/conditions/conditions-manager.test.ts
================================================
import { HassEntities } from 'home-assistant-js-websocket';
import { afterEach, describe, expect, it, vi } from 'vitest';
import { MicrophoneState } from '../../src/card-controller/types';
import { ConditionsManager } from '../../src/conditions/conditions-manager';
import { ConditionStateManager } from '../../src/conditions/state-manager';
import { HomeAssistant } from '../../src/ha/types';
import {
  createConfig,
  createHASS,
  createMediaLoadedInfo,
  createStateEntity,
  createUser,
} from '../test-utils';

// @vitest-environment jsdom
describe('ConditionsManager', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('should evaluate conditions', () => {
    describe('with a view condition', () => {
      it('should match named view change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'view' as const, views: ['foo'] }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ view: 'foo' });
        expect(manager.getEvaluation().result).toBeTruthy();
      });

      it('should match any view change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'view' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ view: 'clips' });
        expect(listener).toHaveBeenLastCalledWith({
          result: true,
          triggerData: {
            view: {
              to: 'clips',
            },
          },
        });

        stateManager.setState({ view: 'timeline' });
        expect(listener).toHaveBeenLastCalledWith({
          result: true,
          triggerData: {
            view: {
              from: 'clips',
              to: 'timeline',
            },
          },
        });

        expect(listener).toBeCalledTimes(2);
      });

      it('should not re-trigger without a real change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'view' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ view: 'clips' });
        expect(listener).toHaveBeenCalledTimes(1);

        stateManager.setState({ view: 'clips' });
        expect(listener).toHaveBeenCalledTimes(1);
      });
    });

    it('with fullscreen condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'fullscreen' as const, fullscreen: true }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ fullscreen: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ fullscreen: false });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with expand condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'expand' as const, expand: true }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ expand: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ expand: false });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    describe('with camera condition', () => {
      it('should match named camera change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'camera' as const, cameras: ['bar'] }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ camera: 'bar' });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ camera: 'will-not-match' });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('should match any camera change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'camera' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ camera: 'bar' });
        expect(listener).toHaveBeenLastCalledWith({
          result: true,
          triggerData: {
            camera: {
              to: 'bar',
            },
          },
        });

        stateManager.setState({ camera: 'foo' });
        expect(listener).toHaveBeenLastCalledWith({
          result: true,
          triggerData: {
            camera: {
              from: 'bar',
              to: 'foo',
            },
          },
        });

        expect(listener).toBeCalledTimes(2);
      });

      it('should not re-trigger without a real change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'camera' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ camera: 'bar' });
        expect(listener).toHaveBeenCalledTimes(1);

        stateManager.setState({ camera: 'bar' });
        expect(listener).toHaveBeenCalledTimes(1);
      });
    });

    describe('with stock HA conditions', () => {
      describe('with state condition', () => {
        it('neither positive nor negative', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                condition: 'state' as const,
                entity: 'binary_sensor.foo',
              },
            ],
            stateManager,
          );
          const listener = vi.fn();
          manager.addListener(listener);

          stateManager.setState({
            hass: createHASS({
              'binary_sensor.foo': createStateEntity({ state: 'on' }),
            }),
          });
          expect(listener).toBeCalledWith({
            result: true,
            triggerData: {
              state: {
                entity: 'binary_sensor.foo',
                to: 'on',
              },
            },
          });
          expect(listener).toBeCalledTimes(1);

          stateManager.setState({
            hass: createHASS({
              'binary_sensor.foo': createStateEntity({ state: 'off' }),
            }),
          });
          expect(listener).toBeCalledWith({
            result: true,
            triggerData: {
              state: {
                entity: 'binary_sensor.foo',
                from: 'on',
                to: 'off',
              },
            },
          });
          expect(listener).toBeCalledTimes(2);
        });

        describe('positive', () => {
          it('single state', () => {
            const stateManager = new ConditionStateManager();
            const manager = new ConditionsManager(
              [
                {
                  condition: 'state' as const,
                  entity: 'binary_sensor.foo',
                  state: 'on',
                },
              ],
              stateManager,
            );

            expect(manager.getEvaluation().result).toBeFalsy();
            stateManager.setState({
              hass: createHASS({ 'binary_sensor.foo': createStateEntity() }),
            });
            expect(manager.getEvaluation().result).toBeTruthy();
            stateManager.setState({
              hass: createHASS({
                'binary_sensor.foo': createStateEntity({ state: 'off' }),
              }),
            });
            expect(manager.getEvaluation().result).toBeFalsy();
          });

          it('multiple states', () => {
            const stateManager = new ConditionStateManager();
            const manager = new ConditionsManager(
              [
                {
                  condition: 'state' as const,
                  entity: 'binary_sensor.foo',
                  state: ['active', 'on'],
                },
              ],
              stateManager,
            );

            expect(manager.getEvaluation().result).toBeFalsy();
            stateManager.setState({
              hass: createHASS({ 'binary_sensor.foo': createStateEntity() }),
            });
            expect(manager.getEvaluation().result).toBeTruthy();
            stateManager.setState({
              hass: createHASS({
                'binary_sensor.foo': createStateEntity({ state: 'active' }),
              }),
            });
            expect(manager.getEvaluation().result).toBeTruthy();
            stateManager.setState({
              hass: createHASS({
                'binary_sensor.foo': createStateEntity({ state: 'off' }),
              }),
            });
            expect(manager.getEvaluation().result).toBeFalsy();
          });
        });

        describe('negative', () => {
          it('single state', () => {
            const stateManager = new ConditionStateManager();
            const manager = new ConditionsManager(
              [
                {
                  condition: 'state' as const,
                  entity: 'binary_sensor.foo',
                  state_not: 'on',
                },
              ],
              stateManager,
            );

            expect(manager.getEvaluation().result).toBeFalsy();
            stateManager.setState({
              hass: createHASS({ 'binary_sensor.foo': createStateEntity() }),
            });
            expect(manager.getEvaluation().result).toBeFalsy();
            stateManager.setState({
              hass: createHASS({
                'binary_sensor.foo': createStateEntity({ state: 'off' }),
              }),
            });
            expect(manager.getEvaluation().result).toBeTruthy();
          });
        });

        it('multiple states', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                condition: 'state' as const,
                entity: 'binary_sensor.foo',
                state_not: ['active', 'on'],
              },
            ],
            stateManager,
          );

          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({ 'binary_sensor.foo': createStateEntity() }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({
              'binary_sensor.foo': createStateEntity({ state: 'active' }),
            }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({
              'binary_sensor.foo': createStateEntity({ state: 'off' }),
            }),
          });
          expect(manager.getEvaluation().result).toBeTruthy();
        });

        it('implicit state condition', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                entity: 'binary_sensor.foo',
                state: 'on',
              },
            ],
            stateManager,
          );

          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({ 'binary_sensor.foo': createStateEntity() }),
          });
          expect(manager.getEvaluation().result).toBeTruthy();
          stateManager.setState({
            hass: createHASS({
              'binary_sensor.foo': createStateEntity({ state: 'off' }),
            }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
        });

        it('should match any state change when state and state_not omitted', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              { condition: 'state' as const, entity: 'switch.one' },
              { condition: 'state' as const, entity: 'switch.two' },
            ],
            stateManager,
          );

          const listener = vi.fn();
          manager.addListener(listener);

          stateManager.setState({
            hass: createHASS({
              'switch.one': createStateEntity({ state: 'on' }),
              'switch.two': createStateEntity({ state: 'off' }),
            }),
          });
          expect(listener).toHaveBeenLastCalledWith({
            result: true,
            triggerData: {
              // Only the last matching state will be included in the data.
              state: {
                entity: 'switch.two',
                to: 'off',
              },
            },
          });

          stateManager.setState({
            hass: createHASS({
              'switch.one': createStateEntity({ state: 'off' }),
              'switch.two': createStateEntity({ state: 'on' }),
            }),
          });

          expect(listener).toHaveBeenLastCalledWith({
            result: true,
            triggerData: {
              // Only the last matching state will be included in the data.
              state: {
                entity: 'switch.two',
                from: 'off',
                to: 'on',
              },
            },
          });

          expect(listener).toBeCalledTimes(2);
        });

        it('should not re-trigger without a real change', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [{ condition: 'state' as const, entity: 'switch.one' }],
            stateManager,
          );

          const listener = vi.fn();
          manager.addListener(listener);

          const hass = createHASS({
            'switch.one': createStateEntity({ state: 'on' }),
          });
          stateManager.setState({
            hass,
          });
          expect(listener).toBeCalledTimes(1);
          expect(manager.getEvaluation()).toEqual({
            result: true,
            triggerData: {
              // Only the last matching state will be included in the data.
              state: {
                entity: 'switch.one',
                to: 'on',
              },
            },
          });

          stateManager.setState({ hass });
          expect(listener).toBeCalledTimes(1);
        });
      });

      describe('with numeric state condition', () => {
        it('above', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                condition: 'numeric_state' as const,
                entity: 'sensor.foo',
                above: 10,
              },
            ],
            stateManager,
          );

          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({ 'sensor.foo': createStateEntity({ state: '11' }) }),
          });
          expect(manager.getEvaluation().result).toBeTruthy();
          stateManager.setState({
            hass: createHASS({ 'binary_sensor.foo': createStateEntity({ state: '9' }) }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
        });

        it('below', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                condition: 'numeric_state' as const,
                entity: 'sensor.foo',
                below: 10,
              },
            ],
            stateManager,
          );

          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({ 'sensor.foo': createStateEntity({ state: '11' }) }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
          stateManager.setState({
            hass: createHASS({ 'sensor.foo': createStateEntity({ state: '9' }) }),
          });
          expect(manager.getEvaluation().result).toBeTruthy();
        });
      });

      describe('with template condition', () => {
        const createHASSForTemplateCondition = (states: HassEntities): HomeAssistant => {
          const hass = createHASS(states);
          vi.mocked(hass.connection.sendMessagePromise).mockResolvedValue([]);
          return hass;
        };

        it('should evaluate true when template evalutes to true', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                condition: 'template' as const,
                value_template: '{{ is_state("sensor.foo", "on") }}',
              },
            ],
            stateManager,
          );

          expect(manager.getEvaluation().result).toBeFalsy();

          stateManager.setState({
            hass: createHASSForTemplateCondition({
              'sensor.foo': createStateEntity({ state: 'on' }),
            }),
          });
          expect(manager.getEvaluation().result).toBeTruthy();

          stateManager.setState({
            hass: createHASSForTemplateCondition({
              'sensor.foo': createStateEntity({ state: 'off' }),
            }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
        });

        it('should evaluate false when template evalutes to non-boolean', () => {
          const stateManager = new ConditionStateManager();
          const manager = new ConditionsManager(
            [
              {
                condition: 'template' as const,
                // This does not result in a boolean.
                value_template: '{{ hass.states["light.office"].state }}',
              },
            ],
            stateManager,
          );

          stateManager.setState({
            hass: createHASSForTemplateCondition({
              'light.office': createStateEntity({ state: 'on' }),
            }),
          });
          expect(manager.getEvaluation().result).toBeFalsy();
        });
      });

      it('should not call listeners for HA state changes without relevant condition', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [
            {
              condition: 'fullscreen' as const,
              fullscreen: true,
            },
          ],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({
          hass: createHASS({ 'sensor.foo': createStateEntity({ state: '11' }) }),
        });

        expect(listener).not.toBeCalled();
      });
    });

    it('with user condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [
          {
            condition: 'user' as const,
            users: ['user_1', 'user_2'],
          },
        ],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({
        hass: createHASS({}, createUser({ id: 'user_1' })),
      });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({
        hass: createHASS({}, createUser({ id: 'user_WRONG' })),
      });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with media loaded condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'media_loaded' as const, media_loaded: true }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ mediaLoadedInfo: createMediaLoadedInfo() });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ mediaLoadedInfo: null });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    describe('with screen condition', () => {
      it('on evaluation', () => {
        vi.spyOn(window, 'matchMedia')
          .mockReturnValueOnce({
            addEventListener: vi.fn(),
          } as unknown as MediaQueryList)
          .mockReturnValueOnce({
            matches: true,
          } as unknown as MediaQueryList);

        const manager = new ConditionsManager([
          { condition: 'screen' as const, media_query: 'whatever' },
        ]);
        expect(manager.getEvaluation().result).toBeTruthy();
      });

      it('on trigger', () => {
        const addEventListener = vi.fn();
        const removeEventListener = vi.fn();
        vi.spyOn(window, 'matchMedia')
          .mockReturnValueOnce({
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
          } as unknown as MediaQueryList)
          .mockReturnValueOnce({
            matches: false,
          } as unknown as MediaQueryList)
          .mockReturnValueOnce({
            matches: true,
          } as unknown as MediaQueryList);

        const manager = new ConditionsManager([
          {
            condition: 'screen' as const,
            media_query: 'media query goes here',
          },
        ]);

        expect(addEventListener).toHaveBeenCalledWith('change', expect.anything());

        const callback = vi.fn();
        manager.addListener(callback);

        // Call the media query callback and use it to pretend a match happened. The
        // callback is the 0th mock innvocation and the 1st argument.
        addEventListener.mock.calls[0][1]();

        // This should result in a callback to our state listener.
        expect(callback).toBeCalledWith({ result: true, triggerData: {} });

        // Destroy the manager and ensure the event listener is removed.
        manager.destroy();
        expect(removeEventListener).toBeCalled();
      });
    });

    it('with display mode condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'display_mode' as const, display_mode: 'grid' as const }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ displayMode: 'grid' });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ displayMode: 'single' });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with triggered condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'triggered' as const, triggered: ['camera_1', 'camera_2'] }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ triggered: new Set(['camera_1']) });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({
        triggered: new Set(['camera_2', 'camera_1', 'camera_3']),
      });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ triggered: new Set(['camera_3']) });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with interaction condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'interaction' as const, interaction: true }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ interaction: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ interaction: false });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    describe('with microphone condition', () => {
      const createMicrophoneState = (
        state: Partial<MicrophoneState>,
      ): MicrophoneState => {
        return {
          connected: false,
          muted: false,
          forbidden: false,
          ...state,
        };
      };
      it('empty', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'microphone' as const }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: true }),
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: false }),
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: true }) });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: false }) });
        expect(manager.getEvaluation().result).toBeTruthy();
      });

      it('connected is true', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'microphone' as const, connected: true }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: true }),
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: false }),
        });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('connected is false', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'microphone' as const, connected: false }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: true }),
        });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: false }),
        });
        expect(manager.getEvaluation().result).toBeTruthy();
      });

      it('muted is true', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'microphone' as const, muted: true }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: true }) });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: false }) });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('muted is false', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'microphone' as const, muted: false }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: true }) });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: false }) });
        expect(manager.getEvaluation().result).toBeTruthy();
      });

      it('connected and muted', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'microphone' as const, muted: false, connected: true }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: true }) });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ microphone: createMicrophoneState({ muted: false }) });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: false, muted: false }),
        });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          microphone: createMicrophoneState({ connected: true, muted: false }),
        });
        expect(manager.getEvaluation().result).toBeTruthy();
      });
    });

    describe('with key condition', () => {
      it('simple keypress', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'key' as const, key: 'a' }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          keys: {
            a: { state: 'down', ctrl: false, shift: false, alt: false, meta: false },
          },
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          keys: {
            a: { state: 'up', ctrl: false, shift: false, alt: false, meta: false },
          },
        });

        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('keypress with modifiers', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [
            {
              condition: 'key' as const,
              key: 'a',
              state: 'down' as const,
              ctrl: true,
              shift: true,
              alt: true,
              meta: true,
            },
          ],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          keys: {
            a: { state: 'down', ctrl: false, shift: false, alt: false, meta: false },
          },
        });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          keys: {
            a: { state: 'down', ctrl: true, shift: true, alt: true, meta: false },
          },
        });
        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          keys: {
            a: { state: 'down', ctrl: true, shift: true, alt: true, meta: true },
          },
        });
        expect(manager.getEvaluation().result).toBeTruthy();
      });
    });

    describe('with user agent condition', () => {
      const userAgent =
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';

      it('should match exact user agent', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'user_agent' as const, user_agent: userAgent }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          userAgent: userAgent,
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          userAgent: 'Something else',
        });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('should match user agent regex', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'user_agent' as const, user_agent_re: 'Chrome/' }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          userAgent: userAgent,
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          userAgent: 'Something else',
        });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('should match companion app', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'user_agent' as const, companion: true }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          userAgent: 'Home Assistant/',
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          userAgent: userAgent,
        });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('should match multiple parameters', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [
            {
              condition: 'user_agent' as const,
              companion: true,
              user_agent: 'Home Assistant/',
              user_agent_re: 'Home.Assistant',
            },
          ],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({
          userAgent: 'Home Assistant/',
        });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({
          userAgent: 'Something else',
        });
        expect(manager.getEvaluation().result).toBeFalsy();
      });
    });

    describe('with config condition', () => {
      const config_1 = createConfig({
        // Default is:
        //
        // view: {
        //   default: live,
        // },
      });
      const config_2 = createConfig({
        view: {
          default: 'clips',
        },
      });
      const config_3 = createConfig({
        view: {
          default: 'clips',
          default_cycle_camera: true,
        },
      });
      const config_4 = createConfig({
        view: {
          default: 'clips',
          default_cycle_camera: true,
          dim: true,
        },
      });

      it('should match any config change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'config' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ config: config_1 });
        expect(listener).toHaveBeenLastCalledWith({
          result: true,
          triggerData: {
            config: {
              to: config_1,
            },
          },
        });

        stateManager.setState({ config: config_2 });
        expect(listener).toHaveBeenLastCalledWith({
          result: true,
          triggerData: {
            config: {
              from: config_1,
              to: config_2,
            },
          },
        });

        expect(listener).toBeCalledTimes(2);
      });

      it('should match specific config change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'config' as const, paths: ['view.default'] }],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ config: config_1 });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ config: config_2 });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ config: config_3 });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('should match multiple config change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [
            {
              condition: 'config' as const,
              paths: ['view.default', 'view.default_cycle_camera'],
            },
          ],
          stateManager,
        );

        expect(manager.getEvaluation().result).toBeFalsy();
        stateManager.setState({ config: config_1 });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ config: config_2 });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ config: config_3 });
        expect(manager.getEvaluation().result).toBeTruthy();
        stateManager.setState({ config: config_4 });
        expect(manager.getEvaluation().result).toBeFalsy();
      });

      it('should not match unrelated changes', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'config' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ config: config_1 });
        expect(listener).toBeCalledTimes(1);

        // On the next state set, the condition won't match anymore (as the
        // config is the same), the listener will still be called to indicate
        // the condition evaluation has changed.
        stateManager.setState({ expand: true });
        expect(listener).toBeCalledTimes(2);
        expect(listener).toHaveBeenLastCalledWith({ result: false });

        // Future unrelated state changes won't call the listener.
        stateManager.setState({ fullscreen: true });
        expect(listener).toBeCalledTimes(2);
      });

      it('should not re-trigger without a real change', () => {
        const stateManager = new ConditionStateManager();
        const manager = new ConditionsManager(
          [{ condition: 'config' as const }],
          stateManager,
        );

        const listener = vi.fn();
        manager.addListener(listener);

        stateManager.setState({ config: config_1 });
        expect(listener).toHaveBeenCalledTimes(1);

        stateManager.setState({ config: config_1 });
        expect(listener).toHaveBeenCalledTimes(1);
      });
    });

    it('with initialized condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'initialized' as const }],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ initialized: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ initialized: false });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with simple OR condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [
          {
            condition: 'or' as const,
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
              {
                condition: 'expand' as const,
                expand: true,
              },
            ],
          },
        ],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ fullscreen: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ expand: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ fullscreen: false });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ expand: false });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with triggered OR condition', () => {
      const stateManager = new ConditionStateManager();

      // This is not a terribly realistic example, but chosen so that trigger
      // data for both camera and view should be returned.
      const manager = new ConditionsManager(
        [
          {
            condition: 'or' as const,
            conditions: [
              { condition: 'camera' as const },
              { condition: 'view' as const },
            ],
          },
        ],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();

      stateManager.setState({ camera: 'camera-1' });
      expect(manager.getEvaluation().result).toBeTruthy();
      expect(manager.getEvaluation().triggerData).toEqual({
        camera: { to: 'camera-1' },
      });

      stateManager.setState({ view: 'view-1' });
      expect(manager.getEvaluation().result).toBeTruthy();
      expect(manager.getEvaluation().triggerData).toEqual({
        view: { to: 'view-1' },
      });

      stateManager.setState({ camera: 'camera-2', view: 'view-2' });
      expect(manager.getEvaluation().result).toBeTruthy();
      expect(manager.getEvaluation().triggerData).toEqual({
        camera: { to: 'camera-2', from: 'camera-1' },

        // View data will not be here as the view condition is not evaluated,
        // since the camera one will evaluate to true first.
      });
    });

    it('with simple AND condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [
          {
            condition: 'and' as const,
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
              {
                condition: 'expand' as const,
                expand: true,
              },
            ],
          },
        ],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ fullscreen: true });
      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ expand: true });
      expect(manager.getEvaluation().result).toBeTruthy();
      stateManager.setState({ fullscreen: false });
      expect(manager.getEvaluation().result).toBeFalsy();
      stateManager.setState({ expand: false });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with triggered AND condition', () => {
      const stateManager = new ConditionStateManager();

      // This is not a terribly realistic example, but chosen so that trigger
      // data for both camera and view should be returned.
      const manager = new ConditionsManager(
        [
          {
            condition: 'and' as const,
            conditions: [
              { condition: 'camera' as const },
              { condition: 'view' as const },
            ],
          },
        ],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeFalsy();

      stateManager.setState({ camera: 'camera-1' });
      expect(manager.getEvaluation().result).toBeFalsy();

      stateManager.setState({ view: 'view-1' });
      expect(manager.getEvaluation().result).toBeFalsy();

      stateManager.setState({ camera: 'camera-2', view: 'view-2' });
      expect(manager.getEvaluation().result).toBeTruthy();
      expect(manager.getEvaluation().triggerData).toEqual({
        camera: { from: 'camera-1', to: 'camera-2' },
        view: { from: 'view-1', to: 'view-2' },
      });

      stateManager.setState({ view: 'view-3' });
      expect(manager.getEvaluation().result).toBeFalsy();
    });

    it('with not condition', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [
          {
            condition: 'not' as const,
            conditions: [
              {
                condition: 'fullscreen' as const,
                fullscreen: true,
              },
              {
                condition: 'expand' as const,
                expand: true,
              },
            ],
          },
        ],
        stateManager,
      );

      expect(manager.getEvaluation().result).toBeTruthy();

      stateManager.setState({ fullscreen: true });
      expect(manager.getEvaluation().result).toBeTruthy();

      stateManager.setState({ expand: true });
      expect(manager.getEvaluation().result).toBeFalsy();

      stateManager.setState({ fullscreen: false });
      expect(manager.getEvaluation().result).toBeTruthy();

      stateManager.setState({ expand: false });
      expect(manager.getEvaluation().result).toBeTruthy();

      // `not` conditions never have trigger data (as nothing is triggering).
      expect(manager.getEvaluation().triggerData).toEqual({});
    });
  });

  describe('should handle listeners correctly', () => {
    it('should add listener', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'fullscreen' as const, fullscreen: true }],
        stateManager,
      );

      const listener = vi.fn();
      manager.addListener(listener);

      stateManager.setState({ fullscreen: true });

      expect(listener).toBeCalledWith({ result: true, triggerData: {} });
      expect(listener).toBeCalledTimes(1);

      stateManager.setState({ fullscreen: false });
      expect(listener).toBeCalledWith({ result: false });
      expect(listener).toBeCalledTimes(2);

      // Re-add the same listener (will still only be called once).
      manager.addListener(listener);

      stateManager.setState({ fullscreen: true });

      expect(listener).toBeCalledWith({ result: true, triggerData: {} });
      expect(listener).toBeCalledTimes(3);
    });

    it('should remove listener', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'fullscreen' as const, fullscreen: true }],
        stateManager,
      );

      const listener = vi.fn();
      manager.addListener(listener);
      manager.removeListener(listener);

      stateManager.setState({ fullscreen: true });

      expect(listener).not.toBeCalled();
    });

    it('should remove listener on destroy', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'fullscreen' as const, fullscreen: true }],
        stateManager,
      );

      const listener = vi.fn();
      manager.addListener(listener);
      manager.destroy();

      stateManager.setState({ fullscreen: true });

      expect(listener).not.toBeCalled();
    });

    it('with not call listeners when condition result does not change', () => {
      const stateManager = new ConditionStateManager();
      const manager = new ConditionsManager(
        [{ condition: 'view' as const, views: ['foo'] }],
        stateManager,
      );

      const listener = vi.fn();
      manager.addListener(listener);

      stateManager.setState({ view: 'foo' });
      expect(listener).toBeCalledTimes(1);

      stateManager.setState({ view: 'bar' });
      expect(listener).toBeCalledTimes(2);

      stateManager.setState({ view: 'bar' });
      expect(listener).toBeCalledTimes(2);

      stateManager.setState({ view: 'foo' });
      expect(listener).toBeCalledTimes(3);

      stateManager.setState({ view: 'foo' });
      expect(listener).toBeCalledTimes(3);
    });
  });
});



================================================
FILE: tests/conditions/state-manager-via-event.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { ConditionStateManager } from '../../src/conditions/state-manager';
import {
  ConditionStateManagerGetEvent,
  getConditionStateManagerViaEvent,
} from '../../src/conditions/state-manager-via-event';

// @vitest-environment jsdom
describe('getConditionStateManagerViaEvent', () => {
  it('should dispatch event and retrieve state manager', () => {
    const element = document.createElement('div');
    const stateManager = mock<ConditionStateManager>();

    const handler = vi.fn().mockImplementation((ev: ConditionStateManagerGetEvent) => {
      ev.conditionStateManager = stateManager;
    });
    element.addEventListener(
      'advanced-camera-card:condition-state-manager:get',
      handler,
    );

    expect(getConditionStateManagerViaEvent(element)).toBe(stateManager);
  });

  it('should dispatch event and retrieve state manager', () => {
    const element = document.createElement('div');

    const handler = vi.fn();
    element.addEventListener(
      'advanced-camera-card:condition-state-manager:get',
      handler,
    );

    expect(getConditionStateManagerViaEvent(element)).toBeNull();
  });
});



================================================
FILE: tests/conditions/state-manager.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { ConditionStateManager } from '../../src/conditions/state-manager';
import { createHASS, createStateEntity } from '../test-utils';

describe('ConditionStateManager', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should get state', () => {
    const state = { fullscreen: true };

    const manager = new ConditionStateManager();
    manager.setState(state);
    expect(manager.getState()).toEqual(state);
  });

  describe('should set state', () => {
    it('should set and be able to get it again', () => {
      const state = {
        fullscreen: true,
      };

      const manager = new ConditionStateManager();

      manager.setState(state);
      expect(manager.getState()).toEqual(state);
    });

    it('should set but only trigger when necessary', () => {
      const listener = vi.fn();
      const manager = new ConditionStateManager();
      manager.addListener(listener);

      const state = {
        fullscreen: true,
      };

      manager.setState(state);
      expect(listener).toBeCalledTimes(1);

      manager.setState(state);
      expect(listener).toBeCalledTimes(1);

      manager.setState({ ...state });
      expect(listener).toBeCalledTimes(1);

      manager.setState({
        hass: createHASS({
          'binary_sensor.foo': createStateEntity(),
        }),
      });
      expect(listener).toBeCalledTimes(2);

      manager.setState({ fullscreen: true });
      expect(listener).toBeCalledTimes(2);

      manager.setState({
        hass: createHASS({
          'binary_sensor.foo': createStateEntity(),
        }),
      });
      expect(listener).toBeCalledTimes(3);

      manager.setState({ fullscreen: false });
      expect(listener).toBeCalledTimes(4);

      manager.setState({ fullscreen: false });
      expect(listener).toBeCalledTimes(4);

      manager.setState({
        hass: createHASS({
          'binary_sensor.foo': createStateEntity({ state: 'off' }),
        }),
      });
      expect(listener).toBeCalledTimes(5);
    });
  });

  it('should add listener', () => {
    const listener = vi.fn();
    const manager = new ConditionStateManager();

    manager.setState({ fullscreen: true });

    manager.addListener(listener);

    manager.setState({ expand: true });

    expect(listener).toBeCalledWith({
      old: { fullscreen: true },
      change: { expand: true },
      new: { fullscreen: true, expand: true },
    });
  });

  it('should remove listener', () => {
    const listener = vi.fn();
    const manager = new ConditionStateManager();

    manager.addListener(listener);
    manager.removeListener(listener);

    const state = { fullscreen: true };
    manager.setState(state);

    expect(listener).not.toBeCalled();
  });
});



================================================
FILE: tests/config/management.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  copyConfig,
  createRangedTransform,
  deleteConfigValue,
  deleteTransform,
  deleteWithOverrides,
  getArrayConfigPath,
  getConfigValue,
  isConfigUpgradeable,
  moveConfigValue,
  setConfigValue,
  upgradeArrayOfObjects,
  upgradeConfig,
  upgradeMoveTo,
  upgradeMoveToWithOverrides,
  upgradeObjectRecursively,
  upgradeWithOverrides,
} from '../../src/config/management.js';
import { PTZControlAction } from '../../src/config/schema/actions/custom/ptz.js';
import { CallServiceActionConfig } from '../../src/config/schema/actions/stock/call-service.js';
import { PerformActionActionConfig } from '../../src/config/schema/actions/stock/perform-action.js';
import { Actions } from '../../src/config/schema/actions/types.js';
import { advancedCameraCardConfigSchema } from '../../src/config/schema/types.js';
import { RawAdvancedCameraCardConfig } from '../../src/config/types.js';
import { getParseErrorPaths } from '../../src/utils/zod.js';

describe('general functions', () => {
  it('should set value', () => {
    const target = {};
    setConfigValue(target, 'a', 10);
    expect(target).toEqual({
      a: 10,
    });
  });

  describe('should get value', () => {
    it('present', () => {
      expect(getConfigValue({ b: 11 }, 'b')).toEqual(11);
    });
    it('absent', () => {
      expect(getConfigValue({ b: 11 }, 'c')).toBeUndefined();
    });
    it('absent with default', () => {
      expect(getConfigValue({ b: 11 }, 'c', 12)).toBe(12);
    });
  });

  describe('should unset value', () => {
    it('nested', () => {
      const target = {
        moo: {
          foo: {
            a: 10,
          },
          bar: {
            b: 11,
          },
        },
      };
      deleteConfigValue(target, 'moo.foo');
      expect(target).toEqual({ moo: { bar: { b: 11 } } });
    });

    it('top-level', () => {
      const target = {
        a: 10,
        b: 11,
      };
      deleteConfigValue(target, 'a');
      expect(target).toEqual({ b: 11 });
    });
  });

  it('should copy config', () => {
    const target = {
      a: {
        b: {
          c: 10,
        },
      },
    };
    const copy = copyConfig(target);

    expect(copy).toEqual(target);
    expect(copy).not.toBe(target);
  });

  it('should get array config path', () => {
    expect(getArrayConfigPath('a.#.b', 10)).toBe('a.[10].b');
  });
});

describe('upgrade functions', () => {
  it('should determine if config is upgradeable', () => {
    expect(
      // Upgrade example: rename of service_data to data.
      isConfigUpgradeable({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            style: {
              right: '20px',
              top: '20px',
              color: 'white',
            },
            tap_action: {
              action: 'call-service',
              service: 'notify.persistent_notification',
              service_data: {
                message: 'Hello 1',
              },
            },
          },
        ],
      }),
    ).toBeTruthy();
  });

  describe('should create ranged transform', () => {
    describe('with numbers', () => {
      it('inside range', () => {
        expect(createRangedTransform((val) => val, 10, 20)(11)).toBe(11);
      });
      it('outside range', () => {
        expect(createRangedTransform((val) => val, 10, 20)(1)).toBe(10);
      });
      it('with a range', () => {
        expect(createRangedTransform((val) => val)(100)).toBe(100);
      });
    });
    it('with non-number', () => {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      expect(createRangedTransform((_val) => 'foo')(1)).toBe('foo');
    });
  });

  it('should return null from delete property transform', () => {
    expect(deleteTransform(10)).toBeNull();
  });

  describe('should move config value', () => {
    it('simple', () => {
      const config = {
        foo: {
          c: 10,
        },
      };
      expect(moveConfigValue(config, 'foo', 'bar')).toBeTruthy();
      expect(config).toEqual({
        bar: {
          c: 10,
        },
      });
    });

    describe('in place', () => {
      it('non-transformed', () => {
        const config = {
          foo: {
            c: 10,
          },
        };
        expect(moveConfigValue(config, 'foo', 'foo')).toBeFalsy();
        expect(config).toEqual({
          foo: {
            c: 10,
          },
        });
      });

      it('transformed', () => {
        const config = {
          foo: {
            c: 10,
          },
        };
        expect(
          moveConfigValue(config, 'foo.c', 'foo.c', { transform: (val) => String(val) }),
        ).toBeTruthy();
        expect(config).toEqual({
          foo: {
            c: '10',
          },
        });
      });
    });

    describe('with transform result', () => {
      it('move', () => {
        const config = {
          c: 10,
        };
        expect(
          moveConfigValue(config, 'c', 'd', { transform: (val) => String(val) }),
        ).toBeTruthy();
        expect(config).toEqual({ d: '10' });
      });

      it('keep original', () => {
        const config = {
          c: 10,
        };
        expect(
          moveConfigValue(config, 'c', 'd', {
            transform: (val) => String(val),
            keepOriginal: true,
          }),
        ).toBeTruthy();
        expect(config).toEqual({ c: 10, d: '10' });
      });
    });

    describe('with transform null result', () => {
      it('remove', () => {
        const config = {
          c: 10,
        };
        expect(
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          moveConfigValue(config, 'c', 'd', { transform: (_val) => null }),
        ).toBeTruthy();
        expect(config).toEqual({});
      });

      it('keep', () => {
        const config = {
          c: 10,
        };
        expect(
          moveConfigValue(config, 'c', 'd', {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            transform: (_val) => null,
            keepOriginal: true,
          }),
        ).toBeFalsy();
        expect(config).toEqual({ c: 10 });
      });
    });

    it('with transform undefined result', () => {
      const config = {
        c: 10,
      };
      expect(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        moveConfigValue(config, 'c', 'd', { transform: (_val) => undefined }),
      ).toBeFalsy();
      expect(config).toEqual({ c: 10 });
    });
  });

  it('should upgrade with a move', () => {
    const config = {
      c: 10,
    };

    expect(upgradeMoveTo('c', 'd')(config)).toBeTruthy();
    expect(config).toEqual({ d: 10 });
  });

  it('should upgrade config and overrides with a move', () => {
    const config = {
      c: 10,
      overrides: [
        {
          merge: {
            c: 10,
          },
          set: {
            c: 10,
          },
        },
      ],
    };

    expect(upgradeMoveToWithOverrides('c', 'd')(config)).toBeTruthy();
    expect(config).toEqual({ d: 10, overrides: [{ merge: { d: 10 }, set: { d: 10 } }] });
  });

  it('should upgrade config and overrides in-place', () => {
    const config = {
      c: 10,
      overrides: [
        {
          merge: {
            c: 10,
          },
        },
      ],
    };

    expect(upgradeWithOverrides('c', (val) => String(val))(config)).toBeTruthy();
    expect(config).toEqual({ c: '10', overrides: [{ merge: { c: '10' } }] });
  });

  describe('should upgrade array', () => {
    it('in case of non-array', () => {
      const config = { c: 10 };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      expect(upgradeArrayOfObjects('c', (_val) => false)(config)).toBeFalsy();
    });

    it('in case of non-object items', () => {
      const config = { c: [10, 11] };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      expect(upgradeArrayOfObjects('c', (_val) => false)(config)).toBeFalsy();
    });

    it('in case of array', () => {
      const config = { c: [{ d: 10 }, { d: 11 }] };
      expect(
        upgradeArrayOfObjects('c', (val) => {
          val['e'] = 12;
          return true;
        })(config),
      ).toBeTruthy();
      expect(config).toEqual({
        c: [
          {
            d: 10,
            e: 12,
          },
          {
            d: 11,
            e: 12,
          },
        ],
      });
    });
  });

  describe('should recursively upgrade', () => {
    it('ignoring simple objects', () => {
      const config = { c: 10, d: 10 };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      expect(upgradeObjectRecursively((_val) => false)(config)).toBeFalsy();
      expect(config).toEqual({ c: 10, d: 10 });
    });

    it('getting sub-objects', () => {
      const config = { c: 10, target_obj: { target_val: 10 } };
      expect(
        upgradeObjectRecursively(
          (val: RawAdvancedCameraCardConfig) => {
            (val['target_val'] as number)++;
            return true;
          },
          (obj) => obj['target_obj'] as RawAdvancedCameraCardConfig,
        )(config),
      ).toBeTruthy();
      expect(config).toEqual({ c: 10, target_obj: { target_val: 11 } });
    });

    it('iterating into arrays', () => {
      const config = { values: [{ c: 10 }, { d: 10 }, 'random'] };
      expect(
        upgradeObjectRecursively((val) => {
          if (!Array.isArray(val)) {
            val['e'] = 11;
          }
          return true;
        })(config),
      ).toBeTruthy();

      expect(config).toEqual({
        e: 11,
        values: [{ c: 10, e: 11 }, { d: 10, e: 11 }, 'random'],
      });
    });
  });

  it('should have upgrades with bad input data', () => {
    expect(upgradeConfig(3 as unknown as RawAdvancedCameraCardConfig)).toBeFalsy();
  });

  it('should delete properties', () => {
    const config = { c: 10, d: 10 };
    expect(deleteWithOverrides('c')(config)).toBeTruthy();
    expect(config).toEqual({ d: 10 });
  });
});

describe('should handle version specific upgrades', () => {
  const postUpgradeChecks = (config: RawAdvancedCameraCardConfig): void => {
    // Should be no additional upgrades.
    expect(upgradeConfig(config)).toBeFalsy();

    // Result should be parseable.
    const result = advancedCameraCardConfigSchema.safeParse(config);
    if (!result.success) {
      expect(
        result.success,
        'Post-upgrade parse error.\n\n' +
          'Problem paths: ' +
          [...getParseErrorPaths(result.error)] +
          '\n\n' +
          JSON.stringify(config, null, 2),
      ).toBeTruthy();
    }
  };

  describe('v5.2.0 -> v6.0.0', () => {
    describe('should rename service_data to data', () => {
      it('positive case', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'icon',
              icon: 'mdi:cow',
              style: {
                right: '20px',
                top: '20px',
                color: 'white',
              },
              tap_action: {
                action: 'call-service',
                service: 'notify.persistent_notification',
                service_data: {
                  message: 'Hello 1',
                },
              },
            },
            {
              type: 'service-button',
              title: 'title',
              service: 'service',
              service_data: {
                message: "It's a trick",
              },
            },
          ],
          view: {
            actions: {
              double_tap_action: {
                action: 'call-service',
                service: 'notify.persistent_notification',
                service_data: {
                  message: 'Hello 2',
                },
              },
              hold_action: {
                action: 'call-service',
                service: 'notify.persistent_notification',
                data: {
                  message: 'Hello 3',
                },
              },
            },
          },
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'icon',
              icon: 'mdi:cow',
              style: {
                right: '20px',
                top: '20px',
                color: 'white',
              },
              tap_action: {
                action: 'perform-action',
                perform_action: 'notify.persistent_notification',
                data: {
                  message: 'Hello 1',
                },
              },
            },
            {
              type: 'service-button',
              title: 'title',
              service: 'service',
              // Trick: This *is* still called service_data in HA, so should not
              // be modified.
              service_data: {
                message: "It's a trick",
              },
            },
          ],
          view: {
            actions: {
              double_tap_action: {
                action: 'perform-action',
                perform_action: 'notify.persistent_notification',
                data: {
                  message: 'Hello 2',
                },
              },
              hold_action: {
                action: 'perform-action',
                perform_action: 'notify.persistent_notification',
                data: {
                  message: 'Hello 3',
                },
              },
            },
          },
        });
        postUpgradeChecks(config);
      });
      it('negative case', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            default: 'live',
          },
        };
        expect(upgradeConfig(config)).toBeFalsy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            default: 'live',
          },
        });
        postUpgradeChecks(config);
      });
    });

    describe('should move PTZ elements to live', () => {
      it('case with 1 element', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'custom:advanced-camera-card-ptz',
              orientation: 'vertical',
              style: {
                right: '20px',
                top: '20px',
                color: 'white',
              },
              actions_up: {
                tap_action: {
                  action: 'call-service',
                  service: 'notify.persistent_notification',
                  service_data: {
                    message: 'Hello 1',
                  },
                },
              },
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
          cameras_global: {
            ptz: {
              actions_up: {
                action: 'perform-action',
                data: {
                  message: 'Hello 1',
                },
                perform_action: 'notify.persistent_notification',
              },
            },
          },
          live: {
            controls: {
              ptz: {
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          type: 'custom:advanced-camera-card',
        });
        postUpgradeChecks(config);
      });

      it('case with >1 element', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'custom:advanced-camera-card-ptz',
              orientation: 'vertical',
              style: {
                right: '20px',
                top: '20px',
                color: 'white',
              },
              actions_up: {
                tap_action: {
                  action: 'call-service',
                  service: 'notify.persistent_notification',
                  service_data: {
                    message: 'Hello 1',
                  },
                },
              },
            },
            {
              type: 'service-button',
              title: 'title',
              service: 'service',
              service_data: {
                message: "It's a trick",
              },
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
          cameras_global: {
            ptz: {
              actions_up: {
                action: 'perform-action',
                data: {
                  message: 'Hello 1',
                },
                perform_action: 'notify.persistent_notification',
              },
            },
          },
          elements: [
            {
              service: 'service',
              service_data: {
                message: "It's a trick",
              },
              title: 'title',
              type: 'service-button',
            },
          ],
          live: {
            controls: {
              ptz: {
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          type: 'custom:advanced-camera-card',
        });
        postUpgradeChecks(config);
      });

      it('case with custom conditional element with 2 PTZ but nothing else', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'custom:advanced-camera-card-conditional',
              conditions: {
                fullscreen: true,
                media_loaded: true,
              },
              elements: [
                {
                  type: 'custom:advanced-camera-card-ptz',
                  orientation: 'vertical',
                  style: {
                    right: '20px',
                    top: '20px',
                    color: 'white',
                  },
                  actions_up: {
                    tap_action: {
                      action: 'call-service',
                      service: 'notify.persistent_notification',
                      service_data: {
                        message: 'Hello 1',
                      },
                    },
                  },
                },
                {
                  type: 'custom:advanced-camera-card-ptz',
                  orientation: 'vertical',
                  style: {
                    right: '20px',
                    top: '20px',
                    color: 'white',
                  },
                  actions_up: {
                    tap_action: {
                      action: 'call-service',
                      service: 'notify.persistent_notification',
                      service_data: {
                        message: 'Hello 2',
                      },
                    },
                  },
                },
              ],
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
          cameras_global: {
            ptz: {
              actions_up: {
                action: 'perform-action',
                data: {
                  message: 'Hello 1',
                },
                perform_action: 'notify.persistent_notification',
              },
            },
          },
          live: {
            controls: {
              ptz: {
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          type: 'custom:advanced-camera-card',
        });
        postUpgradeChecks(config);
      });

      it('case with custom conditional element with 1 PTZ and another element', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'custom:advanced-camera-card-conditional',
              conditions: {
                fullscreen: true,
                media_loaded: true,
              },
              elements: [
                {
                  type: 'service-button',
                  title: 'title',
                  service: 'service',
                  service_data: {
                    message: "It's a trick",
                  },
                },
                {
                  type: 'custom:advanced-camera-card-ptz',
                  orientation: 'vertical',
                  style: {
                    right: '20px',
                    top: '20px',
                    color: 'white',
                  },
                  actions_up: {
                    tap_action: {
                      action: 'call-service',
                      service: 'notify.persistent_notification',
                      service_data: {
                        message: 'Hello 1',
                      },
                    },
                  },
                },
              ],
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
          cameras_global: {
            ptz: {
              actions_up: {
                action: 'perform-action',
                data: {
                  message: 'Hello 1',
                },
                perform_action: 'notify.persistent_notification',
              },
            },
          },
          live: {
            controls: {
              ptz: {
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          elements: [
            {
              type: 'custom:advanced-camera-card-conditional',
              conditions: [
                {
                  condition: 'fullscreen' as const,
                  fullscreen: true,
                },
                {
                  condition: 'media_loaded' as const,
                  media_loaded: true,
                },
              ],
              elements: [
                {
                  type: 'service-button',
                  title: 'title',
                  service: 'service',
                  service_data: {
                    message: "It's a trick",
                  },
                },
              ],
            },
          ],
          type: 'custom:advanced-camera-card',
        });
        postUpgradeChecks(config);
      });

      it('case with stock conditional element with 1 PTZ', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          elements: [
            {
              type: 'conditional',
              conditions: [{ entity: 'light.office', state: 'on' }],
              elements: [
                {
                  type: 'custom:advanced-camera-card-ptz',
                  orientation: 'vertical',
                  style: {
                    right: '20px',
                    top: '20px',
                    color: 'white',
                  },
                  actions_up: {
                    tap_action: {
                      action: 'call-service',
                      service: 'notify.persistent_notification',
                      service_data: {
                        message: 'Hello 1',
                      },
                    },
                  },
                },
              ],
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
          cameras_global: {
            ptz: {
              actions_up: {
                action: 'perform-action',
                data: {
                  message: 'Hello 1',
                },
                perform_action: 'notify.persistent_notification',
              },
            },
          },
          live: {
            controls: {
              ptz: {
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          type: 'custom:advanced-camera-card',
        });
        postUpgradeChecks(config);
      });

      it('case when live.controls.ptz already exists', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          live: {
            controls: {
              ptz: {
                actions_up: {
                  tap_action: {
                    action: 'call-service',
                    data: {
                      message: 'Original',
                    },
                    service: 'notify.persistent_notification',
                  },
                },
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          elements: [
            {
              type: 'custom:advanced-camera-card-ptz',
              orientation: 'vertical',
              style: {
                right: '20px',
                top: '20px',
                color: 'white',
              },
              actions_up: {
                tap_action: {
                  action: 'call-service',
                  service: 'notify.persistent_notification',
                  service_data: {
                    message: 'Replacement that should be ignored',
                  },
                },
              },
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          cameras: [{ camera_entity: 'camera.office' }],
          cameras_global: {
            ptz: {
              actions_up: {
                action: 'perform-action',
                data: {
                  message: 'Original',
                },
                perform_action: 'notify.persistent_notification',
              },
            },
          },
          live: {
            controls: {
              ptz: {
                orientation: 'vertical',
                style: {
                  color: 'white',
                  right: '20px',
                  top: '20px',
                },
              },
            },
          },
          type: 'custom:advanced-camera-card',
        });
        postUpgradeChecks(config);
      });
    });

    it('should move view.timeout_seconds', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        view: {
          timeout_seconds: 200,
        },
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        view: {
          interaction_seconds: 200,
        },
      });
      postUpgradeChecks(config);
    });

    describe('should handle all and never action conditions', () => {
      describe('live', () => {
        describe('lazy_unload', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                lazy_unload: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                lazy_unload: ['unselected', 'hidden'],
              },
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                lazy_unload: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {},
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                lazy_unload: 'unselected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                lazy_unload: ['unselected'],
              },
            });
            postUpgradeChecks(config);
          });
        });

        describe('auto_play', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_play: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {},
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_play: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_play: [],
              },
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_play: 'selected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_play: ['selected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
        describe('auto_pause', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_pause: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_pause: ['unselected', 'hidden'],
              },
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_pause: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {},
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_pause: 'unselected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_pause: ['unselected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
        describe('auto_mute', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_mute: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {},
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_mute: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_mute: [],
              },
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_mute: 'unselected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_mute: ['unselected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
        describe('auto_unmute', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_unmute: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_unmute: ['selected', 'visible', 'microphone'],
              },
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_unmute: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {},
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_unmute: 'selected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                auto_unmute: ['selected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
      });

      describe('media_viewer', () => {
        describe('auto_play', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_play: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {},
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_play: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_play: [],
              },
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_play: 'selected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_play: ['selected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
        describe('auto_pause', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_pause: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {},
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_pause: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_pause: [],
              },
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_pause: 'unselected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_pause: ['unselected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
        describe('auto_mute', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_mute: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {},
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_mute: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_mute: [],
              },
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_mute: 'unselected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_mute: ['unselected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
        describe('auto_unmute', () => {
          it('all', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_unmute: 'all',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_unmute: ['selected', 'visible'],
              },
            });
            postUpgradeChecks(config);
          });
          it('never', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_unmute: 'never',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {},
            });
            postUpgradeChecks(config);
          });
          it('other value', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_unmute: 'selected',
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              media_viewer: {
                auto_unmute: ['selected'],
              },
            });
            postUpgradeChecks(config);
          });
        });
      });
    });

    describe('should rename thumbnails.media to thumbnails.events_media_type', () => {
      it.each([['all' as const], ['clips' as const], ['snapshots' as const]])(
        '%s',
        (mediaEventType: string) => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            live: {
              controls: {
                thumbnails: {
                  media: mediaEventType,
                },
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            live: {
              controls: {
                thumbnails: {
                  events_media_type: mediaEventType,
                },
              },
            },
          });
          postUpgradeChecks(config);
        },
      );
    });

    describe('should rename timeline.media to timeline.events_media_type', () => {
      it.each([['all' as const], ['clips' as const], ['snapshots' as const]])(
        '%s',
        (mediaEventType: string) => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            timeline: {
              media: mediaEventType,
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            timeline: {
              events_media_type: mediaEventType,
            },
          });
          postUpgradeChecks(config);
        },
      );
    });

    describe('should rename live.controls.timeline.media to live.controls.timeline.events_media_type', () => {
      it.each([['all' as const], ['clips' as const], ['snapshots' as const]])(
        '%s',
        (mediaEventType: string) => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            live: {
              controls: {
                timeline: {
                  media: mediaEventType,
                },
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            live: {
              controls: {
                timeline: {
                  events_media_type: mediaEventType,
                },
              },
            },
          });
          postUpgradeChecks(config);
        },
      );
    });

    describe('should rename media_viewer.controls.timeline.media to media_viewer.controls.timeline.events_media_type', () => {
      it.each([['all' as const], ['clips' as const], ['snapshots' as const]])(
        '%s',
        (mediaEventType: string) => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            media_viewer: {
              controls: {
                timeline: {
                  media: mediaEventType,
                },
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            media_viewer: {
              controls: {
                timeline: {
                  events_media_type: mediaEventType,
                },
              },
            },
          });
          postUpgradeChecks(config);
        },
      );
    });

    describe('should transform scan mode', () => {
      describe('should move and transform untrigger_reset', () => {
        it('when true', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            view: {
              scan: {
                untrigger_reset: true,
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            view: {
              triggers: {
                actions: {
                  untrigger: 'default',
                },
              },
            },
          });
          postUpgradeChecks(config);
        });

        it('when false', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            view: {
              scan: {
                untrigger_reset: false,
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            view: {
              triggers: {},
            },
          });
          postUpgradeChecks(config);
        });
      });

      describe('should rename view.scan.enabled to a trigger action', () => {
        it('when true', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            view: {
              scan: {
                enabled: true,
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            view: {
              triggers: {
                filter_selected_camera: false,
                actions: {
                  trigger: 'live',
                },
              },
            },
          });
          postUpgradeChecks(config);
        });

        it('when false', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            view: {
              scan: {
                enabled: false,
              },
            },
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            view: {
              triggers: {},
            },
          });
          postUpgradeChecks(config);
        });
      });
    });

    describe('should handle media layout changes', () => {
      it('from live.layout to camera_global.dimensions', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            layout: {
              fit: 'cover',
              position: {
                x: 42,
                y: 43,
              },
            },
          },
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {},
          cameras_global: {
            dimensions: {
              layout: {
                fit: 'cover',
                position: {
                  x: 42,
                  y: 43,
                },
              },
            },
          },
        });
        postUpgradeChecks(config);
      });

      describe('from delete old media layouts', () => {
        it.each([['media_viewer' as const], ['image' as const]])(
          '%s',
          (section: string) => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              [section]: {
                layout: {
                  fit: 'cover',
                  position: {
                    x: 42,
                    y: 43,
                  },
                },
              },
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              [section]: {},
            });
            postUpgradeChecks(config);
          },
        );
      });
    });

    describe('from condition object to condition array', () => {
      describe('with view condition', () => {
        it('elements', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: {
                  view: ['clips', 'snapshots'],
                },
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: [
                  {
                    condition: 'view' as const,
                    views: ['clips', 'snapshots'],
                  },
                ],
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('overrides', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: {
                  view: ['clips', 'snapshots'],
                },
                overrides: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: [
                  {
                    condition: 'view' as const,
                    views: ['clips', 'snapshots'],
                  },
                ],
                merge: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('automations', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: {
                  view: ['clips', 'snapshots'],
                },
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: [
                  {
                    condition: 'view' as const,
                    views: ['clips', 'snapshots'],
                  },
                ],
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          });
          postUpgradeChecks(config);
        });
      });

      describe('with camera condition', () => {
        it('elements', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: {
                  camera: ['camera_1', 'camera_2'],
                },
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: [
                  {
                    condition: 'camera' as const,
                    cameras: ['camera_1', 'camera_2'],
                  },
                ],
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('overrides', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: {
                  camera: ['camera_1', 'camera_2'],
                },
                overrides: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: [
                  {
                    condition: 'camera' as const,
                    cameras: ['camera_1', 'camera_2'],
                  },
                ],
                merge: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('automations', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: {
                  camera: ['camera_1', 'camera_2'],
                },
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: [
                  {
                    condition: 'camera' as const,
                    cameras: ['camera_1', 'camera_2'],
                  },
                ],
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          });
          postUpgradeChecks(config);
        });
      });

      describe('with boolean conditions', () => {
        describe.each([
          ['fullscreen' as const],
          ['expand' as const],
          ['media_loaded' as const],
        ])('%s', (condition: string) => {
          it('elements', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{ camera_entity: 'camera.office' }],
              elements: [
                {
                  type: 'custom:random',
                  conditions: {
                    [condition]: true,
                  },
                },
                {
                  type: 'custom:random2',
                  conditions: 'not an object',
                },
              ],
            };
            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{ camera_entity: 'camera.office' }],
              elements: [
                {
                  type: 'custom:random',
                  conditions: [
                    {
                      condition: condition,
                      [condition]: true,
                    },
                  ],
                },
                {
                  type: 'custom:random2',
                  conditions: 'not an object',
                },
              ],
            });
            postUpgradeChecks(config);
          });

          it('overrides', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{ camera_entity: 'camera.office' }],
              overrides: [
                {
                  conditions: {
                    [condition]: true,
                  },
                  overrides: {
                    view: {
                      default: 'clips',
                    },
                  },
                },
              ],
            };

            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{ camera_entity: 'camera.office' }],
              overrides: [
                {
                  conditions: [
                    {
                      condition: condition,
                      [condition]: true,
                    },
                  ],
                  merge: {
                    view: {
                      default: 'clips',
                    },
                  },
                },
              ],
            });
            postUpgradeChecks(config);
          });

          it('automations', () => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{ camera_entity: 'camera.office' }],
              automations: [
                {
                  conditions: {
                    [condition]: true,
                  },
                  actions: [
                    {
                      action: 'custom:advanced-camera-card-action' as const,
                      advanced_camera_card_action: 'live_substream_on' as const,
                    },
                  ],
                },
              ],
            };

            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{ camera_entity: 'camera.office' }],
              automations: [
                {
                  conditions: [
                    {
                      condition: condition,
                      [condition]: true,
                    },
                  ],
                  actions: [
                    {
                      action: 'custom:advanced-camera-card-action' as const,
                      advanced_camera_card_action: 'live_substream_on' as const,
                    },
                  ],
                },
              ],
            });
            postUpgradeChecks(config);
          });
        });
      });

      describe('with state condition', () => {
        it('elements', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: {
                  state: [
                    {
                      entity: 'binary_sensor.first',
                      state: 'on',
                    },
                    {
                      entity: 'binary_sensor.second',
                      state_not: 'off',
                    },
                    {},
                  ],
                },
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: [
                  {
                    condition: 'state' as const,
                    entity: 'binary_sensor.first',
                    state: 'on',
                  },
                  {
                    condition: 'state' as const,
                    entity: 'binary_sensor.second',
                    state_not: 'off',
                  },
                ],
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('overrides', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: {
                  state: [
                    {
                      entity: 'binary_sensor.first',
                      state: 'on',
                    },
                    {
                      entity: 'binary_sensor.second',
                      state_not: 'off',
                    },
                    {},
                  ],
                },
                overrides: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: [
                  {
                    condition: 'state' as const,
                    entity: 'binary_sensor.first',
                    state: 'on',
                  },
                  {
                    condition: 'state' as const,
                    entity: 'binary_sensor.second',
                    state_not: 'off',
                  },
                ],
                merge: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('automations', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: {
                  state: [
                    {
                      entity: 'binary_sensor.first',
                      state: 'on',
                    },
                    {
                      entity: 'binary_sensor.second',
                      state_not: 'off',
                    },
                    {},
                  ],
                },
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: [
                  {
                    condition: 'state' as const,
                    entity: 'binary_sensor.first',
                    state: 'on',
                  },
                  {
                    condition: 'state' as const,
                    entity: 'binary_sensor.second',
                    state_not: 'off',
                  },
                ],
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          });
          postUpgradeChecks(config);
        });
      });

      describe('with media query condition', () => {
        it('elements', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: {
                  media_query: 'query',
                },
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          };
          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            elements: [
              {
                type: 'custom:random',
                conditions: [
                  {
                    condition: 'screen' as const,
                    media_query: 'query',
                  },
                ],
              },
              {
                type: 'custom:random2',
                conditions: 'not an object',
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('overrides', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: {
                  media_query: 'query',
                },
                overrides: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            overrides: [
              {
                conditions: [
                  {
                    condition: 'screen' as const,
                    media_query: 'query',
                  },
                ],
                merge: {
                  view: {
                    default: 'clips',
                  },
                },
              },
            ],
          });
          postUpgradeChecks(config);
        });

        it('automations', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: {
                  media_query: 'query',
                },
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{ camera_entity: 'camera.office' }],
            automations: [
              {
                conditions: [
                  {
                    condition: 'screen' as const,
                    media_query: 'query',
                  },
                ],
                actions: [
                  {
                    action: 'custom:advanced-camera-card-action' as const,
                    advanced_camera_card_action: 'live_substream_on' as const,
                  },
                ],
              },
            ],
          });
          postUpgradeChecks(config);
        });
      });
    });

    describe('from hide to substream capability disable', () => {
      it('overrides', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [
            { camera_entity: 'camera.office', hide: true },
            { camera_entity: 'camera.sitting_room', hide: false },
          ],
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [
            {
              camera_entity: 'camera.office',
              capabilities: { disable_except: ['substream'] },
            },
            { camera_entity: 'camera.sitting_room' },
          ],
        });
        postUpgradeChecks(config);
      });

      describe('from performance profile to generic profile', () => {
        it('low performance', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            performance: {
              profile: 'low',
            },
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            profiles: ['low-performance'],
            performance: {},
          });
          postUpgradeChecks(config);
        });

        it('high performance', () => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            performance: {
              profile: 'high',
            },
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            performance: {},
          });
          postUpgradeChecks(config);
        });
      });
    });

    it('from overrides to merge', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{}],
        overrides: [
          {
            conditions: [
              {
                condition: 'view',
                views: ['clips'],
              },
            ],
            overrides: {
              menu: {
                style: 'hidden',
              },
            },
          },
        ],
      };

      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{}],
        overrides: [
          {
            conditions: [
              {
                condition: 'view',
                views: ['clips'],
              },
            ],
            merge: {
              menu: {
                style: 'hidden',
              },
            },
          },
        ],
      });
      postUpgradeChecks(config);
    });

    describe('split live.ptz', () => {
      const getActionBefore = (action: PTZControlAction): CallServiceActionConfig => ({
        action: 'call-service',
        service: 'service',
        data: {
          arg: action,
        },
      });

      const getActionAfter = (action: PTZControlAction): PerformActionActionConfig => ({
        action: 'perform-action',
        perform_action: 'service',
        data: {
          arg: action,
        },
      });

      const getTapAction = (action: PTZControlAction): Actions => ({
        tap_action: getActionBefore(action),
      });

      it('with action_ format', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              ptz: {
                actions_up: getTapAction('up'),
                actions_down: getTapAction('down'),
                actions_left: getTapAction('left'),
                actions_right: getTapAction('right'),
                actions_zoom_in: getTapAction('zoom_in'),
                actions_zoom_out: getTapAction('zoom_out'),
                actions_home: {
                  ...getTapAction('home'),
                  double_tap_action: getActionBefore('up'),
                },

                mode: 'auto' as const,
                position: 'bottom-right' as const,
                orientation: 'horizontal' as const,
                hide_pan_tilt: false,
                hide_zoom: false,
                hide_home: false,
                style: {
                  color: 'red',
                },

                something_not_related: 'very_unrelated',
              },
            },
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          cameras_global: {
            ptz: {
              actions_left: getActionAfter('left'),
              actions_right: getActionAfter('right'),
              actions_up: getActionAfter('up'),
              actions_down: getActionAfter('down'),
              actions_zoom_in: getActionAfter('zoom_in'),
              actions_zoom_out: getActionAfter('zoom_out'),
              presets: {
                home: getActionAfter('home'),
              },
            },
          },
          live: {
            controls: {
              ptz: {
                mode: 'auto' as const,
                position: 'bottom-right' as const,
                orientation: 'horizontal' as const,
                hide_pan_tilt: false,
                hide_zoom: false,
                hide_home: false,
                style: {
                  color: 'red',
                },
              },
            },
          },
        });
        postUpgradeChecks(config);
      });

      it('with data_ format', () => {
        const getDataAction = (action: PTZControlAction): Actions => ({
          action: {
            device: '048123',
            cmd: action,
          },
        });

        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              ptz: {
                service: 'service',
                data_up: getDataAction('up'),
                data_down: getDataAction('down'),
                data_left: getDataAction('left'),
                data_right: getDataAction('right'),
                data_zoom_in: getDataAction('zoom_in'),
                data_zoom_out: getDataAction('zoom_out'),
                data_home: getDataAction('home'),

                mode: 'auto' as const,
                position: 'bottom-right' as const,
                orientation: 'horizontal' as const,
                hide_pan_tilt: false,
                hide_zoom: false,
                hide_home: false,
                style: {
                  color: 'red',
                },

                something_not_related: 'very_unrelated',
              },
            },
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          cameras_global: {
            ptz: {
              service: 'service',
              data_left: getDataAction('left'),
              data_right: getDataAction('right'),
              data_up: getDataAction('up'),
              data_down: getDataAction('down'),
              data_zoom_in: getDataAction('zoom_in'),
              data_zoom_out: getDataAction('zoom_out'),
              presets: {
                service: 'service',
                data_home: getDataAction('home'),
              },
            },
          },
          live: {
            controls: {
              ptz: {
                mode: 'auto' as const,
                position: 'bottom-right' as const,
                orientation: 'horizontal' as const,
                hide_pan_tilt: false,
                hide_zoom: false,
                hide_home: false,
                style: {
                  color: 'red',
                },
              },
            },
          },
        });
        postUpgradeChecks(config);
      });

      it('with invalid ptz type', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              ptz: 3, // Not an object.
            },
          },
        };

        expect(upgradeConfig(config)).toBeFalsy();
      });

      it('with nothing to transform', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              ptz: {
                mode: 'auto',
              },
            },
          },
        };

        expect(upgradeConfig(config)).toBeFalsy();
      });

      it('without tap_action', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              ptz: {
                actions_up: {
                  double_tap_action: getActionBefore('up'),
                },
                actions_down: getTapAction('down'),
              },
            },
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual(
          expect.objectContaining({
            cameras_global: {
              ptz: {
                actions_down: getActionAfter('down'),
              },
            },
          }),
        );
        postUpgradeChecks(config);
      });

      it('without pre-existing presets', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              ptz: {
                presets: {
                  home: getActionBefore('left'),
                  other: getActionBefore('right'),
                },
                actions_home: getTapAction('home'),
              },
            },
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual(
          expect.objectContaining({
            cameras_global: {
              ptz: {
                presets: {
                  other: getActionAfter('right'),
                  home: getActionAfter('home'),
                },
              },
            },
          }),
        );
        postUpgradeChecks(config);
      });
    });

    it('view.update_cycle_camera -> view.default_cycle_camera', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{}],
        view: {
          update_cycle_camera: true,
        },
      };

      expect(upgradeConfig(config)).toBeTruthy();
      expect(config.view).toEqual({
        default_cycle_camera: true,
      });
      postUpgradeChecks(config);
    });

    describe('view.update_force -> view.default_reset.interaction_mode', () => {
      it('should convert to all when true', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          view: {
            update_force: true,
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config.view).toEqual({
          default_reset: {
            interaction_mode: 'all',
          },
        });
        postUpgradeChecks(config);
      });

      it('should remove when false', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          view: {
            update_force: false,
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config.view).toEqual({});
        postUpgradeChecks(config);
      });
    });

    it('view.update_seconds', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{}],
        view: {
          update_seconds: 42,
        },
      };

      expect(upgradeConfig(config)).toBeTruthy();
      expect(config.view).toEqual({
        default_reset: {
          every_seconds: 42,
        },
      });
      postUpgradeChecks(config);
    });

    it('view.update_entities', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{}],
        view: {
          update_entities: ['binary_sensor.foo', 'camera.bar'],
        },
      };

      expect(upgradeConfig(config)).toBeTruthy();
      expect(config.view).toEqual({
        default_reset: {
          entities: ['binary_sensor.foo', 'camera.bar'],
        },
      });
      postUpgradeChecks(config);
    });

    describe('title controls to status bar', () => {
      it('when mode is none', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: {
            controls: {
              title: {
                mode: 'none',
              },
            },
          },
          media_viewer: {
            controls: {
              title: {
                mode: 'none',
              },
            },
          },
        };

        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{}],
          live: { controls: {} },
          media_viewer: { controls: {} },
          status_bar: {
            style: 'none',
          },
        });

        postUpgradeChecks(config);
      });

      describe('when mode is invalid type', () => {
        it.each([[{ mode: { should_not_be: 'an object' } }], ['sideways']])(
          '%s',
          (mode: unknown) => {
            const config = {
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: {
                controls: {
                  title: {
                    mode,
                  },
                },
              },
              media_viewer: {
                controls: {
                  title: {
                    mode,
                  },
                },
              },
            };

            expect(upgradeConfig(config)).toBeTruthy();
            expect(config).toEqual({
              type: 'custom:advanced-camera-card',
              cameras: [{}],
              live: { controls: {} },
              media_viewer: { controls: {} },
            });

            postUpgradeChecks(config);
          },
        );
      });

      describe.each([['bottom'], ['top']])('on the %s', (position: string) => {
        it.each([
          [`popup-${position}-left` as const],
          [`popup-${position}-right` as const],
        ])('%s', (mode: string) => {
          const config = {
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            live: {
              controls: {
                title: {
                  mode,
                },
              },
            },
            media_viewer: {
              controls: {
                title: {
                  mode,
                },
              },
            },
          };

          expect(upgradeConfig(config)).toBeTruthy();
          expect(config).toEqual({
            type: 'custom:advanced-camera-card',
            cameras: [{}],
            live: { controls: {} },
            media_viewer: { controls: {} },
            status_bar: {
              position,
            },
          });

          postUpgradeChecks(config);
        });
      });
    });

    it('rename call-service -> perform-action', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            tap_action: {
              action: 'call-service',
              service: 'foo',
            },
          },
        ],
        view: {
          actions: {
            double_tap_action: {
              action: 'call-service',
              service: 'bar',
              data: {
                key: 'value',
              },
            },
          },
        },
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            tap_action: {
              action: 'perform-action',
              perform_action: 'foo',
            },
          },
        ],
        view: {
          actions: {
            double_tap_action: {
              action: 'perform-action',
              perform_action: 'bar',
              data: {
                key: 'value',
              },
            },
          },
        },
      });
      postUpgradeChecks(config);
    });

    it('rename dimensions.max_height -> dimensions.height', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        dimensions: {
          max_height: '500px',
        },
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        dimensions: {
          height: '500px',
        },
      });
      postUpgradeChecks(config);
    });

    it('delete dimensions.min_height', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        dimensions: {
          min_height: '100px',
        },
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        dimensions: {},
      });
      postUpgradeChecks(config);
    });
  });

  describe('v6.1.2+', () => {
    describe('view.dark_mode -> view.dim', () => {
      it.each([
        ['on' as const, true],
        ['auto' as const, false],
        ['off' as const, false],
      ])('%s', (darkMode: 'on' | 'off' | 'auto', expected: boolean) => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            dark_mode: darkMode,
          },
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            dim: expected,
          },
        });
        postUpgradeChecks(config);
      });
    });
  });

  describe('v7.0.0+', () => {
    it('custom:frigate-card -> custom:advanced-camera-card', () => {
      const config = {
        type: 'custom:frigate-card',
        cameras: [{}],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{}],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-action -> custom:advanced-camera-card-action', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            tap_action: {
              action: 'custom:frigate-card-action',
              advanced_camera_card_action: 'camera_ui',
            },
          },
        ],
        view: {
          actions: {
            double_tap_action: {
              action: 'custom:frigate-card-action',
              advanced_camera_card_action: 'camera_ui',
            },
          },
        },
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            tap_action: {
              action: 'custom:advanced-camera-card-action',
              advanced_camera_card_action: 'camera_ui',
            },
          },
        ],
        view: {
          actions: {
            double_tap_action: {
              action: 'custom:advanced-camera-card-action',
              advanced_camera_card_action: 'camera_ui',
            },
          },
        },
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-menu-icon -> custom:advanced-camera-card-menu-icon', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-menu-icon',
            icon: 'mdi:cow',
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-menu-icon',
            icon: 'mdi:cow',
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-menu-state-icon -> custom:advanced-camera-card-menu-state-icon', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-menu-state-icon',
            entity: 'binary_sensor.office',
            icon: 'mdi:cow',
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-menu-state-icon',
            entity: 'binary_sensor.office',
            icon: 'mdi:cow',
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-menu-submenu -> custom:advanced-camera-card-menu-submenu', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-menu-submenu',
            icon: 'mdi:cow',
            items: [],
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-menu-submenu',
            icon: 'mdi:cow',
            items: [],
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-status-bar-icon -> custom:advanced-camera-card-status-bar-icon', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-status-bar-icon',
            icon: 'mdi:cow',
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-status-bar-icon',
            icon: 'mdi:cow',
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-status-bar-image -> custom:advanced-camera-card-status-bar-image', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-status-bar-image',
            image: 'image',
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-status-bar-image',
            image: 'image',
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-status-bar-string -> custom:advanced-camera-card-status-bar-string', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-status-bar-string',
            string: 'string',
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-status-bar-string',
            string: 'string',
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('custom:frigate-card-conditional -> custom:advanced-camera-card-conditional', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:frigate-card-conditional',
            conditions: [],
            elements: [],
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'custom:advanced-camera-card-conditional',
            conditions: [],
            elements: [],
          },
        ],
      });
      postUpgradeChecks(config);
    });

    it('frigate_card_action -> advanced_camera_card_action', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            tap_action: {
              action: 'custom:advanced-camera-card-action',
              frigate_card_action: 'camera_ui',
            },
          },
        ],
        view: {
          actions: {
            double_tap_action: {
              action: 'custom:advanced-camera-card-action',
              frigate_card_action: 'camera_ui',
            },
          },
        },
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:cow',
            tap_action: {
              action: 'custom:advanced-camera-card-action',
              advanced_camera_card_action: 'camera_ui',
            },
          },
        ],
        view: {
          actions: {
            double_tap_action: {
              action: 'custom:advanced-camera-card-action',
              advanced_camera_card_action: 'camera_ui',
            },
          },
        },
      });
      postUpgradeChecks(config);
    });

    describe('frigate card style overrides -> advanced camera card style overrides', () => {
      it('valid style overrides', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            theme: {
              overrides: {
                '--zero': 'zero',
                '--frigate-card-one': 'one',
              },
            },
          },
          overrides: [
            {
              conditions: [
                {
                  condition: 'media_loaded' as const,
                  media_loaded: true,
                },
              ],
              merge: {
                view: {
                  theme: {
                    overrides: {
                      '--frigate-card-two': 'two',
                    },
                  },
                },
              },
            },
          ],
        };
        expect(upgradeConfig(config)).toBeTruthy();
        expect(config).toEqual({
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            theme: {
              overrides: {
                '--zero': 'zero',
                '--advanced-camera-card-one': 'one',
              },
            },
          },
          overrides: [
            {
              conditions: [
                {
                  condition: 'media_loaded' as const,
                  media_loaded: true,
                },
              ],
              merge: {
                view: {
                  theme: {
                    overrides: {
                      '--advanced-camera-card-two': 'two',
                    },
                  },
                },
              },
            },
          ],
        });
        postUpgradeChecks(config);
      });

      it('invalid style overrides', () => {
        const config = {
          type: 'custom:advanced-camera-card',
          cameras: [{ camera_entity: 'camera.office' }],
          view: {
            theme: {
              overrides: ['should', 'not', 'be', 'an', 'array'],
            },
          },
        };
        expect(upgradeConfig(config)).toBeFalsy();
      });
    });

    it('frigate card button -> iris button', () => {
      const config = {
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        menu: {
          buttons: {
            frigate: {
              icon: 'mdi:cow',
            },
          },
        },
        overrides: [
          {
            conditions: [
              {
                condition: 'media_loaded' as const,
                media_loaded: true,
              },
            ],
            merge: {
              menu: {
                buttons: {
                  frigate: {
                    icon: 'mdi:cow',
                  },
                },
              },
            },
          },
        ],
      };
      expect(upgradeConfig(config)).toBeTruthy();
      expect(config).toEqual({
        type: 'custom:advanced-camera-card',
        cameras: [{ camera_entity: 'camera.office' }],
        menu: {
          buttons: {
            iris: {
              icon: 'mdi:cow',
            },
          },
        },
        overrides: [
          {
            conditions: [
              {
                condition: 'media_loaded' as const,
                media_loaded: true,
              },
            ],
            merge: {
              menu: {
                buttons: {
                  iris: {
                    icon: 'mdi:cow',
                  },
                },
              },
            },
          },
        ],
      });
      postUpgradeChecks(config);
    });
  });
});



================================================
FILE: tests/config/types.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { advancedCameraCardCustomActionsBaseSchema } from '../../src/config/schema/actions/custom/base';
import { statusBarActionConfigSchema } from '../../src/config/schema/actions/types';
import { cameraConfigSchema } from '../../src/config/schema/cameras';
import { advancedCameraCardConditionSchema } from '../../src/config/schema/conditions/types';
import { dimensionsConfigSchema } from '../../src/config/schema/dimensions';
import { customSchema } from '../../src/config/schema/elements/stock/custom';
import { conditionalSchema } from '../../src/config/schema/elements/types';
import { createConfig } from '../test-utils';

// @vitest-environment jsdom
describe('config defaults', () => {
  it('should be as expected', () => {
    expect(createConfig()).toEqual({
      cameras: [{}],
      cameras_global: {
        always_error_if_entity_unavailable: false,
        dependencies: {
          all_cameras: false,
          cameras: [],
        },
        engine: 'auto',
        frigate: {
          client_id: 'frigate',
        },
        image: {
          mode: 'auto',
          refresh_seconds: 1,
        },
        live_provider: 'auto',
        motioneye: {
          images: {
            directory_pattern: '%Y-%m-%d',
            file_pattern: '%H-%M-%S',
          },
          movies: {
            directory_pattern: '%Y-%m-%d',
            file_pattern: '%H-%M-%S',
          },
        },
        proxy: {
          dynamic: true,
          media: 'auto',
          ssl_verification: 'auto',
          ssl_ciphers: 'auto',
        },
        ptz: {
          c2r_delay_between_calls_seconds: 0.2,
          r2c_delay_between_calls_seconds: 0.5,
        },
        reolink: {
          media_resolution: 'low',
        },
        triggers: {
          events: ['events', 'clips', 'snapshots'],
          entities: [],
          motion: false,
          occupancy: false,
        },
      },
      debug: {
        logging: false,
      },
      dimensions: {
        aspect_ratio: [16, 9],
        aspect_ratio_mode: 'dynamic',
        height: 'auto',
      },
      image: {
        zoomable: true,
        mode: 'auto',
        refresh_seconds: 1,
      },
      live: {
        auto_mute: ['unselected', 'hidden', 'microphone'],
        auto_pause: [],
        auto_play: ['selected', 'visible'],
        auto_unmute: ['microphone'],
        controls: {
          builtin: true,
          next_previous: {
            size: 48,
            style: 'chevrons',
          },
          ptz: {
            hide_home: false,
            hide_pan_tilt: false,
            hide_zoom: false,
            mode: 'auto',
            orientation: 'horizontal',
            position: 'bottom-right',
          },
          thumbnails: {
            media_type: 'events',
            events_media_type: 'all',
            mode: 'right',
            show_details: true,
            show_download_control: true,
            show_favorite_control: true,
            show_timeline_control: true,
            size: 100,
          },
          timeline: {
            clustering_threshold: 3,
            events_media_type: 'all',
            format: {
              '24h': true,
            },
            mode: 'none',
            pan_mode: 'pan',
            show_recordings: true,
            style: 'ribbon',
            window_seconds: 3600,
          },
        },
        draggable: true,
        lazy_load: true,
        lazy_unload: [],
        microphone: {
          always_connected: false,
          disconnect_seconds: 90,
          mute_after_microphone_mute_seconds: 60,
        },
        preload: false,
        show_image_during_load: true,
        transition_effect: 'slide',
        zoomable: true,
      },
      media_gallery: {
        controls: {
          filter: {
            mode: 'right',
          },
          thumbnails: {
            show_details: false,
            show_download_control: true,
            show_favorite_control: true,
            show_timeline_control: true,
            size: 100,
          },
        },
      },
      media_viewer: {
        auto_mute: ['unselected', 'hidden'],
        auto_pause: ['unselected', 'hidden'],
        auto_play: ['selected', 'visible'],
        auto_unmute: [],
        controls: {
          builtin: true,
          next_previous: {
            size: 48,
            style: 'thumbnails',
          },
          ptz: {
            hide_home: false,
            hide_pan_tilt: false,
            hide_zoom: false,
            mode: 'off',
            orientation: 'horizontal',
            position: 'bottom-right',
          },
          thumbnails: {
            mode: 'right',
            show_details: true,
            show_download_control: true,
            show_favorite_control: true,
            show_timeline_control: true,
            size: 100,
          },
          timeline: {
            clustering_threshold: 3,
            events_media_type: 'all',
            format: {
              '24h': true,
            },
            mode: 'none',
            pan_mode: 'pan',
            show_recordings: true,
            style: 'ribbon',
            window_seconds: 3600,
          },
        },
        draggable: true,
        lazy_load: true,
        snapshot_click_plays_clip: true,
        transition_effect: 'slide',
        zoomable: true,
      },
      menu: {
        alignment: 'left',
        button_size: 40,
        buttons: {
          camera_ui: {
            enabled: true,
            priority: 50,
          },
          cameras: {
            enabled: true,
            priority: 50,
          },
          clips: {
            enabled: true,
            priority: 50,
          },
          display_mode: {
            enabled: true,
            priority: 50,
          },
          download: {
            enabled: true,
            priority: 50,
          },
          expand: {
            enabled: false,
            priority: 50,
          },
          folders: {
            enabled: true,
            priority: 50,
          },
          fullscreen: {
            enabled: true,
            priority: 50,
          },
          image: {
            enabled: false,
            priority: 50,
          },
          iris: {
            enabled: true,
            priority: 50,
          },
          live: {
            enabled: true,
            priority: 50,
          },
          media_player: {
            enabled: true,
            priority: 50,
          },
          microphone: {
            enabled: false,
            priority: 50,
            type: 'momentary',
          },
          mute: {
            enabled: false,
            priority: 50,
          },
          play: {
            enabled: false,
            priority: 50,
          },
          ptz_controls: {
            enabled: false,
            priority: 50,
          },
          ptz_home: {
            enabled: false,
            priority: 50,
          },
          recordings: {
            enabled: false,
            priority: 50,
          },
          screenshot: {
            enabled: false,
            priority: 50,
          },
          snapshots: {
            enabled: true,
            priority: 50,
          },
          substreams: {
            enabled: true,
            priority: 50,
          },
          timeline: {
            enabled: true,
            priority: 50,
          },
        },
        position: 'top',
        style: 'hidden',
      },
      performance: {
        features: {
          animated_progress_indicator: true,
          card_loading_indicator: true,
          media_chunk_size: 50,
        },
        style: {
          border_radius: true,
          box_shadow: true,
        },
      },
      remote_control: {
        entities: {
          camera_priority: 'card',
        },
      },
      status_bar: {
        height: 40,
        items: {
          engine: {
            enabled: true,
            priority: 50,
          },
          resolution: {
            enabled: true,
            priority: 50,
          },
          technology: {
            enabled: true,
            priority: 50,
          },
          title: {
            enabled: true,
            priority: 50,
          },
        },
        popup_seconds: 3,
        position: 'bottom',
        style: 'popup',
      },
      timeline: {
        clustering_threshold: 3,
        controls: {
          thumbnails: {
            mode: 'right',
            show_details: true,
            show_download_control: true,
            show_favorite_control: true,
            show_timeline_control: true,
            size: 100,
          },
        },
        events_media_type: 'all',
        format: {
          '24h': true,
        },
        pan_mode: 'pan',
        show_recordings: true,
        style: 'stack',
        window_seconds: 3600,
      },
      type: 'advanced-camera-card',
      view: {
        camera_select: 'current',
        default: 'live',
        keyboard_shortcuts: {
          enabled: true,
          ptz_down: {
            key: 'ArrowDown',
          },
          ptz_home: {
            key: 'h',
          },
          ptz_left: {
            key: 'ArrowLeft',
          },
          ptz_right: {
            key: 'ArrowRight',
          },
          ptz_up: {
            key: 'ArrowUp',
          },
          ptz_zoom_in: {
            key: '+',
          },
          ptz_zoom_out: {
            key: '-',
          },
        },
        theme: {
          themes: ['traditional'],
        },
        triggers: {
          show_trigger_status: false,
          untrigger_seconds: 0,
          actions: {
            trigger: 'update',
            untrigger: 'none',
            interaction_mode: 'inactive',
          },
          filter_selected_camera: true,
        },
        interaction_seconds: 300,
        dim: false,
        default_cycle_camera: false,
        default_reset: {
          after_interaction: false,
          every_seconds: 0,
          entities: [],
          interaction_mode: 'inactive',
        },
      },
    });
  });

  it('should include all stock elements', () => {
    const stockElements = [
      {
        type: 'icon',
        icon: 'mdi:dog',
        entity: 'camera.office',
      },
      {
        type: 'custom:element',
        data: 'foo',
      },
      {
        type: 'image',
        entity: 'camera.office',
        image: 'image',
        camera_image: 'camera_image',
        camera_view: 'camera_view',
        state_image: {},
        filter: 'filter',
        state_filter: { on: '/foo' },
        aspect_ratio: '16 / 9',
      },
      {
        type: 'custom:advanced-camera-card-menu-icon',
        icon: 'mdi:cat',
        entity: 'camera.kitchen',
      },
      {
        type: 'custom:advanced-camera-card-menu-state-icon',
        entity: 'camera.kitchen',
        icon: 'mdi:sheep',
        state_color: false,
      },
      {
        type: 'state-badge',
        entity: 'sensor.kitchen_dining_multisensor_air_temperature',
        style: {
          left: '100px',
          top: '50px',
        },
        title: 'Temperature',
      },
      {
        type: 'state-icon',
        entity: 'light.office_main_lights',
        icon: 'mdi:lamp',
        state_color: true,
        style: {
          left: '100px',
          top: '100px',
        },
      },
      {
        type: 'state-label',
        entity: 'sensor.kitchen_motion_sensor_battery',
        attribute: 'battery_voltage',
        prefix: 'Volts',
        title: 'Battery Voltage',
        style: {
          left: '100px',
          top: '150px',
        },
      },
      {
        type: 'state-label',
        entity: 'sensor.kitchen_motion_sensor_battery',
        attribute: 'battery_voltage',
        prefix: 'Volts: ',
        title: 'Battery Voltage',
        style: {
          backgroundColor: 'black',
          left: '100px',
          top: '200px',
        },
      },
      {
        type: 'service-button',
        title: 'Light on',
        service: 'homeassistant.turn_on',
        service_data: {
          entity: 'light.office_main_lights',
        },
        style: {
          left: '100px',
          top: '250px',
        },
      },
      {
        type: 'icon',
        icon: 'mdi:cow',
        title: 'Moo',
        style: {
          left: '100px',
          top: '300px',
        },
      },
      {
        type: 'image',
        entity: 'light.office_main_lights',
        title: 'Image',
        state_image: {
          on: 'https://picsum.photos/id/1003/1181/1772',
          off: 'https://picsum.photos/id/102/4320/3240',
        },
        state_filter: {
          on: 'brightness(110%) saturate(1.2)',
          off: 'brightness(50%) hue-rotate(45deg)',
        },
        style: {
          left: '100px',
          top: '350px',
          height: '50px',
          width: '100px',
        },
      },
      {
        type: 'conditional',
        conditions: [
          {
            condition: 'state',
            entity: 'light.office_main_lights',
            state: 'on',
            state_not: 'off',
          },
        ],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:dog',
            title: 'Woof',
            style: {
              left: '100px',
              top: '400px',
            },
          },
        ],
      },
    ];

    expect(
      createConfig({
        elements: stockElements,
      }).elements,
    ).toEqual(stockElements);
  });

  it('should include all custom elements', () => {
    const customElements = [
      {
        type: 'custom:advanced-camera-card-menu-icon',
        alignment: 'matching',
        enabled: true,
        entity: 'light.office_main_lights',
        icon: 'mdi:car',
        permanent: false,
        priority: 50,
        style: {
          color: 'white',
        },
        title: 'Vroom',
      },
      {
        type: 'custom:advanced-camera-card-menu-state-icon',
        alignment: 'matching',
        enabled: true,
        entity: 'light.office_main_lights',
        icon: 'mdi:chair-rolling',
        permanent: false,
        priority: 50,
        state_color: true,
        style: {
          color: 'white',
        },
        title: 'Office lights',
      },
      {
        type: 'custom:advanced-camera-card-menu-submenu',
        alignment: 'matching',
        enabled: true,
        entity: 'light.office_main_lights',
        icon: 'mdi:menu',
        items: [
          {
            enabled: true,
            entity: 'light.office_main_lights',
            icon: 'mdi:lightbulb',
            selected: false,
            state_color: true,
            style: {
              color: 'white',
            },
            tap_action: {
              action: 'toggle',
            },
            title: 'Lights',
          },
          {
            enabled: true,
            icon: 'mdi:google',
            selected: false,
            state_color: false,
            style: {
              color: 'white',
            },
            tap_action: {
              action: 'url',
              url_path: 'https://www.google.com',
            },
            title: 'Google',
          },
        ],
        permanent: false,
        priority: 50,
        style: {
          color: 'white',
        },
        title: 'Office lights',
      },
      {
        type: 'custom:advanced-camera-card-menu-submenu-select',
        alignment: 'matching',
        enabled: true,
        entity: 'input_select.kitchen_scene',
        icon: 'mdi:lamps',
        options: {
          'scene.kitchen_cooking_scene': {
            enabled: true,
            icon: 'mdi:chef-hat',
            selected: false,
            state_color: true,
            style: {
              color: 'white',
            },
            title: 'Cooking time!',
          },
          'scene.kitchen_tv_scene': {
            icon: 'mdi:television',
            title: 'TV!',
          },
        },
        permanent: false,
        priority: 50,
        state_color: true,
        style: {
          color: 'white',
        },
        title: 'Kitchen Scene',
      },
      {
        type: 'custom:advanced-camera-card-conditional',
        elements: [
          {
            type: 'icon',
            icon: 'mdi:pig',
            title: 'Oink',
            style: {
              left: '300px',
              top: '100px',
            },
          },
        ],
        conditions: [
          {
            condition: 'view',
            views: ['live'],
          },
        ],
      },
      {
        type: 'custom:advanced-camera-card-status-bar-string',
        enabled: true,
        exclusive: false,
        expand: false,
        string: 'Intruder alert!',
        priority: 50,
        sufficient: false,
      },
      {
        type: 'custom:advanced-camera-card-status-bar-icon',
        enabled: true,
        exclusive: false,
        expand: false,
        icon: 'mdi:cow',
        priority: 50,
        sufficient: false,
      },
      {
        type: 'custom:advanced-camera-card-status-bar-image',
        enabled: true,
        exclusive: false,
        expand: false,
        image: 'https://my.site.com/status.png',
        priority: 50,
        sufficient: false,
      },
    ];

    expect(
      createConfig({
        elements: customElements,
      }).elements,
    ).toEqual(customElements);
  });

  it('should include all conditions', () => {
    const conditions = [
      { condition: 'and', conditions: [{ condition: 'initialized' }] },
      { condition: 'camera', cameras: ['camera.office'] },
      { condition: 'config', paths: ['menu.style'] },
      { condition: 'display_mode', display_mode: 'single' },
      { condition: 'expand', expand: true },
      { condition: 'fullscreen', fullscreen: true },
      { condition: 'initialized' },
      { condition: 'interaction', interaction: true },
      {
        condition: 'key',
        alt: false,
        ctrl: false,
        key: 'F',
        meta: false,
        shift: false,
        state: 'down',
      },
      { condition: 'media_loaded', media_loaded: true },
      { condition: 'microphone', connected: true, muted: true },
      { condition: 'not', conditions: [{ condition: 'initialized' }] },
      {
        condition: 'numeric_state',
        entity: 'sensor.office_temperature',
        above: 10,
        below: 20,
      },
      { condition: 'or', conditions: [{ condition: 'initialized' }] },
      { condition: 'screen', media_query: '(orientation: landscape)' },
      {
        condition: 'state',
        entity: 'climate.office',
        state: 'heat',
        state_not: 'off',
      },
      { condition: 'triggered', triggered: ['camera.office'] },
      { condition: 'user', users: ['581fca7fdc014b8b894519cc531f9a04'] },
      {
        condition: 'user_agent',
        user_agent:
          'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
        user_agent_re: 'Chrome/',
        companion: true,
      },
      { condition: 'view', views: ['live'] },
    ];

    const elements = [
      {
        type: 'custom:advanced-camera-card-conditional',
        elements: [
          {
            type: 'icon',
            icon: 'mdi:pig',
          },
        ],
        conditions: conditions,
      },
    ];

    expect(
      createConfig({
        elements: elements,
      }).elements,
    ).toEqual(elements);
  });

  it('should include all stock actions', () => {
    const stockActions = [
      {
        action: 'more-info',
      },
      {
        action: 'toggle',
      },
      {
        action: 'call-service',
        service: 'homeassistant.toggle',
        data: {
          entity_id: 'light.office_main_lights',
        },
      },
      {
        action: 'navigate',
        navigation_path: '/lovelace/2',
      },
      {
        action: 'url',
        url_path: 'https://www.home-assistant.io/',
      },
      {
        action: 'none',
      },
      {
        action: 'fire-dom-event',
        key: 'value',
      },
      {
        action: 'perform-action',
        perform_action: 'homeassistant.toggle',
        target: {
          entity_id: 'light.office_main_lights',
        },
      },
    ];

    expect(
      createConfig({
        live: {
          actions: {
            tap_action: stockActions,
          },
        },
      }).live.actions?.tap_action,
    ).toEqual(stockActions);
  });

  it('should include all custom actions', () => {
    const customActions = [
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'camera_select',
        camera: 'camera.front_door',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'camera_ui',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'clip',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'clips',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'default',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'diagnostics',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'display_mode_select',
        display_mode: 'grid',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'download',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'expand',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'fullscreen',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'image',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'live',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'live_substream_off',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'live_substream_on',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'live_substream_select',
        camera: 'camera.front_door_hd',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'log',
        message: 'Hello, world!',
        level: 'debug',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'media_player',
        media_player: 'media_player.nesthub50be',
        media_player_action: 'play',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'media_player',
        media_player: 'media_player.nesthub',
        media_player_action: 'stop',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'menu_toggle',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'microphone_connect',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'microphone_disconnect',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'microphone_mute',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'microphone_unmute',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'mute',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'pause',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'play',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'ptz',
        ptz_action: 'preset',
        ptz_preset: 'doorway',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'ptz_controls',
        enabled: true,
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'ptz_digital',
        absolute: {
          zoom: 5,
          pan: {
            x: 58,
            y: 14,
          },
        },
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'ptz_multi',
        ptz_action: 'left',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'recording',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'recordings',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'screenshot',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'sleep',
        duration: {
          h: 1,
          m: 20,
          s: 56,
          ms: 422,
        },
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'snapshot',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'snapshots',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'timeline',
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'unmute',
      },

      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'status_bar',
        status_bar_action: 'add',
        items: [
          {
            type: 'custom:advanced-camera-card-status-bar-string',
            enabled: true,
            exclusive: false,
            expand: false,
            string: 'Intruder alert!',
            priority: 50,
            sufficient: false,
          },
          {
            type: 'custom:advanced-camera-card-status-bar-icon',
            enabled: true,
            exclusive: false,
            expand: false,
            icon: 'mdi:cow',
            priority: 50,
            sufficient: false,
          },
          {
            type: 'custom:advanced-camera-card-status-bar-image',
            enabled: true,
            exclusive: false,
            expand: false,
            image: 'https://my.site.com/status.png',
            priority: 50,
            sufficient: false,
          },
        ],
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'status_bar',
        status_bar_action: 'remove',
        items: [
          {
            type: 'custom:advanced-camera-card-status-bar-string',
            enabled: true,
            exclusive: false,
            expand: false,
            string: 'Intruder alert!',
            priority: 50,
            sufficient: false,
          },
          {
            type: 'custom:advanced-camera-card-status-bar-icon',
            enabled: true,
            exclusive: false,
            expand: false,
            icon: 'mdi:cow',
            priority: 50,
            sufficient: false,
          },
          {
            type: 'custom:advanced-camera-card-status-bar-image',
            enabled: true,
            exclusive: false,
            expand: false,
            image: 'https://my.site.com/status.png',
            priority: 50,
            sufficient: false,
          },
        ],
      },
      {
        action: 'custom:advanced-camera-card-action',
        advanced_camera_card_action: 'status_bar',
        status_bar_action: 'reset',
      },
    ];

    expect(
      createConfig({
        live: {
          actions: {
            tap_action: customActions,
          },
        },
      }).live.actions?.tap_action,
    ).toEqual(
      // Action type will be transformed to fire-dom-event.
      customActions.map((action) => ({ ...action, action: 'fire-dom-event' })),
    );
  });
});

it('should transform dimensions.aspect_ratio', () => {
  expect(
    dimensionsConfigSchema.parse({
      aspect_ratio: '16 / 9',
    }),
  ).toEqual(expect.objectContaining({ aspect_ratio: [16, 9] }));

  expect(
    dimensionsConfigSchema.parse({
      aspect_ratio: '16 : 9',
    }),
  ).toEqual(expect.objectContaining({ aspect_ratio: [16, 9] }));

  expect(
    dimensionsConfigSchema.parse({
      aspect_ratio: [16, 9],
    }),
  ).toEqual(expect.objectContaining({ aspect_ratio: [16, 9] }));
});

describe('should refine user_agent_re conditions', () => {
  it('should successfully parse valid user_agent_re condition', () => {
    expect(
      advancedCameraCardConditionSchema.parse({
        condition: 'user_agent',
        user_agent_re: 'Chrome/',
      }),
    ).toEqual({
      condition: 'user_agent',
      user_agent_re: 'Chrome/',
    });
  });

  it('should reject invalid user_agent_re conditions', () => {
    expect(() =>
      advancedCameraCardConditionSchema.parse({
        condition: 'user_agent',
        user_agent_re: '[',
      }),
    ).toThrowError(/Invalid regular expression/);
  });
});

it('should transform action', () => {
  expect(
    advancedCameraCardCustomActionsBaseSchema.parse({
      action: 'custom:advanced-camera-card-action',
    }),
  ).toEqual({
    action: 'fire-dom-event',
  });
});

describe('should convert webrtc card PTZ to Advanced Camera Card PTZ', () => {
  describe('relative actions', () => {
    it.each([
      ['left' as const],
      ['right' as const],
      ['up' as const],
      ['down' as const],
      ['zoom_in' as const],
      ['zoom_out' as const],
    ])('%s', (action: string) => {
      expect(
        cameraConfigSchema.parse({
          ptz: {
            service: 'foo',
            [`data_${action}`]: {
              device: '048123',
              cmd: action,
            },
          },
        }),
      ).toEqual(
        expect.objectContaining({
          ptz: expect.objectContaining({
            [`actions_${action}`]: {
              action: 'perform-action',
              perform_action: 'foo',
              data: {
                device: '048123',
                cmd: action,
              },
            },
          }),
        }),
      );
    });
  });

  describe('continuous actions', () => {
    it.each([
      ['left' as const],
      ['right' as const],
      ['up' as const],
      ['down' as const],
      ['zoom_in' as const],
      ['zoom_out' as const],
    ])('%s', (action: string) => {
      expect(
        cameraConfigSchema.parse({
          ptz: {
            service: 'foo',
            [`data_${action}_start`]: {
              device: '048123',
              cmd: action,
              phase: 'start',
            },
            [`data_${action}_stop`]: {
              device: '048123',
              cmd: action,
              phase: 'stop',
            },
          },
        }),
      ).toEqual(
        expect.objectContaining({
          ptz: expect.objectContaining({
            [`actions_${action}_start`]: {
              action: 'perform-action',
              perform_action: 'foo',
              data: {
                device: '048123',
                cmd: action,
                phase: 'start',
              },
            },
            [`actions_${action}_stop`]: {
              action: 'perform-action',
              perform_action: 'foo',
              data: {
                device: '048123',
                cmd: action,
                phase: 'stop',
              },
            },
          }),
        }),
      );
    });
  });

  it('presets', () => {
    expect(
      cameraConfigSchema.parse({
        ptz: {
          service: 'service_outer',
          presets: {
            service: 'service_inner',
            data_home: {
              device: '048123',
              cmd: 'home',
            },
            data_another: {
              device: '048123',
              cmd: 'another',
            },
          },
        },
      }),
    ).toEqual(
      expect.objectContaining({
        ptz: expect.objectContaining({
          presets: {
            home: {
              action: 'perform-action',
              perform_action: 'service_inner',
              data: {
                device: '048123',
                cmd: 'home',
              },
            },
            another: {
              action: 'perform-action',
              perform_action: 'service_inner',
              data: {
                device: '048123',
                cmd: 'another',
              },
            },
          },
        }),
      }),
    );
  });
});

describe('should lazy evaluate schemas', () => {
  it('conditional picture element', () => {
    expect(
      conditionalSchema.parse({
        type: 'conditional',
        conditions: [
          {
            condition: 'state',
            entity: 'light.office_main_lights',
            state: 'on',
            state_not: 'off',
          },
        ],
        elements: [
          {
            type: 'icon',
            icon: 'mdi:dog',
            title: 'Woof',
            style: {
              left: '100px',
              top: '400px',
            },
          },
        ],
      }),
    ).toEqual({
      conditions: [
        {
          condition: 'state',
          entity: 'light.office_main_lights',
          state: 'on',
          state_not: 'off',
        },
      ],
      elements: [
        {
          icon: 'mdi:dog',
          style: {
            left: '100px',
            top: '400px',
          },
          title: 'Woof',
          type: 'icon',
        },
      ],
      type: 'conditional',
    });
  });

  it('status bar actions', () => {
    const input = {
      action: 'fire-dom-event',
      advanced_camera_card_action: 'status_bar',
      status_bar_action: 'reset',
      items: [
        {
          type: 'custom:advanced-camera-card-status-bar-string',
          string: 'Item',
        },
      ],
    };
    expect(statusBarActionConfigSchema.parse(input)).toEqual(input);
  });
});

describe('should handle custom advanced camera card elements', () => {
  it('should add custom error on advanced camera card element', () => {
    const result = customSchema.safeParse({
      type: 'custom:advanced-camera-card-foo',
    });
    expect(result.success).toBeFalsy();
    if (!result.success) {
      expect(result.error.errors[0]).toEqual({
        code: 'custom',
        message: 'advanced-camera-card custom elements must match specific schemas',
        fatal: true,
        path: ['type'],
      });
    }
  });

  it('should not add custom error on valid entry', () => {
    const result = customSchema.safeParse({
      type: 'custom:foo',
    });
    expect(result.success).toBeTruthy();
  });
});

// https://github.com/dermotduffy/advanced-camera-card/issues/1280
it('should not require title controls to specify all options', () => {
  expect(
    createConfig({
      cameras: [{}],
      live: {
        controls: {
          title: {
            mode: 'popup-top-left',
          },
        },
      },
    }),
  ).toBeTruthy();
});

it('should strip trailing slashes from go2rtc url', () => {
  const config = createConfig({
    cameras: [
      {
        go2rtc: {
          url: 'https://my-custom-go2rtc//',
        },
      },
    ],
  });
  expect(config).toBeTruthy();
  expect(config.cameras[0].go2rtc.url).toBe('https://my-custom-go2rtc');
});

it('media viewer should not support microphone based conditions', () => {
  expect(() =>
    createConfig({
      cameras: [],
      media_viewer: {
        auto_unmute: 'microphone' as const,
      },
    }),
  ).toThrowError();
});

describe('automations should require at least one action', () => {
  it('no action', () => {
    expect(() =>
      createConfig({
        cameras: [{}],
        automations: [{ conditions: [] }],
      }),
    ).toThrowError(/Automations must include at least one action/);
  });

  it('empty actions', () => {
    expect(() =>
      createConfig({
        cameras: [{}],
        automations: [{ conditions: [], actions: [], actions_not: [] }],
      }),
    ).toThrowError(/Automations must include at least one action/);
  });

  it('at least one action', () => {
    expect(() =>
      createConfig({
        cameras: [{}],
        automations: [
          {
            conditions: [],
            actions: [
              {
                action: 'fire-dom-event',
              },
            ],
          },
        ],
      }),
    ).not.toThrowError();
  });
});



================================================
FILE: tests/config/profiles/casting.test.ts
================================================
import { expect, it } from 'vitest';
import { CASTING_PROFILE } from '../../../src/config/profiles/casting';
import { setProfiles } from '../../../src/config/profiles/set-profiles';
import { advancedCameraCardConfigSchema } from '../../../src/config/schema/types';
import { createRawConfig } from '../../test-utils';

it('should contain expected defaults', () => {
  expect(CASTING_PROFILE).toEqual({
    'cameras_global.image.refresh_seconds': 1,
    'dimensions.aspect_ratio_mode': 'static',
    'dimensions.aspect_ratio': '16:9',
    'live.auto_unmute': ['selected', 'visible'],
    'live.controls.builtin': false,
    'live.show_image_during_load': true,
    'media_viewer.controls.builtin': false,
    'menu.buttons.fullscreen.enabled': false,
    'menu.buttons.media_player.enabled': false,
    'menu.buttons.mute.enabled': true,
    'menu.buttons.play.enabled': true,
    'menu.style': 'none',
  });
});

it('should be parseable after application', () => {
  const rawInputConfig = createRawConfig();
  const parsedConfig = advancedCameraCardConfigSchema.parse(rawInputConfig);

  setProfiles(rawInputConfig, parsedConfig, ['casting']);

  // Reparse the config to ensure the profile did not introduce errors.
  const parseResult = advancedCameraCardConfigSchema.safeParse(parsedConfig);
  expect(parseResult.success, parseResult.error?.toString()).toBeTruthy();
});



================================================
FILE: tests/config/profiles/index.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { setProfiles } from '../../../src/config/profiles/set-profiles';
import { ProfileType } from '../../../src/config/schema/profiles';
import { createConfig } from '../../test-utils';

describe('setProfiles', () => {
  it('should handle failed parse', () => {
    expect(setProfiles({ cameras: 'not_an_array' }, {})).toEqual({});
  });

  it('should handle no profiles', () => {
    const input = createConfig();
    const output = createConfig();

    expect(setProfiles(input, output)).toEqual(input);
  });

  it('should handle invalid profiles', () => {
    const input = createConfig();
    const output = createConfig();

    expect(setProfiles(input, output, ['bogus' as ProfileType])).toEqual(input);
  });

  it('should handle profiles', () => {
    const input = {
      type: 'custom:advanced-camera-card',
      cameras: [{}],
      live: {
        controls: {
          timeline: {
            // This will not be overridden.
            style: 'stack',
          },
        },
      },
    };
    expect(setProfiles(input, {}, ['scrubbing'])).toEqual({
      live: {
        controls: {
          timeline: {
            mode: 'below',
            pan_mode: 'seek',
          },
        },
      },
      media_viewer: {
        controls: {
          timeline: {
            mode: 'below',
            style: 'ribbon',
            pan_mode: 'seek',
          },
        },
      },
    });
  });
});



================================================
FILE: tests/config/profiles/low-performance.test.ts
================================================
import { expect, it } from 'vitest';
import { LOW_PERFORMANCE_PROFILE } from '../../../src/config/profiles/low-performance';
import { setProfiles } from '../../../src/config/profiles/set-profiles';
import { advancedCameraCardConfigSchema } from '../../../src/config/schema/types';
import { createRawConfig } from '../../test-utils';

it('should contain expected defaults', () => {
  expect(LOW_PERFORMANCE_PROFILE).toEqual({
    'cameras_global.image.refresh_seconds': 10,
    'cameras_global.live_provider': 'image',
    'cameras_global.triggers.occupancy': false,
    'live.auto_mute': [],
    'live.controls.thumbnails.mode': 'none',
    'live.controls.thumbnails.show_details': false,
    'live.controls.thumbnails.show_download_control': false,
    'live.controls.thumbnails.show_favorite_control': false,
    'live.controls.thumbnails.show_timeline_control': false,
    'live.controls.timeline.show_recordings': false,
    'live.draggable': false,
    'live.lazy_unload': ['unselected', 'hidden'],
    'live.show_image_during_load': false,
    'live.transition_effect': 'none',
    'media_gallery.controls.thumbnails.show_details': false,
    'media_gallery.controls.thumbnails.show_download_control': false,
    'media_gallery.controls.thumbnails.show_favorite_control': false,
    'media_gallery.controls.thumbnails.show_timeline_control': false,
    'media_viewer.auto_mute': [],
    'media_viewer.auto_pause': [],
    'media_viewer.auto_play': [],
    'media_viewer.controls.next_previous.style': 'chevrons',
    'media_viewer.controls.thumbnails.mode': 'none',
    'media_viewer.controls.thumbnails.show_details': false,
    'media_viewer.controls.thumbnails.show_download_control': false,
    'media_viewer.controls.thumbnails.show_favorite_control': false,
    'media_viewer.controls.thumbnails.show_timeline_control': false,
    'media_viewer.controls.timeline.show_recordings': false,
    'media_viewer.draggable': false,
    'media_viewer.snapshot_click_plays_clip': false,
    'media_viewer.transition_effect': 'none',
    'menu.buttons.iris.enabled': false,
    'menu.buttons.media_player.enabled': false,
    'menu.buttons.timeline.enabled': false,
    'menu.style': 'outside',
    'performance.features.animated_progress_indicator': false,
    'performance.features.card_loading_indicator': false,
    'performance.features.max_simultaneous_engine_requests': 1,
    'performance.features.media_chunk_size': 10,
    'performance.style.border_radius': false,
    'performance.style.box_shadow': false,
    'status_bar.style': 'none',
    'timeline.controls.thumbnails.mode': 'none',
    'timeline.controls.thumbnails.show_details': false,
    'timeline.controls.thumbnails.show_download_control': false,
    'timeline.controls.thumbnails.show_favorite_control': false,
    'timeline.controls.thumbnails.show_timeline_control': false,
    'timeline.show_recordings': false,
    'view.triggers.actions.trigger': 'none',
  });
});

it('should be parseable after application', () => {
  const rawInputConfig = createRawConfig();
  const parsedConfig = advancedCameraCardConfigSchema.parse(rawInputConfig);

  setProfiles(rawInputConfig, parsedConfig, ['low-performance']);

  // Reparse the config to ensure the profile did not introduce errors.
  const parseResult = advancedCameraCardConfigSchema.safeParse(parsedConfig);
  expect(parseResult.success, parseResult.error?.toString()).toBeTruthy();
});



================================================
FILE: tests/config/profiles/scrubbing.test.ts
================================================
import { expect, it } from 'vitest';
import { SCRUBBING_PROFILE } from '../../../src/config/profiles/scrubbing';
import { setProfiles } from '../../../src/config/profiles/set-profiles';
import { advancedCameraCardConfigSchema } from '../../../src/config/schema/types';
import { createRawConfig } from '../../test-utils';

it('should contain expected defaults', () => {
  expect(SCRUBBING_PROFILE).toEqual({
    'live.controls.timeline.mode': 'below',
    'live.controls.timeline.style': 'ribbon',
    'live.controls.timeline.pan_mode': 'seek',
    'media_viewer.controls.timeline.mode': 'below',
    'media_viewer.controls.timeline.style': 'ribbon',
    'media_viewer.controls.timeline.pan_mode': 'seek',
  });
});

it('should be parseable after application', () => {
  const rawInputConfig = createRawConfig();
  const parsedConfig = advancedCameraCardConfigSchema.parse(rawInputConfig);

  setProfiles(rawInputConfig, parsedConfig, ['low-performance']);

  // Reparse the config to ensure the profile did not introduce errors.
  const parseResult = advancedCameraCardConfigSchema.safeParse(parsedConfig);
  expect(parseResult.success, parseResult.error?.toString()).toBeTruthy();
});



================================================
FILE: tests/config/schema/folders.test.ts
================================================
import { NonEmptyTuple } from 'type-fest';
import { describe, expect, it } from 'vitest';
import {
  matcherSchema,
  transformPathURLToPathArray,
} from '../../../src/config/schema/folders';

describe('transformURLToMediaSourceRoot', () => {
  const prefixes: NonEmptyTuple<string>[] = [
    ['http://card.camera/' as const],
    ['/' as const],
    ['' as const],
  ];

  describe('should return the media source root when given a root URL', () => {
    it.each(prefixes)('with prefix %s', (urlPrefix: string) => {
      const url = `${urlPrefix}media-browser/browser`;
      const result = transformPathURLToPathArray(url);
      expect(result).toEqual([{ id: 'media-source://' }]);
    });
  });

  describe('should return the media source root when given a valid URL', () => {
    it.each(prefixes)('with prefix %s', (urlPrefix: string) => {
      const url = `${urlPrefix}media-browser/browser/app%2Cmedia-source%3A%2F%2Fcamera`;
      const result = transformPathURLToPathArray(url);
      expect(result).toEqual([
        { id: 'media-source://' },
        { id: 'media-source://camera' },
      ]);
    });
  });

  describe('should return the decoded frigate URL', () => {
    it.each(prefixes)('with prefix %s', (urlPrefix: string) => {
      const url =
        `${urlPrefix}media-browser/browser/app%2Cmedia-source%3A%2F%2F` +
        'frigate/image%2Cmedia-source%3A%2F%2Ffrigate%2Ffrigate%2F' +
        'event-search%2Fsnapshots%2F%2F%2F%2F%2F%2F/image%2C' +
        'media-source%3A%2F%2Ffrigate%2Ffrigate%2Fevent-search' +
        '%2Fsnapshots%2F.this_month%2F1746082800%2F%2F%2F%2F';
      const result = transformPathURLToPathArray(url);
      expect(result).toEqual([
        { id: 'media-source://' },
        { id: 'media-source://frigate' },
        { id: 'media-source://frigate/frigate/event-search/snapshots//////' },
        {
          id: 'media-source://frigate/frigate/event-search/snapshots/.this_month/1746082800////',
        },
      ]);
    });
  });

  describe('should return the root for unknown URLs', () => {
    it.each(prefixes)('with prefix %s', (urlPrefix: string) => {
      const url = `${urlPrefix}something-completely-different`;
      const result = transformPathURLToPathArray(url);
      expect(result).toEqual([{ id: 'media-source://' }]);
    });
  });

  describe('should throw error for non-media source path component', () => {
    it.each(prefixes)('with prefix %s', (urlPrefix: string) => {
      const url = `${urlPrefix}media-browser/browser,does-not-start-with-media-source`;
      expect(() => transformPathURLToPathArray(url)).toThrowError(
        /Could not parse media source URL/,
      );
    });
  });
});

describe('should lazy evaluate schemas', () => {
  it('should lazy evaluate or matcher', () => {
    expect(
      matcherSchema.parse({
        type: 'or',
        matchers: [
          {
            type: 'title',
            title: 'Test Title',
          },
        ],
      }),
    ).toEqual({
      type: 'or',
      matchers: [
        {
          type: 'title',
          title: 'Test Title',
        },
      ],
    });
  });
});



================================================
FILE: tests/ha/brands-url.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  brandsUrl,
  extractDomainFromBrandUrl,
  isBrandUrl,
} from '../../src/ha/brands-url';

describe('brandsUrl', () => {
  it('generates a basic icon url', () => {
    expect(brandsUrl({ domain: 'amcrest', type: 'icon' })).toBe(
      'https://brands.home-assistant.io/amcrest/icon.png',
    );
  });

  it('generates a logo url with brand', () => {
    expect(brandsUrl({ domain: 'hikvision', type: 'logo', brand: true })).toBe(
      'https://brands.home-assistant.io/brands/hikvision/logo.png',
    );
  });

  it('generates a dark optimized icon@2x url with fallback', () => {
    expect(
      brandsUrl({
        domain: 'unifi',
        type: 'icon@2x',
        useFallback: true,
        darkOptimized: true,
      }),
    ).toBe('https://brands.home-assistant.io/_/unifi/dark_icon@2x.png');
  });

  it('generates a logo@2x url with all options', () => {
    expect(
      brandsUrl({
        domain: 'dahua',
        type: 'logo@2x',
        useFallback: true,
        darkOptimized: true,
        brand: true,
      }),
    ).toBe('https://brands.home-assistant.io/brands/_/dahua/dark_logo@2x.png');
  });
});

describe('extractDomainFromBrandUrl', () => {
  it('extracts domain from a brands url', () => {
    expect(
      extractDomainFromBrandUrl(
        'https://brands.home-assistant.io/brands/hikvision/logo.png',
      ),
    ).toBe('hikvision');
  });
});

describe('isBrandUrl', () => {
  it('returns true for a valid brands url', () => {
    expect(isBrandUrl('https://brands.home-assistant.io/amcrest/icon.png')).toBe(true);
  });

  it('returns false for a non-brands url', () => {
    expect(isBrandUrl('https://example.com/amcrest/icon.png')).toBe(false);
  });

  it('returns false for undefined', () => {
    expect(isBrandUrl(undefined)).toBe(false);
  });

  it('returns false for null', () => {
    expect(isBrandUrl(null)).toBe(false);
  });
});



================================================
FILE: tests/ha/canonical-url.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { canonicalizeHAURL } from '../../src/ha/canonical-url';
import { createHASS } from '../test-utils';

describe('canonicalizeHAURL', () => {
  it('returns canonicalized URL for HA relative URL', () => {
    const hass = createHASS();
    hass.hassUrl = vi.fn((url) => 'hass:' + url);

    const url = '/media/local/file.mp4';
    expect(canonicalizeHAURL(hass, url)).toBe('hass:/media/local/file.mp4');
  });

  it('returns original URL for absolute URL', () => {
    const url = 'https://card.camera/file.mp4';
    expect(canonicalizeHAURL(createHASS(), url)).toBe(url);
  });

  it('returns null if url is null', () => {
    expect(canonicalizeHAURL(createHASS())).toBeNull();
  });
});



================================================
FILE: tests/ha/compute-domain.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { computeDomain } from '../../src/ha/compute-domain.js';

describe('computeDomain', () => {
  it('should return the domain of an entity ID', () => {
    expect(computeDomain('light.kitchen')).toBe('light');
    expect(computeDomain('sensor.temperature')).toBe('sensor');
    expect(computeDomain('switch.garage')).toBe('switch');
  });

  it('should return an empty string if there is no dot in the entity ID', () => {
    expect(computeDomain('invalidEntityId')).toBe('');
  });

  it('should handle entity IDs with multiple dots correctly', () => {
    expect(computeDomain('light.kitchen.ceiling')).toBe('light');
  });

  it('should return an empty string for an empty entity ID', () => {
    expect(computeDomain('')).toBe('');
  });

  it('should return an empty string for a dot-only entity ID', () => {
    expect(computeDomain('.')).toBe('');
  });
});



================================================
FILE: tests/ha/download.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { getMediaDownloadPath } from '../../src/ha/download';
import { ResolvedMediaCache, resolveMedia } from '../../src/ha/resolved-media.js';
import { createHASS } from '../test-utils';

vi.mock('../../src/ha/canonical-url.js', () => ({
  canonicalizeHAURL: vi.fn((_hass, url) => `canonicalized:${url}`),
}));
vi.mock('../../src/ha/resolved-media.js', () => ({
  resolveMedia: vi.fn(),
}));

describe('getMediaDownloadPath', () => {
  it('returns null if contentID is undefined', async () => {
    expect(
      await getMediaDownloadPath(createHASS(), undefined, mock<ResolvedMediaCache>()),
    ).toBeNull();
  });

  it('returns null if contentID is null', async () => {
    expect(
      await getMediaDownloadPath(createHASS(), null, mock<ResolvedMediaCache>()),
    ).toBeNull();
  });

  it('returns null if resolveMedia returns null', async () => {
    const hass = createHASS();
    const resolvedMediaCache = mock<ResolvedMediaCache>();
    vi.mocked(resolveMedia).mockResolvedValueOnce(null);

    expect(await getMediaDownloadPath(hass, 'id-1', resolvedMediaCache)).toBeNull();
    expect(resolveMedia).toHaveBeenCalledWith(hass, 'id-1', resolvedMediaCache);
  });

  it('returns endpoint if resolveMedia returns a url', async () => {
    const hass = createHASS();
    const resolvedMediaCache = mock<ResolvedMediaCache>();
    vi.mocked(resolveMedia).mockResolvedValueOnce({
      url: '/media/path.mp4',
      mime_type: 'video/mp4',
    });

    expect(await getMediaDownloadPath(hass, 'id-1', resolvedMediaCache)).toEqual({
      endpoint: 'canonicalized:/media/path.mp4',
    });
    expect(resolveMedia).toBeCalledWith(hass, 'id-1', resolvedMediaCache);
  });
});



================================================
FILE: tests/ha/entity-state-translation.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { getEntityStateTranslation } from '../../src/ha/entity-state-translation';
import { createHASS, createRegistryEntity, createStateEntity } from '../test-utils';

describe('getEntityStateTranslation', () => {
  it('returns null if state is missing', () => {
    expect(getEntityStateTranslation(createHASS(), 'light.office')).toBeNull();
  });

  it('returns translation_key translation if available', () => {
    const entity = createRegistryEntity({
      entity_id: 'light.office',
      translation_key: 'translation_key',
    });
    const hass = createHASS({
      'light.office': createStateEntity({
        state: 'on',
        attributes: {},
      }),
    });
    vi.mocked(hass.localize).mockReturnValue('Translated State');

    expect(getEntityStateTranslation(hass, 'light.office', { entity })).toBe(
      'Translated State',
    );
  });

  it('returns device_class translation if translation_key not available', () => {
    const entity = createRegistryEntity({
      entity_id: 'light.office',
    });
    const hass = createHASS({
      'light.office': createStateEntity({
        state: 'on',
        attributes: {
          device_class: 'light',
        },
      }),
    });
    vi.mocked(hass.localize).mockReturnValue('Translated State');

    expect(getEntityStateTranslation(hass, 'light.office', { entity })).toBe(
      'Translated State',
    );
  });

  it('returns default translation if translation_key not available', () => {
    const entity = createRegistryEntity({
      entity_id: 'light.office',
    });
    const hass = createHASS({
      'light.office': createStateEntity({
        state: 'on',
      }),
    });
    vi.mocked(hass.localize).mockReturnValue('Translated State');

    expect(getEntityStateTranslation(hass, 'light.office', { entity })).toBe(
      'Translated State',
    );
  });

  it('returns raw state if no translation found', () => {
    const entity = createRegistryEntity({
      entity_id: 'light.office',
    });
    const hass = createHASS({
      'light.office': createStateEntity({
        state: 'on',
      }),
    });
    vi.mocked(hass.localize).mockReturnValue('');

    expect(getEntityStateTranslation(hass, 'light.office', { entity })).toBe('on');
  });

  it('uses passed in state', () => {
    const entity = createRegistryEntity({
      entity_id: 'light.office',
    });
    const hass = createHASS();
    vi.mocked(hass.localize).mockReturnValue('');

    expect(
      getEntityStateTranslation(hass, 'light.office', { entity, state: 'off' }),
    ).toBe('off');
  });
});



================================================
FILE: tests/ha/fire-hass-event.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { fireHASSEvent } from '../../src/ha/fire-hass-event';

// @vitest-environment jsdom
describe('fireHASSEvent', () => {
  it('should fire an event with specified type and detail', () => {
    const target = document.createElement('div');
    const handler = vi.fn();

    const type = 'll-custom';
    const detail = { action: 'test' };

    target.addEventListener(type, handler);

    fireHASSEvent(target, type, detail);

    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail,
      }),
    );
  });
});



================================================
FILE: tests/ha/get-entities.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getEntitiesFromHASS } from '../../src/ha/get-entities';
import { createHASS, createStateEntity } from '../test-utils';

describe('getEntitiesFromHASS', () => {
  const hass = createHASS({
    'camera.front_door': createStateEntity(),
    'light.kitchen': createStateEntity(),
    'light.living_room': createStateEntity(),
    'sensor.temperature': createStateEntity(),
    'switch.garage': createStateEntity(),
  });

  it('returns all entity ids when no domain is specified', () => {
    expect(getEntitiesFromHASS(hass)).toEqual([
      'camera.front_door',
      'light.kitchen',
      'light.living_room',
      'sensor.temperature',
      'switch.garage',
    ]);
  });

  it('returns only entities of the specified domain', () => {
    expect(getEntitiesFromHASS(hass, 'light')).toEqual([
      'light.kitchen',
      'light.living_room',
    ]);
  });

  it('returns an empty array if no entities match the domain', () => {
    const result = getEntitiesFromHASS(hass, 'binary_sensor');
    expect(result).toEqual([]);
  });
});



================================================
FILE: tests/ha/get-entity-title.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getEntityTitle } from '../../src/ha/get-entity-title';
import type { HomeAssistant } from '../../src/ha/types';
import { createHASS, createStateEntity } from '../test-utils';

describe('getEntityTitle', () => {
  const hass: HomeAssistant = createHASS({
    'sensor.temperature': createStateEntity({
      attributes: {
        friendly_name: 'Temperature Sensor',
      },
    }),
    'light.living_room': createStateEntity({
      attributes: {
        friendly_name: 'Living Room Light',
      },
    }),
    'switch.no_friendly': createStateEntity({
      attributes: {},
    }),
  });

  it('returns the friendly_name for a valid entity', () => {
    expect(getEntityTitle(hass, 'sensor.temperature')).toBe('Temperature Sensor');
    expect(getEntityTitle(hass, 'light.living_room')).toBe('Living Room Light');
  });

  it('returns null if the entity does not exist', () => {
    expect(getEntityTitle(hass, 'sensor.unknown')).toBeNull();
  });

  it('returns null if hass is undefined', () => {
    expect(getEntityTitle(undefined, 'sensor.temperature')).toBeNull();
  });

  it('returns null if entity is undefined', () => {
    expect(getEntityTitle(hass)).toBeNull();
  });

  it('returns null if friendly_name attribute is missing', () => {
    expect(getEntityTitle(hass, 'switch.no_friendly')).toBeNull();
  });

  it('returns null if both hass and entity are undefined', () => {
    expect(getEntityTitle()).toBeNull();
  });
});



================================================
FILE: tests/ha/get-hass-differences.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getHassDifferences } from '../../src/ha/get-hass-differences';
import { createHASS, createStateEntity } from '../test-utils';

describe('getHassDifferences', () => {
  const newHass = createHASS({
    'light.office': createStateEntity({
      entity_id: 'light.office',
      state: 'on',
    }),
    'light.kitchen': createStateEntity({
      entity_id: 'light.kitchen',
      state: 'on',
    }),
    'light.attributes_only': createStateEntity({
      entity_id: 'light.attributes_only',
      state: 'on',
      attributes: {
        friendly_name: 'Attributes Only After',
      },
    }),
  });
  const oldHass = createHASS({
    'light.office': createStateEntity({
      entity_id: 'light.office',
      state: 'off',
    }),
    'light.kitchen': createStateEntity({
      entity_id: 'light.kitchen',
      state: 'off',
    }),
    'light.attributes_only': createStateEntity({
      entity_id: 'light.attributes_only',
      state: 'on',
      attributes: {
        friendly_name: 'Attributes Only Before',
      },
    }),
  });

  it('should return empty list without difference', () => {
    expect(getHassDifferences(newHass, newHass, ['light.office'])).toEqual([]);
  });

  it('should return differences', () => {
    expect(
      getHassDifferences(newHass, oldHass, [
        'light.office',
        'light.kitchen',
        'light.attributes_only',
      ]),
    ).toEqual([
      {
        entityID: 'light.office',
        oldState: expect.objectContaining({
          entity_id: 'light.office',
          state: 'off',
        }),
        newState: expect.objectContaining({
          entity_id: 'light.office',
          state: 'on',
        }),
      },
      {
        entityID: 'light.kitchen',
        oldState: expect.objectContaining({
          entity_id: 'light.kitchen',
          state: 'off',
        }),
        newState: expect.objectContaining({
          entity_id: 'light.kitchen',
          state: 'on',
        }),
      },
      {
        entityID: 'light.attributes_only',
        oldState: expect.objectContaining({
          entity_id: 'light.attributes_only',
          state: 'on',
          attributes: {
            friendly_name: 'Attributes Only Before',
          },
        }),
        newState: expect.objectContaining({
          entity_id: 'light.attributes_only',
          state: 'on',
          attributes: {
            friendly_name: 'Attributes Only After',
          },
        }),
      },
    ]);
  });

  it('should return single difference', () => {
    expect(
      getHassDifferences(newHass, oldHass, ['light.office', 'light.kitchen'], {
        firstOnly: true,
      }),
    ).toEqual([
      {
        entityID: 'light.office',
        oldState: expect.objectContaining({
          entity_id: 'light.office',
          state: 'off',
        }),
        newState: expect.objectContaining({
          entity_id: 'light.office',
          state: 'on',
        }),
      },
    ]);
  });

  it('should return only state differences', () => {
    expect(
      getHassDifferences(
        newHass,
        oldHass,
        ['light.office', 'light.kitchen', 'light.attributes_only'],
        {
          stateOnly: true,
        },
      ),
    ).toEqual([
      {
        entityID: 'light.office',
        oldState: expect.objectContaining({
          entity_id: 'light.office',
          state: 'off',
        }),
        newState: expect.objectContaining({
          entity_id: 'light.office',
          state: 'on',
        }),
      },
      {
        entityID: 'light.kitchen',
        oldState: expect.objectContaining({
          entity_id: 'light.kitchen',
          state: 'off',
        }),
        newState: expect.objectContaining({
          entity_id: 'light.kitchen',
          state: 'on',
        }),
      },
    ]);
  });

  describe('should return empty list with empty values', () => {
    it('should return empty list for empty new hass', () => {
      expect(getHassDifferences(null, oldHass, ['light.office'])).toEqual([]);
    });

    it('should return empty list for empty entity list', () => {
      expect(getHassDifferences(newHass, oldHass, [])).toEqual([]);
    });
  });
});



================================================
FILE: tests/ha/haptic.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { fireHASSEvent } from '../../src/ha/fire-hass-event.js';
import { forwardHaptic, HapticType } from '../../src/ha/haptic.js';

vi.mock('../../src/ha/fire-hass-event.js', () => ({
  fireHASSEvent: vi.fn(),
}));

// @vitest-environment jsdom
describe('forwardHaptic', () => {
  it.each([
    ['success' as const],
    ['warning' as const],
    ['failure' as const],
    ['light' as const],
    ['medium' as const],
    ['heavy' as const],
    ['selection' as const],
  ])('should call fireHASSEvent with %s', (hapticType: HapticType) => {
    forwardHaptic(hapticType);

    expect(fireHASSEvent).toBeCalledWith(window, 'haptic', hapticType);
  });
});



================================================
FILE: tests/ha/has-hass-connection-changed.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { hasHAConnectionStateChanged } from '../../src/ha/has-hass-connection-changed';
import { createHASS } from '../test-utils';

describe('hasHAConnectionStateChanged', () => {
  it('returns false if both oldHass and newHass are undefined', () => {
    expect(hasHAConnectionStateChanged()).toBe(false);
  });

  it('returns false if both oldHass and newHass are null', () => {
    expect(hasHAConnectionStateChanged(null, null)).toBe(false);
  });

  it('returns false if both oldHass and newHass are the same object', () => {
    const hass = createHASS();
    expect(hasHAConnectionStateChanged(hass, hass)).toBe(false);
  });

  it('returns false if both oldHass.connected and newHass.connected are the same', () => {
    const oldHass = createHASS();
    const newHass = createHASS();
    oldHass.connected = true;
    newHass.connected = true;
    expect(hasHAConnectionStateChanged(oldHass, newHass)).toBe(false);
  });

  it('returns true if oldHass.connected and newHass.connected are different', () => {
    const oldHass = createHASS();
    const newHass = createHASS();
    oldHass.connected = true;
    newHass.connected = false;
    expect(hasHAConnectionStateChanged(oldHass, newHass)).toBe(true);
  });
});



================================================
FILE: tests/ha/is-ha-relative-url.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { isHARelativeURL } from '../../src/ha/is-ha-relative-url';

describe('isHARelativeURL', () => {
  it('returns true for a simple relative URL', () => {
    expect(isHARelativeURL('/image.jpg')).toBe(true);
  });

  it('returns true for root path', () => {
    expect(isHARelativeURL('/')).toBe(true);
  });

  it('returns false for undefined', () => {
    expect(isHARelativeURL()).toBe(false);
  });

  it('returns false for empty string', () => {
    expect(isHARelativeURL('')).toBe(false);
  });

  it('returns false for absolute URL', () => {
    expect(isHARelativeURL('https://card.camera/image.jpg')).toBe(false);
  });
});



================================================
FILE: tests/ha/is-hass-different.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { getHassDifferences } from '../../src/ha/get-hass-differences';
import { isHassDifferent } from '../../src/ha/is-hass-different';
import { createHASS, createStateEntity } from '../test-utils';

vi.mock('../../src/ha/get-hass-differences');

describe('isHassDifferent', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should return true with difference', async () => {
    vi.mocked(getHassDifferences).mockReturnValue([
      { entityID: 'light.office', newState: createStateEntity() },
    ]);

    const newHass = createHASS();
    const oldHass = createHASS();
    const entities = ['light.office'];

    expect(isHassDifferent(newHass, oldHass, entities)).toBe(true);
    expect(getHassDifferences).toBeCalledWith(newHass, oldHass, entities, {
      firstOnly: true,
    });
  });

  it('should return false without difference', async () => {
    vi.mocked(getHassDifferences).mockReturnValue([]);
    expect(isHassDifferent(createHASS(), createHASS(), ['light.office'])).toBe(false);
  });
});



================================================
FILE: tests/ha/is-triggered-state.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { isTriggeredState } from '../../src/ha/is-triggered-state';

describe('isTriggeredState', () => {
  it('returns true for a state included in STATES_ON', () => {
    expect(isTriggeredState('on')).toBe(true);
    expect(isTriggeredState('open')).toBe(true);
    expect(isTriggeredState('unlocked')).toBe(true);
  });

  it('returns false for a state not included in STATES_ON', () => {
    expect(isTriggeredState('off')).toBe(false);
    expect(isTriggeredState('closed')).toBe(false);
    expect(isTriggeredState('locked')).toBe(false);
    expect(isTriggeredState('other')).toBe(false);
  });

  it('returns false for undefined or empty state', () => {
    expect(isTriggeredState()).toBe(false);
  });
});



================================================
FILE: tests/ha/panel.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { isCardInPanel } from '../../src/ha/panel';
import { createLitElement } from '../test-utils';

// @vitest-environment jsdom
describe('isCardInPanel', () => {
  it('returns true if card is in a ShadowRoot with correct tag name"', () => {
    const card = createLitElement();

    const parent = document.createElement('HUI-PANEL-VIEW');
    parent.attachShadow({ mode: 'open' });
    parent.shadowRoot?.append(card);

    expect(isCardInPanel(card)).toBe(true);
  });

  it('returns false if card is in a ShadowRoot with incorrect tag name"', () => {
    const card = createLitElement();

    const parent = document.createElement('ANOTHER-VIEW');
    parent.attachShadow({ mode: 'open' });
    parent.shadowRoot?.append(card);

    expect(isCardInPanel(card)).toBe(false);
  });
});



================================================
FILE: tests/ha/resolved-media.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { ResolvedMediaCache, resolveMedia } from '../../src/ha/resolved-media';
import { ResolvedMedia, resolvedMediaSchema } from '../../src/ha/types';
import { homeAssistantWSRequest } from '../../src/ha/ws-request';
import { errorToConsole } from '../../src/utils/basic';
import { createHASS } from '../test-utils';

vi.mock('../../src/ha/ws-request', () => ({
  homeAssistantWSRequest: vi.fn(),
}));
vi.mock('../../src/utils/basic', () => ({
  errorToConsole: vi.fn(),
}));

describe('ResolvedMediaCache', () => {
  it('should store and retrieve values', () => {
    const cache = new ResolvedMediaCache();
    const key = 'media-id';
    const resolvedMedia = {
      id: key,
      title: 'Test Media',
      mime_type: 'video/mp4',
      url: 'http://media',
      media_content_type: 'video',
      media_content_id: key,
    };
    cache.set(key, resolvedMedia);
    expect(cache.get(key)).toBe(resolvedMedia);
  });
});

describe('resolveMedia', () => {
  const mediaContentID = 'media-123';
  const resolvedMedia: ResolvedMedia = {
    mime_type: 'video/mp4',
    url: 'http://media',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns cached value if present', async () => {
    const cache = new ResolvedMediaCache();
    cache.set(mediaContentID, resolvedMedia);
    const result = await resolveMedia(createHASS(), mediaContentID, cache);
    expect(result).toBe(resolvedMedia);
    expect(homeAssistantWSRequest).not.toHaveBeenCalled();
  });

  it('fetches and caches value if not present in cache', async () => {
    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(resolvedMedia);

    const hass = createHASS();
    const cache = new ResolvedMediaCache();
    const result = await resolveMedia(hass, mediaContentID, cache);

    expect(homeAssistantWSRequest).toBeCalledWith(
      hass,
      resolvedMediaSchema,
      expect.objectContaining({
        type: 'media_source/resolve_media',
        media_content_id: mediaContentID,
      }),
    );
    expect(result).toEqual(resolvedMedia);
    expect(cache.get(mediaContentID)).toEqual(resolvedMedia);
  });

  it('returns null and logs error if request fails', async () => {
    const error = new Error('fail');
    vi.mocked(homeAssistantWSRequest).mockRejectedValueOnce(error);

    const cache = new ResolvedMediaCache();
    const result = await resolveMedia(createHASS(), mediaContentID, cache);
    expect(result).toBeNull();
    expect(errorToConsole).toBeCalledWith(error);
  });

  it('does not cache null results', async () => {
    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(null);
    const cache = new ResolvedMediaCache();
    const result = await resolveMedia(createHASS(), mediaContentID, cache);
    expect(result).toBeNull();
    expect(cache.get(mediaContentID)).toBeNull();
  });

  it('works without cache argument', async () => {
    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(resolvedMedia);
    const result = await resolveMedia(createHASS(), mediaContentID);
    expect(result).toEqual(resolvedMedia);
  });
});



================================================
FILE: tests/ha/side-load-ha-elements.test.ts
================================================
import { LitElement } from 'lit';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { sideLoadHomeAssistantElements } from '../../src/ha/side-load-ha-elements';

describe('sideLoadHomeAssistantElements', () => {
  beforeEach(() => {
    vi.stubGlobal('customElements', {
      get: vi.fn(),
      whenDefined: vi.fn(),
    });
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  it('returns true if all elements already registered', async () => {
    vi.mocked(customElements.get).mockResolvedValue(LitElement);
    expect(await sideLoadHomeAssistantElements()).toBe(true);
  });

  it('returns false when the picture glance card cannot be found', async () => {
    vi.mocked(customElements.get).mockReturnValue(undefined);

    const createCardElement = vi.fn();
    vi.stubGlobal('window', {
      loadCardHelpers: vi.fn().mockReturnValue({
        createCardElement,
      }),
    });

    expect(await sideLoadHomeAssistantElements()).toBe(false);
  });

  it('returns true when elements are loaded', async () => {
    vi.mocked(customElements.get).mockImplementation((name: string) => {
      if (name === 'hui-picture-glance-card') {
        const result = LitElement;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (result as any).getConfigElement = vi.fn();
        return LitElement;
      }
      return undefined;
    });

    const createCardElement = vi.fn();
    vi.stubGlobal('window', {
      loadCardHelpers: vi.fn().mockReturnValue({
        createCardElement,
      }),
    });

    expect(await sideLoadHomeAssistantElements()).toBe(true);

    expect(customElements.whenDefined).toHaveBeenCalledWith('hui-picture-glance-card');
    expect(createCardElement).toHaveBeenCalledWith({
      type: 'picture-glance',
      entities: [],
      camera_image: 'dummy-to-load-editor-components',
    });
  });
});



================================================
FILE: tests/ha/sign-path.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { homeAssistantSignPath } from '../../src/ha/sign-path';
import { homeAssistantWSRequest } from '../../src/ha/ws-request.js';
import { signedPathSchema } from '../../src/types';
import { createHASS } from '../test-utils';

vi.mock('../../src/ha/ws-request.js');

describe('homeAssistantSignPath', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should sign path', async () => {
    const hass = createHASS();
    const unsignedPath = 'unsigned/path';
    const expires = 42;

    vi.mocked(homeAssistantWSRequest).mockResolvedValue({
      path: 'signed/path',
    });
    vi.mocked(hass.hassUrl).mockImplementation((url) => 'hass:' + url);

    expect(await homeAssistantSignPath(hass, unsignedPath, expires)).toEqual(
      'hass:signed/path',
    );
    expect(homeAssistantWSRequest).toBeCalledWith(hass, signedPathSchema, {
      type: 'auth/sign_path',
      path: unsignedPath,
      expires,
    });
  });

  it('should return null for null response', async () => {
    vi.mocked(homeAssistantWSRequest).mockResolvedValue(null);
    expect(await homeAssistantSignPath(createHASS(), 'unsigned/path', 42)).toBeNull();
  });
});



================================================
FILE: tests/ha/supports-feature.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { supportsFeature } from '../../src/ha/supports-feature';
import { createStateEntity } from '../test-utils';

describe('supportsFeature', () => {
  it('returns true if the feature bit is set', () => {
    const stateObj = createStateEntity({
      attributes: { supported_features: 4 },
    });
    expect(supportsFeature(stateObj, 4)).toBe(true);
  });

  it('returns false if the feature bit is not set', () => {
    const stateObj = createStateEntity({
      attributes: { supported_features: 2 },
    });
    expect(supportsFeature(stateObj, 4)).toBe(false);
  });

  it('returns false if supported_features is undefined', () => {
    const stateObj = createStateEntity({
      attributes: {},
    });
    expect(supportsFeature(stateObj, 1)).toBe(false);
  });

  it('returns true if multiple feature bits are set and one matches', () => {
    const stateObj = createStateEntity({
      attributes: { supported_features: 6 }, // 2 + 4
    });
    expect(supportsFeature(stateObj, 2)).toBe(true);
    expect(supportsFeature(stateObj, 4)).toBe(true);
  });

  it('returns false if feature is 0', () => {
    const stateObj = createStateEntity({
      attributes: { supported_features: 7 },
    });
    expect(supportsFeature(stateObj, 0)).toBe(false);
  });
});



================================================
FILE: tests/ha/web-proxy.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { CameraProxyConfig } from '../../src/camera-manager/types.js';
import {
  addDynamicProxyURL,
  getWebProxiedURL,
  shouldUseWebProxy,
} from '../../src/ha/web-proxy.js';
import { createHASS } from '../test-utils.js';

describe('getWebProxiedURL', () => {
  it('should return proxied URL with v != 0', () => {
    expect(getWebProxiedURL('http://example.com', 2)).toBe(
      '/api/hass_web_proxy/v2/?url=http%3A%2F%2Fexample.com',
    );
  });

  it('should return proxied URL with default v', () => {
    expect(getWebProxiedURL('http://example.com')).toBe(
      '/api/hass_web_proxy/v0/?url=http%3A%2F%2Fexample.com',
    );
  });
});

describe('shouldUseWebProxy', () => {
  const createProxyConfig = (
    config: Partial<CameraProxyConfig> = {},
  ): CameraProxyConfig => ({
    media: true,
    ssl_verification: true,
    ssl_ciphers: 'default',
    dynamic: true,
    ...config,
  });

  it('should return false without a the proxy installed', () => {
    const hass = createHASS();
    hass.config.components = [];

    expect(shouldUseWebProxy(hass, createProxyConfig())).toBe(false);
  });

  it('should return when proxy config does not want proxying', () => {
    const hass = createHASS();
    hass.config.components = ['hass_web_proxy'];

    const proxyConfig = createProxyConfig({ media: false });
    expect(shouldUseWebProxy(hass, proxyConfig, 'media')).toBe(false);
  });

  it('should return when proxy config does want proxying', () => {
    const hass = createHASS();
    hass.config.components = ['hass_web_proxy'];

    const proxyConfig = createProxyConfig({ media: true });
    expect(shouldUseWebProxy(hass, proxyConfig, 'media')).toBe(true);
  });
});

describe('addDynamicProxyURL', () => {
  it('should add dynamic proxy URL', async () => {
    const hass = createHASS();

    await addDynamicProxyURL(hass, 'http://example.com', {
      urlID: 'id',
      sslVerification: true,
      sslCiphers: 'modern',
      openLimit: 5,
      ttl: 60,
      allowUnauthenticated: false,
    });

    expect(hass.callService).toHaveBeenCalledWith(
      'hass_web_proxy',
      'create_proxied_url',
      {
        url_pattern: 'http://example.com',
        url_id: 'id',
        ssl_verification: true,
        ssl_ciphers: 'modern',
        open_limit: 5,
        ttl: 60,
        allow_unauthenticated: false,
      },
    );
  });
});



================================================
FILE: tests/ha/ws-request.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { ResolvedMedia, resolvedMediaSchema } from '../../src/ha/types';
import { homeAssistantWSRequest } from '../../src/ha/ws-request';
import { createHASS } from '../test-utils';

describe('homeAssistantWSRequest', () => {
  const request = {
    type: 'foo',
  };
  const response: ResolvedMedia = {
    url: 'https://example.com/media.mp4',
    mime_type: 'video/mp4',
  };

  it('should return parsed data on successful call', async () => {
    const hass = createHASS();
    vi.mocked(hass.callWS).mockResolvedValueOnce(response);

    expect(await homeAssistantWSRequest(hass, resolvedMediaSchema, request)).toEqual(
      response,
    );
  });

  it('should return parsed data on successful call with passthrough', async () => {
    const hass = createHASS();
    vi.mocked(hass.callWS).mockResolvedValueOnce(JSON.stringify(response));

    expect(
      await homeAssistantWSRequest(hass, resolvedMediaSchema, request, true),
    ).toEqual(response);
  });

  it('should throw on error', async () => {
    const error = new Error('WS call failed');
    const hass = createHASS();
    vi.mocked(hass.callWS).mockRejectedValueOnce(error);

    await expect(
      homeAssistantWSRequest(hass, resolvedMediaSchema, request),
    ).rejects.toThrowError(/Failed to receive response/);
  });

  it('should throw on empty response', async () => {
    const hass = createHASS();
    vi.mocked(hass.callWS).mockResolvedValueOnce(null);

    await expect(
      homeAssistantWSRequest(hass, resolvedMediaSchema, request),
    ).rejects.toThrowError(/Received empty response/);
  });

  it('should throw error on parse failure', async () => {
    const hass = createHASS();
    vi.mocked(hass.callWS).mockResolvedValueOnce({});

    await expect(
      homeAssistantWSRequest(hass, resolvedMediaSchema, request),
    ).rejects.toThrowError(/Received invalid response/);
  });

  it('should throw on JSON parse failure', async () => {
    const malformedJSONResponse = "{ foo: 'test', bar: 123 "; // Malformed JSON

    const hass = createHASS();
    vi.mocked(hass.callWS).mockResolvedValueOnce(malformedJSONResponse);

    await expect(
      homeAssistantWSRequest(hass, resolvedMediaSchema, request, true),
    ).rejects.toThrowError(/Received invalid response/);
  });
});



================================================
FILE: tests/ha/browse-media/browse-media-to-view-media.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getViewMediaFromBrowseMediaArray } from '../../../src/ha/browse-media/browse-media-to-view-media';
import {
  BrowseMediaMetadata,
  MEDIA_CLASS_IMAGE,
  MEDIA_CLASS_VIDEO,
  RichBrowseMedia,
} from '../../../src/ha/browse-media/types';
import { createBrowseMedia, createRichBrowseMedia } from '../../test-utils';

const createBrowseMediaChildren = (
  overrides: Partial<RichBrowseMedia<BrowseMediaMetadata>>[],
) => {
  return overrides.map((override) => createRichBrowseMedia(override));
};

describe('getViewMediaFromBrowseMediaArray', () => {
  it('should not ignore absent metadata', () => {
    const children = [createBrowseMedia()];
    const viewMedia = getViewMediaFromBrowseMediaArray(children, {
      cameraID: 'camera.office',
    });
    expect(viewMedia).toHaveLength(1);
    expect(viewMedia?.[0].getMediaType()).toBe('clip');
    expect(viewMedia?.[0].getID()).toBe('content_id');
  });

  it('should ignore unknown media class', () => {
    const children = createBrowseMediaChildren([{ media_class: 'UNKNOWN' }]);
    expect(
      getViewMediaFromBrowseMediaArray(children, { cameraID: 'camera.office' }),
    ).toEqual([]);
  });

  it('should generate clip view media', () => {
    const children = createBrowseMediaChildren([{ media_class: MEDIA_CLASS_VIDEO }]);
    const viewMedia = getViewMediaFromBrowseMediaArray(children, {
      cameraID: 'camera.office',
    });
    expect(viewMedia).toHaveLength(1);
    expect(viewMedia?.[0].getMediaType()).toBe('clip');
    expect(viewMedia?.[0].getID()).toBe('camera.office/2024-11-19 07:23:00');
  });

  it('should generate snapshot view media', () => {
    const children = createBrowseMediaChildren([{ media_class: MEDIA_CLASS_IMAGE }]);
    const viewMedia = getViewMediaFromBrowseMediaArray(children, {
      cameraID: 'camera.office',
    });
    expect(viewMedia).toHaveLength(1);
    expect(viewMedia?.[0].getMediaType()).toBe('snapshot');
    expect(viewMedia?.[0].getID()).toBe('camera.office/2024-11-19 07:23:00');
  });
});



================================================
FILE: tests/ha/browse-media/item-factory.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  BrowseMediaEventViewMedia,
  BrowseMediaViewFolder,
} from '../../../src/ha/browse-media/item';
import { BrowseMediaViewItemFactory } from '../../../src/ha/browse-media/item-factory';
import {
  MEDIA_CLASS_IMAGE,
  MEDIA_CLASS_VIDEO,
} from '../../../src/ha/browse-media/types';
import { ViewMediaType } from '../../../src/view/item';
import { createBrowseMedia, createFolder } from '../../test-utils';

describe('BrowseMediaViewItemFactory', () => {
  it('returns null if can_expand is true without options.folder', () => {
    const browseMedia = createBrowseMedia({ can_expand: true });
    expect(BrowseMediaViewItemFactory.create(browseMedia)).toBeNull();
  });

  it('returns a folder if can_expand is true with options.folder', () => {
    const browseMedia = createBrowseMedia({ can_expand: true });
    const result = BrowseMediaViewItemFactory.create(browseMedia, {
      folder: createFolder(),
    });
    expect(result).toBeInstanceOf(BrowseMediaViewFolder);
  });

  it('returns BrowseMediaEventViewMedia for MEDIA_CLASS_VIDEO', () => {
    const browseMedia = createBrowseMedia({ media_class: MEDIA_CLASS_VIDEO });
    const result = BrowseMediaViewItemFactory.create(browseMedia);
    expect(result).toBeInstanceOf(BrowseMediaEventViewMedia);
    if (result instanceof BrowseMediaEventViewMedia) {
      expect(result?.getMediaType()).toBe(ViewMediaType.Clip);
    }
  });

  it('returns BrowseMediaEventViewMedia for MEDIA_CLASS_VIDEO', () => {
    const browseMedia = createBrowseMedia({ media_class: MEDIA_CLASS_IMAGE });
    const result = BrowseMediaViewItemFactory.create(browseMedia);
    expect(result).toBeInstanceOf(BrowseMediaEventViewMedia);
    if (result instanceof BrowseMediaEventViewMedia) {
      expect(result?.getMediaType()).toBe(ViewMediaType.Snapshot);
    }
  });

  it('returns null for unknown media_class', () => {
    const browseMedia = createBrowseMedia({ media_class: 'UNKNOWN' });
    expect(BrowseMediaViewItemFactory.create(browseMedia)).toBeNull();
  });
});



================================================
FILE: tests/ha/browse-media/item.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  BrowseMediaEventViewMedia,
  BrowseMediaViewFolder,
} from '../../../src/ha/browse-media/item';
import { VideoContentType, ViewMediaType } from '../../../src/view/item';
import {
  createBrowseMedia,
  createFolder,
  createRichBrowseMedia,
} from '../../test-utils';

describe('BrowseMediaEventViewMedia', () => {
  describe('should set cameraID', () => {
    it('should set cameraID from the metadata', () => {
      const browseMedia = createRichBrowseMedia({
        media_content_id: 'media_content_id',
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
        },
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getCameraID()).toBe('camera.office');
    });

    it('should set cameraID from the options', () => {
      const browseMedia = createRichBrowseMedia({
        media_content_id: 'media_content_id',
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
        },
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia, {
        cameraID: 'camera.kitchen',
      });
      expect(viewMedia.getCameraID()).toBe('camera.kitchen');
    });
  });

  describe('should set ID', () => {
    it('should set id from metadata', () => {
      const browseMedia = createRichBrowseMedia({
        media_content_id: 'media_content_id',
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
        },
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getID()).toBe('camera.office/2025-05-05 07:46:00');
    });

    it('should set id from media_content_id from the options', () => {
      const browseMedia = createBrowseMedia({
        media_content_id: 'media_content_id',
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia, {
        cameraID: 'camera.kitchen',
      });
      expect(viewMedia.getID()).toBe('media_content_id');
    });
  });

  describe('should get start and end time', () => {
    it('should get start and end time from metadata', () => {
      const browseMedia = createRichBrowseMedia({
        media_content_id: 'media_content_id',
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
        },
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getStartTime()).toEqual(new Date('2025-05-05T07:46:00Z'));
      expect(viewMedia.getEndTime()).toEqual(new Date('2025-05-05T07:48:00Z'));
    });

    it('should return null start and end time without metadata', () => {
      const browseMedia = createBrowseMedia({
        media_content_id: 'media_content_id',
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getStartTime()).toBeNull();
      expect(viewMedia.getEndTime()).toBeNull();
    });
  });

  describe('should get video content type', () => {
    it('should get video content type for clip', () => {
      const browseMedia = createRichBrowseMedia();
      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getVideoContentType()).toBe(VideoContentType.MP4);
    });

    it('should get null for snapshot', () => {
      const browseMedia = createBrowseMedia();
      const viewMedia = new BrowseMediaEventViewMedia(
        ViewMediaType.Snapshot,
        browseMedia,
      );
      expect(viewMedia.getVideoContentType()).toBeNull();
    });
  });

  it('should get content ID', () => {
    const browseMedia = createBrowseMedia({
      media_content_id: 'media_content_id',
    });

    const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
    expect(viewMedia.getContentID()).toEqual('media_content_id');
  });

  describe('should get title', () => {
    it('should get title from metadata start time', () => {
      const browseMedia = createRichBrowseMedia({
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
        },
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getTitle()).toEqual('2025-05-05 07:46');
    });

    it('should get title without metadata', () => {
      const browseMedia = createBrowseMedia({
        title: 'Test Title',
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getTitle()).toEqual('Test Title');
    });
  });

  it('should get thumbnail', () => {
    const browseMedia = createRichBrowseMedia({
      thumbnail: 'thumbnail.jpg',
    });

    const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
    expect(viewMedia.getThumbnail()).toEqual('thumbnail.jpg');
  });

  describe('should get what', () => {
    it('should get what from metadata', () => {
      const browseMedia = createRichBrowseMedia({
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
          what: ['car'],
        },
      });

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getWhat()).toEqual(['car']);
    });

    it('should return null without metadata', () => {
      const browseMedia = createBrowseMedia();

      const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
      expect(viewMedia.getWhat()).toBeNull();
    });
  });

  it('should return null for score', () => {
    const browseMedia = createBrowseMedia();
    const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
    expect(viewMedia.getScore()).toBeNull();
  });

  it('should return null for tags', () => {
    const browseMedia = createBrowseMedia();
    const viewMedia = new BrowseMediaEventViewMedia(ViewMediaType.Clip, browseMedia);
    expect(viewMedia.getTags()).toBeNull();
  });

  describe('should determine what is groupable', () => {
    it('should return true when groupable', () => {
      const browseMedia_1 = createRichBrowseMedia({
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
          what: ['car'],
        },
      });

      const browseMedia_2 = createRichBrowseMedia({
        _metadata: {
          startDate: new Date('2025-05-05T07:48:00Z'),
          endDate: new Date('2025-05-05T07:50:00Z'),
          cameraID: 'camera.office',
          what: ['car'],
        },
      });

      const viewMedia_1 = new BrowseMediaEventViewMedia(
        ViewMediaType.Clip,
        browseMedia_1,
      );
      const viewMedia_2 = new BrowseMediaEventViewMedia(
        ViewMediaType.Clip,
        browseMedia_2,
      );
      expect(viewMedia_1.isGroupableWith(viewMedia_2)).toBe(true);
    });

    it('should return false when media types are different', () => {
      const browseMedia_1 = createRichBrowseMedia({
        _metadata: {
          startDate: new Date('2025-05-05T07:46:00Z'),
          endDate: new Date('2025-05-05T07:48:00Z'),
          cameraID: 'camera.office',
          what: ['car'],
        },
      });

      const browseMedia_2 = createRichBrowseMedia({
        _metadata: {
          startDate: new Date('2025-05-05T07:48:00Z'),
          endDate: new Date('2025-05-05T07:50:00Z'),
          cameraID: 'camera.office',
          what: ['car'],
        },
      });

      const viewMedia_1 = new BrowseMediaEventViewMedia(
        ViewMediaType.Clip,
        browseMedia_1,
      );
      const viewMedia_2 = new BrowseMediaEventViewMedia(
        ViewMediaType.Snapshot,
        browseMedia_2,
      );
      expect(viewMedia_1.isGroupableWith(viewMedia_2)).toBe(false);
    });
  });

  describe('should set icon', () => {
    it('should set icon from known  media class', () => {
      const browseMedia = createBrowseMedia({
        media_class: 'channel',
      });

      const media = new BrowseMediaEventViewMedia(ViewMediaType.Snapshot, browseMedia);

      expect(media.getIcon()).toBe('mdi:television-classic');
    });

    it('should set null icon from unknown media class', () => {
      const browseMedia = createBrowseMedia({
        media_class: 'unknown',
      });

      const viewMedia = new BrowseMediaEventViewMedia(
        ViewMediaType.Snapshot,
        browseMedia,
      );
      expect(viewMedia.getIcon()).toBeNull();
    });

    it('should set null icon from null media class', () => {
      const browseMedia = createBrowseMedia({
        media_class: undefined,
      });

      const viewMedia = new BrowseMediaEventViewMedia(
        ViewMediaType.Snapshot,
        browseMedia,
      );
      expect(viewMedia.getIcon()).toBeNull();
    });
  });
});

describe('BrowseMediaViewFolder', () => {
  it('should set folder', () => {
    const folder = createFolder();
    const browseMedia = createBrowseMedia();

    const viewMedia = new BrowseMediaViewFolder(folder, browseMedia);
    expect(viewMedia.getFolder()).toEqual(folder);
  });

  describe('should set icon', () => {
    it('should set icon from known children media class', () => {
      const browseMedia = createBrowseMedia({
        children_media_class: 'album',
      });

      const viewMedia = new BrowseMediaViewFolder(createFolder(), browseMedia);
      expect(viewMedia.getIcon()).toBe('mdi:album');
    });

    it('should set null icon from unknown children media class', () => {
      const browseMedia = createBrowseMedia({
        children_media_class: 'unknown',
      });

      const viewMedia = new BrowseMediaViewFolder(createFolder(), browseMedia);
      expect(viewMedia.getIcon()).toBeNull();
    });
  });
});



================================================
FILE: tests/ha/browse-media/sort.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  BrowseMediaMetadata,
  RichBrowseMedia,
} from '../../../src/ha/browse-media/types';
import { createBrowseMedia, createRichBrowseMedia } from '../../test-utils';
import { sortMostRecentFirst } from '../../../src/ha/browse-media/sort';

const createMetadata = (
  metadata: Partial<BrowseMediaMetadata>,
): BrowseMediaMetadata => ({
  cameraID: 'camera.office',
  startDate: new Date('2025-05-10T20:22:00Z'),
  endDate: new Date('2025-05-10T20:22:10Z'),
  ...metadata,
});

describe('sortMostRecentFirst', () => {
  it('should return an empty array when given an empty array', () => {
    const media: RichBrowseMedia<BrowseMediaMetadata>[] = [];
    expect(sortMostRecentFirst(media)).toEqual([]);
  });

  it('should sort media by startDate in descending order', () => {
    const media: RichBrowseMedia<BrowseMediaMetadata>[] = [
      createRichBrowseMedia({
        title: 'Media 1',
        _metadata: createMetadata({ startDate: new Date('2025-05-10T20:29:00.000Z') }),
      }),
      createRichBrowseMedia({
        title: 'Media 2',
        _metadata: createMetadata({ startDate: new Date('2025-05-12T20:29:00.000Z') }),
      }),
      createRichBrowseMedia({
        title: 'Media 3',
        _metadata: createMetadata({ startDate: new Date('2025-05-11T20:29:00.000Z') }),
      }),
    ];
    const expected: RichBrowseMedia<BrowseMediaMetadata>[] = [
      createRichBrowseMedia({
        title: 'Media 2',
        _metadata: createMetadata({ startDate: new Date('2025-05-12T20:29:00.000Z') }),
      }),
      createRichBrowseMedia({
        title: 'Media 3',
        _metadata: createMetadata({ startDate: new Date('2025-05-11T20:29:00.000Z') }),
      }),
      createRichBrowseMedia({
        title: 'Media 1',
        _metadata: createMetadata({ startDate: new Date('2025-05-10T20:29:00.000Z') }),
      }),
    ];
    expect(sortMostRecentFirst(media)).toEqual(expected);
  });

  it('should handle items with undefined startDate by placing them at the end', () => {
    const media: RichBrowseMedia<BrowseMediaMetadata>[] = [
      createRichBrowseMedia({
        title: 'Media 1',
        _metadata: createMetadata({ startDate: new Date('2025-05-10T20:29:00.000Z') }),
      }),
      createBrowseMedia({
        title: 'Media 2',
      }),
      createRichBrowseMedia({
        title: 'Media 3',
        _metadata: createMetadata({ startDate: new Date('2025-05-12T20:29:00.000Z') }),
      }),
      createBrowseMedia({
        title: 'Media 4',
      }),
    ];
    const expected: RichBrowseMedia<BrowseMediaMetadata>[] = [
      createBrowseMedia({
        title: 'Media 2',
      }),
      createBrowseMedia({
        title: 'Media 4',
      }),
      createRichBrowseMedia({
        title: 'Media 3',
        _metadata: createMetadata({ startDate: new Date('2025-05-12T20:29:00.000Z') }),
      }),
      createRichBrowseMedia({
        title: 'Media 1',
        _metadata: createMetadata({ startDate: new Date('2025-05-10T20:29:00.000Z') }),
      }),
    ];

    expect(sortMostRecentFirst(media)).toEqual(expected);
  });
});



================================================
FILE: tests/ha/browse-media/types.test.ts
================================================
import { expect, it } from 'vitest';
import { browseMediaSchema } from '../../../src/ha/browse-media/types';
import { createBrowseMedia } from '../../test-utils';

it('should lazy evaluate lazy recursive browse media schema', () => {
  expect(browseMediaSchema.parse(createBrowseMedia())).toEqual(createBrowseMedia());
});



================================================
FILE: tests/ha/browse-media/walker.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  BrowseMedia,
  BrowseMediaCache,
  RichBrowseMedia,
  browseMediaSchema,
} from '../../../src/ha/browse-media/types';
import { BrowseMediaStep, BrowseMediaWalker } from '../../../src/ha/browse-media/walker';
import { homeAssistantWSRequest } from '../../../src/ha/ws-request';
import { createBrowseMedia, createHASS } from '../../test-utils';

vi.mock('../../../src/ha/ws-request');

describe('BrowseMediaWalker', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should return an empty array if steps are null or empty', async () => {
    const walker = new BrowseMediaWalker();
    const hass = createHASS();
    expect(await walker.walk(hass, null)).toEqual([]);
    expect(await walker.walk(hass, [])).toEqual([]);
  });

  it('should perform a simple walk with one step', async () => {
    const child = createBrowseMedia();
    const parent = createBrowseMedia({
      media_content_id: 'media/parent',
      children: [child],
    });

    vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

    const hass = createHASS();
    const walker = new BrowseMediaWalker();
    const result = await walker.walk(hass, [
      {
        targets: ['media/parent'],
      },
    ]);

    expect(homeAssistantWSRequest).toBeCalledWith(hass, browseMediaSchema, {
      type: 'media_source/browse_media',
      media_content_id: 'media/parent',
    });
    expect(result).toEqual([child]);
  });

  it('should filter media using a matcher', async () => {
    const childToKeep = createBrowseMedia({
      media_content_id: 'media/child-keep',
    });
    const childToFilter = createBrowseMedia({
      media_content_id: 'media/child-filter',
    });

    const parent = createBrowseMedia({
      media_content_id: 'media/parent',
      media_content_type: 'directory',
      title: 'Parent',
      children: [childToKeep, childToFilter],
    });

    vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

    const hass = createHASS();
    const walker = new BrowseMediaWalker();

    const steps: BrowseMediaStep<undefined>[] = [
      {
        targets: ['media/parent'],
        matcher: (media) => media.media_content_id === 'media/child-keep',
      },
    ];

    const result = await walker.walk(hass, steps);

    expect(homeAssistantWSRequest).toBeCalledWith(hass, browseMediaSchema, {
      type: 'media_source/browse_media',
      media_content_id: 'media/parent',
    });
    expect(result).toEqual([childToKeep]);
  });

  interface TestMetadata {
    custom: string;
  }

  describe('should generate metadata', async () => {
    it('should generate simple metadata', async () => {
      const child = createBrowseMedia({
        media_content_id: 'media/child',
      });

      const parent = createBrowseMedia({
        media_content_id: 'media/parent',
        children: [child],
      });

      const metadataGenerator = (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _media: BrowseMedia,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _parentTarget?: RichBrowseMedia<TestMetadata>,
      ) => ({
        custom: 'foo',
      });

      vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

      const steps: BrowseMediaStep<TestMetadata>[] = [
        {
          targets: ['media/parent'],
          metadataGenerator,
        },
      ];

      const walker = new BrowseMediaWalker();
      const result = await walker.walk(createHASS(), steps);

      expect(result.length).toBe(1);
      expect(result[0]?._metadata).toEqual({
        custom: 'foo',
      });
    });

    it('should handle parents without children', async () => {
      const parent = createBrowseMedia({
        media_content_id: 'media/parent-with-free-time',
        children: null,
      });

      const metadataGenerator = (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _media: BrowseMedia,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _parentTarget?: RichBrowseMedia<TestMetadata>,
      ) => ({
        custom: 'foo',
      });

      vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

      const steps: BrowseMediaStep<TestMetadata>[] = [
        {
          targets: ['media/parent'],
          metadataGenerator,
        },
      ];

      const walker = new BrowseMediaWalker();
      const result = await walker.walk(createHASS(), steps);

      expect(result.length).toBe(0);
    });

    it('should handle metadata generator that returns null', async () => {
      const child = createBrowseMedia({
        media_content_id: 'media/child',
      });
      const parent = createBrowseMedia({
        media_content_id: 'media/parent',
        children: [child],
      });

      const metadataGenerator = (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _media: BrowseMedia,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _parentTarget?: RichBrowseMedia<TestMetadata>,
      ) => null;

      vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

      const steps: BrowseMediaStep<TestMetadata>[] = [
        {
          targets: ['media/parent'],
          metadataGenerator,
        },
      ];

      const walker = new BrowseMediaWalker();
      const result = await walker.walk(createHASS(), steps);

      expect(result).toEqual([child]);
      expect(result[0]?._metadata).toBeUndefined();
    });

    it('should handle recurisve metadata', async () => {
      const grandchild = createBrowseMedia({
        media_content_id: 'media/grandchild',
        can_expand: false,
        can_play: true,
      });
      const subparent = createBrowseMedia({
        media_content_id: 'media/subparent',
        can_expand: true,
        children: [grandchild],
      });
      const parent = createBrowseMedia({
        media_content_id: 'media/parent',
        can_expand: true,
        children: [subparent],
      });

      const metadataGenerator = (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _media: BrowseMedia,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _parentTarget?: RichBrowseMedia<TestMetadata>,
      ) => ({
        custom: 'foo',
      });

      vi.mocked(homeAssistantWSRequest).mockImplementation(
        async (_hass, _schema, request) => {
          if (request.media_content_id === 'media/parent') {
            return parent;
          }
          if (request.media_content_id === 'media/subparent') {
            return subparent;
          }
          throw new Error(
            `Unexpected media_content_id in mock: ${request.media_content_id}`,
          );
        },
      );

      const steps: BrowseMediaStep<TestMetadata>[] = [
        {
          targets: ['media/parent'],
          metadataGenerator,
          advance: (matchedDirs) => {
            return matchedDirs.map((dir) => ({
              targets: [dir],
              metadataGenerator,
            }));
          },
        },
      ];

      const hass = createHASS();
      const walker = new BrowseMediaWalker();
      const result = await walker.walk(hass, steps);

      expect(result.length).toBe(1);
      expect(result[0].media_content_id).toBe('media/grandchild');
      expect(result[0]?._metadata).toEqual({
        custom: 'foo',
      });
    });
  });

  it('should sort media using a sorter', async () => {
    const child_1 = createBrowseMedia({
      media_content_id: 'media/child-1',
    });
    const child_2 = createBrowseMedia({
      media_content_id: 'media/child-2',
    });
    const parent = createBrowseMedia({
      children: [child_2, child_1],
    });

    vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

    const steps: BrowseMediaStep<undefined>[] = [
      {
        targets: ['media/parent'],
        sorter: (media) =>
          [...media].sort((a, b) =>
            a.media_content_id.localeCompare(b.media_content_id),
          ),
      },
    ];

    const walker = new BrowseMediaWalker();
    const result = await walker.walk(createHASS(), steps);
    expect(result.map((m) => m.media_content_id)).toEqual([
      'media/child-1',
      'media/child-2',
    ]);
  });

  it('should exit early when earlyExit returns true', async () => {
    const child_1 = createBrowseMedia({
      media_content_id: 'media/child-1',
    });
    const child_2 = createBrowseMedia({
      media_content_id: 'media/child-2',
    });
    const parent_1 = createBrowseMedia({
      media_content_id: 'media/parent-1',
      children: [child_1],
    });
    const parent_2 = createBrowseMedia({
      media_content_id: 'media/parent-2',
      children: [child_2],
    });

    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(parent_1);

    vi.mocked(homeAssistantWSRequest).mockImplementation(
      async (_hass, _schema, request) => {
        if (request.media_content_id === 'media/parent-1') {
          return parent_1;
        }
        if (request.media_content_id === 'media/parent-2') {
          return parent_2;
        }
        throw new Error('Unexpected request');
      },
    );

    const steps: BrowseMediaStep<undefined>[] = [
      {
        targets: ['media/parent-1', 'media/parent-2'],
        concurrency: 1,
        earlyExit: (media) => media.length >= 1,
      },
    ];

    const hass = createHASS();
    const walker = new BrowseMediaWalker();
    const result = await walker.walk(hass, steps);

    expect(result).toEqual([child_1]);
    expect(homeAssistantWSRequest).toBeCalledTimes(1);
    expect(homeAssistantWSRequest).toBeCalledWith(hass, browseMediaSchema, {
      type: 'media_source/browse_media',
      media_content_id: 'media/parent-1',
    });
  });

  it('should advance to next steps for recursive walking', async () => {
    const grandchild = createBrowseMedia({
      media_content_id: 'media/grandchild',
      can_expand: false,
      can_play: true,
    });
    const subparent = createBrowseMedia({
      media_content_id: 'media/subparent',
      can_expand: true,
      children: [grandchild],
    });
    const parent = createBrowseMedia({
      media_content_id: 'media/parent',
      can_expand: true,
      children: [subparent],
    });

    vi.mocked(homeAssistantWSRequest).mockImplementation(
      async (_hass, _schema, request) => {
        if (request.media_content_id === 'media/parent') {
          return parent;
        }
        if (request.media_content_id === 'media/subparent') {
          return subparent;
        }
        throw new Error(
          `Unexpected media_content_id in mock: ${request.media_content_id}`,
        );
      },
    );

    const steps: BrowseMediaStep<undefined>[] = [
      {
        targets: ['media/parent'],
        matcher: (media) => media.can_expand === true,
        advance: (matchedDirs) => {
          return matchedDirs.map((dir) => ({
            targets: [dir],
            matcher: (childMedia) => childMedia.can_play === true,
          }));
        },
      },
    ];

    const hass = createHASS();
    const walker = new BrowseMediaWalker();
    const result = await walker.walk(hass, steps);

    expect(result.length).toBe(1);
    expect(result[0].media_content_id).toBe('media/grandchild');

    expect(homeAssistantWSRequest).toHaveBeenCalledTimes(2);
    expect(homeAssistantWSRequest).toHaveBeenCalledWith(hass, browseMediaSchema, {
      type: 'media_source/browse_media',
      media_content_id: 'media/parent',
    });
    expect(homeAssistantWSRequest).toHaveBeenCalledWith(hass, browseMediaSchema, {
      type: 'media_source/browse_media',
      media_content_id: 'media/subparent',
    });
  });

  it('should use cache when available', async () => {
    const child = createBrowseMedia({
      media_content_id: 'media/child',
    });
    const parent = createBrowseMedia({
      media_content_id: 'media/parent',
      children: [child],
    });

    vi.mocked(homeAssistantWSRequest).mockResolvedValue(parent);

    const cache = new BrowseMediaCache();
    const hass = createHASS();
    const walker = new BrowseMediaWalker();

    expect(await walker.walk(hass, [{ targets: ['media/parent'] }], { cache })).toEqual([
      child,
    ]);

    expect(homeAssistantWSRequest).toBeCalledTimes(1);
    expect(cache.has('media/parent')).toBe(true);
    expect(cache.get('media/parent')).toEqual(parent);

    expect(await walker.walk(hass, [{ targets: ['media/parent'] }], { cache })).toEqual([
      child,
    ]);
    expect(homeAssistantWSRequest).toBeCalledTimes(1);
  });

  it('should process multiple targets and combine their children', async () => {
    const child_1 = createBrowseMedia({
      media_content_id: 'media/child-1',
    });
    const parent_1 = createBrowseMedia({
      media_content_id: 'media/parent-1',
      children: [child_1],
    });
    const child_2 = createBrowseMedia({
      media_content_id: 'media/child-2',
    });
    const parent_2 = createBrowseMedia({
      media_content_id: 'media/parent-2',
      children: [child_2],
    });

    vi.mocked(homeAssistantWSRequest).mockImplementation(
      async (_hass, _schema, request) => {
        if (request.media_content_id === 'media/parent-1') {
          return parent_1;
        }
        if (request.media_content_id === 'media/parent-2') {
          return parent_2;
        }
        throw new Error('Unexpected request');
      },
    );

    const steps: BrowseMediaStep<undefined>[] = [
      {
        targets: ['media/parent-1', 'media/parent-2'],
      },
    ];

    const hass = createHASS();
    const walker = new BrowseMediaWalker();
    const result = await walker.walk(hass, steps);

    expect(homeAssistantWSRequest).toHaveBeenCalledTimes(2);
    expect(result).toHaveLength(2);
    expect(result).toContainEqual(child_1);
    expect(result).toContainEqual(child_2);
  });
});



================================================
FILE: tests/ha/browse-media/within-dates.test.ts
================================================
import { sub } from 'date-fns';
import { describe, expect, it } from 'vitest';
import { isMediaWithinDates } from '../../../src/ha/browse-media/within-dates';
import { createBrowseMedia, createRichBrowseMedia } from '../../test-utils';

describe('isMediaWithinDates', () => {
  const rangeStart = new Date('2024-11-19T07:00:00');
  const rangeEnd = new Date('2024-11-19T08:00:00');

  it('should never match media without metadata', () => {
    const media = createBrowseMedia();
    expect(isMediaWithinDates(media, rangeStart, rangeEnd)).toBe(false);
  });

  it('should always match media without start or end date', () => {
    expect(isMediaWithinDates(createRichBrowseMedia(), undefined, undefined)).toBe(true);
  });

  it('should match without a start date in the range', () => {
    expect(isMediaWithinDates(createRichBrowseMedia(), undefined, rangeEnd)).toBe(true);
  });

  it('should match without an end date in the range', () => {
    expect(isMediaWithinDates(createRichBrowseMedia(), rangeStart, undefined)).toBe(
      true,
    );
  });

  it('should match when ranges overlap', () => {
    expect(isMediaWithinDates(createRichBrowseMedia(), rangeStart, rangeEnd)).toBe(true);
  });

  it('should not match when ranges do not overlap', () => {
    expect(
      isMediaWithinDates(
        createRichBrowseMedia(),
        sub(rangeStart, { days: 1 }),
        sub(rangeEnd, { days: 1 }),
      ),
    ).toBe(false);
  });
});



================================================
FILE: tests/ha/integration/index.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { getIntegrationManifest } from '../../../src/ha/integration';
import { integrationManifestSchema } from '../../../src/ha/integration/types';
import { homeAssistantWSRequest } from '../../../src/ha/ws-request.js';
import { createHASS } from '../../test-utils';

vi.mock('../../../src/ha/ws-request.js');

describe('getIntegrationManifest', () => {
  it('should get integration manifest', async () => {
    const hass = createHASS();
    await getIntegrationManifest(hass, 'INTEGRATION');
    expect(homeAssistantWSRequest).toHaveBeenCalledWith(
      hass,
      integrationManifestSchema,
      { type: 'manifest/get', integration: 'INTEGRATION' },
    );
  });
});



================================================
FILE: tests/ha/registry/device/index.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { DeviceRegistryManager } from '../../../../src/ha/registry/device';
import { DeviceCache } from '../../../../src/ha/registry/device/types';
import { homeAssistantWSRequest } from '../../../../src/ha/ws-request';
import { createHASS, createRegistryDevice } from '../../../test-utils.js';

vi.mock('../../../../src/ha/ws-request');
vi.spyOn(global.console, 'warn').mockImplementation(() => true);

describe('DeviceRegistryManager', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('getDevice', () => {
    it('should not fetch when cached', async () => {
      const cache = new DeviceCache();
      const testDevice = createRegistryDevice({ id: 'test' });

      cache.set('test', testDevice);

      const manager = new DeviceRegistryManager(cache);
      expect(await manager.getDevice(createHASS(), 'test')).toEqual(testDevice);

      expect(homeAssistantWSRequest).not.toHaveBeenCalled();
    });

    it('should fetch and cache when not cached', async () => {
      const testDevice = createRegistryDevice({ id: 'test' });

      const manager = new DeviceRegistryManager(new DeviceCache());
      vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce([testDevice]);

      expect(await manager.getDevice(createHASS(), 'test')).toEqual(testDevice);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);

      expect(await manager.getDevice(createHASS(), 'test')).toEqual(testDevice);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);

      expect(await manager.getDevice(createHASS(), 'missing')).toBeNull();

      // The fetch call is called exactly once.
      expect(homeAssistantWSRequest).toBeCalledTimes(1);
    });

    it('should return null when fetch fails', async () => {
      vi.mocked(homeAssistantWSRequest).mockRejectedValueOnce(new Error('Fetch error'));

      const manager = new DeviceRegistryManager(new DeviceCache());
      expect(await manager.getDevice(createHASS(), 'test')).toBeNull();

      vi.mocked(expect(console.warn)).toBeCalledWith('Fetch error');
    });
  });

  it('getMatchingDevices', async () => {
    const matchingDevice = createRegistryDevice({ id: 'matching' });
    const notMatchingDevice = createRegistryDevice({ id: 'not-matching' });
    const hass = createHASS();

    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce([
      matchingDevice,
      notMatchingDevice,
    ]);

    const manager = new DeviceRegistryManager(new DeviceCache());
    expect(
      await manager.getMatchingDevices(hass, (entity) => entity.id == 'matching'),
    ).toEqual([matchingDevice]);
  });
});



================================================
FILE: tests/ha/registry/entity/index.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { EntityRegistryManagerLive } from '../../../../src/ha/registry/entity';
import { EntityCache } from '../../../../src/ha/registry/entity/types';
import { homeAssistantWSRequest } from '../../../../src/ha/ws-request';
import { createHASS, createRegistryEntity } from '../../../test-utils.js';

vi.mock('../../../../src/ha/ws-request');
vi.spyOn(global.console, 'warn').mockImplementation(() => true);

describe('EntityRegistryManager', () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('getEntity', () => {
    it('should not fetch when cached', async () => {
      const cache = new EntityCache();
      const testEntity = createRegistryEntity({ entity_id: 'test' });

      cache.set('test', testEntity);

      const manager = new EntityRegistryManagerLive(cache);
      expect(await manager.getEntity(createHASS(), 'test')).toEqual(testEntity);

      expect(homeAssistantWSRequest).not.toHaveBeenCalled();
    });

    it('should fetch and cache when not cached', async () => {
      const testEntity = createRegistryEntity({ entity_id: 'test' });

      const manager = new EntityRegistryManagerLive(new EntityCache());
      vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(testEntity);

      expect(await manager.getEntity(createHASS(), 'test')).toEqual(testEntity);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);

      expect(await manager.getEntity(createHASS(), 'test')).toEqual(testEntity);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);
    });

    it('should return null when entity does not exist', async () => {
      vi.mocked(homeAssistantWSRequest).mockRejectedValueOnce(new Error('Not found'));

      const manager = new EntityRegistryManagerLive(new EntityCache());
      expect(await manager.getEntity(createHASS(), 'missing')).toBeNull();

      vi.mocked(expect(console.warn)).toBeCalledWith('Not found');
    });
  });

  it('getEntities', async () => {
    const cachedEntity = createRegistryEntity({ entity_id: 'cached' });
    const notCachedEntity = createRegistryEntity({ entity_id: 'not-cached' });

    const cache = new EntityCache();
    cache.set('cached', cachedEntity);

    const manager = new EntityRegistryManagerLive(cache);
    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce(notCachedEntity);
    vi.mocked(homeAssistantWSRequest).mockRejectedValueOnce(new Error('Not found'));

    expect(
      await manager.getEntities(createHASS(), ['cached', 'not-cached', 'missing']),
    ).toEqual(
      new Map([
        ['cached', cachedEntity],
        ['not-cached', notCachedEntity],
      ]),
    );

    vi.mocked(expect(console.warn)).toBeCalledWith('Not found');
  });

  describe('fetchEntityList', async () => {
    it('should fetch entire entity list once', async () => {
      const hass = createHASS();
      const entity = createRegistryEntity({ entity_id: 'cached' });
      vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce([entity]);

      const manager = new EntityRegistryManagerLive(new EntityCache());

      await manager.fetchEntityList(hass);

      expect(homeAssistantWSRequest).toBeCalledTimes(1);
      expect(homeAssistantWSRequest).toBeCalledWith(
        expect.anything(),
        expect.anything(),
        {
          type: 'config/entity_registry/list',
        },
      );

      expect(await manager.getEntity(hass, 'cached')).toEqual(entity);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);

      await manager.fetchEntityList(hass);
      expect(homeAssistantWSRequest).toBeCalledTimes(1);
    });

    it('should log to console on error', async () => {
      const hass = createHASS();
      vi.mocked(homeAssistantWSRequest).mockRejectedValueOnce(new Error('Fetch error'));

      const manager = new EntityRegistryManagerLive(new EntityCache());

      await manager.fetchEntityList(hass);

      vi.mocked(expect(console.warn)).toBeCalledWith('Fetch error');
    });
  });

  it('getMatchingEntities', async () => {
    const matchingEntity = createRegistryEntity({ entity_id: 'matching' });
    const notMatchingEntity = createRegistryEntity({ entity_id: 'not-matching' });
    const hass = createHASS();

    vi.mocked(homeAssistantWSRequest).mockResolvedValueOnce([
      matchingEntity,
      notMatchingEntity,
    ]);

    const manager = new EntityRegistryManagerLive(new EntityCache());
    expect(
      await manager.getMatchingEntities(
        hass,
        (entity) => entity.entity_id == 'matching',
      ),
    ).toEqual([matchingEntity]);
  });
});



================================================
FILE: tests/ha/registry/entity/mock.ts
================================================
import {
  Entity,
  EntityCache,
  EntityRegistryManager,
} from '../../../../src/ha/registry/entity/types';
import { HomeAssistant } from '../../../../src/ha/types';

export class EntityRegistryManagerMock implements EntityRegistryManager {
  protected _cache = new EntityCache();
  protected _fetchedEntityList = false;

  constructor(data?: Entity[]) {
    data?.forEach((entity) => {
      this._cache.set(entity.entity_id, entity);
    });
  }

  public async getEntity(
    _hass: HomeAssistant,
    entityID: string,
  ): Promise<Entity | null> {
    return this._cache.get(entityID);
  }

  public async getMatchingEntities(
    _hass: HomeAssistant,
    func: (arg: Entity) => boolean,
  ): Promise<Entity[]> {
    return this._cache.getMatches(func);
  }

  public async getEntities(
    hass: HomeAssistant,
    entityIDs: string[],
  ): Promise<Map<string, Entity>> {
    const output: Map<string, Entity> = new Map();
    for (const entityID of entityIDs) {
      const entityData = await this.getEntity(hass, entityID);
      if (entityData) {
        output.set(entityID, entityData);
      }
    }
    return output;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public async fetchEntityList(_hass: HomeAssistant): Promise<void> {}
}



================================================
FILE: tests/templates/index.test.ts
================================================
import { renderTemplate } from 'ha-nunjucks';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { TemplateRenderer } from '../../src/card-controller/templates';
import { ConditionsTriggerData, ConditionState } from '../../src/conditions/types';
import { createHASS } from '../test-utils';

// ha-nunjucks attempts to make websocket calls initially so mock it out.
vi.mock('ha-nunjucks');

describe('TemplateRenderer', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should render data', () => {
    const data = {
      camera: '{{ acc.camera }}',
      array: ['{{ acc.camera }}', '{{ acc.view }}'],
      nested: {
        camera: '{{ acc.camera }}',
      },
      number: 42,
    };

    vi.mocked(renderTemplate)
      .mockReturnValueOnce('one')
      .mockReturnValueOnce('two')
      .mockReturnValueOnce('three')
      .mockReturnValueOnce('four');

    const renderer = new TemplateRenderer();
    const hass = createHASS();

    expect(renderer.renderRecursively(hass, data)).toEqual({
      camera: 'one',
      array: ['two', 'three'],
      nested: {
        camera: 'four',
      },
      number: 42,
    });
  });

  it('should include triggers', () => {
    const conditionState: ConditionState = {
      camera: 'camera',
      view: 'view',
    };
    const triggerData: ConditionsTriggerData = {
      camera: {
        to: 'camera',
        from: 'previous-camera',
      },
    };

    const renderer = new TemplateRenderer();
    const hass = createHASS();

    renderer.renderRecursively(
      hass,
      {
        key: 'value',
      },
      {
        conditionState,
        triggerData,
      },
    );

    expect(renderTemplate).toHaveBeenCalledWith(hass, 'value', {
      acc: {
        camera: 'camera',
        view: 'view',
        trigger: {
          camera: {
            to: 'camera',
            from: 'previous-camera',
          },
        },
      },
      advanced_camera_card: {
        camera: 'camera',
        view: 'view',
        trigger: {
          camera: {
            to: 'camera',
            from: 'previous-camera',
          },
        },
      },
    });
  });
});



================================================
FILE: tests/utils/action.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { INTERNAL_CALLBACK_ACTION } from '../../src/config/schema/actions/custom/internal.js';
import { ActionConfig } from '../../src/config/schema/actions/types.js';
import {
  createCameraAction,
  createDisplayModeAction,
  createFoldersViewAction,
  createGeneralAction,
  createInternalCallbackAction,
  createLogAction,
  createMediaPlayerAction,
  createPerformAction,
  createPTZAction,
  createPTZControlsAction,
  createPTZDigitalAction,
  createPTZMultiAction,
  createSelectOptionAction,
  createViewAction,
  getActionConfigGivenAction,
  hasAction,
  stopEventFromActivatingCardWideActions,
} from '../../src/utils/action.js';

describe('createGeneralAction', () => {
  it('should create general action', () => {
    expect(
      createGeneralAction('camera_ui', {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'camera_ui',
      card_id: 'card_id',
    });
  });
});

describe('createViewAction', () => {
  it('should create view action', () => {
    expect(
      createViewAction('clips', {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'clips',
      card_id: 'card_id',
    });
  });
});

describe('createCameraAction', () => {
  it('should create camera_select action', () => {
    expect(createCameraAction('camera_select', 'camera', { cardID: 'card_id' })).toEqual(
      {
        action: 'fire-dom-event',
        camera: 'camera',
        advanced_camera_card_action: 'camera_select',
        card_id: 'card_id',
      },
    );
  });
});

describe('createFolderAction', () => {
  it.each([['folder' as const], ['folders' as const]])(
    '%s',
    (viewName: 'folder' | 'folders') => {
      expect(
        createFoldersViewAction(viewName, { folderID: 'folderID', cardID: 'card_id' }),
      ).toEqual({
        action: 'fire-dom-event',
        advanced_camera_card_action: viewName,
        card_id: 'card_id',
        folder: 'folderID',
      });
    },
  );
});

describe('createMediaPlayerAction', () => {
  it('should create media_player action', () => {
    expect(
      createMediaPlayerAction('device', 'play', {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'media_player',
      media_player: 'device',
      media_player_action: 'play',
      card_id: 'card_id',
    });
  });
});

describe('createDisplayModeAction', () => {
  it('should create display mode action', () => {
    expect(
      createDisplayModeAction('grid', {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'display_mode_select',
      display_mode: 'grid',
      card_id: 'card_id',
    });
  });
});

describe('createPTZControlsAction', () => {
  it('should create PTZ controls action', () => {
    expect(
      createPTZControlsAction(true, {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz_controls',
      enabled: true,
      card_id: 'card_id',
    });
  });
});

describe('createPTZAction', () => {
  it('should create ptz action without parameters', () => {
    expect(
      createPTZAction({
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz',
      card_id: 'card_id',
    });
  });

  it('should create ptz action with parameters', () => {
    expect(
      createPTZAction({
        cardID: 'card_id',
        ptzAction: 'right',
        ptzPhase: 'start',
        ptzPreset: 'preset',
        cameraID: 'camera_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz',
      card_id: 'card_id',
      camera: 'camera_id',
      ptz_action: 'right',
      ptz_phase: 'start',
      ptz_preset: 'preset',
    });
  });
});

describe('createPTZDigitalAction', () => {
  it('should create ptz digital without parameters', () => {
    expect(
      createPTZDigitalAction({
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz_digital',
      card_id: 'card_id',
    });
  });

  it('should create ptz digital with parameters', () => {
    expect(
      createPTZDigitalAction({
        cardID: 'card_id',
        targetID: 'target_id',
        absolute: {
          pan: { x: 1, y: 2 },
          zoom: 3,
        },
        ptzAction: 'right',
        ptzPhase: 'start',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz_digital',
      card_id: 'card_id',
      target_id: 'target_id',
      absolute: {
        pan: { x: 1, y: 2 },
        zoom: 3,
      },
      ptz_action: 'right',
      ptz_phase: 'start',
    });
  });
});

describe('createPTZMultiAction', () => {
  it('should create ptz multi with parameters', () => {
    expect(
      createPTZMultiAction({
        cardID: 'card_id',
        ptzAction: 'right',
        ptzPreset: 'preset',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz_multi',
      card_id: 'card_id',
      ptz_action: 'right',
      ptz_preset: 'preset',
    });
  });

  it('should create ptz multi without parameters', () => {
    expect(
      createPTZMultiAction({
        cardID: 'card_id',
        ptzAction: 'right',
        ptzPhase: 'start',
        targetID: 'target_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'ptz_multi',
      card_id: 'card_id',
      ptz_action: 'right',
      ptz_phase: 'start',
      target_id: 'target_id',
    });
  });
});

describe('createLogAction', () => {
  it('should create log action', () => {
    expect(
      createLogAction('Hello, world!', {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: 'log',
      message: 'Hello, world!',
      card_id: 'card_id',
      level: 'info',
    });
  });
});

describe('createInternalCallbackAction', () => {
  it('should create internal callback action', () => {
    const callback = vi.fn();
    expect(
      createInternalCallbackAction(callback, {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'fire-dom-event',
      advanced_camera_card_action: INTERNAL_CALLBACK_ACTION,
      callback: callback,
      card_id: 'card_id',
    });
  });
});

describe('createPerformAction', () => {
  it('should create perform action', () => {
    expect(
      createPerformAction('toggle', {
        cardID: 'card_id',
        target: { entity_id: 'light.office_main_lights' },
        data: {},
      }),
    ).toEqual({
      action: 'perform-action',
      perform_action: 'toggle',
      card_id: 'card_id',
      target: { entity_id: 'light.office_main_lights' },
      data: {},
    });
  });
});

describe('createSelectOptionAction', () => {
  it('should create select option action', () => {
    expect(
      createSelectOptionAction('select', 'select.foo', 'option', {
        cardID: 'card_id',
      }),
    ).toEqual({
      action: 'perform-action',
      perform_action: 'select.select_option',
      card_id: 'card_id',
      target: { entity_id: 'select.foo' },
      data: {
        option: 'option',
      },
    });
  });
});

describe('getActionConfigGivenAction', () => {
  const action = createViewAction('clips');

  it('should not handle undefined arguments', () => {
    expect(getActionConfigGivenAction()).toBeNull();
  });

  it('should not handle unknown interactions', () => {
    expect(
      getActionConfigGivenAction('triple_poke', { triple_poke_action: action }),
    ).toBeNull();
  });

  it('should handle tap actions', () => {
    expect(getActionConfigGivenAction('tap', { tap_action: action })).toBe(action);
  });

  it('should handle default tap action without an entity', () => {
    expect(getActionConfigGivenAction('tap', {})).toBeNull();
  });

  it('should handle default tap action with an entity', () => {
    expect(
      getActionConfigGivenAction('tap', { entity: 'light.office_main_lights' }),
    ).toEqual({
      action: 'more-info',
    });
  });

  it('should handle hold actions', () => {
    expect(getActionConfigGivenAction('hold', { hold_action: action })).toBe(action);
  });

  it('should handle double_tap actions', () => {
    expect(getActionConfigGivenAction('double_tap', { double_tap_action: action })).toBe(
      action,
    );
  });

  it('should handle end_tap actions', () => {
    expect(getActionConfigGivenAction('end_tap', { end_tap_action: action })).toBe(
      action,
    );
  });

  it('should handle start_tap actions', () => {
    expect(getActionConfigGivenAction('start_tap', { start_tap_action: action })).toBe(
      action,
    );
  });
});

describe('hasAction', () => {
  const realAction = createViewAction('clips');
  const noneAction: ActionConfig = {
    action: 'none',
  };

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('should return true for real action', () => {
    expect(hasAction(realAction)).toBeTruthy();
  });

  it('should return false for none action', () => {
    expect(hasAction(noneAction)).toBeFalsy();
  });

  it('should return true with an array of actions some real', () => {
    expect(hasAction([noneAction, noneAction, realAction])).toBeTruthy();
  });

  it('should return false with an array of actions none real', () => {
    expect(hasAction([noneAction, noneAction, noneAction])).toBeFalsy();
  });
});

// @vitest-environment jsdom
describe('stopEventFromActivatingCardWideActions', () => {
  it('should stop event from propogating', () => {
    const event = mock<Event>();
    stopEventFromActivatingCardWideActions(event);
    expect(event.stopPropagation).toBeCalled();
  });
});



================================================
FILE: tests/utils/audio.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { AudioProperties, mayHaveAudio } from '../../src/utils/audio';

// @vitest-environment jsdom
describe('mayHaveAudio', () => {
  it('should detect audio when mozHasAudio true', () => {
    const element: HTMLVideoElement & AudioProperties = document.createElement('video');
    element.mozHasAudio = true;
    expect(mayHaveAudio(element)).toBeTruthy();
  });

  it('should not detect audio when mozHasAudio undefined', () => {
    const element: HTMLVideoElement & AudioProperties = document.createElement('video');
    element.mozHasAudio = undefined;
    expect(mayHaveAudio(element)).toBeFalsy();
  });

  it('should detect audio when audioTracks has length', () => {
    // Workaround: "Cannot set property audioTracks of #<HTMLMediaElement> which has only a getter"
    const element = {} as HTMLVideoElement & AudioProperties;
    element.audioTracks = [1, 2, 3];
    expect(mayHaveAudio(element)).toBeTruthy();
  });

  it('should not detect audio when audioTracks has no length', () => {
    // Workaround: "Cannot set property audioTracks of #<HTMLMediaElement> which has only a getter"
    const element = {} as HTMLVideoElement & AudioProperties;
    element.audioTracks = [];
    expect(mayHaveAudio(element)).toBeFalsy();
  });

  it('should detect audio when no evidence to the contrary', () => {
    const element = {} as HTMLVideoElement & AudioProperties;
    expect(mayHaveAudio(element)).toBeTruthy();
  });
});



================================================
FILE: tests/utils/basic.test.ts
================================================
import { afterAll, describe, expect, it, vi } from 'vitest';
import { AdvancedCameraCardError } from '../../src/types.js';
import {
  allPromises,
  arefloatsApproximatelyEqual,
  arrayify,
  arrayMove,
  aspectRatioToStyle,
  contentsChanged,
  dayToDate,
  desparsifyArrays,
  errorToConsole,
  formatDate,
  formatDateAndTime,
  generateFloatApproximatelyEqualsCustomizer,
  getChildrenFromElement,
  getDurationString,
  isHoverableDevice,
  isHTMLElement,
  isSuperset,
  isTruthy,
  isValidDate,
  prettifyTitle,
  recursivelyMergeObjectsConcatenatingArraysUniquely,
  recursivelyMergeObjectsNotArrays,
  runWhenIdleIfSupported,
  setify,
  setOrRemoveAttribute,
} from '../../src/utils/basic.js';
import { createSlot, createSlotHost } from '../test-utils.js';

describe('prettifyTitle', () => {
  it('should return undefined when passed undefined', () => {
    expect(prettifyTitle(undefined)).toBe(undefined);
  });
  it('should prettify words', () => {
    expect(prettifyTitle('this is_a  string')).toBe('This Is A String');
  });
  it('should handle leading spaces', () => {
    expect(prettifyTitle(' this is_a  string')).toBe('This Is A String');
  });
  it('should handle empty string', () => {
    expect(prettifyTitle('')).toBeUndefined();
  });
});

describe('arrayMove', () => {
  it('should move array item', () => {
    const data = [1, 2, 3];
    expect(arrayMove(data, 1, 0)).toEqual([2, 1, 3]);
  });
});

describe('arrayify', () => {
  it('should convert non array to array', () => {
    expect(arrayify(1)).toEqual([1]);
  });
  it('should return array', () => {
    const data = [1, 2, 3];
    expect(arrayify(data)).toBe(data);
  });
  it('should handle undefined', () => {
    expect(arrayify()).toEqual([]);
  });
});

describe('setify', () => {
  it('should convert non set to set', () => {
    expect(setify(1)).toEqual(new Set([1]));
  });
  it('should return set', () => {
    const data = new Set([1, 2, 3]);
    expect(setify(data)).toBe(data);
  });
});

describe('contentsChanged', () => {
  it('should have changed contents', () => {
    expect(contentsChanged([1, 2], [2, 1])).toBeTruthy();
  });
  it('should not have changed contents', () => {
    expect(contentsChanged([1, 2], [1, 2])).toBeFalsy();
  });
});

describe('errorToConsole', () => {
  const spy = vi.spyOn(global.console, 'warn').mockImplementation(() => true);

  afterAll(() => {
    vi.restoreAllMocks();
  });

  it('should log given error', () => {
    const error = new Error('ERROR');
    errorToConsole(error);
    expect(spy).toHaveBeenCalledWith('ERROR');
  });
  it('should log with context given advanced camera card error', () => {
    const data = { foo: 2 };
    const error = new AdvancedCameraCardError('ERROR', { foo: 2 });
    errorToConsole(error);
    expect(spy).toHaveBeenCalledWith(error, data);
  });
  it('should log with custom function', () => {
    const func = vi.fn();
    const error = new Error('ERROR');
    errorToConsole(error, func);
    expect(func).toHaveBeenCalledWith('ERROR');
  });
  it('should log string', () => {
    errorToConsole('string message');
    expect(spy).toHaveBeenCalledWith('string message');
  });
});

// @vitest-environment jsdom
describe('isHoverableDevice', () => {
  afterAll(() => {
    vi.restoreAllMocks();
  });

  it('should return hoverable', () => {
    vi.spyOn(window, 'matchMedia').mockReturnValue(<MediaQueryList>{ matches: true });
    expect(isHoverableDevice()).toBeTruthy();
  });
  it('should return not hoverable', () => {
    vi.spyOn(window, 'matchMedia').mockReturnValue(<MediaQueryList>{ matches: false });
    expect(isHoverableDevice()).toBeFalsy();
  });
});

describe('formatDateAndTime', () => {
  it('should format date and time', () => {
    const date = new Date(2023, 3, 14, 13, 35, 0);
    expect(formatDateAndTime(date)).toBe('2023-04-14 13:35');
  });
  it('should format date and time with seconds', () => {
    const date = new Date(2023, 3, 14, 13, 35, 1);
    expect(formatDateAndTime(date, true)).toBe('2023-04-14 13:35:01');
  });
});

describe('formatDate', () => {
  it('should format date', () => {
    const date = new Date(2023, 3, 14, 13, 35, 0);
    expect(formatDate(date)).toBe('2023-04-14');
  });
});

// @vitest-environment jsdom
describe('runWhenIdleIfSupported', () => {
  const originalRequestIdleCallback = window.requestIdleCallback;
  afterAll(() => {
    window.requestIdleCallback = originalRequestIdleCallback;
  });

  it('should run directly when not supported', () => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (window as any).requestIdleCallback = undefined;
    const func = vi.fn();
    runWhenIdleIfSupported(func);
    expect(func).toHaveBeenCalled();
  });

  it('should run idle when supported', () => {
    const requestIdle = vi.fn();
    window.requestIdleCallback = requestIdle;
    const func = vi.fn();
    runWhenIdleIfSupported(func);
    expect(requestIdle).toBeCalledWith(func, {});
  });

  it('should run idle with timeout when supported', () => {
    const requestIdle = vi.fn();
    window.requestIdleCallback = requestIdle;
    const func = vi.fn();
    runWhenIdleIfSupported(func, 10);
    expect(requestIdle).toBeCalledWith(func, { timeout: 10 });
  });
});

describe('getDurationString', () => {
  it('should return duration', () => {
    const start = new Date(2023, 3, 14, 13, 35, 0);
    const end = new Date(2023, 3, 14, 15, 37, 20);
    expect(getDurationString(start, end)).toBe('2h 2m 20s');
  });
  it('should return very short duration', () => {
    const start = new Date(2023, 3, 14, 13, 35, 10);
    const end = new Date(2023, 3, 14, 13, 35, 12);
    expect(getDurationString(start, end)).toBe('2s');
  });
  it('should return 0s for no delta', () => {
    const start = new Date(2023, 3, 14, 13, 35, 10);
    expect(getDurationString(start, start)).toBe('0s');
  });
});

describe('allPromises', () => {
  it('should await all promises', async () => {
    const results = await allPromises([1, 2, 3], async (n) => n * 2);
    expect(results).toEqual([2, 4, 6]);
  });
});

describe('dayToDate', () => {
  it('should return correct date', () => {
    expect(dayToDate('2023-04-14')).toEqual(new Date(2023, 3, 14));
  });
});

describe('isSuperset', () => {
  it('should return is a superset', () => {
    expect(isSuperset(new Set([1, 2, 3, 4]), new Set([2, 3]))).toBeTruthy();
  });
  it('should return is not a superset', () => {
    expect(isSuperset(new Set([1, 2, 3, 4]), new Set([2, 3, 5]))).toBeFalsy();
  });
});

describe('isValidDate', () => {
  it('should be valid date', () => {
    expect(isValidDate(new Date(2023, 3, 28))).toBeTruthy();
  });
  it('should be invalid date', () => {
    expect(isValidDate(new Date('moo'))).toBeFalsy();
  });
});

describe('setOrRemoveAttribute', () => {
  it('should set attribute without value', () => {
    const element = document.createElement('div');
    setOrRemoveAttribute(element, true, 'key');
    expect(element.getAttribute('key')).toBe('');
  });

  it('should set attribute with value', () => {
    const element = document.createElement('div');
    setOrRemoveAttribute(element, true, 'key', 'value');
    expect(element.getAttribute('key')).toBe('value');
  });

  it('should remove attribute date', () => {
    const element = document.createElement('div');
    element.setAttribute('key', 'value');
    setOrRemoveAttribute(element, false, 'key');
    expect(element.getAttribute('key')).toBeFalsy();
  });
});

describe('isTruthy', () => {
  it('should return true for true', () => {
    expect(isTruthy(true)).toBeTruthy();
  });
  it('should return false for false', () => {
    expect(isTruthy(false)).toBeFalsy();
  });
});

describe('isHTMLElement', () => {
  it('should return true for HTMLElement', () => {
    const htmlElement = document.createElement('div');
    expect(isHTMLElement(htmlElement)).toBeTruthy();
  });
  it('should return false for Element', () => {
    const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    expect(isHTMLElement(svgElement)).toBeFalsy();
  });
});

describe('getChildrenFromElement', () => {
  it('should return children for simple parent', () => {
    const children = [document.createElement('div'), document.createElement('div')];
    const parent = document.createElement('div');
    children.forEach((child) => parent.appendChild(child));
    expect(getChildrenFromElement(parent)).toEqual(children);
  });

  it('should return children for slot', () => {
    const children = [document.createElement('div'), document.createElement('div')];
    const slot = createSlot();
    createSlotHost({ slot: slot, children: children });
    expect(getChildrenFromElement(slot)).toEqual(children);
  });
});

describe('recursivelyMergeObjectsNotArrays', () => {
  it('should recursively merge objects but replace arrays', () => {
    expect(
      recursivelyMergeObjectsNotArrays(
        {},
        {
          a: {
            b: {
              c: 3,
              d: {
                e: 4,
              },
              array: [1, 2, 3],
            },
            other: {
              field: 7,
            },
          },
        },
        {
          a: {
            b: {
              array: [4],
              d: {
                e: 5,
              },
            },
          },
        },
      ),
    ).toEqual({
      a: {
        b: {
          c: 3,
          array: [4],
          d: {
            e: 5,
          },
        },
        other: {
          field: 7,
        },
      },
    });
  });
});

describe('recursivelyMergeObjectsConcatenatingArraysUniquely', () => {
  it('should recursively merge objects but uniquely concat arrays', () => {
    expect(
      recursivelyMergeObjectsConcatenatingArraysUniquely(
        {},
        {
          a: {
            b: {
              c: 3,
              d: {
                e: 4,
              },
              array: [5, 1, 2, 3, 4],
            },
            other: {
              field: 7,
            },
          },
        },
        {
          a: {
            b: {
              array: [4, 4, 5],
              d: {
                e: 5,
              },
            },
          },
        },
      ),
    ).toEqual({
      a: {
        b: {
          c: 3,
          array: [5, 1, 2, 3, 4],
          d: {
            e: 5,
          },
        },
        other: {
          field: 7,
        },
      },
    });
  });
});

describe('aspectRatioToStyle', () => {
  it('default', () => {
    expect(aspectRatioToStyle()).toEqual({ 'aspect-ratio': 'auto' });
  });
  it('default static', () => {
    expect(aspectRatioToStyle({ defaultStatic: true })).toEqual({
      'aspect-ratio': '16 / 9',
    });
  });
  it('valid ratio', () => {
    expect(aspectRatioToStyle({ ratio: [4, 3] })).toEqual({ 'aspect-ratio': '4 / 3' });
  });
  it('invalid ratio', () => {
    expect(aspectRatioToStyle({ ratio: [4] })).toEqual({ 'aspect-ratio': 'auto' });
  });
});

describe('desparsifyArrays', () => {
  it('number', () => {
    expect(desparsifyArrays(1)).toBe(1);
  });
  it('string', () => {
    expect(desparsifyArrays('foo')).toBe('foo');
  });
  describe('array', () => {
    it('simple', () => {
      expect(desparsifyArrays([1, 2, undefined, 3])).toEqual([1, 2, 3]);
    });
    it('nested', () => {
      expect(
        desparsifyArrays([
          1,
          2,
          undefined,
          {
            subArray: [undefined, 3],
          },
          4,
        ]),
      ).toEqual([1, 2, { subArray: [3] }, 4]);
    });
  });
  describe('object', () => {
    it('simple', () => {
      expect(
        desparsifyArrays({ foo: [1, 2, undefined, 3], bar: [undefined, 4] }),
      ).toEqual({
        foo: [1, 2, 3],
        bar: [4],
      });
    });
    it('nested', () => {
      expect(
        desparsifyArrays({ foo: { bar: [1, undefined, 2], empty: [undefined] } }),
      ).toEqual({
        foo: {
          bar: [1, 2],
          empty: [],
        },
      });
    });
  });
});

describe('arefloatsApproximatelyEqual', () => {
  describe('without precision', () => {
    it('equals', () => {
      expect(arefloatsApproximatelyEqual(1.1, 1.2)).toBeTruthy();
    });
    it('not equals', () => {
      expect(arefloatsApproximatelyEqual(0.5, 1.5)).toBeFalsy();
    });
  });
  describe('with precision', () => {
    it('equals', () => {
      expect(arefloatsApproximatelyEqual(1.00001, 1.00002, 4)).toBeTruthy();
    });
    it('not equals', () => {
      expect(arefloatsApproximatelyEqual(0.5, 1.5, 4)).toBeFalsy();
    });
  });
});

describe('generateFloatApproximatelyEqualsCustomizer', () => {
  describe('with incorrect types', () => {
    it('undefined a', () => {
      expect(
        generateFloatApproximatelyEqualsCustomizer(4)(undefined, 1.2),
      ).toBeUndefined();
    });
    it('undefined b', () => {
      expect(
        generateFloatApproximatelyEqualsCustomizer(4)(1.2, undefined),
      ).toBeUndefined();
    });
    it('strings', () => {
      expect(
        generateFloatApproximatelyEqualsCustomizer(4)('foo', 'bar'),
      ).toBeUndefined();
    });
  });
  describe('with correct types', () => {
    it('equals', () => {
      expect(
        generateFloatApproximatelyEqualsCustomizer(4)(1.00001, 1.00002),
      ).toBeTruthy();
    });
    it('not equals', () => {
      expect(
        generateFloatApproximatelyEqualsCustomizer(5)(1.00001, 1.00002),
      ).toBeFalsy();
    });
  });
});



================================================
FILE: tests/utils/camera.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getCameraID } from '../../src/utils/camera.js';
import { createCameraConfig } from '../test-utils.js';

describe('getCameraID', () => {
  it('should get camera id with id', () => {
    const config = createCameraConfig({ id: 'foo' });
    expect(getCameraID(config)).toBe('foo');
  });
  it('should get camera id with camera_entity', () => {
    const config = createCameraConfig({ camera_entity: 'foo' });
    expect(getCameraID(config)).toBe('foo');
  });
  it('should get camera id with webrtc entity', () => {
    const config = createCameraConfig({ webrtc_card: { entity: 'foo' } });
    expect(getCameraID(config)).toBe('foo');
  });
  it('should get camera id with webrtc url', () => {
    const config = createCameraConfig({ webrtc_card: { url: 'foo' } });
    expect(getCameraID(config)).toBe('foo');
  });
  it('should get camera id with go2rtc url and stream', () => {
    const config = createCameraConfig({
      go2rtc: { url: 'https://foo', stream: 'office' },
    });
    expect(getCameraID(config)).toBe('https://foo#office');
  });
  it('should get camera id with frigate camera_name', () => {
    const config = createCameraConfig({
      frigate: { client_id: 'bar', camera_name: 'foo' },
    });
    expect(getCameraID(config)).toBe('foo');
  });
  it('should get blank id without anything', () => {
    const config = createCameraConfig({});
    expect(getCameraID(config)).toBe('');
  });
});



================================================
FILE: tests/utils/casting.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { isBeingCasted } from '../../src/utils/casting.js';

describe('isBeingCasted', () => {
  it('should confirm being casted', () => {
    vi.stubGlobal('navigator', {
      userAgent:
        'Mozilla/5.0 (Fuchsia) AppleWebKit/537.36 (KHTML, like Gecko) ' +
        'Chrome/114.0.0.0 Safari/537.36 CrKey/1.56.500000',
    });

    // Import the function
    expect(isBeingCasted()).toBeTruthy();
  });

  it('should confirm not being casted', () => {
    vi.stubGlobal('navigator', {
      userAgent:
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) ' +
        'Chrome/131.0.0.0 Safari/537.36',
    });

    // Import the function
    expect(isBeingCasted()).toBeFalsy();
  });
});



================================================
FILE: tests/utils/companion.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  isCompanionApp,
  isAndroidCompanionApp,
  isIOSCompanionApp,
} from '../../src/utils/companion';

describe('isCompanionApp', () => {
  it('should return true for userAgent starting with "Home Assistant/"', () => {
    expect(isCompanionApp('Home Assistant/1.0')).toBe(true);
  });

  it('should return true for userAgent starting with "HomeAssistant/"', () => {
    expect(isCompanionApp('HomeAssistant/1.0')).toBe(true);
  });

  it('should return false for userAgent not starting with "Home Assistant/" or "HomeAssistant/"', () => {
    expect(isCompanionApp('Mozilla/5.0')).toBe(false);
  });

  it('should return false for an empty userAgent', () => {
    expect(isCompanionApp('')).toBe(false);
  });
});

describe('isAndroidCompanionApp', () => {
  it('should return true for userAgent containing "Home Assistant" and "Android"', () => {
    expect(isAndroidCompanionApp('Home Assistant/1.0 (Android 1.0; 1.0)')).toBe(true);
  });

  it('should return true for userAgent containing "HomeAssistant" and "Android"', () => {
    expect(isAndroidCompanionApp('HomeAssistant/2.0 (Android 2.0; 2.0)')).toBe(true);
  });

  it('should return false for userAgent not starting with "Home Assistant/" or "HomeAssistant/"', () => {
    expect(isAndroidCompanionApp('Mozilla/5.0')).toBe(false);
  });

  it('should return false for userAgent containing "Home Assistant/" or "HomeAssistant/" and iOS', () => {
    expect(
      isAndroidCompanionApp(
        'Home Assistant/2025.1.1 (io.robbie.HomeAssistant; build:2025.1077; iOS 18.3.0',
      ),
    ).toBe(false);
  });
});

describe('isIOSCompanionApp', () => {
  it('should return true for userAgent containing "Home Assistant" and "iOS"', () => {
    expect(isIOSCompanionApp('Home Assistant/1.0 (iOS 1.0; 1.0)')).toBe(true);
  });

  it('should return true for userAgent containing "HomeAssistant" and "iOS"', () => {
    expect(isIOSCompanionApp('HomeAssistant/2.0 (iOS 2.0; 2.0)')).toBe(true);
  });

  it('should return false for userAgent not starting with "Home Assistant/" or "HomeAssistant/"', () => {
    expect(isIOSCompanionApp('Mozilla/5.0')).toBe(false);
  });

  it('should return false for userAgent containing "Home Assistant/" or "HomeAssistant/" and Android', () => {
    expect(
      isIOSCompanionApp(
        'Home Assistant/2025.1.1 (io.robbie.HomeAssistant; build:2025.1077; Android 18.3.0',
      ),
    ).toBe(false);
  });
});



================================================
FILE: tests/utils/controls.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import {
  AdvancedCameraCardHTMLVideoElement,
  MEDIA_LOAD_CONTROLS_HIDE_SECONDS,
  hideMediaControlsTemporarily,
  setControlsOnVideo,
} from '../../src/utils/controls.js';

// @vitest-environment jsdom
describe('setControlsOnVideo', () => {
  it('should set controls', () => {
    const video = document.createElement('video');

    setControlsOnVideo(video, false);
    expect(video.controls).toBeFalsy();
  });

  it('should stop timer', () => {
    const video: AdvancedCameraCardHTMLVideoElement = document.createElement('video');
    hideMediaControlsTemporarily(video);

    expect(video._controlsHideTimer).toBeTruthy();
    expect(video._controlsHideTimer?.isRunning()).toBeTruthy();

    setControlsOnVideo(video, false);
    expect(video.controls).toBeFalsy();
    expect(video._controlsHideTimer).toBeFalsy();
  });
});

describe('hideMediaControlsTemporarily', () => {
  beforeAll(() => {
    vi.useFakeTimers();
  });

  afterAll(() => {
    vi.useRealTimers();
  });

  it('should set controls', () => {
    const video: AdvancedCameraCardHTMLVideoElement = document.createElement('video');
    video.controls = true;
    hideMediaControlsTemporarily(video);

    expect(video.controls).toBeFalsy();
    vi.runOnlyPendingTimers();

    expect(video.controls).toBeTruthy();
    expect(video._controlsHideTimer).toBeFalsy();
  });

  it('should add event listener that resets controls', () => {
    const video: AdvancedCameraCardHTMLVideoElement = document.createElement('video');
    video.controls = true;

    hideMediaControlsTemporarily(video);
    expect(video.controls).toBeFalsy();

    // After a new media starts to load, the controls should reset.
    video.dispatchEvent(new Event('loadstart'));
    expect(video.controls).toBeTruthy();

    // ... but only once, future loadstart events without subsequent calls to
    // hideMediaControlsTemporarily() should do nothing.
    video.controls = false;
    video.dispatchEvent(new Event('loadstart'));
    expect(video._controlsHideTimer).toBeFalsy();
  });
});

describe('constants', () => {
  it('MEDIA_LOAD_CONTROLS_HIDE_SECONDS', () => {
    expect(MEDIA_LOAD_CONTROLS_HIDE_SECONDS).toBe(2);
  });
});



================================================
FILE: tests/utils/debug.test.ts
================================================
import { afterAll, describe, expect, it, vi } from 'vitest';
import { log } from '../../src/utils/debug.js';

describe('log', () => {
  const spy = vi.spyOn(global.console, 'debug').mockReturnValue(undefined);
  afterAll(() => {
    vi.restoreAllMocks();
  });
  it('should do nothing without debug logging set', () => {
    log({}, 'foo');
    expect(spy).not.toBeCalled();
  });
  it('should log debug when appropriately configured', () => {
    log({ debug: { logging: true } }, 'foo');
    expect(spy).toBeCalledWith('foo');
  });
});



================================================
FILE: tests/utils/diagnostics.test.ts
================================================
import { HassConfig } from 'home-assistant-js-websocket';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { DeviceRegistryManager } from '../../src/ha/registry/device';
import { homeAssistantWSRequest } from '../../src/ha/ws-request';
import { getLanguage } from '../../src/localize/localize';
import { getDiagnostics, getReleaseVersion } from '../../src/utils/diagnostics.js';
import { createHASS, createRegistryDevice } from '../test-utils';

vi.mock('../../package.json', () => ({
  default: {
    gitAbbrevHash: 'g4cf13b1',
    buildDate: 'Tue, 19 Sep 2023 04:59:27 GMT',
    gitDate: 'Wed, 6 Sep 2023 21:27:28 -0700',
  },
}));
vi.mock('../../src/ha');
vi.mock('../../src/localize/localize.js');
vi.mock('../../src/ha/registry/device/index.js');
vi.mock('../../src/ha/ws-request.js');

describe('getReleaseVersion', () => {
  it('should get release version', () => {
    expect(getReleaseVersion()).toBe('__ADVANCED_CAMERA_CARD_RELEASE_VERSION__');
  });
});

// @vitest-environment jsdom
describe('getDiagnostics', () => {
  const now = new Date('2023-10-01T21:53Z');
  const hass = createHASS();
  hass.config = { version: '2023.9.0' } as HassConfig;

  beforeEach(() => {
    vi.resetAllMocks();

    vi.useFakeTimers();
    vi.setSystemTime(now);

    vi.mocked(getLanguage).mockReturnValue('en');
    vi.stubGlobal('navigator', { userAgent: 'AdvancedCameraCardTest/1.0' });
  });

  afterEach(() => {
    vi.useRealTimers();
    vi.unstubAllGlobals();
  });

  it('should fetch diagnostics', async () => {
    const deviceRegistryManager = mock<DeviceRegistryManager>();
    deviceRegistryManager.getMatchingDevices.mockResolvedValue([
      createRegistryDevice({
        id: 'id1',
        model: '4.0.0/0.13.0-aded314',
        config_entries: ['ac4e79d258449a83bc0cf6d47a021c46'],
      }),
      createRegistryDevice({
        id: 'id2',
        model: '4.0.0/0.13.0-aded314',
        config_entries: ['b03e70c659d58ae2ce7f2dc76fed2929'],
      }),
      createRegistryDevice({
        id: 'no-model',
        model: null,
        config_entries: ['b03e70c659d58ae2ce7f2dc76fed2920'],
      }),
    ]);

    vi.mocked(homeAssistantWSRequest).mockResolvedValue({
      domain: 'domain',
      version: '0.0.1',
    });

    expect(
      await getDiagnostics(hass, deviceRegistryManager, {
        cameras: [{ camera_entity: 'camera.office' }],
      }),
    ).toEqual({
      browser: 'AdvancedCameraCardTest/1.0',
      card_version: '__ADVANCED_CAMERA_CARD_RELEASE_VERSION__',
      config: {
        cameras: [{ camera_entity: 'camera.office' }],
      },
      git: {
        build_date: 'Tue, 19 Sep 2023 04:59:27 GMT',
        commit_date: 'Wed, 6 Sep 2023 21:27:28 -0700',
        hash: 'g4cf13b1',
      },
      custom_integrations: {
        frigate: {
          detected: true,
          devices: {
            ac4e79d258449a83bc0cf6d47a021c46: '4.0.0/0.13.0-aded314',
            b03e70c659d58ae2ce7f2dc76fed2929: '4.0.0/0.13.0-aded314',
          },
          version: '0.0.1',
        },
        hass_web_proxy: {
          detected: true,
          version: '0.0.1',
        },
      },
      date: now,
      lang: 'en',
      ha_version: '2023.9.0',
      timezone: expect.anything(),
    });
  });

  it('should use correct device registry matcher', async () => {
    const deviceRegistryManager = mock<DeviceRegistryManager>();
    deviceRegistryManager.getMatchingDevices.mockResolvedValue([]);

    await getDiagnostics(hass, deviceRegistryManager, {
      cameras: [{ camera_entity: 'camera.office' }],
    });

    // Verify the matcher passed into the deviceRegistryManager correctly filters
    // Frigate cameras.
    const matcher = deviceRegistryManager.getMatchingDevices.mock.calls[0][1];
    expect(matcher(createRegistryDevice())).toBe(false);
    expect(
      matcher(
        createRegistryDevice({
          manufacturer: 'Frigate',
        }),
      ),
    ).toBe(true);
  });

  it('should fetch diagnostics without hass or config', async () => {
    expect(await getDiagnostics()).toEqual({
      browser: 'AdvancedCameraCardTest/1.0',
      card_version: '__ADVANCED_CAMERA_CARD_RELEASE_VERSION__',
      git: {
        build_date: 'Tue, 19 Sep 2023 04:59:27 GMT',
        commit_date: 'Wed, 6 Sep 2023 21:27:28 -0700',
        hash: 'g4cf13b1',
      },
      custom_integrations: {
        frigate: {
          detected: false,
        },
        hass_web_proxy: {
          detected: false,
        },
      },
      date: now,
      lang: 'en',
      timezone: expect.anything(),
    });
  });

  it('should fetch diagnostics without device model', async () => {
    const deviceRegistryManager = mock<DeviceRegistryManager>();
    deviceRegistryManager.getMatchingDevices.mockResolvedValue([]);

    expect(await getDiagnostics(hass, deviceRegistryManager)).toEqual({
      browser: 'AdvancedCameraCardTest/1.0',
      card_version: '__ADVANCED_CAMERA_CARD_RELEASE_VERSION__',
      git: {
        build_date: 'Tue, 19 Sep 2023 04:59:27 GMT',
        commit_date: 'Wed, 6 Sep 2023 21:27:28 -0700',
        hash: 'g4cf13b1',
      },
      custom_integrations: {
        frigate: {
          detected: false,
        },
        hass_web_proxy: {
          detected: false,
        },
      },
      ha_version: '2023.9.0',
      date: now,
      lang: 'en',
      timezone: expect.anything(),
    });
  });
});



================================================
FILE: tests/utils/download.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { downloadURL } from '../../src/utils/download';

// @vitest-environment jsdom
describe('downloadURL', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should download same origin via link', () => {
    const location: Location & { origin: string } = mock<Location>();
    location.origin = 'http://foo';

    vi.spyOn(window, 'location', 'get').mockReturnValue(location);

    const link = document.createElement('a');
    link.click = vi.fn();
    link.setAttribute = vi.fn();
    vi.spyOn(document, 'createElement').mockReturnValue(link);

    downloadURL('http://foo/url.mp4');

    expect(link.href).toBe('http://foo/url.mp4');
    expect(link.setAttribute).toBeCalledWith('download', 'download');
    expect(link.click).toBeCalled();
  });

  it('should download data URL via link', () => {
    const link = document.createElement('a');
    link.click = vi.fn();
    link.setAttribute = vi.fn();
    vi.spyOn(document, 'createElement').mockReturnValue(link);

    downloadURL('data:text/plain;charset=utf-8;base64,VEhJUyBJUyBEQVRB');

    expect(link.href).toBe('data:text/plain;charset=utf-8;base64,VEhJUyBJUyBEQVRB');
    expect(link.setAttribute).toBeCalledWith('download', 'download');
    expect(link.click).toBeCalled();
  });

  it('should download different origin via window.open', () => {
    // Set the origin to the same.
    const location: Location & { origin: string } = mock<Location>();
    location.origin = 'http://foo';

    vi.spyOn(window, 'location', 'get').mockReturnValue(location);

    const windowSpy = vi.spyOn(window, 'open').mockReturnValue(null);

    downloadURL('http://bar/url.mp4');
    expect(windowSpy).toBeCalledWith('http://bar/url.mp4', '_blank');
  });
});



================================================
FILE: tests/utils/endpoint.test.ts
================================================
import { afterEach, describe, expect, it, vi } from 'vitest';
import { homeAssistantSignPath } from '../../src/ha/sign-path.js';
import { convertEndpointAddressToSignedWebsocket } from '../../src/utils/endpoint';
import { createHASS } from '../test-utils';

vi.mock('../../src/ha/sign-path.js');

describe('convertEndpointAddressToSignedWebsocket', () => {
  it('without signing', async () => {
    expect(
      await convertEndpointAddressToSignedWebsocket(createHASS(), {
        endpoint: 'http://example.com',
        sign: false,
      }),
    ).toBe('http://example.com');
  });

  describe('with signing', () => {
    afterEach(() => {
      vi.clearAllMocks();
    });

    it('successful', async () => {
      vi.mocked(homeAssistantSignPath).mockResolvedValue('http://signed.com');

      expect(
        await convertEndpointAddressToSignedWebsocket(createHASS(), {
          endpoint: 'http://example.com',
          sign: true,
        }),
      ).toBe('ws://signed.com');
    });

    it('with null response', async () => {
      vi.mocked(homeAssistantSignPath).mockResolvedValue(null);

      expect(
        await convertEndpointAddressToSignedWebsocket(createHASS(), {
          endpoint: 'http://example.com',
          sign: true,
        }),
      ).toBeNull();
    });

    it('with exception on signing', async () => {
      const consoleSpy = vi.spyOn(global.console, 'warn').mockReturnValue(undefined);

      vi.mocked(homeAssistantSignPath).mockRejectedValue(new Error());

      expect(
        await convertEndpointAddressToSignedWebsocket(createHASS(), {
          endpoint: 'http://example.com',
          sign: true,
        }),
      ).toBeNull();

      expect(consoleSpy).toBeCalled();
    });
  });
});



================================================
FILE: tests/utils/fire-advanced-camera-card-event.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { fireAdvancedCameraCardEvent } from '../../src/utils/fire-advanced-camera-card-event.js';

// @vitest-environment jsdom
describe('fireAdvancedCameraCardEvent', () => {
  it('should fire event without data', () => {
    const element = document.createElement('div');
    const handler = vi.fn();
    element.addEventListener('advanced-camera-card:foo', handler);

    fireAdvancedCameraCardEvent(element, 'foo');
    expect(handler).toBeCalled();
  });

  it('should fire event with data', () => {
    const element = document.createElement('div');
    const data = { bar: 2 };
    const handler = vi.fn((ev) => {
      expect(ev.detail).toBe(data);
    });

    element.addEventListener('advanced-camera-card:foo', handler);
    fireAdvancedCameraCardEvent(element, 'foo', data);
    expect(handler).toBeCalled();
  });
});



================================================
FILE: tests/utils/initializer.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { Initializer } from '../../src/utils/initializer/initializer';

describe('Initializer', () => {
  it('should initialize with initializer', async () => {
    const initializer = new Initializer();

    expect(initializer.isInitialized('foo')).toBeFalsy();
    expect(
      await initializer.initializeIfNecessary('foo', async () => true),
    ).toBeTruthy();
    expect(initializer.isInitialized('foo')).toBeTruthy();
  });

  it('should initialize without initializer', async () => {
    const initializer = new Initializer();

    expect(initializer.isInitialized('foo')).toBeFalsy();
    expect(
      await initializer.initializeIfNecessary('foo', async () => true),
    ).toBeTruthy();
    expect(initializer.isInitialized('foo')).toBeTruthy();
  });

  it('should initialize when already initialized', async () => {
    const initializer = new Initializer();

    expect(initializer.isInitialized('foo')).toBeFalsy();
    expect(
      await initializer.initializeIfNecessary('foo', async () => true),
    ).toBeTruthy();
    expect(
      await initializer.initializeIfNecessary('foo', async () => true),
    ).toBeTruthy();
    expect(initializer.isInitialized('foo')).toBeTruthy();
  });

  it('should not initialize with failed initializer', async () => {
    const initializer = new Initializer();

    expect(initializer.isInitialized('foo')).toBeFalsy();
    expect(
      await initializer.initializeIfNecessary('foo', async () => false),
    ).toBeFalsy();
    expect(initializer.isInitialized('foo')).toBeFalsy();
  });

  it('should initialize multiple', async () => {
    const initializer = new Initializer();

    expect(initializer.isInitializedMultiple(['foo', 'bar'])).toBeFalsy();
    expect(
      await initializer.initializeMultipleIfNecessary({
        foo: async () => true,
        bar: async () => false,
      }),
    ).toBeFalsy();

    expect(initializer.isInitializedMultiple(['foo', 'bar'])).toBeFalsy();

    expect(
      await initializer.initializeMultipleIfNecessary({
        bar: async () => true,
      }),
    ).toBeTruthy();

    expect(initializer.isInitializedMultiple(['foo', 'bar'])).toBeTruthy();
  });

  it('should uninitialize', async () => {
    const initializer = new Initializer();
    await initializer.initializeIfNecessary('foo');
    expect(initializer.isInitialized('foo')).toBeTruthy();

    initializer.uninitialize('foo');

    expect(initializer.isInitialized('foo')).toBeFalsy();
  });
});



================================================
FILE: tests/utils/interaction-mode.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { isActionAllowedBasedOnInteractionState } from '../../src/utils/interaction-mode';

describe('isActionAllowedBasedOnInteractionState', () => {
  it('should handle interactionMode: all', () => {
    expect(isActionAllowedBasedOnInteractionState('all', true)).toBeTruthy();
    expect(isActionAllowedBasedOnInteractionState('all', false)).toBeTruthy();
  });

  it('should handle interactionMode: active', () => {
    expect(isActionAllowedBasedOnInteractionState('active', true)).toBeTruthy();
    expect(isActionAllowedBasedOnInteractionState('active', false)).toBeFalsy();
  });

  it('should handle interactionMode: inactive', () => {
    expect(isActionAllowedBasedOnInteractionState('inactive', true)).toBeFalsy();
    expect(isActionAllowedBasedOnInteractionState('inactive', false)).toBeTruthy();
  });
});



================================================
FILE: tests/utils/media-info.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import { AdvancedCameraCardMediaPlayer, MediaLoadedCapabilities } from '../../src/types';
import {
  createMediaLoadedInfo,
  dispatchExistingMediaLoadedInfoAsEvent,
  dispatchMediaLoadedEvent,
  dispatchMediaPauseEvent,
  dispatchMediaPlayEvent,
  dispatchMediaUnloadedEvent,
  dispatchMediaVolumeChangeEvent,
  isValidMediaLoadedInfo,
} from '../../src/utils/media-info';
import { createMediaLoadedInfo as createTestMediaLoadedInfo } from '../test-utils.js';

const options = {
  player: mock<AdvancedCameraCardMediaPlayer>(),
  capabilities: mock<MediaLoadedCapabilities>(),
};

// @vitest-environment jsdom
describe('createMediaLoadedInfo', () => {
  it('should create from image', () => {
    const img = document.createElement('img');

    // Need to write readonly properties.
    Object.defineProperty(img, 'naturalWidth', { value: 10 });
    Object.defineProperty(img, 'naturalHeight', { value: 20 });

    expect(createMediaLoadedInfo(img, options)).toEqual({
      width: 10,
      height: 20,
      ...options,
    });
  });

  it('should create from video', () => {
    const video = document.createElement('video');

    // Need to write readonly properties.
    Object.defineProperty(video, 'videoWidth', { value: 30 });
    Object.defineProperty(video, 'videoHeight', { value: 40 });

    expect(createMediaLoadedInfo(video, options)).toEqual({
      width: 30,
      height: 40,
      ...options,
    });
  });

  it('should create from canvas', () => {
    const canvas = document.createElement('canvas');
    canvas.width = 50;
    canvas.height = 60;

    expect(createMediaLoadedInfo(canvas, options)).toEqual({
      width: 50,
      height: 60,
      ...options,
    });
  });

  it('should not create from unknown', () => {
    const div = document.createElement('div');
    expect(createMediaLoadedInfo(div, options)).toBeNull();
  });

  it('should create from event', () => {
    const img = document.createElement('img');

    // Need to write readonly properties.
    Object.defineProperty(img, 'naturalWidth', { value: 70 });
    Object.defineProperty(img, 'naturalHeight', { value: 80 });

    const event = new Event('foo');
    Object.defineProperty(event, 'composedPath', { value: () => [img] });

    expect(createMediaLoadedInfo(event, options)).toEqual({
      width: 70,
      height: 80,
      ...options,
    });
  });
});

// @vitest-environment jsdom
describe('dispatchMediaLoadedEvent', () => {
  const options = {
    player: mock<AdvancedCameraCardMediaPlayer>(),
    capabilities: mock<MediaLoadedCapabilities>(),
  };

  it('should dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:loaded', handler);

    // Need to write readonly properties.
    const img = document.createElement('img');
    Object.defineProperty(img, 'naturalWidth', { value: 10 });
    Object.defineProperty(img, 'naturalHeight', { value: 20 });

    dispatchMediaLoadedEvent(div, img, options);
    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: {
          width: 10,
          height: 20,
          ...options,
        },
      }),
    );
  });

  it('should not dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:loaded', handler);

    dispatchMediaLoadedEvent(div, div, options);
    expect(handler).not.toBeCalled();
  });
});

// @vitest-environment jsdom
describe('dispatchExistingMediaLoadedInfoAsEvent', () => {
  it('should dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:loaded', handler);
    const info = createTestMediaLoadedInfo();

    dispatchExistingMediaLoadedInfoAsEvent(div, info);
    expect(handler).toBeCalledWith(
      expect.objectContaining({
        detail: info,
      }),
    );
  });
});

// @vitest-environment jsdom
describe('dispatchMediaUnloadedEvent', () => {
  it('should dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:unloaded', handler);

    dispatchMediaUnloadedEvent(div);
    expect(handler).toBeCalled();
  });
});

// @vitest-environment jsdom
describe('dispatchMediaVolumeChangeEvent', () => {
  it('should dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:volumechange', handler);

    dispatchMediaVolumeChangeEvent(div);
    expect(handler).toBeCalled();
  });
});

// @vitest-environment jsdom
describe('dispatchMediaPlayEvent', () => {
  it('should dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:play', handler);

    dispatchMediaPlayEvent(div);
    expect(handler).toBeCalled();
  });
});

// @vitest-environment jsdom
describe('dispatchMediaPauseEvent', () => {
  it('should dispatch', () => {
    const handler = vi.fn();
    const div = document.createElement('div');
    div.addEventListener('advanced-camera-card:media:pause', handler);

    dispatchMediaPauseEvent(div);
    expect(handler).toBeCalled();
  });
});

// @vitest-environment jsdom
describe('isValidMediaLoadedInfo', () => {
  it('should be valid with correct dimensions', () => {
    expect(
      isValidMediaLoadedInfo(createTestMediaLoadedInfo({ width: 100, height: 100 })),
    ).toBeTruthy();
  });
  it('should be invalid with unlikely dimensions', () => {
    expect(
      isValidMediaLoadedInfo(createTestMediaLoadedInfo({ width: 0, height: 0 })),
    ).toBeFalsy();
  });
});



================================================
FILE: tests/utils/media-layout.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { updateElementStyleFromMediaLayoutConfig } from '../../src/utils/media-layout.js';

// @vitest-environment jsdom
describe('updateElementStyleFromMediaLayoutConfig', () => {
  describe('fit', () => {
    it('set', () => {
      const video = document.createElement('video');

      updateElementStyleFromMediaLayoutConfig(video, {
        fit: 'cover',
      });

      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-fit'),
      ).toBe('cover');
    });

    it('unset', () => {
      const video = document.createElement('video');
      video.style.setProperty('--advanced-camera-card-media-layout-fit', 'cover');

      updateElementStyleFromMediaLayoutConfig(video);

      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-fit'),
      ).toBeFalsy();
    });
  });

  describe('position', () => {
    it('set', () => {
      const video = document.createElement('video');

      updateElementStyleFromMediaLayoutConfig(video, {
        position: {
          x: 10,
          y: 20,
        },
      });

      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-position-x'),
      ).toBe('10%');
      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-position-y'),
      ).toBe('20%');
    });

    it('unset', () => {
      const video = document.createElement('video');
      video.style.setProperty('--advanced-camera-card-media-layout-position-x', '10%');
      video.style.setProperty('--advanced-camera-card-media-layout-position-y', '20%');

      updateElementStyleFromMediaLayoutConfig(video);

      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-position-x'),
      ).toBeFalsy();
      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-position-y'),
      ).toBeFalsy();
    });
  });

  describe('view_box', () => {
    it('set', () => {
      const video = document.createElement('video');

      updateElementStyleFromMediaLayoutConfig(video, {
        view_box: {
          top: 1,
          bottom: 2,
          left: 3,
          right: 4,
        },
      });

      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-view-box-top'),
      ).toBe('1%');
      expect(
        video.style.getPropertyValue(
          '--advanced-camera-card-media-layout-view-box-bottom',
        ),
      ).toBe('2%');
      expect(
        video.style.getPropertyValue(
          '--advanced-camera-card-media-layout-view-box-left',
        ),
      ).toBe('3%');
      expect(
        video.style.getPropertyValue(
          '--advanced-camera-card-media-layout-view-box-right',
        ),
      ).toBe('4%');
    });

    it('unset', () => {
      const video = document.createElement('video');
      video.style.setProperty('--advanced-camera-card-media-layout-view-box-top', '1%');
      video.style.setProperty(
        '--advanced-camera-card-media-layout-view-box-bottom',
        '2%',
      );
      video.style.setProperty('--advanced-camera-card-media-layout-view-box-left', '3%');
      video.style.setProperty(
        '--advanced-camera-card-media-layout-view-box-right',
        '4%',
      );

      updateElementStyleFromMediaLayoutConfig(video);

      expect(
        video.style.getPropertyValue('--advanced-camera-card-media-layout-view-box-top'),
      ).toBeFalsy();
      expect(
        video.style.getPropertyValue(
          '--advanced-camera-card-media-layout-view-box-bottom',
        ),
      ).toBeFalsy();
      expect(
        video.style.getPropertyValue(
          '--advanced-camera-card-media-layout-view-box-left',
        ),
      ).toBeFalsy();
      expect(
        video.style.getPropertyValue(
          '--advanced-camera-card-media-layout-view-box-right',
        ),
      ).toBeFalsy();
    });
  });
});



================================================
FILE: tests/utils/ptz.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { Capabilities } from '../../src/camera-manager/capabilities';
import { AdvancedCameraCardView } from '../../src/config/schema/common/const';
import { IMAGE_VIEW_ZOOM_TARGET_SENTINEL } from '../../src/const';
import {
  getPTZTarget,
  hasCameraTruePTZ,
  ptzActionToCapabilityKey,
} from '../../src/utils/ptz';
import { QueryResults } from '../../src/view/query-results';
import {
  TestViewMedia,
  createCameraManager,
  createStore,
  createView,
} from '../test-utils';

describe('getPTZTarget', () => {
  describe('in a viewer view', () => {
    it('with media', () => {
      const media = [new TestViewMedia({ id: 'media-id' })];
      const view = createView({
        view: 'media',
        queryResults: new QueryResults({ results: media, selectedIndex: 0 }),
      });
      expect(getPTZTarget(view, { cameraManager: createCameraManager() })).toEqual({
        targetID: 'media-id',
        type: 'digital',
      });
    });

    it('without media', () => {
      const view = createView({
        view: 'media',
      });
      expect(getPTZTarget(view, { cameraManager: createCameraManager() })).toBeNull();
    });

    it('with true PTZ restriction', () => {
      const media = [new TestViewMedia({ id: 'media-id' })];
      const view = createView({
        view: 'media',
        queryResults: new QueryResults({ results: media, selectedIndex: 0 }),
      });
      expect(
        getPTZTarget(view, { type: 'ptz', cameraManager: createCameraManager() }),
      ).toBeNull();
    });
  });

  it('in image view', () => {
    expect(getPTZTarget(createView({ view: 'image' }))).toEqual({
      targetID: IMAGE_VIEW_ZOOM_TARGET_SENTINEL,
      type: 'digital',
    });
  });

  describe('in live view', () => {
    it('without restriction with true PTZ capability', () => {
      const view = createView({
        view: 'live',
        camera: 'camera-1',
      });
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: ['relative'] } }),
        },
      ]);

      expect(getPTZTarget(view, { cameraManager: createCameraManager(store) })).toEqual({
        targetID: 'camera-1',
        type: 'ptz',
      });
    });

    it('without restriction without true PTZ capability', () => {
      const view = createView({
        view: 'live',
        camera: 'camera-1',
      });

      expect(getPTZTarget(view, { cameraManager: createCameraManager() })).toEqual({
        targetID: 'camera-1',
        type: 'digital',
      });
    });

    it('with truePTZ restriction without true PTZ capability', () => {
      const view = createView({
        view: 'live',
        camera: 'camera-1',
      });

      expect(
        getPTZTarget(view, { type: 'ptz', cameraManager: createCameraManager() }),
      ).toBeNull();
    });

    it('with digitalPTZ restriction with true PTZ capability', () => {
      const view = createView({
        view: 'live',
        camera: 'camera-1',
      });
      const store = createStore([
        {
          cameraID: 'camera-1',
          capabilities: new Capabilities({ ptz: { left: ['relative'] } }),
        },
      ]);

      expect(
        getPTZTarget(view, {
          type: 'digital',
          cameraManager: createCameraManager(store),
        }),
      ).toEqual({
        targetID: 'camera-1',
        type: 'digital',
      });
    });
  });

  describe('in non-media views', () => {
    it.each([['timeline' as const], ['diagnostics' as const]])(
      '%s',
      (viewName: AdvancedCameraCardView) => {
        const view = createView({
          view: viewName,
        });
        expect(getPTZTarget(view, { cameraManager: createCameraManager() })).toBeNull();
      },
    );
  });
});

describe('hasCameraTruePTZ', () => {
  it('with true PTZ', () => {
    const store = createStore([
      {
        cameraID: 'camera-1',
        capabilities: new Capabilities({ ptz: { left: ['relative'] } }),
      },
    ]);

    expect(hasCameraTruePTZ(createCameraManager(store), 'camera-1')).toBeTruthy();
  });

  it('without true PTZ', () => {
    expect(hasCameraTruePTZ(createCameraManager(createStore()), 'camera-1')).toBeFalsy();
  });
});

it('ptzActionToCapabilityKey', () => {
  expect(ptzActionToCapabilityKey('left')).toBe('left');
  expect(ptzActionToCapabilityKey('right')).toBe('right');
  expect(ptzActionToCapabilityKey('up')).toBe('up');
  expect(ptzActionToCapabilityKey('down')).toBe('down');
  expect(ptzActionToCapabilityKey('zoom_in')).toBe('zoomIn');
  expect(ptzActionToCapabilityKey('zoom_out')).toBe('zoomOut');
  expect(ptzActionToCapabilityKey('preset')).toBeNull();
});



================================================
FILE: tests/utils/regexp-extract.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { regexpExtract } from '../../src/utils/regexp-extract';

describe('regexpExtract', () => {
  it('returns null if no match is found', () => {
    expect(regexpExtract(/foo/, 'bar')).toBeNull();
  });

  it('returns the full match if no group is specified', () => {
    expect(regexpExtract(/foo/, 'foo bar')).toBe('foo');
  });

  it('returns the named group if groupName is specified', () => {
    const pattern = /(?<first>\w+)\s(?<second>\w+)/;
    expect(regexpExtract(pattern, 'hello world', { groupName: 'first' })).toBe('hello');
    expect(regexpExtract(pattern, 'hello world', { groupName: 'second' })).toBe('world');
  });

  it('returns the numbered group if groupNumber is specified', () => {
    expect(regexpExtract(/(\d+)-(\w+)/, '123-abc', { groupNumber: 1 })).toBe('123');
    expect(regexpExtract(/(\d+)-(\w+)/, '123-abc', { groupNumber: 2 })).toBe('abc');
  });

  it('returns full match if groupName does not exist', () => {
    expect(regexpExtract(/(?<foo>\w+)/, 'bar', { groupName: 'baz' })).toBe('bar');
  });

  it('returns full match if groupNumber does not exist', () => {
    expect(regexpExtract(/(\d+)/, '123', { groupNumber: 2 })).toBe('123');
  });

  it('works with string pattern', () => {
    expect(regexpExtract('(foo)', 'foo bar', { groupNumber: 1 })).toBe('foo');
  });

  it('prefers groupName over groupNumber if both are provided', () => {
    const pattern = /(?<word>\w+)\s(\w+)/;
    expect(
      regexpExtract(pattern, 'hello world', { groupName: 'word', groupNumber: 2 }),
    ).toBe('hello');
  });

  it('returns null if match exists but group is undefined', () => {
    expect(regexpExtract(/foo(bar)?/, 'foo', { groupNumber: 1 })).toBe('foo');
  });
});



================================================
FILE: tests/utils/screenshot.test.ts
================================================
import { afterAll, afterEach, beforeAll, describe, expect, it, vi } from 'vitest';
import { mock } from 'vitest-mock-extended';
import {
  generateScreenshotFilename,
  screenshotImage,
  screenshotVideo,
} from '../../src/utils/screenshot';
import { QueryResults } from '../../src/view/query-results';
import { View } from '../../src/view/view';
import { TestViewMedia, createView } from '../test-utils';

// @vitest-environment jsdom
describe('screenshotVideo', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should not screenshot without context', () => {
    const video = document.createElement('video');

    const canvas = document.createElement('canvas');
    const getContext = vi.fn().mockReturnValue(null);
    canvas.getContext = getContext;
    vi.spyOn(document, 'createElement').mockReturnValue(canvas);

    expect(screenshotVideo(video)).toBeNull();
  });

  it('should screenshot', () => {
    const video = document.createElement('video');

    const canvas = document.createElement('canvas');
    const getContext = vi.fn().mockReturnValue(mock<CanvasRenderingContext2D>());
    canvas.getContext = getContext;
    canvas.toDataURL = vi.fn().mockReturnValue('data:image/jpeg;base64');
    vi.spyOn(document, 'createElement').mockReturnValue(canvas);

    expect(screenshotVideo(video)).toBe('data:image/jpeg;base64');
  });
});

describe('screenshotImage', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should not screenshot without context', () => {
    const image = document.createElement('img');

    const canvas = document.createElement('canvas');
    const getContext = vi.fn().mockReturnValue(null);
    canvas.getContext = getContext;
    vi.spyOn(document, 'createElement').mockReturnValue(canvas);

    expect(screenshotImage(image)).toBeNull();
  });

  it('should screenshot', () => {
    const image = document.createElement('img');

    const canvas = document.createElement('canvas');
    const getContext = vi.fn().mockReturnValue(mock<CanvasRenderingContext2D>());
    canvas.getContext = getContext;
    canvas.toDataURL = vi.fn().mockReturnValue('data:image/jpeg;base64');
    vi.spyOn(document, 'createElement').mockReturnValue(canvas);

    expect(screenshotImage(image)).toBe('data:image/jpeg;base64');
  });
});

describe('generateScreenshotTitle', () => {
  beforeAll(() => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2023-06-13T21:54:01'));
  });

  afterAll(() => {
    vi.useRealTimers();
  });

  it('should get title without view', () => {
    expect(generateScreenshotFilename()).toBe('screenshot.jpg');
  });

  it('should get title for live view', () => {
    expect(
      generateScreenshotFilename(new View({ view: 'live', camera: 'camera-1' })),
    ).toBe('live_camera-1_2023-06-13-21-54-01.jpg');
  });

  it('should get title for image view', () => {
    expect(
      generateScreenshotFilename(new View({ view: 'image', camera: 'camera-1' })),
    ).toBe('image_camera-1_2023-06-13-21-54-01.jpg');
  });

  it('should get title for media viewer view with id', () => {
    const media = new TestViewMedia({
      id: 'id1',
      startTime: new Date('2023-06-16T18:52'),
      cameraID: 'camera-1',
    });
    const view = createView({
      view: 'media',
      camera: 'camera-1',
      queryResults: new QueryResults({ results: [media], selectedIndex: 0 }),
    });

    expect(generateScreenshotFilename(view)).toBe('media_camera-1_id1.jpg');
  });

  it('should get title for media viewer view without id', () => {
    const media = new TestViewMedia({
      id: null,
      startTime: new Date('2023-06-16T18:52'),
      cameraID: 'camera-1',
    });
    const view = createView({
      view: 'media',
      camera: 'camera-1',
      queryResults: new QueryResults({ results: [media], selectedIndex: 0 }),
    });

    expect(generateScreenshotFilename(view)).toBe('media_camera-1.jpg');
  });
});



================================================
FILE: tests/utils/scroll.test.ts
================================================
import { compute as computeScroll } from 'compute-scroll-into-view';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { scrollIntoView } from '../../src/utils/scroll';

vi.mock('compute-scroll-into-view');

// @vitest-environment jsdom
describe('scrollIntoView', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should call computeScroll with the correct arguments', () => {
    const element = document.createElement('div');
    vi.mocked(computeScroll).mockReturnValue([
      {
        el: element,
        top: 42,
        left: 142,
      },
    ]);
    const options = { block: 'start' as const, inline: 'nearest' as const };

    expect(element.scrollTop).toBe(0);
    expect(element.scrollLeft).toBe(0);

    scrollIntoView(element, options);

    expect(computeScroll).toBeCalledWith(element, options);
    expect(element.scrollTop).toBe(42);
    expect(element.scrollLeft).toBe(142);
  });
});



================================================
FILE: tests/utils/sleep.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { sleep } from '../../src/utils/sleep';

describe('sleep', () => {
  it('should sleep', async () => {
    const spy = vi
      .spyOn(global, 'setTimeout')
      // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
      .mockImplementation((func: () => unknown, _time?: number): any => {
        func();
      });
    sleep(10);
    expect(spy).toHaveBeenCalledWith(expect.anything(), 10000);
  });
});



================================================
FILE: tests/utils/substream.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  getStreamCameraID,
  hasSubstream,
  removeSubstream,
} from '../../src/utils/substream';
import { View } from '../../src/view/view';
import { createView } from '../test-utils';

describe('hasSubstream/getStreamCameraID', () => {
  it('should detect substream', () => {
    const view = createView({
      camera: 'camera',
      context: {
        live: {
          overrides: new Map([['camera', 'camera2']]),
        },
      },
    });
    expect(hasSubstream(view)).toBeTruthy();
    expect(getStreamCameraID(view)).toBe('camera2');
  });
  it('should not detect substream when absent', () => {
    const view = createView({
      camera: 'camera',
    });
    expect(hasSubstream(view)).toBeFalsy();
    expect(getStreamCameraID(view)).toBe('camera');
  });
  it('should not detect substream when main stream', () => {
    const view = createView({
      camera: 'camera',
      context: {
        live: {
          overrides: new Map([['camera', 'camera']]),
        },
      },
    });
    expect(hasSubstream(view)).toBeFalsy();
    expect(getStreamCameraID(view)).toBe('camera');
  });
  describe('should respect cameraID override', () => {
    it('should respect cameraID override when present in overrides', () => {
      const view = createView({
        camera: 'camera',
        context: {
          live: {
            overrides: new Map([
              ['camera', 'camera2'],
              ['camera3', 'camera4'],
            ]),
          },
        },
      });
      expect(hasSubstream(view)).toBeTruthy();
      expect(getStreamCameraID(view, 'camera3')).toBe('camera4');
    });

    it('should respect cameraID override when not present in overrides', () => {
      const view = createView();
      expect(hasSubstream(view)).toBeFalsy();
      expect(getStreamCameraID(view, 'camera3')).toBe('camera3');
    });
  });
});

describe('removeSubstream', () => {
  it('should remove substream that exists', () => {
    const view = new View({
      view: 'live',
      camera: 'camera',
      context: {
        live: {
          overrides: new Map([['camera', 'camera2']]),
        },
      },
    });
    removeSubstream(view);
    expect(view.context).toEqual({
      live: {
        overrides: new Map(),
      },
    });
  });

  it('should not remove substream that does not exists', () => {
    const view = new View({
      view: 'live',
      camera: 'camera-has-no-overrides',
      context: {
        live: {
          overrides: new Map([['camera', 'camera2']]),
        },
      },
    });
    removeSubstream(view);
    expect(view.context).toEqual({
      live: {
        overrides: new Map([['camera', 'camera2']]),
      },
    });
  });
});



================================================
FILE: tests/utils/text-direction.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getTextDirection } from '../../src/utils/text-direction.js';

// @vitest-environment jsdom
describe('getTextDirection', () => {
  it('should return rtl', () => {
    const element = document.createElement('div');
    element.style.direction = 'rtl';

    expect(getTextDirection(element)).toBe('rtl');
  });

  it('should return ltr', () => {
    const element = document.createElement('div');
    element.style.direction = 'ltr';

    expect(getTextDirection(element)).toBe('ltr');
  });

  it('should return ltr by default', () => {
    const element = document.createElement('div');
    element.style.direction = '_ANYTHING_ELSE_';

    expect(getTextDirection(element)).toBe('ltr');
  });
});



================================================
FILE: tests/utils/timer.test.ts
================================================
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { Timer } from '../../src/utils/timer';

// @vitest-environment jsdom
describe('Timer', () => {
  beforeAll(() => {
    vi.useFakeTimers();
  });

  afterAll(() => {
    vi.useRealTimers();
  });

  it('should not be running on construct', () => {
    const timer = new Timer();
    expect(timer.isRunning()).toBeFalsy();
  });

  it('should fire when started', () => {
    const timer = new Timer();
    const handler = vi.fn();
    timer.start(10, handler);

    expect(timer.isRunning()).toBeTruthy();
    expect(handler).not.toBeCalled();

    vi.runOnlyPendingTimers();

    expect(timer.isRunning()).toBeFalsy();
    expect(handler).toBeCalled();
  });

  it('should not fire when stopped', () => {
    const timer = new Timer();
    const handler = vi.fn();
    timer.start(10, handler);

    expect(timer.isRunning()).toBeTruthy();
    expect(handler).not.toBeCalled();

    timer.stop();

    vi.runOnlyPendingTimers();

    expect(timer.isRunning()).toBeFalsy();
    expect(handler).not.toBeCalled();
  });

  it('should fire repeatedly when started', () => {
    const timer = new Timer();
    const handler = vi.fn();
    timer.startRepeated(10, handler);

    expect(timer.isRunning()).toBeTruthy();
    expect(handler).not.toBeCalled();

    vi.runOnlyPendingTimers();

    expect(timer.isRunning()).toBeTruthy();
    expect(handler).toBeCalledTimes(1);

    vi.runOnlyPendingTimers();

    expect(timer.isRunning()).toBeTruthy();
    expect(handler).toBeCalledTimes(2);
  });

  it('should not fire repeatedly when stopped', () => {
    const timer = new Timer();
    const handler = vi.fn();
    timer.startRepeated(10, handler);

    expect(timer.isRunning()).toBeTruthy();
    expect(handler).not.toBeCalled();

    timer.stop();

    vi.runOnlyPendingTimers();

    expect(timer.isRunning()).toBeFalsy();
    expect(handler).not.toBeCalled();
  });
});



================================================
FILE: tests/utils/zod.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { z, ZodError } from 'zod';
import {
  deepRemoveDefaults,
  getParseErrorKeys,
  getParseErrorPaths,
} from '../../src/utils/zod';

describe('deepRemoveDefaults', () => {
  it('should remove string defaults', () => {
    const schema = z.object({
      string: z.string().default('foo'),
    });
    const result = deepRemoveDefaults(schema).parse({});
    expect(result.string).toBeUndefined();
  });
  it('should remove array defaults', () => {
    const schema = z.object({
      array: z.string().array().default(['foo']),
    });
    const result = deepRemoveDefaults(schema).parse({});
    expect(result.array).toBeUndefined();
  });
  it('should remove optional defaults', () => {
    const schema = z.object({
      string: z.string().default('foo').optional(),
    });
    const result = deepRemoveDefaults(schema).parse({});
    expect(result.string).toBeUndefined();
  });
  it('should remove null defaults', () => {
    const schema = z.object({
      null: z.string().default('foo').nullable(),
    });
    const result = deepRemoveDefaults(schema).parse({});
    expect(result.null).toBeUndefined();
  });
  it('should remove null defaults', () => {
    const schema = z.object({
      tuple: z.tuple([z.string()]).default(['foo']),
    });
    const result = deepRemoveDefaults(schema).parse({});
    expect(result.tuple).toBeUndefined();
  });
  it('should not interfere with parsing', () => {
    const schema = z.object({
      string: z.string().default('foo'),
    });
    const result = deepRemoveDefaults(schema).parse({ string: 'moo' });
    expect(result.string).toBe('moo');
  });
  describe('should still enforce array length', () => {
    it('min', () => {
      const schema = z.number().array().min(1);
      const result = deepRemoveDefaults(schema).safeParse([]);
      expect(result.success).toBeFalsy();
    });
    it('max', () => {
      const schema = z.number().array().max(1);
      const result = deepRemoveDefaults(schema).safeParse([1, 2]);
      expect(result.success).toBeFalsy();
    });
    it('exact', () => {
      const schema = z.number().array().length(1);
      const result = deepRemoveDefaults(schema).safeParse([]);
      expect(result.success).toBeFalsy();
    });
  });
});

describe('getParseErrorKeys', () => {
  it('should get error keys', () => {
    const result = z.object({ required: z.string() }).safeParse({});
    expect(result.success).toBeFalsy();
    if (result.success) {
      return;
    }
    expect(getParseErrorKeys(result.error)).toEqual(['required']);
  });
});

describe('getParseErrorPaths', () => {
  it('should get simple error paths', () => {
    const result = z.object({ required: z.string() }).safeParse({});
    expect(result.success).toBeFalsy();
    if (result.success) {
      return;
    }
    expect(getParseErrorPaths(result.error)).toEqual(new Set(['required']));
  });
  it('should get union error paths', () => {
    const type_one = z.object({ type: z.string(), data: z.string() });
    const type_two = z.object({ type: z.literal('two'), data: z.string() });

    const schema = z.object({
      array: type_one.or(type_two).array(),
    });

    const result = schema.safeParse({ array: [{}] });
    expect(result.success).toBeFalsy();
    if (result.success) {
      return;
    }
    expect(getParseErrorPaths(result.error)).toEqual(
      new Set(['array[0] -> type', 'array[0] -> data']),
    );
  });
  it('should get no paths for empty error', () => {
    expect(getParseErrorPaths(new ZodError([]))).toEqual(new Set());
  });
});



================================================
FILE: tests/utils/embla/carousel-controller.test.ts
================================================
import EmblaCarousel, { EmblaCarouselType } from 'embla-carousel';
import { MockedObject, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { CarouselController } from '../../../src/utils/embla/carousel-controller';
import AutoMediaLoadedInfo from '../../../src/utils/embla/plugins/auto-media-loaded-info/auto-media-loaded-info';
import {
  MutationObserverMock,
  callMutationHandler,
  createParent,
  createSlot,
  createSlotHost,
} from '../../test-utils';
import {
  callEmblaHandler,
  createEmblaApiInstance,
  createTestSlideNodes,
} from './test-utils';

vi.mock('embla-carousel', () => ({
  default: vi.fn().mockImplementation(() => {
    return createEmblaApiInstance();
  }),
}));

// Get the nth most recently constructed EmblaAPI instance.
const getEmblaApi = (n = 0): MockedObject<EmblaCarouselType> | null => {
  const constructions = vi.mocked(EmblaCarousel).mock.results;
  const mostRecentResult = constructions[constructions.length - 1 - n] ?? null;
  if (mostRecentResult && mostRecentResult.type === 'return') {
    return vi.mocked(mostRecentResult.value);
  }
  return null;
};

const createRoot = (): HTMLElement => {
  return document.createElement('div');
};

// @vitest-environment jsdom
describe('CarouselController', () => {
  beforeAll(() => {
    vi.stubGlobal('MutationObserver', MutationObserverMock);
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should construct', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    const carousel = new CarouselController(createRoot(), parent);
    expect(carousel).toBeTruthy();
  });

  it('should construct with slot parent', () => {
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: createTestSlideNodes() });
    const carousel = new CarouselController(host, slot);
    expect(carousel).toBeTruthy();
  });

  it('should destroy', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    const carousel = new CarouselController(createRoot(), parent);

    carousel.destroy();

    expect(getEmblaApi()?.destroy).toBeCalled();
  });

  it('should destroy with slot', () => {
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: createTestSlideNodes() });
    const carousel = new CarouselController(host, slot);

    carousel.destroy();

    expect(getEmblaApi()?.destroy).toBeCalled();
  });

  it('should get slide by index', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    const carousel = new CarouselController(createRoot(), parent);

    getEmblaApi()?.slideNodes.mockReturnValue(children);
    expect(carousel.getSlide(2)).toBe(children[2]);
  });

  it('should get slide by index when index is invalid', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    const carousel = new CarouselController(createRoot(), parent);

    expect(carousel.getSlide(1000)).toBeNull();
  });

  it('should get selected slide', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    const carousel = new CarouselController(createRoot(), parent);

    getEmblaApi()?.slideNodes.mockReturnValue(children);
    getEmblaApi()?.selectedScrollSnap.mockReturnValue(3);
    expect(carousel.getSelectedIndex()).toBe(3);
    expect(carousel.getSelectedSlide()).toBe(children[3]);
  });

  it('should select given slide', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });

    const forceSelectListener = vi.fn();
    parent.addEventListener(
      'advanced-camera-card:carousel:force-select',
      forceSelectListener,
    );

    const carousel = new CarouselController(createRoot(), parent);

    carousel.selectSlide(4);

    expect(getEmblaApi()?.scrollTo).toBeCalledWith(4, false);
    expect(forceSelectListener).toBeCalledWith(
      expect.objectContaining({
        detail: { index: 4, element: children[4] },
      }),
    );
  });

  it('should not select non-existent slide', () => {
    const children = createTestSlideNodes({ n: 10 });
    const parent = createParent({ children: children });

    const forceSelectListener = vi.fn();
    parent.addEventListener(
      'advanced-camera-card:carousel:force-select',
      forceSelectListener,
    );

    const carousel = new CarouselController(createRoot(), parent);

    carousel.selectSlide(11);

    expect(getEmblaApi()?.scrollTo).toBeCalledWith(11, false);
    expect(forceSelectListener).not.toBeCalled();
  });

  it('should dispatch select event', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    new CarouselController(createRoot(), parent);

    const selectHandler = vi.fn();
    parent.addEventListener('advanced-camera-card:carousel:select', selectHandler);

    getEmblaApi()?.selectedScrollSnap.mockReturnValue(6);
    getEmblaApi()?.slideNodes.mockReturnValue(children);
    callEmblaHandler(getEmblaApi(), 'select');

    expect(selectHandler).toBeCalledWith(
      expect.objectContaining({
        detail: {
          index: 6,
          element: children[6],
        },
      }),
    );
  });

  it('should not dispatch anything with an invalid scroll snap', () => {
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    new CarouselController(createRoot(), parent);

    const selectHandler = vi.fn();
    parent.addEventListener('advanced-camera-card:carousel:select', selectHandler);

    getEmblaApi()?.selectedScrollSnap.mockReturnValue(1000);
    getEmblaApi()?.slideNodes.mockReturnValue(children);
    callEmblaHandler(getEmblaApi(), 'init');
    callEmblaHandler(getEmblaApi(), 'select');
    callEmblaHandler(getEmblaApi(), 'settle');

    expect(selectHandler).not.toBeCalled();
  });

  it('should honor creation options', () => {
    const children = createTestSlideNodes({ n: 1 });
    const root = createRoot();
    const parent = createParent({ children: children });
    const plugins = [AutoMediaLoadedInfo()];

    new CarouselController(root, parent, {
      direction: 'vertical',
      transitionEffect: 'none',
      startIndex: 7,
      dragFree: true,
      loop: true,
      dragEnabled: false,
      plugins: plugins,
      textDirection: 'rtl',
    });

    expect(EmblaCarousel).toBeCalledWith(
      root,
      {
        slides: children,
        axis: 'y',
        duration: 20,
        startIndex: 7,
        dragFree: true,
        loop: true,
        containScroll: 'trimSnaps',
        watchSlides: false,
        watchResize: true,
        watchDrag: false,
        direction: 'rtl',
      },
      plugins,
    );
  });

  it('should include wheel plugin when slides > 1', () => {
    const children = createTestSlideNodes();
    const root = createRoot();
    const parent = createParent({ children: children });
    new CarouselController(root, parent);

    expect(EmblaCarousel).toBeCalledWith(
      root,
      expect.anything(),
      expect.arrayContaining([
        expect.objectContaining({
          name: 'wheelGestures',
        }),
      ]),
    );
  });

  it('should recreate carousel when children are added', () => {
    const children = createTestSlideNodes();
    const root = createRoot();
    const parent = createParent({ children: children });
    new CarouselController(root, parent);

    expect(EmblaCarousel).toBeCalledTimes(1);

    const originalEmblaApi = getEmblaApi();
    expect(originalEmblaApi).toBeTruthy();

    originalEmblaApi?.slideNodes.mockReturnValue(children);
    parent.appendChild(document.createElement('div'));
    callMutationHandler();

    expect(originalEmblaApi?.destroy).toBeCalled();
    expect(getEmblaApi()).not.toBe(originalEmblaApi);

    expect(EmblaCarousel).toBeCalledTimes(2);
  });

  it('should not recreate carousel when children have not changed', () => {
    const children = createTestSlideNodes();
    const root = createRoot();
    const parent = createParent({ children: children });
    new CarouselController(root, parent);

    expect(EmblaCarousel).toBeCalledTimes(1);

    const originalEmblaApi = getEmblaApi();
    expect(originalEmblaApi).toBeTruthy();

    originalEmblaApi?.slideNodes.mockReturnValue(children);
    callMutationHandler();

    expect(originalEmblaApi?.destroy).not.toBeCalled();
    expect(getEmblaApi()).toBe(originalEmblaApi);

    expect(EmblaCarousel).toBeCalledTimes(1);
  });

  it('should recreate carousel when children are added to slot', () => {
    const children = createTestSlideNodes();
    const slot = createSlot();
    const host = createSlotHost({ slot: slot, children: children });

    new CarouselController(host, slot);

    expect(EmblaCarousel).toBeCalledTimes(1);

    const originalEmblaApi = getEmblaApi();
    expect(originalEmblaApi).toBeTruthy();

    originalEmblaApi?.slideNodes.mockReturnValue(children);

    host.appendChild(document.createElement('div'));
    slot.dispatchEvent(new Event('slotchange'));

    expect(originalEmblaApi?.destroy).toBeCalled();
    expect(getEmblaApi()).not.toBe(originalEmblaApi);

    expect(EmblaCarousel).toBeCalledTimes(2);
  });
});



================================================
FILE: tests/utils/embla/test-utils.ts
================================================
import { EmblaCarouselType, EmblaEventType } from 'embla-carousel';
import { EngineType } from 'embla-carousel/components/Engine';
import { LooseOptionsType } from 'embla-carousel/components/Options';
import { OptionsHandlerType } from 'embla-carousel/components/OptionsHandler';
import { merge } from 'lodash-es';
import { vi } from 'vitest';
import { mock } from 'vitest-mock-extended';

export const createTestEmblaOptionHandler = (): OptionsHandlerType => ({
  mergeOptions: <TypeA extends LooseOptionsType, TypeB extends LooseOptionsType>(
    optionsA: TypeA,
    optionsB?: TypeB,
  ): TypeA => {
    return merge({}, optionsA, optionsB);
  },
  optionsAtMedia: <Type extends LooseOptionsType>(options: Type): Type => {
    return options;
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  optionsMediaQueries: (_optionsList: LooseOptionsType[]): MediaQueryList[] => [],
});

export const callEmblaHandler = (
  emblaApi: EmblaCarouselType | null,
  eventName: EmblaEventType,
): void => {
  if (!emblaApi) {
    return;
  }
  const mock = vi.mocked(emblaApi.on).mock;
  for (const [evt, cb] of mock.calls) {
    if (evt === eventName) {
      cb(emblaApi, evt);
    }
  }
};

export const callResizeHandler = (
  entries: {
    target: HTMLElement;
    width: number;
    height: number;
  }[],
  n = 0,
): void => {
  const mockResult = vi.mocked(ResizeObserver).mock.results[n];
  if (mockResult.type !== 'return') {
    return;
  }
  const observer = mockResult.value;
  vi.mocked(ResizeObserver).mock.calls[n][0](
    // Note this is a very incomplete / invalid ResizeObserverEntry that
    // just provides the bare basics current implementation uses.
    entries.map(
      (entry) =>
        ({
          target: entry.target,
          contentRect: {
            height: entry.height,
            width: entry.width,
          },
        }) as unknown as ResizeObserverEntry,
    ),
    observer,
  );
};

export const createEmblaApiInstance = (options?: {
  slideNodes?: HTMLElement[];
  selectedScrollSnap?: number;
  previousScrollSnap?: number;
  containerNode?: HTMLElement;
  axis?: 'x' | 'y';
  slideRegistry?: number[][];
}): EmblaCarouselType => {
  const emblaApi = mock<EmblaCarouselType>();
  emblaApi.slideNodes.mockReturnValue(options?.slideNodes ?? createTestSlideNodes());
  emblaApi.selectedScrollSnap.mockReturnValue(options?.selectedScrollSnap ?? 0);
  emblaApi.previousScrollSnap.mockReturnValue(options?.previousScrollSnap ?? 0);
  emblaApi.containerNode.mockReturnValue(
    options?.containerNode ?? document.createElement('div'),
  );
  emblaApi.internalEngine.mockReturnValue({
    options: { axis: options?.axis ?? 'x' },
    ...(options?.slideRegistry && { slideRegistry: options.slideRegistry }),
  } as EngineType);
  return emblaApi;
};

export const createTestSlideNodes = (options?: { n?: number }): HTMLElement[] => {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return [...Array(options?.n ?? 10).keys()].map((_) => document.createElement('div'));
};



================================================
FILE: tests/utils/embla/plugins/auto-media-loaded-info/auto-media-loaded-info.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import AutoMediaLoadedInfo from '../../../../../src/utils/embla/plugins/auto-media-loaded-info/auto-media-loaded-info';
import {
  dispatchExistingMediaLoadedInfoAsEvent,
  dispatchMediaUnloadedEvent,
} from '../../../../../src/utils/media-info';
import { createMediaLoadedInfo, createParent } from '../../../../test-utils';
import {
  createEmblaApiInstance,
  createTestEmblaOptionHandler,
  createTestSlideNodes,
} from '../../test-utils';

// @vitest-environment jsdom
describe('AutoMediaLoadedInfo', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should construct', () => {
    const plugin = AutoMediaLoadedInfo();
    expect(plugin.name).toBe('autoMediaLoadedInfo');
  });

  it('should destroy', () => {
    const plugin = AutoMediaLoadedInfo();
    const emblaApi = createEmblaApiInstance();
    plugin.init(emblaApi, createTestEmblaOptionHandler());
    plugin.destroy();

    expect(emblaApi.off).toBeCalledWith('init', expect.anything());
  });

  describe('should correctly propogate media load/unload depending on whether media is currently selected', () => {
    it.each([
      ['loaded' as const, true],
      ['unloaded' as const, true],
      ['loaded' as const, false],
      ['unloaded' as const, false],
    ])('%s', (type: string, selected: boolean) => {
      const plugin = AutoMediaLoadedInfo();
      const children = createTestSlideNodes();
      const parent = createParent({ children: children });

      const emblaApi = createEmblaApiInstance({
        containerNode: parent,
        slideNodes: children,
        selectedScrollSnap: selected ? 5 : 4,
      });
      plugin.init(emblaApi, createTestEmblaOptionHandler());

      const mediaLoadedHandler = vi.fn();
      parent.addEventListener('advanced-camera-card:media:' + type, mediaLoadedHandler);
      if (type === 'loaded') {
        dispatchExistingMediaLoadedInfoAsEvent(children[5], createMediaLoadedInfo());
      } else if (type === 'unloaded') {
        dispatchMediaUnloadedEvent(children[5]);
      }

      if (selected) {
        expect(mediaLoadedHandler).toBeCalled();
      } else {
        expect(mediaLoadedHandler).not.toBeCalled();
      }
    });
  });

  it('selecting a slide should dispatch a previously saved media loaded info if present', () => {
    const plugin = AutoMediaLoadedInfo();
    const children = createTestSlideNodes();
    const parent = createParent({ children: children });
    const emblaApi = createEmblaApiInstance({
      containerNode: parent,
      slideNodes: children,
    });
    plugin.init(emblaApi, createTestEmblaOptionHandler());

    const mediaLoadedHandler = vi.fn();
    parent.addEventListener('advanced-camera-card:media:loaded', mediaLoadedHandler);
    dispatchExistingMediaLoadedInfoAsEvent(children[5], createMediaLoadedInfo());

    vi.mocked(emblaApi.selectedScrollSnap).mockReturnValue(4);
    emblaApi
      .containerNode()
      .dispatchEvent(new Event('advanced-camera-card:carousel:force-select'));
    expect(mediaLoadedHandler).not.toBeCalled();

    vi.mocked(emblaApi.selectedScrollSnap).mockReturnValue(5);
    emblaApi
      .containerNode()
      .dispatchEvent(new Event('advanced-camera-card:carousel:force-select'));
    expect(mediaLoadedHandler).toBeCalled();
  });
});



================================================
FILE: tests/view/item-classifier.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { ViewFolder, ViewMediaType } from '../../src/view/item';
import { ViewItemClassifier } from '../../src/view/item-classifier';
import { createFolder, TestViewMedia } from '../test-utils';

describe('ViewItemClassifier', () => {
  it('isMedia', () => {
    expect(ViewItemClassifier.isMedia(new TestViewMedia())).toBe(true);
    expect(ViewItemClassifier.isMedia(new ViewFolder(createFolder()))).toBe(false);
  });

  it('isFolder', () => {
    expect(ViewItemClassifier.isFolder(new ViewFolder(createFolder()))).toBe(true);
    expect(ViewItemClassifier.isFolder(new TestViewMedia())).toBe(false);
  });

  describe('isEvent', () => {
    it.each([
      [ViewMediaType.Clip as const, true],
      [ViewMediaType.Snapshot as const, true],
      [ViewMediaType.Recording as const, false],
    ])('%s', (mediaType: ViewMediaType, expectedResult: boolean) => {
      expect(
        ViewItemClassifier.isEvent(new TestViewMedia({ mediaType: mediaType })),
      ).toBe(expectedResult);
    });
  });

  describe('isRecording', () => {
    it.each([
      [ViewMediaType.Clip as const, false],
      [ViewMediaType.Snapshot as const, false],
      [ViewMediaType.Recording as const, true],
    ])('%s', (mediaType: ViewMediaType, expectedResult: boolean) => {
      expect(
        ViewItemClassifier.isRecording(new TestViewMedia({ mediaType: mediaType })),
      ).toBe(expectedResult);
    });
  });

  describe('isClip', () => {
    it.each([
      [ViewMediaType.Clip as const, true],
      [ViewMediaType.Snapshot as const, false],
      [ViewMediaType.Recording as const, false],
    ])('%s', (mediaType: ViewMediaType, expectedResult: boolean) => {
      expect(
        ViewItemClassifier.isClip(new TestViewMedia({ mediaType: mediaType })),
      ).toBe(expectedResult);
    });
  });

  describe('isSnapshot', () => {
    it.each([
      [ViewMediaType.Clip as const, false],
      [ViewMediaType.Snapshot as const, true],
      [ViewMediaType.Recording as const, false],
    ])('%s', (mediaType: ViewMediaType, expectedResult: boolean) => {
      expect(
        ViewItemClassifier.isSnapshot(new TestViewMedia({ mediaType: mediaType })),
      ).toBe(expectedResult);
    });
  });

  describe('isVideo', () => {
    it.each([
      [ViewMediaType.Clip as const, true],
      [ViewMediaType.Snapshot as const, false],
      [ViewMediaType.Recording as const, true],
    ])('%s', (mediaType: ViewMediaType, expectedResult: boolean) => {
      expect(
        ViewItemClassifier.isVideo(new TestViewMedia({ mediaType: mediaType })),
      ).toBe(expectedResult);
    });
  });
});



================================================
FILE: tests/view/item.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  VideoContentType,
  ViewFolder,
  ViewMedia,
  ViewMediaType,
} from '../../src/view/item';
import { createFolder, TestViewMedia } from '../test-utils';

describe('VideoContentType', () => {
  it('MP4', () => {
    expect(VideoContentType.MP4).toBe('mp4');
  });
  it('HLS', () => {
    expect(VideoContentType.HLS).toBe('hls');
  });
});

describe('ViewMedia', () => {
  beforeEach(() => {
    vi.useRealTimers();
  });

  it('should construct', () => {
    const media = new ViewMedia(ViewMediaType.Clip, {
      cameraID: 'camera',
    });
    expect(media.getCameraID()).toBe('camera');
    expect(media.getMediaType()).toBe('clip');
    expect(media.getVideoContentType()).toBeNull();
    expect(media.getID()).toBeNull();
    expect(media.getStartTime()).toBeNull();
    expect(media.getEndTime()).toBeNull();
    expect(media.getUsableEndTime()).toBeNull();
    expect(media.inProgress()).toBeNull();
    expect(media.getContentID()).toBeNull();
    expect(media.getTitle()).toBeNull();
    expect(media.getThumbnail()).toBeNull();
    expect(media.getTitle()).toBeNull();
    expect(media.includesTime(new Date())).toBeFalsy();
    expect(media.getWhere()).toBeNull();
    expect(media.setFavorite(true)).toBeUndefined();
    expect(media.isFavorite()).toBeNull();
    expect(media.getIcon()).toBeNull();
  });

  it('should correctly determine if a media item includes a time', () => {
    const media = new TestViewMedia({
      startTime: new Date('2023-08-08T17:00:00'),
      endTime: new Date('2023-08-08T17:59:59'),
    });
    expect(media.includesTime(new Date('2023-08-08T17:30:30'))).toBeTruthy();
    expect(media.includesTime(new Date('2023-08-08T18:00:00'))).toBeFalsy();
  });

  it('should correctly get usable end time for in-progress event', () => {
    const media = new TestViewMedia({
      startTime: new Date('2023-08-08T17:00:00'),
      inProgress: true,
    });

    vi.useFakeTimers();
    const fakeNow = new Date('2023-08-08T17:15:00');
    vi.setSystemTime(fakeNow);

    expect(media.getUsableEndTime()).toEqual(fakeNow);
  });
});

describe('ViewFolder', () => {
  it('should construct', () => {
    const folder = createFolder();
    const item = new ViewFolder(folder, {
      icon: 'icon',
      id: 'id',
      title: 'title',
      thumbnail: 'thumbnail',
    });

    expect(item.getFolder()).toEqual(folder);
    expect(item.getID()).toBe('id');
    expect(item.getTitle()).toBe('title');
    expect(item.getThumbnail()).toBe('thumbnail');
    expect(item.getIcon()).toBe('icon');
    expect(item.isFavorite()).toBeNull();
  });
});



================================================
FILE: tests/view/query-classifier.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { QueryType } from '../../src/camera-manager/types';
import {
  EventMediaQuery,
  FolderViewQuery,
  RecordingMediaQuery,
} from '../../src/view/query';
import { QueryClassifier } from '../../src/view/query-classifier';
import { createFolder } from '../test-utils';

describe('QueryClassifier', () => {
  it('isEventQuery', () => {
    expect(QueryClassifier.isEventQuery(new EventMediaQuery())).toBeTruthy();
    expect(QueryClassifier.isEventQuery(new RecordingMediaQuery())).toBeFalsy();
  });

  it('isRecordingQuery', () => {
    expect(QueryClassifier.isRecordingQuery(new RecordingMediaQuery())).toBeTruthy();
    expect(QueryClassifier.isRecordingQuery(new EventMediaQuery())).toBeFalsy();
  });

  it('getQueryType', () => {
    expect(QueryClassifier.getQueryType(new EventMediaQuery())).toBe('event');
    expect(QueryClassifier.getQueryType(new FolderViewQuery())).toBe('folder');
    expect(QueryClassifier.getQueryType(new RecordingMediaQuery())).toBe('recording');
    expect(QueryClassifier.getQueryType()).toBeNull();
  });

  it('isClipsQuery', () => {
    expect(
      QueryClassifier.isClipsQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasClip: true },
        ]),
      ),
    ).toBeTruthy();
    expect(
      QueryClassifier.isClipsQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasClip: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasClip: false },
        ]),
      ),
    ).toBeFalsy();
    expect(
      QueryClassifier.isClipsQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasClip: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']) },
        ]),
      ),
    ).toBeFalsy();
  });

  it('isSnapshotQuery', () => {
    expect(
      QueryClassifier.isSnapshotQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
        ]),
      ),
    ).toBeTruthy();
    expect(
      QueryClassifier.isSnapshotQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: false },
        ]),
      ),
    ).toBeFalsy();
    expect(
      QueryClassifier.isSnapshotQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']) },
        ]),
      ),
    ).toBeFalsy();
  });

  it('isFolderQuery', () => {
    expect(
      QueryClassifier.isFolderQuery(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
        ]),
      ),
    ).toBeFalsy();
    expect(
      QueryClassifier.isFolderQuery(
        new RecordingMediaQuery([
          { type: QueryType.Recording, cameraIDs: new Set(['camera']) },
        ]),
      ),
    ).toBeFalsy();
    expect(
      QueryClassifier.isFolderQuery(new FolderViewQuery({ folder: createFolder() })),
    ).toBeTruthy();
  });

  it('getMediaType', () => {
    expect(
      QueryClassifier.getMediaType(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
        ]),
      ),
    ).toBe('snapshots');

    expect(
      QueryClassifier.getMediaType(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasClip: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasClip: true },
        ]),
      ),
    ).toBe('clips');

    expect(
      QueryClassifier.getMediaType(
        new RecordingMediaQuery([
          { type: QueryType.Recording, cameraIDs: new Set(['camera']) },
          { type: QueryType.Recording, cameraIDs: new Set(['camera']) },
        ]),
      ),
    ).toBe('recordings');

    expect(
      QueryClassifier.getMediaType(
        new EventMediaQuery([
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: true },
          { type: QueryType.Event, cameraIDs: new Set(['camera']), hasSnapshot: false },
        ]),
      ),
    ).toBeNull();
  });
});



================================================
FILE: tests/view/query-results.test.ts
================================================
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { ViewFolder, ViewItem } from '../../src/view/item';
import { QueryResults } from '../../src/view/query-results';
import { createFolder, generateViewMediaArray } from '../test-utils';

describe('dispatchViewContextChangeEvent', () => {
  beforeEach(() => {
    vi.useRealTimers();
  });

  it('should function with empty results', () => {
    const fakeNow = new Date('2023-08-07T20:44');
    vi.useFakeTimers();
    vi.setSystemTime(fakeNow);

    const results = new QueryResults();
    expect(results.isSupersetOf(results)).toBeFalsy();
    expect(results.getCameraIDs()).toEqual(new Set());
    expect(results.getResults()).toEqual([]);
    expect(results.getResultsCount()).toEqual(0);
    expect(results.hasResults()).toBeFalsy();
    expect(results.getResult(0)).toBeNull();
    expect(results.getSelectedIndex()).toBeNull();
    expect(results.getSelectedResult()).toBeNull();
    expect(results.hasSelectedResult()).toBeFalsy();

    expect(results.resetSelectedResult()).toBe(results);
    expect(results.getResultsTimestamp()).toEqual(fakeNow);

    expect(results.selectIndex(0)).toEqual(results);
    expect(results.getSelectedResult()).toBeNull();

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    expect(results.selectResultIfFound((_item: ViewItem) => true)).toEqual(results);
    expect(results.getSelectedResult()).toBeNull();

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    expect(results.selectBestResult((_item: ViewItem[]) => null)).toEqual(results);
    expect(results.getSelectedResult()).toBeNull();
    expect(results.getMultipleSelectedResults()).toEqual([]);
  });

  it('should function with basic results', () => {
    const testResults = generateViewMediaArray();
    const results = new QueryResults({ results: testResults });

    expect(results.isSupersetOf(results)).toBeTruthy();
    expect(results.getCameraIDs()).toEqual(new Set(['kitchen', 'office']));
    expect(results.getResults()).toEqual(testResults);
    expect(results.getResultsCount()).toEqual(200);
    expect(results.hasResults()).toBeTruthy();
    expect(results.getResult(0)).not.toBeNull();
    expect(results.getSelectedIndex()).toBe(199);
    expect(results.getSelectedResult()).not.toBeNull();
    expect(results.hasSelectedResult()).toBeTruthy();

    expect(results.resetSelectedResult()).toBe(results);
    expect(results.getSelectedResult()).toBeNull();

    expect(results.selectIndex(100)).toEqual(results);
    expect(results.getSelectedIndex()).toBe(100);

    expect(
      results.selectResultIfFound((item: ViewItem) => item.getID() === 'id-kitchen-42'),
    ).toEqual(results);
    expect(results.getSelectedResult()?.getID()).toBe('id-kitchen-42');

    expect(
      results.selectBestResult((itemArray: ViewItem[]) =>
        itemArray.findIndex((item) => item.getID() === 'id-kitchen-43'),
      ),
    ).toEqual(results);
    expect(results.getSelectedResult()?.getID()).toBe('id-kitchen-43');
  });

  it('should function with camera slice', () => {
    const testResults = generateViewMediaArray();
    const results = new QueryResults({ results: testResults });
    const slice = results.getSlice('office');
    expect(slice).not.toBeNull();
    expect(slice!.getResults()).toEqual(
      testResults.filter((item) => item.getCameraID() === 'office'),
    );
    expect(slice!.getResultsCount()).toEqual(100);
    expect(slice!.hasResults()).toBeTruthy();
    expect(slice!.getResult(0)).not.toBeNull();
    expect(slice!.getResult()).toBeNull();
    expect(slice!.getSelectedIndex()).toBe(99);
    expect(slice!.getSelectedResult()?.getID()).toEqual('id-office-99');
    expect(slice!.hasSelectedResult()).toBeTruthy();

    expect(slice!.resetSelectedResult());
    expect(slice!.getSelectedResult()).toBeNull();

    expect(slice!.selectIndex(10));
    expect(slice!.getSelectedIndex()).toBe(10);

    expect(slice!.selectIndex(10000));
    expect(slice!.getSelectedIndex()).toBe(10);

    expect(slice!.selectIndex(-10000));
    expect(slice!.getSelectedIndex()).toBe(10);

    slice!.selectResultIfFound((item: ViewItem) => item.getID() === 'id-office-42');
    expect(slice!.getSelectedResult()?.getID()).toBe('id-office-42');

    slice!.selectBestResult((itemArray: ViewItem[]) =>
      itemArray.findIndex((item) => item.getID() === 'id-office-43'),
    );
    expect(slice!.getSelectedResult()?.getID()).toBe('id-office-43');
  });

  describe('should respect select approach during construction', () => {
    it.each([
      ['first' as const, 0],
      ['last' as const, 199],
    ])('%s', async (selectApproach, expectedIndex) => {
      const results = new QueryResults({
        results: generateViewMediaArray(),
        selectApproach: selectApproach,
      });
      expect(results.getSelectedIndex()).toBe(expectedIndex);
    });
  });

  it('should respect selectIndex during construction', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
      selectedIndex: 42,
    });
    expect(results.getSelectedIndex()).toBe(42);
  });

  it('should correctly clone a slice', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });
    const slice = results.getSlice('office');
    const clone = slice?.clone();
    expect(clone?.getResults()).toBe(slice?.getResults());
    expect(clone?.getSelectedIndex()).toBe(slice?.getSelectedIndex());
  });

  it('should not get slice for non-existent camera', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });
    expect(results.getSlice('not-a-camera')).toBeNull();
  });

  it('should get main slice', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });
    expect(results.getSlice()?.getResults()).toBe(results.getResults());
  });

  it('should correctly clone', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });
    const clone = results.clone();
    expect(results.getResultsTimestamp()).toBe(clone.getResultsTimestamp());
    expect(results.getResults()).toBe(clone.getResults());
    for (const cameraID of results.getCameraIDs()) {
      expect(results.getSlice(cameraID)?.getResults()).toBe(
        clone.getSlice(cameraID)?.getResults(),
      );
    }
  });

  it('should not getResults on invalid slice', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });
    expect(results.getResults('not-a-camera')).toBeNull();
    expect(results.getResultsCount('not-a-camera')).toBe(0);
    expect(results.hasSelectedResult('not-a-camera')).toBeFalsy();
  });

  it('should always demote main selection', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    results
      .getSlice('office')
      ?.selectResultIfFound((item) => item.getID() === 'id-office-42');

    // Verify main and office selections are as expected.
    expect(results.getSelectedIndex()).toBe(199);
    expect(results.getSelectedResult('office')?.getID()).toBe('id-office-42');

    // Select a different main result...
    results?.selectResultIfFound((item) => item.getID() === 'id-office-80');

    // ... and ensure that selection has been demoted into the camera slice.
    expect(results.getSelectedResult('office')?.getID()).toBe('id-office-80');
  });

  it('should promote camera selection', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    results
      .getSlice('office')
      ?.selectResultIfFound((item) => item.getID() === 'id-office-42');

    expect(results.getSelectedIndex()).toBe(199);

    results.promoteCameraSelectionToMainSelection('office');

    expect(results.getSelectedIndex()).not.toBe(199);
    expect(results.getSelectedResult()?.getID()).toBe('id-office-42');
  });

  it('should selectBestResult via advanced selection criteria', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    results.selectBestResult(
      (itemArray: ViewItem[]) => {
        const index = itemArray.findIndex((item) => item.getID()?.endsWith('-42'));
        return index < 0 ? null : index;
      },
      { allCameras: true },
    );

    expect(results.getSelectedResult('office')?.getID()).toBe('id-office-42');
    expect(results.getSelectedResult('kitchen')?.getID()).toBe('id-kitchen-42');
  });

  it('should get multiple selected results', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    expect(
      results
        .getMultipleSelectedResults({ main: true, allCameras: true })
        .map((item) => item.getID()),
    ).toEqual(['id-office-99', 'id-kitchen-99', 'id-office-99']);
  });

  it('should get multiple selected results without main', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    expect(
      results
        .getMultipleSelectedResults({ main: false, allCameras: true })
        .map((item) => item.getID()),
    ).toEqual(['id-kitchen-99', 'id-office-99']);
  });

  it('should get no results with invalid camera ID without main', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    expect(
      results
        .getMultipleSelectedResults({ main: false, cameraID: 'not-a-real-camera' })
        .map((item) => item.getID()),
    ).toEqual([]);
  });

  it('should not demote main selection when selecting from a specific camera', () => {
    const results = new QueryResults({
      results: generateViewMediaArray(),
    });

    results.selectIndex(42);
    results.selectIndex(24, 'office');

    expect(results.getSelectedIndex()).toBe(42);
    expect(results.getSelectedIndex('office')).toBe(24);
  });

  it('should keep selected folder in main slice but not camera slices', () => {
    const folder = new ViewFolder(createFolder());
    const results = new QueryResults({
      results: [
        folder,
        ...generateViewMediaArray({
          cameraIDs: ['camera.office', 'camera.kitchen'],
        }),
      ],
      selectedIndex: 0,
    });

    expect(results.getSelectedResult()).toBe(folder);
    expect(results.getSelectedResult('camera.office')).not.toBe(folder);
  });
});



================================================
FILE: tests/view/query.test.ts
================================================
import { describe, expect, it } from 'vitest';
import {
  EventQuery,
  PartialEventQuery,
  PartialRecordingQuery,
  QueryType,
  RecordingQuery,
} from '../../src/camera-manager/types';
import { setify } from '../../src/utils/basic';
import {
  EventMediaQuery,
  FolderViewQuery,
  RecordingMediaQuery,
} from '../../src/view/query';
import { createFolder } from '../test-utils';

describe('EventMediaQuery', () => {
  const createRawEventQueries = (
    cameraIDs: string | Set<string>,
    query?: PartialEventQuery,
  ): EventQuery[] => {
    return [
      {
        type: QueryType.Event,
        cameraIDs: setify(cameraIDs),
        ...query,
      },
    ];
  };

  it('should construct', () => {
    const rawQueries = createRawEventQueries('office');
    const query = new EventMediaQuery(rawQueries);
    expect(query.getQuery()).toBe(rawQueries);
  });

  it('should set', () => {
    const rawQueries = createRawEventQueries('office');
    const query = new EventMediaQuery(rawQueries);

    const newRawQueries = createRawEventQueries('kitchen');
    query.setQuery(newRawQueries);
    expect(query.getQuery()).toBe(newRawQueries);
  });

  it('should determine if queries exist for CameraIDs', () => {
    const rawQueries = createRawEventQueries(new Set(['office', 'kitchen']));
    const query = new EventMediaQuery(rawQueries);

    expect(query.hasQueriesForCameraIDs(new Set(['office']))).toBeTruthy();
    expect(query.hasQueriesForCameraIDs(new Set(['office', 'kitchen']))).toBeTruthy();
    expect(query.hasQueriesForCameraIDs(new Set(['office', 'front_door']))).toBeFalsy();
  });

  it('should convert to clips querys', () => {
    const rawQueries = createRawEventQueries('office', { hasSnapshot: true });
    const query = new EventMediaQuery(rawQueries);

    expect(query.convertToClipsQueries().getQuery()).toEqual([
      {
        type: QueryType.Event,
        cameraIDs: new Set(['office']),
        hasClip: true,
      },
    ]);
  });

  it('should convert when queries are null', () => {
    const query = new EventMediaQuery();
    expect(query.convertToClipsQueries().getQuery()).toBeNull();
  });

  it('should clone', () => {
    const rawQueries = createRawEventQueries('office', { hasSnapshot: true });
    const query = new EventMediaQuery(rawQueries);
    expect(query.clone().getQuery()).toEqual(query.getQuery());
  });

  it('should get camera IDs when queries are null', () => {
    expect(new EventMediaQuery().getQueryCameraIDs()).toBeNull();
  });

  it('should get camera IDs', () => {
    const cameraIDs = ['office', 'kitchen'];
    const query = new EventMediaQuery(createRawEventQueries(new Set(cameraIDs)));
    expect(query.getQueryCameraIDs()).toEqual(new Set(cameraIDs));
  });

  it('should set camera IDs when queries are null', () => {
    expect(
      new EventMediaQuery().setQueryCameraIDs(new Set(['office'])).getQueryCameraIDs(),
    ).toBeNull();
  });

  it('should set camera IDs', () => {
    const query = new EventMediaQuery(createRawEventQueries('sitting_room'));
    const newCameraIDs = new Set(['office', 'kitchen']);
    expect(query.setQueryCameraIDs(newCameraIDs).getQueryCameraIDs()).toEqual(
      newCameraIDs,
    );
  });

  describe('should determine when queries are a superset', () => {
    it('should return true with itself', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      expect(query_1.isSupersetOf(query_1)).toBeTruthy();
    });

    it('should return true with an identical but shorter query', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T01:00:00.000Z'),
          end: new Date('2025-03-07T23:00:00.000Z'),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeTruthy();
    });

    it('should return false with an identical but longer query', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-06T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeFalsy();
    });

    it('should return false with a non-matching query', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['DIFFERENT']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeFalsy();
    });

    it('should return true with a matching query where the source has multiple', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
        {
          type: QueryType.Event,
          cameraIDs: new Set(['kitchen']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeTruthy();
    });

    it('should return false with a matching query where the target has multiple', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
        {
          type: QueryType.Event,
          cameraIDs: new Set(['kitchen']),
          start: new Date('2025-03-07T00:00:00.000Z'),
          end: new Date('2025-03-08T00:00:00.000Z'),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeFalsy();
    });

    it('should return true when queries do not have start or end', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
        },
      ]);
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeTruthy();
    });

    it('should return true when target has no queries', () => {
      const query_1 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
        },
      ]);
      const query_2 = new EventMediaQuery();
      expect(query_1.isSupersetOf(query_2)).toBeTruthy();
    });

    it('should return false when source has no queries', () => {
      const query_1 = new EventMediaQuery();
      const query_2 = new EventMediaQuery([
        {
          type: QueryType.Event,
          cameraIDs: new Set(['office']),
        },
      ]);
      expect(query_1.isSupersetOf(query_2)).toBeFalsy();
    });
  });
});

describe('RecordingMediaQuery', () => {
  const createRawRecordingQueries = (
    cameraIDs: string | Set<string>,
    query?: PartialRecordingQuery,
  ): RecordingQuery[] => {
    return [
      {
        type: QueryType.Recording,
        cameraIDs: setify(cameraIDs),
        ...query,
      },
    ];
  };

  it('should construct', () => {
    const rawQueries = createRawRecordingQueries('office');
    const query = new RecordingMediaQuery(rawQueries);
    expect(query.getQuery()).toBe(rawQueries);
  });
});

describe('FolderViewQuery', () => {
  it('should construct', () => {
    const rawQuery = {
      folder: createFolder(),
      path: 'path',
    };

    const query = new FolderViewQuery(rawQuery);
    expect(query.getQuery()).toBe(rawQuery);
  });
});



================================================
FILE: tests/view/view-to-cameras.test.ts
================================================
import { describe, expect, it, vi } from 'vitest';
import { AdvancedCameraCardView } from '../../src/config/schema/common/const';
import { CapabilityKey } from '../../src/types';
import { getCameraIDsForViewName } from '../../src/view/view-to-cameras';
import {
  createCameraConfig,
  createCameraManager,
  createCapabilities,
  createStore,
} from '../test-utils';

describe('getCameraIDsForViewName', () => {
  describe('views that are always supported', () => {
    it.each([
      ['diagnostics' as const],
      ['folder' as const],
      ['folders' as const],
      ['image' as const],
      ['media' as const],
    ])('%s', (viewName: AdvancedCameraCardView) => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({ dependencies: { cameras: ['camera-2'] } }),
          },
          { cameraID: 'camera-2' },
        ]),
      );

      expect(getCameraIDsForViewName(cameraManager, viewName)).toEqual(
        new Set(['camera-1', 'camera-2']),
      );
      expect(getCameraIDsForViewName(cameraManager, viewName, 'camera-1')).toEqual(
        new Set(['camera-1', 'camera-2']),
      );
      expect(getCameraIDsForViewName(cameraManager, viewName, 'camera-2')).toEqual(
        new Set(['camera-1', 'camera-2']),
      );
    });
  });

  describe('views that respect dependencies and need a capability', () => {
    it.each([
      ['live' as const, 'live' as const],
      ['clip' as const, 'clips' as const],
      ['clips' as const, 'clips' as const],
      ['snapshot' as const, 'snapshots' as const],
      ['snapshots' as const, 'snapshots' as const],
      ['recording' as const, 'recordings' as const],
      ['recordings' as const, 'recordings' as const],
      ['timeline' as const, 'clips' as const],
      ['timeline' as const, 'snapshots' as const],
      ['timeline' as const, 'recordings' as const],
    ])('%s', (viewName: AdvancedCameraCardView, capabilityKey: CapabilityKey) => {
      const cameraManager = createCameraManager();
      vi.mocked(cameraManager.getStore).mockReturnValue(
        createStore([
          {
            cameraID: 'camera-1',
            config: createCameraConfig({ dependencies: { cameras: ['camera-2'] } }),
          },
          {
            cameraID: 'camera-2',
            capabilities: createCapabilities({ [capabilityKey]: true }),
          },
        ]),
      );

      expect(getCameraIDsForViewName(cameraManager, viewName)).toEqual(
        new Set(['camera-2']),
      );
      expect(getCameraIDsForViewName(cameraManager, viewName, 'camera-1')).toEqual(
        new Set(['camera-2']),
      );
      expect(getCameraIDsForViewName(cameraManager, viewName, 'camera-2')).toEqual(
        new Set(['camera-2']),
      );
    });
  });
});



================================================
FILE: tests/view/view.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { EventMediaQuery } from '../../src/view/query';
import { QueryResults } from '../../src/view/query-results';
import { createView } from '../test-utils';

describe('View Basics', () => {
  it('should construct from parameters', () => {
    const query = new EventMediaQuery();
    const queryResults = new QueryResults();
    const context = {};

    const view = createView({
      view: 'live',
      camera: 'camera',
      query: query,
      queryResults: queryResults,
      context: context,
    });
    expect(view.is('live')).toBeTruthy();
    expect(view.view).toBe('live');
    expect(view.camera).toBe('camera');
    expect(view.query).toBe(query);
    expect(view.queryResults).toBe(queryResults);
    expect(view.context).toBe(context);
  });

  describe('should clone', () => {
    it('with query and queryResults', () => {
      const view = createView({
        view: 'live',
        camera: 'camera',
        query: new EventMediaQuery(),
        queryResults: new QueryResults(),
        context: {},
      });

      expect(view.clone()).toEqual(view);
    });

    it('without query and queryResults', () => {
      const view = createView({
        view: 'live',
        camera: 'camera',
        context: {},
      });

      expect(view.clone()).toEqual(view);
    });
  });

  it('should evolve with everything set', () => {
    const view = createView({
      view: 'live',
      camera: 'camera-1',
      query: new EventMediaQuery(),
      queryResults: new QueryResults(),
      context: {},
      displayMode: 'single',
    });

    const evolved = view.evolve({
      view: 'clips',
      camera: 'camera-2',
      query: new EventMediaQuery(),
      queryResults: new QueryResults(),
      context: {},
      displayMode: 'grid',
    });
    expect(evolved.view).not.toBe(view.view);
    expect(evolved.camera).not.toBe(view.camera);
    expect(evolved.query).not.toBe(view.query);
    expect(evolved.queryResults).not.toBe(view.queryResults);
    expect(evolved.context).not.toBe(view.context);
    expect(evolved.displayMode).not.toBe(view.displayMode);
  });

  it('should evolve with nothing set', () => {
    const view = createView({
      view: 'live',
      camera: 'camera-1',
      query: new EventMediaQuery(),
      queryResults: new QueryResults(),
      context: {},
    });

    const evolved = view.evolve({});

    expect(evolved.view).toBe(view.view);
    expect(evolved.camera).toBe(view.camera);
    expect(evolved.context).toBe(view.context);

    // Query and QueryResults are cloned if not set.
    expect(evolved.query).not.toBe(view.query);
    expect(evolved.query).toEqual(view.query);
    expect(evolved.queryResults).not.toBe(view.queryResults);
    expect(evolved.queryResults).toEqual(view.queryResults);
  });

  it('should not clone query and queryResults with nothing set', () => {
    const view = createView();
    const evolved = view.evolve({});

    // Query and QueryResults are cloned if not set.
    expect(evolved.query).toBeNull();
    expect(evolved.queryResults).toBeNull();
  });

  it('should merge in context', () => {
    const view = createView();
    const liveContext = { overrides: new Map() };
    const timelineContext = { window: { start: new Date(), end: new Date() } };

    view.mergeInContext({ live: liveContext });
    expect(view.context?.live).toEqual(liveContext);

    view.mergeInContext({ timeline: timelineContext });
    expect(view.context?.live).toEqual(liveContext);
    expect(view.context?.timeline).toEqual(timelineContext);

    // Verify that merging context creates a new context object, as some
    // downstream users may check for context equality.
    const oldContext = view.context;
    view.mergeInContext({ live: liveContext });
    expect(view.context).not.toBe(oldContext);
  });

  it('should remove context', () => {
    const view = createView({ context: { live: { overrides: new Map() } } });

    view.removeContext('live');
    expect(view.context).toEqual({});
  });

  it('should not remove context when no context', () => {
    const view = createView();
    expect(view.context).toBeNull();

    view.removeContext('live');
    expect(view.context).toBeNull();
  });

  it('should remove context property', () => {
    const view = createView({ context: { live: { overrides: new Map() } } });

    view.removeContextProperty('live', 'overrides');
    expect(view.context).toEqual({ live: {} });
  });

  it('should not remove context property that does not exist', () => {
    const view = createView({ context: {} });

    view.removeContextProperty('live', 'overrides');
    expect(view.context).toEqual({});
  });

  describe('should detect folder views', () => {
    it('should detect folder views', () => {
      expect(createView({ view: 'folder' }).isAnyFolderView()).toBeTruthy();
      expect(createView({ view: 'folders' }).isAnyFolderView()).toBeTruthy();
    });

    it('should not detect folder views', () => {
      expect(createView({ view: 'live' }).isAnyFolderView()).toBeFalsy();
      expect(createView({ view: 'clip' }).isAnyFolderView()).toBeFalsy();
      expect(createView({ view: 'clips' }).isAnyFolderView()).toBeFalsy();
    });
  });

  describe('should detect media views', () => {
    it('should detect any media views', () => {
      expect(createView({ view: 'clip' }).isAnyMediaView()).toBeTruthy();
      expect(createView({ view: 'snapshot' }).isAnyMediaView()).toBeTruthy();
      expect(createView({ view: 'media' }).isAnyMediaView()).toBeTruthy();
      expect(createView({ view: 'recording' }).isAnyMediaView()).toBeTruthy();
      expect(createView({ view: 'live' }).isAnyMediaView()).toBeTruthy();
      expect(createView({ view: 'image' }).isAnyMediaView()).toBeTruthy();
      expect(createView({ view: 'folder' }).isAnyMediaView()).toBeTruthy();
    });

    it('should not detect any media view', () => {
      expect(createView({ view: 'timeline' }).isAnyMediaView()).toBeFalsy();
    });
  });

  describe('should detect gallery views', () => {
    it('should detect gallery views', () => {
      expect(createView({ view: 'clips' }).isMediaGalleryView()).toBeTruthy();
      expect(createView({ view: 'folders' }).isMediaGalleryView()).toBeTruthy();
      expect(createView({ view: 'snapshots' }).isMediaGalleryView()).toBeTruthy();
      expect(createView({ view: 'recordings' }).isMediaGalleryView()).toBeTruthy();
    });

    it('should not detect gallery view', () => {
      expect(createView({ view: 'live' }).isMediaGalleryView()).toBeFalsy();
      expect(createView({ view: 'timeline' }).isMediaGalleryView()).toBeFalsy();
    });
  });

  describe('should detect viewer views', () => {
    it('should detect viewer views', () => {
      expect(createView({ view: 'clip' }).isViewerView()).toBeTruthy();
      expect(createView({ view: 'snapshot' }).isViewerView()).toBeTruthy();
      expect(createView({ view: 'media' }).isViewerView()).toBeTruthy();
      expect(createView({ view: 'recording' }).isViewerView()).toBeTruthy();
      expect(createView({ view: 'folder' }).isAnyMediaView()).toBeTruthy();
    });

    it('should not detect viewer views', () => {
      expect(createView({ view: 'live' }).isViewerView()).toBeFalsy();
      expect(createView({ view: 'live' }).isViewerView()).toBeFalsy();
      expect(createView({ view: 'timeline' }).isViewerView()).toBeFalsy();
    });
  });

  describe('should get default media type', () => {
    it('should get default media type', () => {
      expect(createView({ view: 'clip' }).getDefaultMediaType()).toBe('clips');
      expect(createView({ view: 'clips' }).getDefaultMediaType()).toBe('clips');
      expect(createView({ view: 'snapshot' }).getDefaultMediaType()).toBe('snapshots');
      expect(createView({ view: 'snapshots' }).getDefaultMediaType()).toBe('snapshots');
      expect(createView({ view: 'recording' }).getDefaultMediaType()).toBe('recordings');
      expect(createView({ view: 'recordings' }).getDefaultMediaType()).toBe(
        'recordings',
      );
    });

    it('should not get default media type', () => {
      expect(createView({ view: 'live' }).getDefaultMediaType()).toBeNull();
      expect(createView({ view: 'timeline' }).getDefaultMediaType()).toBeNull();
    });
  });

  it('should determine if display mode is grid', () => {
    expect(createView({ displayMode: 'grid' }).isGrid()).toBeTruthy();
    expect(createView({ displayMode: 'single' }).isGrid()).toBeFalsy();
    expect(createView().isGrid()).toBeFalsy();
  });

  it('should determine if view supports multiple display modes', () => {
    expect(createView({ view: 'live' }).supportsMultipleDisplayModes()).toBeTruthy();
    expect(createView({ view: 'media' }).supportsMultipleDisplayModes()).toBeTruthy();
    expect(createView({ view: 'clip' }).supportsMultipleDisplayModes()).toBeTruthy();
    expect(createView({ view: 'snapshot' }).supportsMultipleDisplayModes()).toBeTruthy();
    expect(
      createView({ view: 'recording' }).supportsMultipleDisplayModes(),
    ).toBeTruthy();

    expect(createView({ view: 'clips' }).supportsMultipleDisplayModes()).toBeFalsy();
    expect(createView({ view: 'snapshots' }).supportsMultipleDisplayModes()).toBeFalsy();
    expect(
      createView({ view: 'recordings' }).supportsMultipleDisplayModes(),
    ).toBeFalsy();
    expect(createView({ view: 'image' }).supportsMultipleDisplayModes()).toBeFalsy();
    expect(createView({ view: 'timeline' }).supportsMultipleDisplayModes()).toBeFalsy();
  });
});



================================================
FILE: .devcontainer/devcontainer.json
================================================
// See https://aka.ms/vscode-remote/devcontainer.json for format details.
{
  "dockerComposeFile": "../docker-compose.yml",
  "service": "devcontainer",
  "features": {
    "ghcr.io/devcontainers/features/docker-outside-of-docker:1": {
      "moby": false
    }
  },
  "updateRemoteUserUID": true,
  "workspaceFolder": "${localWorkspaceFolder}",
  "initializeCommand": [".devcontainer/scripts/devcontainer_initialize.sh"],
  "postCreateCommand": ["yarn", "install"],
  "forwardPorts": [10001, "homeassistant:8123", "frigate:5000"],
  "portsAttributes": {
    "10001": {
      "label": "Rollup",
      "onAutoForward": "silent"
    },
    "homeassistant:8123": {
      "label": "Home Assistant",
      "onAutoForward": "silent"
    },
    "frigate:5000": {
      "label": "Frigate",
      "onAutoForward": "silent"
    }
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "runem.lit-plugin",
        "davidanson.vscode-markdownlint",
        "redhat.vscode-yaml",
        "vitest.explorer",
        "inlang.vs-code-extension",
        "YoavBls.pretty-ts-errors",
        "github.vscode-pull-request-github",
        "github.vscode-github-actions",
        "ms-azuretools.vscode-docker"
      ],
      "settings": {
        "task.allowAutomaticTasks": "on",
        "files.eol": "\n",
        "editor.tabSize": 2,
        "editor.formatOnPaste": false,
        "editor.formatOnSave": true,
        "editor.formatOnType": true,
        "files.trimTrailingWhitespace": true,
        "[json][jsonc][yaml][markdown][typescript][javascript]": {
          "editor.defaultFormatter": "esbenp.prettier-vscode"
        }
      }
    }
  }
}



================================================
FILE: .devcontainer/Dockerfile
================================================
FROM mcr.microsoft.com/devcontainers/base:ubuntu-24.04

USER vscode

# Install Volta
ARG HOME="/home/vscode"
ENV VOLTA_HOME="${HOME}/.volta"
ENV PATH="${VOLTA_HOME}/bin:${PATH}"
RUN bash -c "$(curl -fsSL https://get.volta.sh)" -- --skip-setup

CMD ["sleep", "infinity"]



================================================
FILE: .devcontainer/homeassistant_preconfig/.storage/lovelace
================================================
{
  "version": 1,
  "minor_version": 1,
  "key": "lovelace",
  "data": {
    "config": {
      "title": "Advanced Camera Card",
      "views": [
        {
          "theme": "Backend-selected",
          "title": "Basic",
          "path": "basic",
          "badges": [],
          "cards": [
            {
              "type": "custom:advanced-camera-card",
              "name": "Advanced Camera Card with Frigate Camera",
              "cameras": [
                {
                  "camera_entity": "camera.big_buck_bunny",
                  "live_provider": "jsmpeg",
                  "id": "big_buck_bunny_jsmpeg"
                },
                {
                  "camera_entity": "camera.big_buck_bunny",
                  "live_provider": "ha",
                  "id": "big_buck_bunny_ha"
                }
              ]
            }
          ]
        }
      ]
    }
  }
}



================================================
FILE: .devcontainer/homeassistant_preconfig/.storage/lovelace_resources
================================================
{
  "version": 1,
  "minor_version": 1,
  "key": "lovelace_resources",
  "data": {
    "items": [
      {
        "url": "http://localhost:10001/advanced-camera-card.js",
        "type": "module",
        "id": "00c459541bac4290af01c51bf9c06ba1"
      }
    ]
  }
}



================================================
FILE: .devcontainer/scripts/devcontainer_initialize.sh
================================================
#!/bin/bash

set -euxo pipefail

git submodule update --init

.devcontainer/frigate-hass-integration/.devcontainer/scripts/devcontainer_initialize.sh

echo "$0 finished." >&2



================================================
FILE: .github/dependabot.yml
================================================
version: 2

updates:
  - package-ecosystem: github-actions
    directory: /
    schedule:
      interval: daily
    target-branch: 'dev'



================================================
FILE: .github/FUNDING.yml
================================================
github: [dermotduffy]



================================================
FILE: .github/labels.yml
================================================
---
# Conventional Commit related labels (match entries in `semantics-prs.yml`).
- name: bug
  description: Something isn't working
  color: d73a4a
- name: chore
  description: Chore
  color: bfdadc
- name: ci
  description: Continuous Integration
  color: 4a97d6
- name: documentation
  description: Improvements or additions to documentation
  color: 0075ca
- name: feature
  description: New feature or request
  color: a2eeef
- name: performance
  description: Performance
  color: '016175'
- name: refactoring
  description: Refactoring
  color: ef67c4
- name: testing
  description: Testing
  color: b1fc6f

# Other labels
- name: breaking
  description: Breaking Changes
  color: bfd4f2
- name: help wanted
  description: Extra attention is needed
  color: 008672
- name: question
  description: Further information is requested
  color: d876e3
- name: waiting
  description: Waiting for something
  color: daa036



================================================
FILE: .github/release-drafter.yml
================================================
---
categories:
  - title: ':boom: Breaking Changes'
    label: 'breaking'
  - title: ':rocket: Features'
    label: 'feature'
  - title: ':bug: Fixes'
    label: 'bug'
  - title: ':racehorse: Performance'
    label: 'performance'
  - title: ':rotating_light: Testing'
    label: 'testing'
  - title: ':construction_worker: Continuous Integration'
    label: 'ci'
  - title: ':books: Documentation'
    label: 'documentation'
  - title: ':hammer: Refactoring'
    label: 'refactoring'
  - title: ':wrench: Chore'
    label: 'chore'

template: |
  ## Changes

  $CHANGES



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help the card improve
title: ''
labels: bug
assignees: ''
---

<!-- =================================================================
***               PLEASE DO NOT IGNORE THIS TEMPLATE
***
*** This is the smallest amount of information needed to help you!
====================================================================== -->

**Checklist:**

- Please try updating to the [latest available version](https://github.com/dermotduffy/advanced-camera-card/releases).
- Please try clearing your browser cache.

**[REQUIRED] Card diagnostic information:**

<!--
On the card, hold down the Iris (default) menu button for a few seconds then paste the diagnostics *between* the pair of triple backticks below. No help can be provided without this.
-->

```yaml

```

**[REQUIRED] Description of problem:**

<!--
Explain what the issue is, and how things should look/behave. If possible provide a screenshot with a description.
-->

**[OPTIONAL] Last working release (if known):**

**[OPTIONAL] Javascript errors shown in the web inspector:**

```text

```

**[OPTIONAL] Additional information:**



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: feature request
assignees: ''
---

**[REQUIRED] Describe the feature you'd like:**

A clear and concise description of what you want to happen.

**[OPTIONAL] Describe alternatives you've considered:**

A clear and concise description of any alternative solutions or features you've considered.

**[OPTIONAL] Additional context:**

Add any other context or screenshots about the feature request here.



================================================
FILE: .github/workflows/build.yml
================================================
---
name: 'Build'

on:
  push:
    branches:
      - main
      - dev
  pull_request:
  schedule:
    - cron: '17 6 * * *'
  workflow_dispatch:

jobs:
  build:
    name: Test build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node and Yarn
        uses: volta-cli/action@v4

      - name: Install dependencies
        run: yarn install --immutable

      - name: Lint
        run: yarn run lint

      - name: Check formatting
        run: yarn run format-check

      - name: Test & Coverage
        run: yarn run coverage

      - name: Build
        run: yarn run build

      - name: HACS build validation
        uses: 'hacs/action@21.12.1'
        with:
          category: 'plugin'

          # Don't attempt to load into HACS (as it loads the release, not the
          # build).
          ignore: 'hacs'

      - name: Upload javascript
        uses: actions/upload-artifact@v4
        with:
          name: advanced-camera-card
          path: dist/*.js

      # When this issue is fixed, it would be useful to upload visualizations:
      # https://github.com/actions/upload-artifact/issues/14
      # - name: Upload visualizations
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: advanced-camera-card
      #     path: visualizations/*.html



================================================
FILE: .github/workflows/labeler.yml
================================================
---
name: Manage labels

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  labeler:
    name: Labeler
    runs-on: ubuntu-latest
    steps:
      - name: Check out the repository
        uses: actions/checkout@v4

      - name: Run Labeler
        uses: crazy-max/ghaction-github-labeler@v5.0.0
        with:
          skip-delete: true



================================================
FILE: .github/workflows/lock.yml
================================================
name: Lock

# yamllint disable-line rule:truthy
on:
  schedule:
    - cron: '23 13 * * *'
  workflow_dispatch:

jobs:
  lock:
    if: github.repository_owner == 'dermotduffy'
    runs-on: ubuntu-latest
    steps:
      - uses: dessant/lock-threads@v5.0.1
        with:
          github-token: ${{ github.token }}
          issue-inactive-days: '30'
          issue-lock-reason: ''
          pr-inactive-days: '30'
          pr-lock-reason: ''
          log-output: true



================================================
FILE: .github/workflows/manual-release-drafter.yml
================================================
---
name: Manual Release Drafter

on:
  workflow_dispatch:

jobs:
  draft_release:
    name: Release Drafter
    runs-on: ubuntu-latest
    steps:
      - name: Run release-drafter
        uses: release-drafter/release-drafter@v6.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



================================================
FILE: .github/workflows/manual-release.yml
================================================
---
name: Manual Release

on:
  workflow_dispatch:

jobs:
  release:
    name: Prepare release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node and Yarn
        uses: volta-cli/action@v4

      - name: Install dependencies
        run: yarn install --immutable

      - name: Build the files
        run: yarn run build

      - name: Zip the files
        uses: thedoctor0/zip-release@0.7.6
        with:
          type: zip
          path: dist
          filename: advanced-camera-card.zip

      - name: Upload JS files to release
        uses: svenstaro/upload-release-action@2.9.0

        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: dist/*.js
          file_glob: true
          tag: ${{ github.ref }}
          overwrite: true

      - name: Upload Zip file to release
        uses: svenstaro/upload-release-action@2.9.0

        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: advanced-camera-card.zip
          tag: ${{ github.ref }}
          overwrite: true

      - name: HACS release validation
        uses: hacs/action@22.5.0
        with:
          category: plugin



================================================
FILE: .github/workflows/semantic-prs.yml
================================================
---
name: Semantic PR

on:
  pull_request_target:
    types:
      - opened
      - edited
      - synchronize
      - reopened

jobs:
  main:
    name: Validate PR title
    runs-on: ubuntu-latest
    steps:
      - uses: ytanikin/PRConventionalCommits@1.2.0
        with:
          task_types: '["feat","fix","docs","test","ci","refactor","perf","chore"]'
          custom_labels: '{"feat": "feature", "fix": "bug", "docs": "documentation", "test": "testing", "ci": "ci", "refactor": "refactoring", "perf": "performance", "chore": "chore"}'



================================================
FILE: .github/workflows/semantic-release.yml
================================================
---
name: Semantic Release

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write # To be able to publish a GitHub release
  issues: write # To be able to comment on released issues
  pull-requests: write # To be able to comment on released pull requests

jobs:
  get-next-version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
      - uses: volta-cli/action@v4
      - run: yarn install --immutable
      - run: npx semantic-release --dry-run
        id: get-next-version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    outputs:
      new-release-published: ${{ steps.get-next-version.outputs.new-release-published }}
      new-release-version: ${{ steps.get-next-version.outputs.new-release-version }}
      new-release-git-tag: ${{ steps.get-next-version.outputs.new-release-git-tag }}

  release:
    runs-on: ubuntu-latest
    needs: get-next-version
    if: needs.get-next-version.outputs.new-release-published == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
      - uses: volta-cli/action@v4
      - run: yarn install --immutable
      - run: yarn run build
        env:
          RELEASE_VERSION: ${{ needs.get-next-version.outputs.new-release-version }}
          RELEASE_TAG: ${{ needs.get-next-version.outputs.new-release-git-tag }}
      - uses: thedoctor0/zip-release@0.7.6
        with:
          type: zip
          path: dist
          filename: advanced-camera-card.zip
      - run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


